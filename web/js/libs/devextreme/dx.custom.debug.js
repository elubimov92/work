/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* Core (dx.module-core.js) */

	var $ = __webpack_require__(1);
	var DevExpress = __webpack_require__(2);
	/* Integrations (dx.module-core.js) */
	__webpack_require__(81);
	/* UI core (dx.module-core.js) */
	var ui = DevExpress.ui = __webpack_require__(110);
	ui.dialog = __webpack_require__(111);
	/* Base widgets (dx.module-widgets-base.js) */
	ui.dxDataGrid = __webpack_require__(141);
	ui.dxChart = __webpack_require__(290);
	ui.dxPieChart = __webpack_require__(364);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.1.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-09-22T22:30Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};



		function DOMEval( code, doc ) {
			doc = doc || document;

			var script = doc.createElement( "script" );

			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.1.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&

				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;

		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;

		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( jQuery.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win, rect, doc,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;

				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}

			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	jQuery.parseJSON = JSON.parse;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}





	return jQuery;
	} );


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (bundles/modules/core.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var DevExpress = window.DevExpress = window.DevExpress || {};
	var errors = DevExpress.errors = __webpack_require__(3);
	if (DevExpress._DEVEXTREME_BUNDLE_INITIALIZED) {
	    throw errors.Error("E0024")
	}
	DevExpress._DEVEXTREME_BUNDLE_INITIALIZED = true;
	DevExpress.clientExporter = __webpack_require__(13);
	DevExpress.VERSION = __webpack_require__(12);
	DevExpress.Class = __webpack_require__(18);
	DevExpress.DOMComponent = __webpack_require__(28);
	DevExpress.registerComponent = __webpack_require__(44);
	DevExpress.devices = __webpack_require__(40);
	DevExpress.Color = __webpack_require__(24);
	var $ = __webpack_require__(5);
	var compareVersions = __webpack_require__(11).compare;
	if (compareVersions($.fn.jquery, [1, 10]) < 0) {
	    throw errors.Error("E0012")
	}
	var animationFrame = __webpack_require__(46);
	DevExpress.requestAnimationFrame = function() {
	    errors.log("W0000", "DevExpress.requestAnimationFrame", "15.2", "Use the 'DevExpress.utils.requestAnimationFrame' method instead.");
	    return animationFrame.requestAnimationFrame.apply(animationFrame, arguments)
	};
	DevExpress.cancelAnimationFrame = function() {
	    errors.log("W0000", "DevExpress.cancelAnimationFrame", "15.2", "Use the 'DevExpress.utils.cancelAnimationFrame' method instead.");
	    return animationFrame.cancelAnimationFrame.apply(animationFrame, arguments)
	};
	DevExpress.EventsMixin = __webpack_require__(38);
	DevExpress.utils = {};
	DevExpress.utils.requestAnimationFrame = animationFrame.requestAnimationFrame;
	DevExpress.utils.cancelAnimationFrame = animationFrame.cancelAnimationFrame;
	DevExpress.utils.initMobileViewport = __webpack_require__(47).initMobileViewport;
	DevExpress.utils.extendFromObject = __webpack_require__(36).extendFromObject;
	DevExpress.utils.createComponents = __webpack_require__(43).createComponents;
	DevExpress.utils.triggerShownEvent = __webpack_require__(43).triggerShownEvent;
	DevExpress.utils.triggerHidingEvent = __webpack_require__(43).triggerHidingEvent;
	DevExpress.utils.resetActiveElement = __webpack_require__(43).resetActiveElement;
	DevExpress.utils.findBestMatches = __webpack_require__(8).findBestMatches;
	DevExpress.createQueue = __webpack_require__(50).create;
	DevExpress.utils.dom = __webpack_require__(43);
	DevExpress.utils.common = __webpack_require__(8);
	DevExpress.utils.date = __webpack_require__(51);
	DevExpress.utils.browser = __webpack_require__(16);
	DevExpress.utils.inflector = __webpack_require__(49);
	DevExpress.utils.resizeCallbacks = __webpack_require__(29).resizeCallbacks;
	DevExpress.utils.console = __webpack_require__(6);
	DevExpress.utils.string = __webpack_require__(7);
	DevExpress.utils.support = __webpack_require__(48);
	DevExpress.processHardwareBackButton = __webpack_require__(52);
	DevExpress.viewPort = __webpack_require__(42).value;
	DevExpress.hideTopOverlay = __webpack_require__(53);
	DevExpress.formatHelper = __webpack_require__(54);
	var config = DevExpress.config = __webpack_require__(9);
	Object.defineProperty(DevExpress, "rtlEnabled", {
	    get: function() {
	        errors.log("W0003", "DevExpress", "rtlEnabled", "16.1", "Use the 'DevExpress.config' method instead");
	        return config().rtlEnabled
	    },
	    set: function(value) {
	        errors.log("W0003", "DevExpress", "rtlEnabled", "16.1", "Use the 'DevExpress.config' method instead");
	        config({
	            rtlEnabled: value
	        })
	    }
	});
	Object.defineProperty(DevExpress, "designMode", {
	    get: function() {
	        return config().designMode
	    },
	    set: function(value) {
	        config({
	            designMode: value
	        })
	    }
	});
	DevExpress.animationPresets = __webpack_require__(57).presets;
	DevExpress.fx = __webpack_require__(58);
	DevExpress.TransitionExecutor = __webpack_require__(64).TransitionExecutor;
	DevExpress.AnimationPresetCollection = __webpack_require__(57).PresetCollection;
	module.exports = DevExpress.events = {};
	DevExpress.events.click = __webpack_require__(65);
	DevExpress.events.utils = __webpack_require__(61);
	DevExpress.events.GestureEmitter = __webpack_require__(76);
	DevExpress.localization = __webpack_require__(78);
	module.exports = DevExpress;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/errors.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var errorUtils = __webpack_require__(4);
	module.exports = errorUtils({
	    E0001: "Method is not implemented",
	    E0002: "Member name collision: {0}",
	    E0003: "A class must be instantiated using the 'new' keyword",
	    E0004: "The NAME property of the component is not specified",
	    E0005: "Unknown device",
	    E0006: "Unknown endpoint key is requested",
	    E0007: "'Invalidate' method is called outside the update transaction",
	    E0008: "Type of the option name is not appropriate to create an action",
	    E0009: "Component '{0}' has not been initialized for an element",
	    E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
	    E0011: "Unknown animation type '{0}'",
	    E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
	    E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
	    E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
	    E0015: "Queued task returned an unexpected result",
	    E0017: "Event namespace is not defined",
	    E0018: "DevExpress.ui.DevExpressPopup widget is required",
	    E0020: "Template engine '{0}' is not supported",
	    E0021: "Unknown theme is set: {0}",
	    E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
	    E0023: "Template name is not specified",
	    E0024: "DevExtreme bundle already included",
	    E0100: "Unknown validation type is detected",
	    E0101: "Misconfigured range validation rule is detected",
	    E0102: "Misconfigured comparison validation rule is detected",
	    E0110: "Unknown validation group is detected",
	    E0120: "Adapter for a DevExpressValidator component cannot be configured",
	    E0121: "The onCustomItemCreating action should return an item or Promise of jQuery Deferred object resolved when an item is created",
	    E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
	    W0000: "'{0}' is deprecated in {1}. {2}",
	    W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
	    W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
	    W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
	    W0004: "Timeout for theme loading is over: {0}",
	    W0005: "'{0}' event is deprecated in {1}. {2}",
	    W0006: "Invalid recurrence rule: '{0}'",
	    W0007: "'{0}' Globalize culture is not defined",
	    W0008: "Invalid view name: '{0}'",
	    W0009: "Invalid time zone name: '{0}'",
	    W0010: "{0} is deprecated in {1}. {2}",
	    W0011: "Number parsing is invoked while the parser is not defined",
	    W0012: "Date parsing is invoked while the parser is not defined",
	    W0013: "'{0}' file is deprecated in {1}. {2}"
	});


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/error.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    consoleUtils = __webpack_require__(6),
	    stringUtils = __webpack_require__(7),
	    version = __webpack_require__(12);
	var ERROR_URL = "http://js.devexpress.com/error/" + version.split(".").slice(0, 2).join("_") + "/";
	module.exports = function(baseErrors, errors) {
	    var exports = {
	        ERROR_MESSAGES: $.extend(errors, baseErrors),
	        Error: function() {
	            return makeError($.makeArray(arguments))
	        },
	        log: function(id) {
	            var method = "log";
	            if (/^E\d+$/.test(id)) {
	                method = "error"
	            } else {
	                if (/^W\d+$/.test(id)) {
	                    method = "warn"
	                }
	            }
	            consoleUtils.logger[method]("log" === method ? id : combineMessage($.makeArray(arguments)))
	        }
	    };
	    var combineMessage = function(args) {
	        var id = args[0];
	        args = args.slice(1);
	        return formatMessage(id, formatDetails(id, args))
	    };
	    var formatDetails = function(id, args) {
	        args = [exports.ERROR_MESSAGES[id]].concat(args);
	        return stringUtils.format.apply(this, args).replace(/\.*\s*?$/, "")
	    };
	    var formatMessage = function(id, details) {
	        return stringUtils.format.apply(this, ["{0} - {1}. See:\n{2}", id, details, ERROR_URL + id])
	    };
	    var makeError = function(args) {
	        var id, details, message;
	        id = args[0];
	        args = args.slice(1);
	        details = formatDetails(id, args);
	        message = formatMessage(id, details);
	        return $.extend(new Error(message), {
	            __id: id,
	            __details: details
	        })
	    };
	    return exports
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/console.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var logger = function() {
	    var console = window.console;

	    function info(text) {
	        if (!console || !$.isFunction(console.info)) {
	            return
	        }
	        console.info(text)
	    }

	    function warn(text) {
	        if (!console || !$.isFunction(console.warn)) {
	            return
	        }
	        console.warn(text)
	    }

	    function error(text) {
	        if (!console || !$.isFunction(console.error)) {
	            return
	        }
	        console.error(text)
	    }
	    return {
	        info: info,
	        warn: warn,
	        error: error
	    }
	}();
	var debug = function() {
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message)
	        }
	    }

	    function assertParam(parameter, message) {
	        assert(null !== parameter && void 0 !== parameter, message)
	    }
	    return {
	        assert: assert,
	        assertParam: assertParam
	    }
	}();
	exports.logger = logger;
	exports.debug = debug;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/string.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8);
	var encodeHtml = function() {
	    var encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
	    return function(str) {
	        return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;")
	    }
	}();
	var pairToObject = function(raw) {
	    var pair = commonUtils.splitPair(raw),
	        h = parseInt(pair && pair[0], 10),
	        v = parseInt(pair && pair[1], 10);
	    if (!isFinite(h)) {
	        h = 0
	    }
	    if (!isFinite(v)) {
	        v = h
	    }
	    return {
	        h: h,
	        v: v
	    }
	};
	var quadToObject = function(raw) {
	    var quad = commonUtils.splitQuad(raw),
	        left = parseInt(quad && quad[0], 10),
	        top = parseInt(quad && quad[1], 10),
	        right = parseInt(quad && quad[2], 10),
	        bottom = parseInt(quad && quad[3], 10);
	    if (!isFinite(left)) {
	        left = 0
	    }
	    if (!isFinite(top)) {
	        top = left
	    }
	    if (!isFinite(right)) {
	        right = left
	    }
	    if (!isFinite(bottom)) {
	        bottom = top
	    }
	    return {
	        top: top,
	        right: right,
	        bottom: bottom,
	        left: left
	    }
	};
	var stringFormat = function() {
	    var replaceDollarCount, reg, value, s = arguments[0],
	        values = $.makeArray(arguments).slice(1);
	    if ($.isFunction(s)) {
	        return s.apply(this, values)
	    }
	    for (var i = 0; i < values.length; i++) {
	        reg = new RegExp("\\{" + i + "\\}", "gm");
	        value = values[i];
	        if ("string" === $.type(value) && value.indexOf("$") >= 0) {
	            replaceDollarCount = "$".replace("$", "$$").length;
	            value = value.replace("$", 1 === replaceDollarCount ? "$$$$" : "$$")
	        }
	        s = s.replace(reg, value)
	    }
	    return s
	};
	var replaceAll = function() {
	    var quote = function(str) {
	        return (str + "").replace(/([\+\*\?\\\.\[\^\]\$\(\)\{\}\><\|\=\!\:])/g, "\\$1")
	    };
	    return function(text, searchToken, replacementToken) {
	        return text.replace(new RegExp("(" + quote(searchToken) + ")", "gi"), replacementToken)
	    }
	}();
	var isEmpty = function() {
	    var SPACE_REGEXP = /\s/g;
	    return function(text) {
	        return !text || !text.replace(SPACE_REGEXP, "")
	    }
	}();
	exports.encodeHtml = encodeHtml;
	exports.pairToObject = pairToObject;
	exports.quadToObject = quadToObject;
	exports.format = stringFormat;
	exports.replaceAll = replaceAll;
	exports.isEmpty = isEmpty;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/common.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    config = __webpack_require__(9),
	    when = __webpack_require__(10).when;
	var isDefined = function(object) {
	    return null !== object && void 0 !== object
	};
	var isString = function(object) {
	    return "string" === $.type(object)
	};
	var isNumber = function(object) {
	    return "number" === typeof object && isFinite(object) || $.isNumeric(object)
	};
	var isObject = function(object) {
	    return "object" === $.type(object)
	};
	var isArray = function(object) {
	    return "array" === $.type(object)
	};
	var isDate = function(object) {
	    return "date" === $.type(object)
	};
	var isBoolean = function(object) {
	    return "boolean" === $.type(object)
	};
	var isFunction = function(object) {
	    return "function" === $.type(object)
	};
	var isPrimitive = function(value) {
	    return $.inArray($.type(value), ["object", "array", "function"]) === -1
	};
	var isExponential = function(value) {
	    return isNumber(value) && value.toString().indexOf("e") !== -1
	};
	var ensureDefined = function(value, defaultValue) {
	    return isDefined(value) ? value : defaultValue
	};
	var getDefaultAlignment = function(isRtlEnabled) {
	    var rtlEnabled = isRtlEnabled || config().rtlEnabled;
	    return rtlEnabled ? "right" : "left"
	};
	var executeAsync = function(action, context) {
	    var timerId, deferred = $.Deferred(),
	        normalizedContext = context || this,
	        task = {
	            promise: deferred.promise(),
	            abort: function() {
	                clearTimeout(timerId);
	                deferred.rejectWith(normalizedContext)
	            }
	        },
	        callback = function() {
	            var result = action.call(normalizedContext);
	            if (result && result.done && $.isFunction(result.done)) {
	                result.done(function() {
	                    deferred.resolveWith(normalizedContext)
	                })
	            } else {
	                deferred.resolveWith(normalizedContext)
	            }
	        };
	    timerId = (arguments[2] || setTimeout)(callback, "number" === typeof context ? context : 0);
	    return task
	};
	var delayedFuncs = [];
	var delayedNames = [];
	var delayedDeferreds = [];
	var executingName;
	var deferExecute = function(name, func, deferred) {
	    if (executingName && executingName !== name) {
	        delayedFuncs.push(func);
	        delayedNames.push(name);
	        deferred = deferred || $.Deferred();
	        delayedDeferreds.push(deferred);
	        return deferred
	    } else {
	        var oldExecutingName = executingName,
	            currentDelayedCount = delayedDeferreds.length;
	        executingName = name;
	        var result = func();
	        if (!result) {
	            if (delayedDeferreds.length > currentDelayedCount) {
	                result = when.apply($, delayedDeferreds.slice(currentDelayedCount))
	            } else {
	                if (deferred) {
	                    deferred.resolve()
	                }
	            }
	        }
	        executingName = oldExecutingName;
	        if (deferred && result && result.done) {
	            result.done(deferred.resolve).fail(deferred.reject)
	        }
	        if (!executingName && delayedFuncs.length) {
	            ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift())
	        }
	        return result
	    }
	};
	var deferRender = function(func, deferred) {
	    return deferExecute("render", func, deferred)
	};
	var deferUpdate = function(func, deferred) {
	    return deferExecute("update", func, deferred)
	};
	var deferRenderer = function(func) {
	    return function() {
	        var that = this;
	        return deferExecute("render", function() {
	            return func.call(that)
	        })
	    }
	};
	var deferUpdater = function(func) {
	    return function() {
	        var that = this;
	        return deferExecute("update", function() {
	            return func.call(that)
	        })
	    }
	};
	var findBestMatches = function(targetFilter, items, mapFn) {
	    var bestMatches = [],
	        maxMatchCount = 0;
	    $.each(items, function(index, itemSrc) {
	        var matchCount = 0,
	            item = mapFn ? mapFn(itemSrc) : itemSrc;
	        $.each(targetFilter, function(paramName, targetValue) {
	            var value = item[paramName];
	            if (void 0 === value) {
	                return
	            }
	            if (match(value, targetValue)) {
	                matchCount++;
	                return
	            }
	            matchCount = -1;
	            return false
	        });
	        if (matchCount < maxMatchCount) {
	            return
	        }
	        if (matchCount > maxMatchCount) {
	            bestMatches.length = 0;
	            maxMatchCount = matchCount
	        }
	        bestMatches.push(itemSrc)
	    });
	    return bestMatches
	};
	var match = function(value, targetValue) {
	    if ($.isArray(value) && $.isArray(targetValue)) {
	        var mismatch = false;
	        $.each(value, function(index, valueItem) {
	            if (valueItem !== targetValue[index]) {
	                mismatch = true;
	                return false
	            }
	        });
	        if (mismatch) {
	            return false
	        }
	        return true
	    }
	    if (value === targetValue) {
	        return true
	    }
	    return false
	};
	var splitPair = function(raw) {
	    switch (typeof raw) {
	        case "string":
	            return raw.split(/\s+/, 2);
	        case "object":
	            return [raw.x || raw.h, raw.y || raw.v];
	        case "number":
	            return [raw];
	        default:
	            return raw
	    }
	};
	var splitQuad = function(raw) {
	    switch (typeof raw) {
	        case "string":
	            return raw.split(/\s+/, 4);
	        case "object":
	            return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
	        case "number":
	            return [raw];
	        default:
	            return raw
	    }
	};
	var normalizeKey = function(id) {
	    var key = isString(id) ? id : id.toString(),
	        arr = key.match(/[^a-zA-Z0-9]/g);
	    arr && $.each(arr, function(_, sign) {
	        key = key.replace(sign, "_" + sign.charCodeAt() + "_")
	    });
	    return key
	};
	var isArraysEqualByValue = function(array1, array2, deep) {
	    if (array1.length !== array2.length) {
	        return false
	    }
	    for (var i = 0; i < array1.length; i++) {
	        if (!equalByValue(array1[i], array2[i], deep + 1)) {
	            return false
	        }
	    }
	    return true
	};
	var isObjectsEqualByValue = function(object1, object2, deep) {
	    for (var propertyName in object1) {
	        if (object1.hasOwnProperty(propertyName) && !equalByValue(object1[propertyName], object2[propertyName], deep + 1)) {
	            return false
	        }
	    }
	    for (propertyName in object2) {
	        if (!(propertyName in object1)) {
	            return false
	        }
	    }
	    return true
	};
	var equalByValue = function(object1, object2, deep) {
	    if (object1 === object2) {
	        return true
	    }
	    var maxDeep = 3;
	    deep = deep || 0;
	    if (deep >= maxDeep) {
	        return true
	    }
	    if (isObject(object1) && isObject(object2)) {
	        return isObjectsEqualByValue(object1, object2, deep)
	    } else {
	        if (isArray(object1) && isArray(object2)) {
	            return isArraysEqualByValue(object1, object2, deep)
	        } else {
	            if (isDate(object1) && isDate(object2)) {
	                return object1.getTime() === object2.getTime()
	            }
	        }
	    }
	    return false
	};
	var getKeyHash = function(key) {
	    if (isObject(key) || isArray(key)) {
	        try {
	            var keyHash = JSON.stringify(key);
	            return "{}" === keyHash ? key : keyHash
	        } catch (e) {
	            return key
	        }
	    }
	    return key
	};
	var escapeRegExp = function(string) {
	    return string.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
	};
	var applyServerDecimalSeparator = function(value) {
	    var separator = config().serverDecimalSeparator;
	    if (isDefined(value)) {
	        value = value.toString().replace(".", separator)
	    }
	    return value
	};
	exports.isDefined = isDefined;
	exports.isString = isString;
	exports.isNumber = isNumber;
	exports.isObject = isObject;
	exports.isArray = isArray;
	exports.isDate = isDate;
	exports.isBoolean = isBoolean;
	exports.isFunction = isFunction;
	exports.isPrimitive = isPrimitive;
	exports.isExponential = isExponential;
	exports.ensureDefined = ensureDefined;
	exports.executeAsync = executeAsync;
	exports.deferRender = deferRender;
	exports.deferRenderer = deferRenderer;
	exports.deferUpdate = deferUpdate;
	exports.deferUpdater = deferUpdater;
	exports.splitPair = splitPair;
	exports.splitQuad = splitQuad;
	exports.findBestMatches = findBestMatches;
	exports.getDefaultAlignment = getDefaultAlignment;
	exports.normalizeKey = normalizeKey;
	exports.equalByValue = equalByValue;
	exports.getKeyHash = getKeyHash;
	exports.escapeRegExp = escapeRegExp;
	exports.applyServerDecimalSeparator = applyServerDecimalSeparator;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/config.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    config = {
	        rtlEnabled: false,
	        defaultCurrency: "USD",
	        designMode: false,
	        serverDecimalSeparator: "."
	    };
	module.exports = function() {
	    if (!arguments.length) {
	        return config
	    }
	    $.extend(config, arguments[0])
	};
	module.exports.default = module.exports;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/jquery/deferred.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    compareVersion = __webpack_require__(11).compare;
	exports.fromPromise = function(promise, context) {
	    var isDeferred = promise && $.isFunction(promise.done) && $.isFunction(promise.fail);
	    if (isDeferred) {
	        return promise
	    }
	    var d = $.Deferred();
	    promise.then(function() {
	        d.resolveWith.apply(d, [context].concat([$.makeArray(arguments)]))
	    }, function() {
	        d.rejectWith.apply(d, [context].concat([$.makeArray(arguments)]))
	    });
	    return d
	};
	exports.when = compareVersion($.fn.jquery, [3]) < 0 ? $.when : function(singleArg) {
	    if (0 === arguments.length) {
	        return $.Deferred().resolve()
	    } else {
	        if (1 === arguments.length) {
	            return singleArg && singleArg.then ? singleArg : $.Deferred().resolve(singleArg)
	        } else {
	            return $.when.apply($, arguments)
	        }
	    }
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (core/utils/version.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	exports.compare = function(x, y, maxLevel) {
	    function normalizeArg(value) {
	        if ("string" === typeof value) {
	            return value.split(".")
	        }
	        if ("number" === typeof value) {
	            return [value]
	        }
	        return value
	    }
	    x = normalizeArg(x);
	    y = normalizeArg(y);
	    var length = Math.max(x.length, y.length);
	    if (isFinite(maxLevel)) {
	        length = Math.min(length, maxLevel)
	    }
	    for (var i = 0; i < length; i++) {
	        var xItem = parseInt(x[i] || 0, 10),
	            yItem = parseInt(y[i] || 0, 10);
	        if (xItem < yItem) {
	            return -1
	        }
	        if (xItem > yItem) {
	            return 1
	        }
	    }
	    return 0
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (core/version.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = "16.2.3";


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (client_exporter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var fileSaver = __webpack_require__(14).fileSaver,
	    _isFunction = __webpack_require__(8).isFunction;
	exports.export = function(data, options, getData) {
	    if (!data) {
	        return
	    }
	    var exportingAction = options.exportingAction,
	        exportedAction = options.exportedAction,
	        fileSavingAction = options.fileSavingAction,
	        eventArgs = {
	            fileName: options.fileName,
	            format: options.format,
	            cancel: false
	        };
	    _isFunction(exportingAction) && exportingAction(eventArgs);
	    if (!eventArgs.cancel) {
	        getData(data, options, function(blob) {
	            _isFunction(exportedAction) && exportedAction();
	            if (_isFunction(fileSavingAction)) {
	                eventArgs.data = blob;
	                fileSavingAction(eventArgs)
	            }
	            if (!eventArgs.cancel) {
	                fileSaver.saveAs(eventArgs.fileName, options.format, blob, options.proxyUrl)
	            }
	        })
	    }
	};
	exports.fileSaver = fileSaver;
	exports.excel = {
	    creator: __webpack_require__(17).ExcelCreator,
	    getData: __webpack_require__(17).getData,
	    formatConverter: __webpack_require__(17).excelFormatConverter
	};
	exports.image = {
	    creator: __webpack_require__(23).imageCreator,
	    getData: __webpack_require__(23).getData
	};
	exports.pdf = {
	    getData: __webpack_require__(25).getData
	};
	exports.svg = {
	    creator: __webpack_require__(26).svgCreator,
	    getData: __webpack_require__(26).getData
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (client_exporter/file_saver.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(15),
	    browser = __webpack_require__(16),
	    commonUtils = __webpack_require__(8),
	    FILE_EXTESIONS = {
	        EXCEL: "xlsx",
	        CSS: "css",
	        PNG: "png",
	        JPEG: "jpeg",
	        GIF: "gif",
	        SVG: "svg",
	        PDF: "pdf"
	    };
	var MIME_TYPES = exports.MIME_TYPES = {
	    CSS: "text/css",
	    EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
	    PNG: "image/png",
	    JPEG: "image/jpeg",
	    GIF: "image/gif",
	    SVG: "image/svg+xml",
	    PDF: "application/pdf"
	};
	exports.fileSaver = {
	    _getDataUri: function(format, data) {
	        return "data:" + MIME_TYPES[format] + ";base64," + data
	    },
	    _linkDownloader: function(fileName, href, callback) {
	        var exportLinkElement = document.createElement("a"),
	            attributes = {
	                download: fileName,
	                href: href
	            };
	        document.body.appendChild(exportLinkElement);
	        $(exportLinkElement).css({
	            display: "none"
	        }).text("load").attr(attributes)[0].click();
	        return exportLinkElement
	    },
	    _formDownloader: function(proxyUrl, fileName, contentType, data, callback) {
	        var formAttributes = {
	                method: "post",
	                action: proxyUrl,
	                enctype: "multipart/form-data"
	            },
	            exportForm = $("<form>").css({
	                display: "none"
	            }).attr(formAttributes);
	        exportForm.append('<input type="hidden" name="fileName" value="' + fileName + '" />');
	        exportForm.append('<input type="hidden" name="contentType" value="' + contentType + '" />');
	        exportForm.append('<input type="hidden" name="data" value="' + data + '" />');
	        exportForm.appendTo("body");
	        exportForm.submit();
	        if (exportForm.submit()) {
	            exportForm.remove()
	        }
	    },
	    _saveByProxy: function(proxyUrl, fileName, format, data, callback) {
	        return this._formDownloader(proxyUrl, fileName, MIME_TYPES[format], data, callback)
	    },
	    _winJSBlobSave: function(blob, fileName, format) {
	        var savePicker = new Windows.Storage.Pickers.FileSavePicker;
	        savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
	        savePicker.fileTypeChoices.insert(MIME_TYPES[format], ["." + FILE_EXTESIONS[format]]);
	        savePicker.suggestedFileName = fileName;
	        savePicker.pickSaveFileAsync().then(function(file) {
	            if (file) {
	                file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function(outputStream) {
	                    var inputStream = blob.msDetachStream();
	                    Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
	                        outputStream.flushAsync().done(function() {
	                            inputStream.close();
	                            outputStream.close()
	                        })
	                    })
	                })
	            }
	        })
	    },
	    _saveBlobAs: function(fileName, format, data, linkClick) {
	        this._blobSaved = false;
	        if (commonUtils.isDefined(navigator.msSaveOrOpenBlob)) {
	            navigator.msSaveOrOpenBlob(data, fileName);
	            this._blobSaved = true
	        } else {
	            if (commonUtils.isDefined(window.WinJS)) {
	                this._winJSBlobSave(data, fileName, format);
	                this._blobSaved = true
	            } else {
	                var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
	                linkClick = commonUtils.isDefined(linkClick) ? linkClick : function() {
	                    var link = $("#dxExportLink");
	                    URL.revokeObjectURL(link.attr("href"));
	                    link.remove()
	                };
	                if (commonUtils.isDefined(URL)) {
	                    return this._linkDownloader(fileName, URL.createObjectURL(data), linkClick)
	                }
	            }
	        }
	    },
	    saveAs: function(fileName, format, data, proxyURL, linkClick) {
	        fileName += "." + FILE_EXTESIONS[format];
	        if (commonUtils.isFunction(window.Blob)) {
	            this._saveBlobAs(fileName, format, data)
	        } else {
	            if (commonUtils.isDefined(proxyURL) && !commonUtils.isDefined(navigator.userAgent.match(/iPad/i))) {
	                this._saveByProxy(proxyURL, fileName, format, data)
	            } else {
	                if (!commonUtils.isDefined(navigator.userAgent.match(/iPad/i))) {
	                    errors.log("E1034")
	                }
	                if (browser.msie && parseInt(browser.version) < 10) {
	                    return
	                }
	                this._linkDownloader(fileName, this._getDataUri(format, data), linkClick)
	            }
	        }
	    }
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/ui.errors.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var errorUtils = __webpack_require__(4),
	    errors = __webpack_require__(3);
	module.exports = errorUtils(errors.ERROR_MESSAGES, {
	    E1001: "Module '{0}'. Controller '{1}' is already registered",
	    E1002: "Module '{0}'. Controller '{1}' must be inheritor of DevExpress.ui.dxDataGrid.Controller",
	    E1003: "Module '{0}'. View '{1}' is already registered",
	    E1004: "Module '{0}'. View '{1}' must be inheritor of DevExpress.ui.dxDataGrid.View",
	    E1005: "Public method '{0}' is already registered",
	    E1006: "Public method '{0}.{1}' is not exists",
	    E1007: "State storing can not be provided due to the restrictions of your browser",
	    E1010: "A template should contain dxTextBox widget",
	    E1011: "You have to implement 'remove' method in dataStore used by dxList to be able to delete items",
	    E1012: "Editing type '{0}' with name '{1}' not supported",
	    E1016: "Unexpected type of data source is provided for a lookup column",
	    E1018: "The 'collapseAll' method cannot be called when using a remote data source",
	    E1019: "Search mode '{0}' is unavailable",
	    E1020: "Type can not be changed after initialization",
	    E1021: "{0} '{1}' you are trying to remove does not exist",
	    E1022: "Markers option should be an array",
	    E1023: "Routes option should be an array",
	    E1025: "This layout is too complex to render",
	    E1026: "The 'custom' value is set to a summary item's summaryType option, but a function for calculating the custom summary is not assigned to the grid's calculateCustomSummary option",
	    E1030: "Unknown dxScrollView refresh strategy: '{0}'",
	    E1031: "Unknown subscription is detected in the dxScheduler widget: '{0}'",
	    E1032: "Unknown start date is detected in an appointment of the dxScheduler widget: '{0}'",
	    E1033: "Unknown step is specified for the scheduler's navigator: '{0}'",
	    E1034: "The current browser does not implement an API required for saving files",
	    E1035: "The editor could not be created because of the internal error: {0}",
	    E1036: "Validation rules are not defined for any form item",
	    E1037: "Invalid structure of grouped data",
	    E1038: "Your browser does not support local storage for local web pages",
	    E1039: "The cell position can not be calculated",
	    E1040: "The key value should be unique within the data array",
	    E1041: "The jszip script should be included before DevExtreme scripts",
	    E1042: 'Selection cannot be performed asynchronously if the "key" field is not set for the store.',
	    W1001: "Key option can not be modified after initialization",
	    W1002: "The item with the key '{0}' does not exist",
	    W1003: "Group with key '{0}' in which you are trying to select items does not exist",
	    W1004: "Item '{0}' you are trying to select in group '{1}' does not exist",
	    W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns."
	});


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/browser.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var webkitRegExp = /(webkit)[ \/]([\w.]+)/,
	    ieRegExp = /(msie) (\d{1,2}\.\d)/,
	    ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/,
	    msEdge = /(edge)\/((\d+)?[\w\.]+)/,
	    mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
	var browserFromUA = function(ua) {
	    ua = ua.toLowerCase();
	    var result = {},
	        matches = ieRegExp.exec(ua) || ie11RegExp.exec(ua) || msEdge.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || webkitRegExp.exec(ua) || [],
	        browserName = matches[1],
	        browserVersion = matches[2];
	    if ("trident" === browserName || "edge" === browserName) {
	        browserName = "msie"
	    }
	    if (browserName) {
	        result[browserName] = true;
	        result.version = browserVersion
	    }
	    return result
	};
	module.exports = $.extend({
	    _fromUA: browserFromUA
	}, browserFromUA(navigator.userAgent));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (client_exporter/excel_creator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    errors = __webpack_require__(15),
	    stringUtils = __webpack_require__(7),
	    JSZip = __webpack_require__(19),
	    numberFormatter = __webpack_require__(20),
	    fileSaver = __webpack_require__(14),
	    XML_TAG = '<?xml version="1.0" encoding="utf-8"?>',
	    GROUP_SHEET_PR_XML = '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>',
	    SINGLE_SHEET_PR_XML = "<sheetPr/>",
	    BASE_STYLE_XML = '<fonts count="2"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="1"><fill><patternFill patternType="none"/></fill></fills><borders count="1"><border><left style="thin"><color rgb="FFD3D3D3"/></left><right style="thin"><color rgb="FFD3D3D3"/></right><top style="thin"><color rgb="FFD3D3D3"/></top><bottom style="thin"><color rgb="FFD3D3D3"/></bottom></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>',
	    OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org",
	    RELATIONSHIP_PART_NAME = "rels",
	    XL_FOLDER_NAME = "xl",
	    WORKBOOK_FILE_NAME = "workbook.xml",
	    CONTENTTYPES_FILE_NAME = "[Content_Types].xml",
	    SHAREDSTRING_FILE_NAME = "sharedStrings.xml",
	    STYLE_FILE_NAME = "styles.xml",
	    WORKSHEETS_FOLDER = "worksheets",
	    WORKSHEET_FILE_NAME = "sheet1.xml",
	    DEFINED_DATE_FORMATS = {
	        longDate: "d MMMM yyyy",
	        longTime: "H:mm:ss",
	        monthAndDay: "MMMM dd",
	        monthAndYear: "MMMM yyyy",
	        quarterAndYear: "MM\\/dd\\/yyyy",
	        shortDate: "MM\\/dd\\/yyyy",
	        shortTime: "H:mm",
	        shortDateShortTime: "m\\/d\\/yy h:mm AM/PM",
	        longDateLongTime: "dddd, mmmm dd, yyyy H:mm:ss AM/PM",
	        dayOfWeek: "dddd",
	        millisecond: "H:mm:ss",
	        day: "dd",
	        month: "MMMM",
	        quarter: "MM\\/dd\\/yyyy",
	        year: "yyyy"
	    },
	    DEFAULT_DATE_FORMAT = "shortTime",
	    DEFINED_NUMBER_FORMTATS = {
	        thousands: "#,##0{0},&quot;K&quot;",
	        millions: "#,##0{0},,&quot;M&quot;",
	        billions: "#,##0{0},,,&quot;B&quot;",
	        trillions: "#,##0{0},,,,&quot;T&quot;",
	        percent: "0{0}%",
	        decimal: "#{0}",
	        fixedpoint: "#,##0{0}",
	        exponential: "0{0}E+00",
	        currency: " "
	    },
	    VALID_TYPES = {
	        "boolean": "b",
	        date: "d",
	        number: "n",
	        string: "s"
	    },
	    EXCEL_START_TIME = Date.UTC(1899, 11, 30),
	    DAYS_COUNT_BEFORE_29_FEB_1900 = 60,
	    BOLD_STYLES_COUNT = 4,
	    MAX_DIGIT_WIDTH_IN_PIXELS = 7,
	    CUSTOM_FORMAT_START_INDEX = 165;
	__webpack_require__(22);
	exports.excelFormatConverter = {
	    _applyPrecision: function(format, precision) {
	        var result, i;
	        if (precision > 0) {
	            result = "decimal" !== format ? "." : "";
	            for (i = 0; i < precision; i++) {
	                result += "0"
	            }
	            return result
	        }
	        return ""
	    },
	    _getCurrencyFormat: function(currency) {
	        return numberFormatter.getOpenXmlCurrencyFormat(currency)
	    },
	    _convertDateFormat: function(format) {
	        return DEFINED_DATE_FORMATS[format] || DEFINED_DATE_FORMATS[DEFAULT_DATE_FORMAT]
	    },
	    _convertNumberFormat: function(format, precision, currency) {
	        var result, excelFormat = "currency" === format ? this._getCurrencyFormat(currency) : DEFINED_NUMBER_FORMTATS[format.toLowerCase()];
	        if (excelFormat) {
	            result = stringUtils.format(excelFormat, this._applyPrecision(format, precision))
	        }
	        return result
	    },
	    convertFormat: function(format, precision, type, currency) {
	        if (commonUtils.isDefined(format)) {
	            if ("date" === type) {
	                return exports.excelFormatConverter._convertDateFormat(format)
	            } else {
	                if (DEFINED_NUMBER_FORMTATS[format.toLowerCase()]) {
	                    return exports.excelFormatConverter._convertNumberFormat(format, precision, currency)
	                }
	            }
	        }
	    }
	};
	exports.ExcelCreator = Class.inherit({
	    _getXMLTag: function(tagName, attributes, content) {
	        var i, attr, result = "<" + tagName,
	            length = attributes.length;
	        for (i = 0; i < length; i++) {
	            attr = attributes[i];
	            result = result + " " + attr.name + '="' + attr.value + '"'
	        }
	        return commonUtils.isDefined(content) ? result + ">" + content + "</" + tagName + ">" : result + " />"
	    },
	    _getDataProviderRowIndex: function(rowIndex) {
	        var correctRowIndex = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 0;
	        return rowIndex - correctRowIndex
	    },
	    _getExcelRowIndex: function(exRowIndex) {
	        var correctRowIndex = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 0;
	        return exRowIndex + correctRowIndex
	    },
	    _getCellIndex: function(rowIndex, cellIndex) {
	        var charCode, sheetIndex = "",
	            max = 26;
	        if (this._maxIndex[0] < Number(rowIndex)) {
	            this._maxIndex[0] = Number(rowIndex)
	        }
	        if (this._maxIndex[1] < Number(cellIndex)) {
	            this._maxIndex[1] = Number(cellIndex)
	        }
	        while (true) {
	            charCode = 65 + (cellIndex >= max ? cellIndex % max : Math.ceil(cellIndex));
	            sheetIndex = String.fromCharCode(charCode) + sheetIndex;
	            if (cellIndex >= max) {
	                cellIndex = Math.floor(cellIndex / max) - 1
	            } else {
	                break
	            }
	        }
	        return sheetIndex + rowIndex
	    },
	    _getDataType: function(dataType) {
	        return VALID_TYPES[dataType] || "s"
	    },
	    _formatObjectConverter: function(format, precision, dataType) {
	        var result = {
	            format: format,
	            precision: precision,
	            dataType: dataType
	        };
	        if (commonUtils.isObject(format)) {
	            return $.extend(result, format, {
	                format: format.type,
	                currency: format.currency
	            })
	        }
	        return result
	    },
	    _appendFormat: function(format, precision, dataType) {
	        var currency, newFormat = this._formatObjectConverter(format, precision, dataType);
	        format = newFormat.format;
	        precision = newFormat.precision;
	        currency = newFormat.currency;
	        dataType = newFormat.dataType;
	        format = exports.excelFormatConverter.convertFormat(format, precision, dataType, currency);
	        if (format) {
	            if ($.inArray(format, this._styleFormat) === -1) {
	                this._styleFormat.push(format)
	            }
	            return $.inArray(format, this._styleFormat) + 1
	        }
	    },
	    _appendString: function(value) {
	        if (commonUtils.isDefined(value)) {
	            value = String(value);
	            if (value.length) {
	                value = stringUtils.encodeHtml(value);
	                if (void 0 === this._stringHash[value]) {
	                    this._stringHash[value] = this._stringArray.length;
	                    this._stringArray.push(value)
	                }
	                return this._stringHash[value]
	            }
	        }
	    },
	    _getExcelDateValue: function(date) {
	        var days, totalTime;
	        if (commonUtils.isDate(date)) {
	            days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / 864e5);
	            if (days < DAYS_COUNT_BEFORE_29_FEB_1900) {
	                days--
	            }
	            totalTime = (3600 * date.getHours() + 60 * date.getMinutes() + date.getSeconds()) / 86400;
	            return days + totalTime
	        }
	    },
	    _prepareValue: function(rowIndex, cellIndex) {
	        var dataProvider = this._dataProvider,
	            value = dataProvider.getCellValue(rowIndex, cellIndex),
	            type = this._getDataType(dataProvider.getCellType(rowIndex, cellIndex)),
	            formatID = this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID,
	            format = commonUtils.isNumber(formatID) ? this._styleFormat[formatID - 1] : null;
	        if ("d" === type && !commonUtils.isDate(value)) {
	            type = "s"
	        }
	        switch (type) {
	            case "s":
	                value = this._appendString(value);
	                break;
	            case "d":
	                value = this._getExcelDateValue(value, format);
	                type = "n"
	        }
	        return {
	            value: value,
	            type: type
	        }
	    },
	    _getHeadersArray: function() {
	        var i, j, column, columns = this._dataProvider.getColumns(true),
	            result = [];
	        for (i = 0; i < columns.length - 1; i++) {
	            result.push([]);
	            for (j = 0; j < columns[i].length; j++) {
	                column = columns[i][j];
	                result[i].push({
	                    style: 0,
	                    type: "s",
	                    value: this._appendString(column.caption)
	                })
	            }
	        }
	        return result
	    },
	    _getDataArray: function() {
	        var rowIndex, cellIndex, cellsArray, cellData, cellsLength, type, styleID, result = [],
	            rowsLength = this._dataProvider.getRowsCount(),
	            columns = this._dataProvider.getColumns();
	        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
	            cellsArray = [];
	            cellsLength = columns.length;
	            for (cellIndex = 0; cellIndex !== cellsLength; cellIndex++) {
	                cellData = this._prepareValue(rowIndex, cellIndex);
	                type = cellData.type;
	                if (!this._dataProvider.isGroupRow(rowIndex) && commonUtils.isDefined(this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID) && "s" !== cellData.type) {
	                    type = "n"
	                }
	                styleID = cellIndex + BOLD_STYLES_COUNT;
	                if (this._dataProvider.isGroupRow(rowIndex)) {
	                    styleID = BOLD_STYLES_COUNT - 1
	                }
	                if (this._dataProvider.isTotalCell(rowIndex, cellIndex)) {
	                    styleID = this._getBoldStyleID(columns[cellIndex].alignment)
	                }
	                cellsArray.push({
	                    style: styleID,
	                    value: cellData.value,
	                    type: type
	                })
	            }
	            if (rowIndex && !this._needSheetPr && this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)) > 0) {
	                this._needSheetPr = true
	            }
	            result.push(cellsArray)
	        }
	        return result
	    },
	    _getBoldStyleID: function(alignment) {
	        for (var i = 0; i < BOLD_STYLES_COUNT - 1; i++) {
	            if (this._styleArray[i].alignment === alignment) {
	                return i
	            }
	        }
	    },
	    _calculateWidth: function(pixelsWidth) {
	        pixelsWidth = parseInt(pixelsWidth, 10);
	        if (!pixelsWidth || pixelsWidth < 5) {
	            pixelsWidth = 100
	        }
	        return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + .5) / 100)
	    },
	    _prepareStyleData: function() {
	        var i, column, wrapText = Number(!!this._options.wrapTextEnabled),
	            alignments = ["center", "left", "right"],
	            columns = this._dataProvider.getColumns();
	        for (i = 0; i < alignments.length; i++) {
	            this._styleArray.push({
	                bold: true,
	                alignment: alignments[i],
	                wrapText: 1
	            })
	        }
	        this._styleArray.push({
	            bold: true,
	            alignment: commonUtils.getDefaultAlignment(this._rtlEnabled),
	            wrapText: 0
	        });
	        for (i = 0; i < columns.length; i++) {
	            column = columns[i];
	            this._styleArray.push({
	                alignment: commonUtils.isDefined(column.alignment) ? column.alignment : "left",
	                formatID: this._appendFormat(column.format, column.precision, column.dataType),
	                wrapText: wrapText
	            });
	            this._colsArray.push(this._calculateWidth(column.width))
	        }
	    },
	    _prepareCellData: function() {
	        if (this._dataProvider.isHeadersVisible()) {
	            this._cellsArray = this._cellsArray.concat(this._getHeadersArray())
	        }
	        this._cellsArray = this._cellsArray.concat(this._getDataArray())
	    },
	    _createXMLRelationships: function(xmlRelationships) {
	        return this._getXMLTag("Relationships", [{
	            name: "xmlns",
	            value: OPEN_XML_FORMAT_URL + "/package/2006/relationships"
	        }], xmlRelationships)
	    },
	    _createXMLRelationship: function(id, type, target) {
	        return this._getXMLTag("Relationship", [{
	            name: "Id",
	            value: "rId" + id
	        }, {
	            name: "Type",
	            value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type
	        }, {
	            name: "Target",
	            value: target
	        }])
	    },
	    _getWorkbookContent: function() {
	        var content = '<bookViews><workbookView xWindow="0" yWindow="0" windowWidth="0" windowHeight="0"/></bookViews><sheets><sheet name="Sheet" sheetId="1" r:id="rId1" /></sheets><definedNames><definedName name="_xlnm.Print_Titles" localSheetId="0">Sheet!$1:$1</definedName><definedName name="_xlnm._FilterDatabase" hidden="0" localSheetId="0">Sheet!$A$1:$F$6332</definedName></definedNames>';
	        return XML_TAG + this._getXMLTag("workbook", [{
	            name: "xmlns:r",
	            value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships"
	        }, {
	            name: "xmlns",
	            value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
	        }], content)
	    },
	    _getContentTypesContent: function() {
	        return XML_TAG + '<Types xmlns="' + OPEN_XML_FORMAT_URL + '/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" /><Default Extension="xml" ContentType="application/xml" /><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" /><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" /><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" /><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" /></Types>'
	    },
	    _generateStylesXML: function() {
	        var styleIndex, style, formatIndex, folder = this._zip.folder(XL_FOLDER_NAME),
	            stylesLength = this._styleArray.length,
	            xmlStyles = [],
	            XML = "";
	        for (formatIndex = 0; formatIndex < this._styleFormat.length; formatIndex++) {
	            this._styleFormat[formatIndex] = this._getXMLTag("numFmt", [{
	                name: "numFmtId",
	                value: Number(formatIndex) + CUSTOM_FORMAT_START_INDEX
	            }, {
	                name: "formatCode",
	                value: this._styleFormat[formatIndex]
	            }])
	        }
	        XML = XML + this._getXMLTag("numFmts", [{
	            name: "count",
	            value: this._styleFormat.length
	        }], this._styleFormat.join("")) + BASE_STYLE_XML;
	        for (styleIndex = 0; styleIndex < stylesLength; styleIndex++) {
	            style = this._styleArray[styleIndex];
	            xmlStyles.push(this._getXMLTag("xf", [{
	                name: "xfId",
	                value: 0
	            }, {
	                name: "applyAlignment",
	                value: 1
	            }, {
	                name: "fontId",
	                value: Number(!!style.bold)
	            }, {
	                name: "applyNumberFormat",
	                value: commonUtils.isDefined(style.formatID) ? 1 : 0
	            }, {
	                name: "numFmtId",
	                value: commonUtils.isDefined(style.formatID) ? Number(style.formatID) + CUSTOM_FORMAT_START_INDEX - 1 : 0
	            }], this._getXMLTag("alignment", [{
	                name: "horizontal",
	                value: style.alignment
	            }, {
	                name: "vertical",
	                value: "top"
	            }, {
	                name: "wrapText",
	                value: style.wrapText
	            }])))
	        }
	        XML += this._getXMLTag("cellXfs", [{
	            name: "count",
	            value: xmlStyles.length
	        }], xmlStyles.join(""));
	        XML += this._getXMLTag("cellStyles", [{
	            name: "count",
	            value: 1
	        }], this._getXMLTag("cellStyle", [{
	            name: "name",
	            value: "Normal"
	        }, {
	            name: "xfId",
	            value: 0
	        }, {
	            name: "builtinId",
	            value: 0
	        }]));
	        XML = XML_TAG + this._getXMLTag("styleSheet", [{
	            name: "xmlns",
	            value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
	        }], XML);
	        folder.file(STYLE_FILE_NAME, XML);
	        this._styleArray = []
	    },
	    _generateStringsXML: function() {
	        var stringIndex, folder = this._zip.folder(XL_FOLDER_NAME),
	            stringsLength = this._stringArray.length,
	            sharedStringXml = XML_TAG;
	        for (stringIndex = 0; stringIndex < stringsLength; stringIndex++) {
	            this._stringArray[stringIndex] = this._getXMLTag("si", [], this._getXMLTag("t", [], this._stringArray[stringIndex]))
	        }
	        sharedStringXml += this._getXMLTag("sst", [{
	            name: "xmlns",
	            value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
	        }, {
	            name: "count",
	            value: this._stringArray.length
	        }, {
	            name: "uniqueCount",
	            value: this._stringArray.length
	        }], this._stringArray.join(""));
	        folder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
	        this._stringArray = []
	    },
	    _getPaneXML: function() {
	        var attributes = [{
	                name: "activePane",
	                value: "bottomLeft"
	            }, {
	                name: "state",
	                value: "frozen"
	            }],
	            frozenArea = this._dataProvider.getFrozenArea();
	        if (!(frozenArea.x || frozenArea.y)) {
	            return ""
	        }
	        if (frozenArea.x) {
	            attributes.push({
	                name: "xSplit",
	                value: frozenArea.x
	            })
	        }
	        if (frozenArea.y) {
	            attributes.push({
	                name: "ySplit",
	                value: frozenArea.y
	            })
	        }
	        attributes.push({
	            name: "topLeftCell",
	            value: this._getCellIndex(frozenArea.y + 1, frozenArea.x)
	        });
	        return this._getXMLTag("pane", attributes)
	    },
	    _generateWorksheetXML: function() {
	        var colIndex, rowIndex, cellData, xmlCells, maxCellIndex, cellsLength, counter = 0,
	            xmlRows = [],
	            rowsLength = this._cellsArray.length,
	            colsLength = this._colsArray.length,
	            rSpans = "1:" + colsLength,
	            headerRowCount = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 1,
	            xmlResult = [
	                ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">', this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML, '<dimension ref="A1:', this._getCellIndex(this._maxIndex[0], this._maxIndex[1]) + '"/><sheetViews><sheetView ' + (this._rtlEnabled ? 'rightToLeft="1" ' : "") + 'tabSelected="1" workbookViewId="0">' + this._getPaneXML() + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" outlineLevelRow="', this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0, '" x14ac:dyDescent="0.25"/>'].join("")
	            ];
	        for (colIndex = 0; colIndex < colsLength; colIndex++) {
	            this._colsArray[colIndex] = this._getXMLTag("col", [{
	                name: "width",
	                value: this._colsArray[colIndex]
	            }, {
	                name: "min",
	                value: Number(colIndex) + 1
	            }, {
	                name: "max",
	                value: Number(colIndex) + 1
	            }])
	        }
	        xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
	        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
	            xmlCells = [];
	            cellsLength = this._cellsArray[rowIndex].length;
	            for (colIndex = 0; colIndex < cellsLength; colIndex++) {
	                rowIndex = Number(rowIndex);
	                cellData = this._cellsArray[rowIndex][colIndex];
	                xmlCells.push(this._getXMLTag("c", [{
	                    name: "r",
	                    value: this._getCellIndex(rowIndex + 1, colIndex)
	                }, {
	                    name: "s",
	                    value: cellData.style
	                }, {
	                    name: "t",
	                    value: cellData.type
	                }], commonUtils.isDefined(cellData.value) ? this._getXMLTag("v", [], cellData.value) : null))
	            }
	            xmlRows.push(this._getXMLTag("row", [{
	                name: "r",
	                value: Number(rowIndex) + 1
	            }, {
	                name: "spans",
	                value: rSpans
	            }, {
	                name: "outlineLevel",
	                value: rowIndex >= headerRowCount ? this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)) : 0
	            }, {
	                name: "x14ac:dyDescent",
	                value: "0.25"
	            }], xmlCells.join("")));
	            this._cellsArray[rowIndex] = null;
	            if (counter++ > 1e4) {
	                xmlResult.push(xmlRows.join(""));
	                xmlRows = [];
	                counter = 0
	            }
	        }
	        xmlResult.push(xmlRows.join(""));
	        xmlRows = [];
	        maxCellIndex = this._getCellIndex(this._maxIndex[0], this._maxIndex[1]);
	        xmlResult.push("</sheetData>" + (this._options.autoFilterEnabled ? '<autoFilter ref="A' + this._dataProvider.getHeaderRowCount() + ":" + maxCellIndex + '" />' : "") + this._generateMergingXML() + '<ignoredErrors><ignoredError sqref="A1:' + maxCellIndex + '" numberStoredAsText="1" /></ignoredErrors></worksheet>');
	        this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
	        this._colsArray = [];
	        this._cellsArray = [];
	        xmlResult = []
	    },
	    _generateMergingXML: function() {
	        var k, l, cellIndex, rowIndex, mergeArrayLength, mergeIndex, rowsLength = commonUtils.isDefined(this._dataProvider.getHeaderRowCount) ? this._dataProvider.getHeaderRowCount() : this._dataProvider.getRowsCount(),
	            columnsLength = this._dataProvider.getColumns().length,
	            usedArea = [],
	            mergeArray = [],
	            mergeXML = "";
	        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
	            for (cellIndex = 0; cellIndex !== columnsLength; cellIndex++) {
	                if (!commonUtils.isDefined(usedArea[rowIndex]) || !commonUtils.isDefined(usedArea[rowIndex][cellIndex])) {
	                    var cellMerge = this._dataProvider.getCellMerging(rowIndex, cellIndex);
	                    if (cellMerge.colspan || cellMerge.rowspan) {
	                        mergeArray.push({
	                            start: this._getCellIndex(rowIndex + 1, cellIndex),
	                            end: this._getCellIndex(rowIndex + 1 + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
	                        });
	                        for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++) {
	                            for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
	                                if (!commonUtils.isDefined(usedArea[k])) {
	                                    usedArea[k] = []
	                                }
	                                usedArea[k][l] = true
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        mergeArrayLength = mergeArray.length;
	        for (mergeIndex = 0; mergeIndex < mergeArrayLength; mergeIndex++) {
	            mergeXML += this._getXMLTag("mergeCell", [{
	                name: "ref",
	                value: mergeArray[mergeIndex].start + ":" + mergeArray[mergeIndex].end
	            }])
	        }
	        return mergeXML.length ? this._getXMLTag("mergeCells", [{
	            name: "count",
	            value: mergeArrayLength
	        }], mergeXML) : ""
	    },
	    _generateCommonXML: function() {
	        var xmlRelationships, relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME)),
	            folder = this._zip.folder(XL_FOLDER_NAME),
	            relsXML = XML_TAG;
	        this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
	        xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
	        relsXML += this._createXMLRelationships(xmlRelationships);
	        folder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
	        folder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
	        this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent())
	    },
	    _generateContent: function() {
	        this._prepareStyleData();
	        this._prepareCellData();
	        this._generateWorkXML();
	        this._generateCommonXML()
	    },
	    _generateWorkXML: function() {
	        this._generateStylesXML();
	        this._generateStringsXML();
	        this._generateWorksheetXML()
	    },
	    ctor: function(dataProvider, options) {
	        this._rtlEnabled = options && !!options.rtlEnabled;
	        this._options = options;
	        this._maxIndex = [1, 2];
	        this._stringArray = [];
	        this._stringHash = {};
	        this._styleArray = [];
	        this._colsArray = [];
	        this._cellsArray = [];
	        this._styleFormat = [];
	        this._needSheetPr = false;
	        this._dataProvider = dataProvider;
	        if (commonUtils.isDefined(JSZip)) {
	            this._zip = new JSZip
	        } else {
	            this._zip = null
	        }
	    },
	    _checkZipState: function() {
	        if (!this._zip) {
	            throw errors.Error("E1041")
	        }
	    },
	    ready: function() {
	        return this._dataProvider.ready()
	    },
	    getData: function(isBlob) {
	        var options = {
	            type: isBlob ? "blob" : "base64",
	            compression: "DEFLATE",
	            mimeType: fileSaver.MIME_TYPES.EXCEL
	        };
	        this._checkZipState();
	        this._generateContent();
	        return this._zip.generateAsync ? this._zip.generateAsync(options) : this._zip.generate(options)
	    }
	});
	exports.getData = function(data, options, callback) {
	    var excelCreator = new exports.ExcelCreator(data, options);
	    excelCreator._checkZipState();
	    excelCreator.ready().done(function() {
	        if (excelCreator._zip.generateAsync) {
	            excelCreator.getData(commonUtils.isFunction(window.Blob)).then(callback)
	        } else {
	            callback(excelCreator.getData(commonUtils.isFunction(window.Blob)))
	        }
	    })
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/class.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var errors = __webpack_require__(3);
	var wrapOverridden = function(baseProto, methodName, method) {
	    return function() {
	        var prevCallBase = this.callBase;
	        this.callBase = baseProto[methodName];
	        try {
	            return method.apply(this, arguments)
	        } finally {
	            this.callBase = prevCallBase
	        }
	    }
	};
	var clonePrototype = function(obj) {
	    var func = function() {};
	    func.prototype = obj.prototype;
	    return new func
	};
	var redefine = function(members) {
	    var overridden, memberName, member, that = this;
	    if (!members) {
	        return that
	    }
	    for (memberName in members) {
	        member = members[memberName];
	        overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
	        that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member
	    }
	    return that
	};
	var include = function() {
	    var argument, name, i, classObj = this;
	    for (i = 0; i < arguments.length; i++) {
	        argument = arguments[i];
	        if (argument.ctor) {
	            classObj._includedCtors.push(argument.ctor)
	        }
	        if (argument.postCtor) {
	            classObj._includedPostCtors.push(argument.postCtor)
	        }
	        for (name in argument) {
	            if ("ctor" === name || "postCtor" === name) {
	                continue
	            }
	            if (name in classObj.prototype) {
	                throw errors.Error("E0002", name)
	            }
	            classObj.prototype[name] = argument[name]
	        }
	    }
	    return classObj
	};
	var subclassOf = function(parentClass) {
	    if (this.parent === parentClass) {
	        return true
	    }
	    if (!this.parent || !this.parent.subclassOf) {
	        return false
	    }
	    return this.parent.subclassOf(parentClass)
	};
	var abstract = function() {
	    throw errors.Error("E0001")
	};
	var copyStatic = function() {
	    var hasOwn = Object.prototype.hasOwnProperty;
	    return function(source, destination) {
	        for (var key in source) {
	            if (!hasOwn.call(source, key)) {
	                return
	            }
	            destination[key] = source[key]
	        }
	    }
	}();
	var classImpl = function() {};
	classImpl.inherit = function(members) {
	    var inheritor = function() {
	        if (!this || this === window || "function" !== typeof this.constructor) {
	            throw errors.Error("E0003")
	        }
	        var i, instance = this,
	            ctor = instance.ctor,
	            includedCtors = instance.constructor._includedCtors,
	            includedPostCtors = instance.constructor._includedPostCtors;
	        for (i = 0; i < includedCtors.length; i++) {
	            includedCtors[i].call(instance)
	        }
	        if (ctor) {
	            ctor.apply(instance, arguments)
	        }
	        for (i = 0; i < includedPostCtors.length; i++) {
	            includedPostCtors[i].call(instance)
	        }
	    };
	    inheritor.prototype = clonePrototype(this);
	    copyStatic(this, inheritor);
	    inheritor.inherit = this.inherit;
	    inheritor.abstract = abstract;
	    inheritor.redefine = redefine;
	    inheritor.include = include;
	    inheritor.subclassOf = subclassOf;
	    inheritor.parent = this;
	    inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
	    inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
	    inheritor.prototype.constructor = inheritor;
	    inheritor.redefine(members);
	    return inheritor
	};
	classImpl.abstract = abstract;
	module.exports = classImpl;


/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = window.JSZip;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (localization/number.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    dependencyInjector = __webpack_require__(21),
	    errors = __webpack_require__(3);
	var MAX_LARGE_NUMBER_POWER = 4,
	    DECIMAL_BASE = 10;
	var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
	var LargeNumberFormatPostfixes = {
	    1: "K",
	    2: "M",
	    3: "B",
	    4: "T"
	};
	var LargeNumberFormatPowers = {
	    largenumber: "auto",
	    thousands: 1,
	    millions: 2,
	    billions: 3,
	    trillions: 4
	};
	var numberLocalization = dependencyInjector({
	    numericFormats: NUMERIC_FORMATS,
	    defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
	    _parseNumberFormatString: function(formatType) {
	        var formatList, formatObject = {};
	        if (!formatType || "string" !== typeof formatType) {
	            return
	        }
	        formatList = formatType.split(" ");
	        $.each(formatList, function(index, value) {
	            if ($.inArray(value, NUMERIC_FORMATS) > -1) {
	                formatObject.formatType = value
	            } else {
	                if (value in LargeNumberFormatPowers) {
	                    formatObject.power = LargeNumberFormatPowers[value]
	                }
	            }
	        });
	        if (formatObject.power && !formatObject.formatType) {
	            formatObject.formatType = "fixedpoint"
	        }
	        if (formatObject.formatType) {
	            return formatObject
	        }
	    },
	    _calculateNumberPower: function(value, base, minPower, maxPower) {
	        var number = Math.abs(value),
	            power = 0;
	        if (number > 1) {
	            while (number && number >= base && (void 0 === maxPower || power < maxPower)) {
	                power++;
	                number /= base
	            }
	        } else {
	            if (number > 0 && number < 1) {
	                while (number < 1 && (void 0 === minPower || power > minPower)) {
	                    power--;
	                    number *= base
	                }
	            }
	        }
	        return power
	    },
	    _getNumberByPower: function(number, power, base) {
	        var result = number;
	        while (power > 0) {
	            result /= base;
	            power--
	        }
	        while (power < 0) {
	            result *= base;
	            power++
	        }
	        return result
	    },
	    _formatNumber: function(value, formatObject, formatConfig) {
	        var powerPostfix;
	        if ("auto" === formatObject.power) {
	            formatObject.power = this._calculateNumberPower(value, 1e3, 0, MAX_LARGE_NUMBER_POWER)
	        }
	        if (formatObject.power) {
	            value = this._getNumberByPower(value, formatObject.power, 1e3)
	        }
	        powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
	        return this._formatNumberCore(value, formatObject.formatType, formatConfig) + powerPostfix
	    },
	    _formatNumberExponential: function(value, formatConfig) {
	        var powString, power = this._calculateNumberPower(value, DECIMAL_BASE),
	            number = this._getNumberByPower(value, power, DECIMAL_BASE);
	        if (void 0 === formatConfig.precision) {
	            formatConfig.precision = 1
	        }
	        if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
	            power++;
	            number /= DECIMAL_BASE
	        }
	        powString = (power >= 0 ? "+" : "") + power.toString();
	        return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString
	    },
	    _addZeroes: function(value, precision) {
	        var multiplier = Math.pow(10, precision);
	        value = (value * multiplier >>> 0) / multiplier;
	        var result = value.toString();
	        while (result.length < precision) {
	            result = "0" + result
	        }
	        return result
	    },
	    _addGroupSeparators: function(value) {
	        var parts = value.toString().split(".");
	        return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",") + (parts[1] ? "." + parts[1] : "")
	    },
	    _formatNumberCore: function(value, format, formatConfig) {
	        if ("exponential" === format) {
	            return this._formatNumberExponential(value, formatConfig)
	        }
	        if ("decimal" !== format) {
	            formatConfig.precision = formatConfig.precision || 0
	        }
	        if ("percent" === format) {
	            value = 100 * value
	        }
	        if (void 0 !== formatConfig.precision) {
	            if ("decimal" === format) {
	                value = this._addZeroes(value, formatConfig.precision)
	            } else {
	                value = value.toFixed(formatConfig.precision)
	            }
	        }
	        if ("decimal" !== format) {
	            value = this._addGroupSeparators(value)
	        }
	        if ("percent" === format) {
	            value += "%"
	        }
	        return value.toString()
	    },
	    _normalizeFormat: function(format) {
	        if (!format) {
	            return {}
	        }
	        if ("function" === typeof format) {
	            return format
	        }
	        if (!$.isPlainObject(format)) {
	            format = {
	                type: format
	            }
	        }
	        if (format.type) {
	            format.type = format.type.toLowerCase()
	        }
	        return format
	    },
	    format: function(value, format) {
	        if ("number" !== typeof value) {
	            return value
	        }
	        if ("number" === typeof format) {
	            return value
	        }
	        format = format && format.formatter || format;
	        if ("function" === typeof format) {
	            return format(value)
	        }
	        format = this._normalizeFormat(format);
	        if (!format.type) {
	            format.type = "decimal"
	        }
	        var numberConfig = this._parseNumberFormatString(format.type);
	        if (!numberConfig) {
	            return
	        }
	        return this._formatNumber(value, numberConfig, format)
	    },
	    parse: function(text, format) {
	        if (!text) {
	            return
	        }
	        if (format && format.parser) {
	            return format.parser(text)
	        }
	        if (format) {
	            errors.log("W0011")
	        }
	        return parseFloat(text.replace(/^\D+|,+/g, ""))
	    }
	});
	module.exports = numberLocalization;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/dependency_injector.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = function(object) {
	    var $ = __webpack_require__(5),
	        Class = __webpack_require__(18);
	    var BaseClass = Class.inherit(object),
	        InjectedClass = BaseClass,
	        instance = new InjectedClass(object),
	        initialFields = {};
	    var injectFields = function(injectionObject, initial) {
	        $.each(injectionObject, function(key) {
	            if ($.isFunction(instance[key])) {
	                if (initial || !object[key]) {
	                    object[key] = function() {
	                        return instance[key].apply(object, arguments)
	                    }
	                }
	            } else {
	                if (initial) {
	                    initialFields[key] = object[key]
	                }
	                object[key] = instance[key]
	            }
	        })
	    };
	    injectFields(object, true);
	    object.inject = function(injectionObject) {
	        InjectedClass = InjectedClass.inherit(injectionObject);
	        instance = new InjectedClass;
	        injectFields(injectionObject)
	    };
	    object.resetInjection = function() {
	        $.extend(object, initialFields);
	        InjectedClass = BaseClass;
	        instance = new BaseClass
	    };
	    return object
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (localization/currency.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    numberLocalization = __webpack_require__(20);
	numberLocalization.inject({
	    _formatNumberCore: function(value, format, formatConfig) {
	        if ("currency" === format) {
	            formatConfig.precision = formatConfig.precision || 0;
	            return this.getCurrencySymbol().symbol + this.format(value, $.extend({}, formatConfig, {
	                type: "fixedpoint"
	            }))
	        }
	        return this.callBase.apply(this, arguments)
	    },
	    getCurrencySymbol: function() {
	        return {
	            symbol: "$"
	        }
	    },
	    getOpenXmlCurrencyFormat: function() {
	        return "$#,##0{0}_);\\($#,##0{0}\\)"
	    }
	});


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (client_exporter/image_creator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Color = __webpack_require__(24),
	    commonUtils = __webpack_require__(8),
	    when = __webpack_require__(10).when,
	    _math = Math,
	    PI = _math.PI,
	    _min = _math.min,
	    _abs = _math.abs,
	    _sqrt = _math.sqrt,
	    _pow = _math.pow,
	    _atan2 = _math.atan2,
	    _cos = _math.cos,
	    _sin = _math.sin,
	    _each = $.each,
	    _extend = $.extend,
	    _number = Number,
	    IMAGE_QUALITY = 1,
	    TEXT_DECORATION_LINE_WIDTH_COEFF = .05,
	    DEFAULT_MARGIN_SIZE = {
	        x: 30,
	        y: 20
	    },
	    DEFAULT_FONT_SIZE = "10px",
	    DEFAULT_FONT_FAMILY = "sans-serif",
	    DEFAULT_TEXT_COLOR = "#000",
	    currentTspanY, clipPaths, textOffset, imageDeferreds, patterns, filters;

	function createCanvas(width, height, withoutMargins) {
	    var canvas = $("<canvas>")[0];
	    canvas.width = width + (withoutMargins ? 0 : 2 * DEFAULT_MARGIN_SIZE.x);
	    canvas.height = height + (withoutMargins ? 0 : 2 * DEFAULT_MARGIN_SIZE.y);
	    return canvas
	}

	function getStringFromCanvas(canvas, mimeType) {
	    var dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY),
	        imageData = atob(dataURL.substring(("data:" + mimeType + ";base64,").length));
	    return imageData
	}

	function arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {
	    var opSide, adjSide, centerX, centerY, startAngle, endAngle, cBx = (x1 + x2) / 2,
	        cBy = (y1 + y2) / 2,
	        aB = _atan2(y1 - y2, x1 - x2),
	        k = largeArcFlag ? 1 : -1;
	    aB += 90 * (PI / 180) * (clockwise ? 1 : -1);
	    opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;
	    adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));
	    centerX = cBx + k * (adjSide * _cos(aB));
	    centerY = cBy + k * (adjSide * _sin(aB));
	    startAngle = _atan2(y1 - centerY, x1 - centerX);
	    endAngle = _atan2(y2 - centerY, x2 - centerX);
	    context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise)
	}

	function getElementOptions(element, isText) {
	    var coords, attr = parseAttributes(element.attributes || {}),
	        style = element.style || {},
	        options = _extend({}, attr, {
	            text: element.textContent.replace(/\s+/g, " "),
	            textAlign: "middle" === attr["text-anchor"] ? "center" : attr["text-anchor"]
	        }),
	        transform = attr.transform;
	    if (transform) {
	        coords = transform.match(/translate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
	        if (coords) {
	            coords = coords[0].match(/-*\d+([.]\d+)*/g);
	            options.translateX = _number(coords[0]);
	            options.translateY = coords[1] ? _number(coords[1]) : 0
	        }
	        coords = transform.match(/rotate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*,*\s*-*\d+([.]\d+)*)*/);
	        if (coords) {
	            coords = coords[0].match(/-*\d+([.]\d+)*/g);
	            options.rotationAngle = _number(coords[0]);
	            options.rotationX = coords[1] && _number(coords[1]);
	            options.rotationY = coords[2] && _number(coords[2])
	        }
	    }
	    parseStyles(style, options);
	    isText && aggregateTextPosition(options);
	    return options
	}

	function drawRect(context, options) {
	    var x = options.x,
	        y = options.y,
	        width = options.width,
	        height = options.height,
	        cornerRadius = options.rx;
	    if (!cornerRadius) {
	        context.rect(options.x, options.y, options.width, options.height)
	    } else {
	        cornerRadius = _min(cornerRadius, width / 2, height / 2);
	        context.save();
	        context.translate(x, y);
	        context.moveTo(width / 2, 0);
	        context.arcTo(width, 0, width, height, cornerRadius);
	        context.arcTo(width, height, 0, height, cornerRadius);
	        context.arcTo(0, height, 0, 0, cornerRadius);
	        context.arcTo(0, 0, cornerRadius, 0, cornerRadius);
	        context.lineTo(width / 2, 0);
	        context.restore()
	    }
	}

	function drawImage(context, options) {
	    var d = $.Deferred(),
	        image = new Image;
	    image.onload = function() {
	        context.save();
	        context.globalAlpha = options.globalAlpha;
	        transformElement(context, options);
	        clipElement(context, options);
	        context.drawImage(image, options.x, options.y, options.width, options.height);
	        context.restore();
	        d.resolve()
	    };
	    image.onerror = function() {
	        d.resolve()
	    };
	    imageDeferreds.push(d);
	    image.setAttribute("crossOrigin", "anonymous");
	    image.src = options["xlink:href"]
	}

	function drawPath(context, dAttr) {
	    var param1, param2, dArray = dAttr.split(" "),
	        i = 0;
	    do {
	        param1 = _number(dArray[i + 1]);
	        param2 = _number(dArray[i + 2]);
	        switch (dArray[i]) {
	            case "M":
	                context.moveTo(param1, param2);
	                i += 3;
	                break;
	            case "L":
	                context.lineTo(param1, param2);
	                i += 3;
	                break;
	            case "C":
	                context.bezierCurveTo(param1, param2, _number(dArray[i + 3]), _number(dArray[i + 4]), _number(dArray[i + 5]), _number(dArray[i + 6]));
	                i += 7;
	                break;
	            case "A":
	                arcTo(_number(dArray[i - 2]), _number(dArray[i - 1]), _number(dArray[i + 6]), _number(dArray[i + 7]), param1, _number(dArray[i + 4]), _number(dArray[i + 5]), context);
	                i += 8;
	                break;
	            case "Z":
	                context.closePath();
	                i += 1
	        }
	    } while (i < dArray.length)
	}

	function parseStyles(style, options) {
	    _each(style, function(_, field) {
	        if ("" !== style[field]) {
	            options[$.camelCase(field)] = style[field]
	        }
	    });
	    options.textDecoration = options.textDecoration || options.textDecorationLine;
	    options.globalAlpha = options.opacity || options.globalAlpha
	}

	function parseUrl(urlString) {
	    return urlString.match(/\w+/g).pop()
	}

	function setFontStyle(context, options) {
	    var fontParams = [];
	    options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;
	    options.fontFamily || DEFAULT_FONT_FAMILY;
	    options.fill = options.fill || DEFAULT_TEXT_COLOR;
	    options.fontStyle && fontParams.push(options.fontStyle);
	    options.fontWeight && fontParams.push(options.fontWeight);
	    fontParams.push(options.fontSize);
	    fontParams.push(options.fontFamily);
	    context.font = fontParams.join(" ");
	    context.textAlign = options.textAlign;
	    context.fillStyle = options.fill;
	    context.globalAlpha = options.globalAlpha
	}

	function drawText(context, options) {
	    setFontStyle(context, options);
	    options.text && context.fillText(options.text, options.x, options.y);
	    strokeElement(context, options, true);
	    drawTextDecoration(context, options);
	    textOffset = options.x + context.measureText(options.text).width
	}

	function drawTextDecoration(context, options) {
	    if (!options.textDecoration || "none" === options.textDecoration) {
	        return
	    }
	    var x = options.x,
	        align = options.textAlign,
	        textWidth = context.measureText(options.text).width,
	        textHeight = parseInt(options.fontSize, 10),
	        lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF,
	        y = options.y;
	    if ("center" === align) {
	        x -= textWidth / 2
	    } else {
	        if ("end" === align) {
	            x -= textWidth
	        }
	    }
	    switch (options.textDecoration) {
	        case "line-through":
	            y -= textHeight / 3 + lineHeight / 2;
	            break;
	        case "overline":
	            y -= textHeight - lineHeight;
	            break;
	        case "underline":
	            y += lineHeight
	    }
	    context.rect(x, y, textWidth, lineHeight);
	    fillElement(context, options);
	    strokeElement(context, options)
	}

	function createClipPath(element) {
	    clipPaths[element.attributes.id.textContent] = element.childNodes[0]
	}

	function createPattern(element) {
	    patterns[element.attributes.id.textContent] = element
	}

	function aggregateOpacity(options) {
	    options.strokeOpacity = void 0 !== options["stroke-opacity"] ? options["stroke-opacity"] : 1;
	    options.fillOpacity = void 0 !== options["fill-opacity"] ? options["fill-opacity"] : 1;
	    if (void 0 !== options.opacity) {
	        options.strokeOpacity *= options.opacity;
	        options.fillOpacity *= options.opacity
	    }
	}

	function aggregateTextPosition(options) {
	    if (options.dy) {
	        options.y = currentTspanY + _number(options.dy)
	    }
	    if (textOffset && void 0 === options.x) {
	        options.x = textOffset
	    }
	    if (void 0 !== options.y) {
	        currentTspanY = options.y
	    } else {
	        options.y = currentTspanY
	    }
	}

	function drawElement(element, context, parentOptions) {
	    var tagName = element.tagName,
	        isText = "text" === tagName || "tspan" === tagName || void 0 === tagName,
	        isImage = "image" === tagName,
	        options = _extend({}, parentOptions, getElementOptions(element, isText));
	    if ("hidden" === options.visibility) {
	        return
	    }
	    context.save();
	    !isImage && transformElement(context, options);
	    clipElement(context, options);
	    aggregateOpacity(options);
	    context.beginPath();
	    switch (element.tagName) {
	        case void 0:
	            drawText(context, options);
	            break;
	        case "text":
	        case "tspan":
	            textOffset = 0;
	            drawCanvasElements(element.childNodes, context, options);
	            break;
	        case "image":
	            drawImage(context, options);
	            break;
	        case "path":
	            drawPath(context, options.d);
	            break;
	        case "rect":
	            drawRect(context, options);
	            context.closePath();
	            break;
	        case "circle":
	            context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1)
	    }
	    applyFilter(context, options);
	    if (!isText) {
	        fillElement(context, options);
	        strokeElement(context, options)
	    }
	    context.restore()
	}

	function applyFilter(context, options) {
	    var filterOptions, matches = options.filter && options.filter.match(/url\(\#(.*)\)/);
	    if (matches && matches[1]) {
	        filterOptions = filters && filters[matches[1]];
	        if (!filterOptions) {
	            filterOptions = {
	                offsetX: 0,
	                offsetY: 0,
	                blur: 0,
	                color: "#000"
	            }
	        }
	        context.shadowOffsetX = filterOptions.offsetX;
	        context.shadowOffsetY = filterOptions.offsetY;
	        context.shadowColor = filterOptions.color;
	        context.shadowBlur = filterOptions.blur
	    }
	}

	function transformElement(context, options) {
	    context.translate(options.translateX || 0, options.translateY || 0);
	    delete options.translateX;
	    delete options.translateY;
	    if (options.rotationAngle) {
	        context.translate(options.rotationX || 0, options.rotationY || 0);
	        context.rotate(options.rotationAngle * PI / 180);
	        context.translate(-(options.rotationX || 0), -(options.rotationY || 0));
	        delete options.rotationAngle;
	        delete options.rotationX;
	        delete options.rotationY
	    }
	}

	function clipElement(context, options) {
	    if (options["clip-path"]) {
	        drawElement(clipPaths[parseUrl(options["clip-path"])], context, {});
	        context.clip();
	        delete options["clip-path"]
	    }
	}

	function hex2rgba(hexColor, alpha) {
	    var color = new Color(hexColor);
	    return "rgba(" + color.r + "," + color.g + "," + color.b + "," + alpha + ")"
	}

	function createFilter(element) {
	    var color, opacity, filterOptions = {};
	    _each(element.childNodes, function(_, node) {
	        var attr = node.attributes;
	        if (!attr.result) {
	            return
	        }
	        switch (attr.result.value) {
	            case "gaussianBlurResult":
	                filterOptions.blur = _number(attr.stdDeviation.value);
	                break;
	            case "offsetResult":
	                filterOptions.offsetX = _number(attr.dx.value);
	                filterOptions.offsetY = _number(attr.dy.value);
	                break;
	            case "floodResult":
	                color = attr["flood-color"] ? attr["flood-color"].value : "#000";
	                opacity = attr["flood-opacity"] ? attr["flood-opacity"].value : 1;
	                filterOptions.color = hex2rgba(color, opacity)
	        }
	    });
	    filters[element.id] = filterOptions
	}

	function drawCanvasElements(elements, context, parentOptions) {
	    var options;
	    _each(elements, function(_, element) {
	        switch (element.tagName && element.tagName.toLowerCase()) {
	            case "g":
	                options = _extend({}, parentOptions, getElementOptions(element));
	                context.save();
	                transformElement(context, options);
	                clipElement(context, options);
	                drawCanvasElements(element.childNodes, context, options);
	                context.restore();
	                break;
	            case "defs":
	                clipPaths = {};
	                patterns = {};
	                filters = {};
	                drawCanvasElements(element.childNodes, context);
	                break;
	            case "clippath":
	                createClipPath(element);
	                break;
	            case "pattern":
	                createPattern(element);
	                break;
	            case "filter":
	                createFilter(element);
	                break;
	            default:
	                drawElement(element, context, parentOptions)
	        }
	    })
	}

	function setLineDash(context, options) {
	    var matches = options["stroke-dasharray"] && options["stroke-dasharray"].match(/(\d+)/g);
	    if (matches && matches.length) {
	        matches = $.map(matches, function(item) {
	            return _number(item)
	        });
	        context.setLineDash(matches)
	    }
	}

	function strokeElement(context, options, isText) {
	    var stroke = options.stroke;
	    if (stroke && "none" !== stroke && 0 !== options["stroke-width"]) {
	        setLineDash(context, options);
	        context.lineJoin = options["stroke-linejoin"];
	        context.lineWidth = options["stroke-width"];
	        context.globalAlpha = options.strokeOpacity;
	        context.strokeStyle = stroke;
	        isText ? context.strokeText(options.text, options.x, options.y) : context.stroke()
	    }
	}

	function getPattern(context, fill) {
	    var pattern = patterns[parseUrl(fill)],
	        options = getElementOptions(pattern),
	        patternCanvas = createCanvas(options.width, options.height, true),
	        patternContext = patternCanvas.getContext("2d");
	    drawCanvasElements(pattern.childNodes, patternContext, options);
	    return context.createPattern(patternCanvas, "repeat")
	}

	function fillElement(context, options) {
	    var fill = options.fill;
	    if (fill && "none" !== fill) {
	        context.fillStyle = fill.search(/url/) === -1 ? fill : getPattern(context, fill);
	        context.globalAlpha = options.fillOpacity;
	        context.fill()
	    }
	}
	var parseAttributes = function(attributes) {
	    var attr, newAttributes = {};
	    $.each(attributes, function(index, item) {
	        attr = item.textContent;
	        if (isFinite(attr)) {
	            attr = _number(attr)
	        }
	        newAttributes[item.name.toLowerCase()] = attr
	    });
	    return newAttributes
	};

	function drawBackground(context, width, height, backgroundColor) {
	    context.fillStyle = backgroundColor || "#ffffff";
	    context.fillRect(-DEFAULT_MARGIN_SIZE.x, -DEFAULT_MARGIN_SIZE.y, width + 2 * DEFAULT_MARGIN_SIZE.x, height + 2 * DEFAULT_MARGIN_SIZE.y)
	}

	function getCanvasFromSvg(markup, width, height, backgroundColor) {
	    var canvas = createCanvas(width, height),
	        context = canvas.getContext("2d"),
	        parser = new DOMParser,
	        elem = parser.parseFromString(markup, "image/svg+xml"),
	        svgElem = elem.childNodes[0];
	    context.translate(DEFAULT_MARGIN_SIZE.x, DEFAULT_MARGIN_SIZE.y);
	    imageDeferreds = [];
	    document.body.appendChild(canvas);
	    if (svgElem.attributes.direction) {
	        canvas.dir = svgElem.attributes.direction.textContent
	    }
	    drawBackground(context, width, height, backgroundColor);
	    drawCanvasElements(svgElem.childNodes, context, {});
	    document.body.removeChild(canvas);
	    return canvas
	}

	function resolveString(string, canvas, mimeType) {
	    when.apply($, imageDeferreds).done(function() {
	        var resultString = getStringFromCanvas(canvas, mimeType);
	        string.resolve(resultString)
	    })
	}
	exports.imageCreator = {
	    getImageData: function(markup, options) {
	        var mimeType = "image/" + options.format,
	            string = $.Deferred(),
	            width = options.width,
	            height = options.height,
	            backgroundColor = options.backgroundColor;
	        if ($.isFunction(options.__parseAttributesFn)) {
	            parseAttributes = options.__parseAttributesFn
	        }
	        resolveString(string, getCanvasFromSvg(markup, width, height, backgroundColor), mimeType);
	        return string
	    },
	    getData: function(markup, options) {
	        var that = this,
	            imageData = exports.imageCreator.getImageData(markup, options),
	            mimeType = "image/" + options.format,
	            data = $.Deferred();
	        when(imageData).done(function(binaryData) {
	            imageData = commonUtils.isFunction(window.Blob) ? that._getBlob(binaryData, mimeType) : that._getBase64(binaryData);
	            data.resolve(imageData)
	        });
	        return data
	    },
	    _getBlob: function(binaryData, mimeType) {
	        var i, dataArray = new Uint8Array(binaryData.length);
	        for (i = 0; i < binaryData.length; i++) {
	            dataArray[i] = binaryData.charCodeAt(i)
	        }
	        return new Blob([dataArray.buffer], {
	            type: mimeType
	        })
	    },
	    _getBase64: function(binaryData) {
	        return window.btoa(binaryData)
	    }
	};
	exports.getData = function(data, options, callback) {
	    exports.imageCreator.getData(data, options).done(callback)
	};


/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (color.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var standardColorNames = {
	    aliceblue: "f0f8ff",
	    antiquewhite: "faebd7",
	    aqua: "00ffff",
	    aquamarine: "7fffd4",
	    azure: "f0ffff",
	    beige: "f5f5dc",
	    bisque: "ffe4c4",
	    black: "000000",
	    blanchedalmond: "ffebcd",
	    blue: "0000ff",
	    blueviolet: "8a2be2",
	    brown: "a52a2a",
	    burlywood: "deb887",
	    cadetblue: "5f9ea0",
	    chartreuse: "7fff00",
	    chocolate: "d2691e",
	    coral: "ff7f50",
	    cornflowerblue: "6495ed",
	    cornsilk: "fff8dc",
	    crimson: "dc143c",
	    cyan: "00ffff",
	    darkblue: "00008b",
	    darkcyan: "008b8b",
	    darkgoldenrod: "b8860b",
	    darkgray: "a9a9a9",
	    darkgreen: "006400",
	    darkkhaki: "bdb76b",
	    darkmagenta: "8b008b",
	    darkolivegreen: "556b2f",
	    darkorange: "ff8c00",
	    darkorchid: "9932cc",
	    darkred: "8b0000",
	    darksalmon: "e9967a",
	    darkseagreen: "8fbc8f",
	    darkslateblue: "483d8b",
	    darkslategray: "2f4f4f",
	    darkturquoise: "00ced1",
	    darkviolet: "9400d3",
	    deeppink: "ff1493",
	    deepskyblue: "00bfff",
	    dimgray: "696969",
	    dodgerblue: "1e90ff",
	    feldspar: "d19275",
	    firebrick: "b22222",
	    floralwhite: "fffaf0",
	    forestgreen: "228b22",
	    fuchsia: "ff00ff",
	    gainsboro: "dcdcdc",
	    ghostwhite: "f8f8ff",
	    gold: "ffd700",
	    goldenrod: "daa520",
	    gray: "808080",
	    green: "008000",
	    greenyellow: "adff2f",
	    honeydew: "f0fff0",
	    hotpink: "ff69b4",
	    indianred: "cd5c5c",
	    indigo: "4b0082",
	    ivory: "fffff0",
	    khaki: "f0e68c",
	    lavender: "e6e6fa",
	    lavenderblush: "fff0f5",
	    lawngreen: "7cfc00",
	    lemonchiffon: "fffacd",
	    lightblue: "add8e6",
	    lightcoral: "f08080",
	    lightcyan: "e0ffff",
	    lightgoldenrodyellow: "fafad2",
	    lightgrey: "d3d3d3",
	    lightgreen: "90ee90",
	    lightpink: "ffb6c1",
	    lightsalmon: "ffa07a",
	    lightseagreen: "20b2aa",
	    lightskyblue: "87cefa",
	    lightslateblue: "8470ff",
	    lightslategray: "778899",
	    lightsteelblue: "b0c4de",
	    lightyellow: "ffffe0",
	    lime: "00ff00",
	    limegreen: "32cd32",
	    linen: "faf0e6",
	    magenta: "ff00ff",
	    maroon: "800000",
	    mediumaquamarine: "66cdaa",
	    mediumblue: "0000cd",
	    mediumorchid: "ba55d3",
	    mediumpurple: "9370d8",
	    mediumseagreen: "3cb371",
	    mediumslateblue: "7b68ee",
	    mediumspringgreen: "00fa9a",
	    mediumturquoise: "48d1cc",
	    mediumvioletred: "c71585",
	    midnightblue: "191970",
	    mintcream: "f5fffa",
	    mistyrose: "ffe4e1",
	    moccasin: "ffe4b5",
	    navajowhite: "ffdead",
	    navy: "000080",
	    oldlace: "fdf5e6",
	    olive: "808000",
	    olivedrab: "6b8e23",
	    orange: "ffa500",
	    orangered: "ff4500",
	    orchid: "da70d6",
	    palegoldenrod: "eee8aa",
	    palegreen: "98fb98",
	    paleturquoise: "afeeee",
	    palevioletred: "d87093",
	    papayawhip: "ffefd5",
	    peachpuff: "ffdab9",
	    peru: "cd853f",
	    pink: "ffc0cb",
	    plum: "dda0dd",
	    powderblue: "b0e0e6",
	    purple: "800080",
	    rebeccapurple: "663399",
	    red: "ff0000",
	    rosybrown: "bc8f8f",
	    royalblue: "4169e1",
	    saddlebrown: "8b4513",
	    salmon: "fa8072",
	    sandybrown: "f4a460",
	    seagreen: "2e8b57",
	    seashell: "fff5ee",
	    sienna: "a0522d",
	    silver: "c0c0c0",
	    skyblue: "87ceeb",
	    slateblue: "6a5acd",
	    slategray: "708090",
	    snow: "fffafa",
	    springgreen: "00ff7f",
	    steelblue: "4682b4",
	    tan: "d2b48c",
	    teal: "008080",
	    thistle: "d8bfd8",
	    tomato: "ff6347",
	    turquoise: "40e0d0",
	    violet: "ee82ee",
	    violetred: "d02090",
	    wheat: "f5deb3",
	    white: "ffffff",
	    whitesmoke: "f5f5f5",
	    yellow: "ffff00",
	    yellowgreen: "9acd32"
	};
	var standardColorTypes = [{
	    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
	    process: function(colorString) {
	        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
	    }
	}, {
	    re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
	    process: function(colorString) {
	        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])]
	    }
	}, {
	    re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
	    process: function(colorString) {
	        return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
	    }
	}, {
	    re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
	    process: function(colorString) {
	        return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
	    }
	}, {
	    re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
	    process: function(colorString) {
	        var h = parseInt(colorString[1], 10),
	            s = parseInt(colorString[2], 10),
	            v = parseInt(colorString[3], 10),
	            rgb = hsvToRgb(h, s, v);
	        return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]]
	    }
	}, {
	    re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
	    process: function(colorString) {
	        var h = parseInt(colorString[1], 10),
	            s = parseInt(colorString[2], 10),
	            l = parseInt(colorString[3], 10),
	            rgb = hslToRgb(h, s, l);
	        return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]]
	    }
	}];

	function Color(value) {
	    this.baseColor = value;
	    var color;
	    if (value) {
	        color = String(value).toLowerCase().replace(/ /g, "");
	        color = standardColorNames[color] ? "#" + standardColorNames[color] : color;
	        color = parseColor(color)
	    }
	    if (!color) {
	        this.colorIsInvalid = true
	    }
	    color = color || {};
	    this.r = normalize(color[0]);
	    this.g = normalize(color[1]);
	    this.b = normalize(color[2]);
	    this.a = normalize(color[3], 1, 1);
	    if (color[4]) {
	        this.hsv = {
	            h: color[4][0],
	            s: color[4][1],
	            v: color[4][2]
	        }
	    } else {
	        this.hsv = toHsvFromRgb(this.r, this.g, this.b)
	    }
	    if (color[5]) {
	        this.hsl = {
	            h: color[5][0],
	            s: color[5][1],
	            l: color[5][2]
	        }
	    } else {
	        this.hsl = toHslFromRgb(this.r, this.g, this.b)
	    }
	}

	function parseColor(color) {
	    if ("transparent" === color) {
	        return [0, 0, 0, 0]
	    }
	    var str, i = 0,
	        ii = standardColorTypes.length;
	    for (; i < ii; ++i) {
	        str = standardColorTypes[i].re.exec(color);
	        if (str) {
	            return standardColorTypes[i].process(str)
	        }
	    }
	    return null
	}

	function normalize(colorComponent, def, max) {
	    def = def || 0;
	    max = max || 255;
	    return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent
	}

	function toHexFromRgb(r, g, b) {
	    return "#" + (16777216 | r << 16 | g << 8 | b).toString(16).slice(1)
	}

	function toHsvFromRgb(r, g, b) {
	    var H, S, V, max = Math.max(r, g, b),
	        min = Math.min(r, g, b),
	        delta = max - min;
	    V = max;
	    S = 0 === max ? 0 : 1 - min / max;
	    if (max === min) {
	        H = 0
	    } else {
	        switch (max) {
	            case r:
	                H = 60 * ((g - b) / delta);
	                if (g < b) {
	                    H += 360
	                }
	                break;
	            case g:
	                H = 60 * ((b - r) / delta) + 120;
	                break;
	            case b:
	                H = 60 * ((r - g) / delta) + 240
	        }
	    }
	    S *= 100;
	    V *= 100 / 255;
	    return {
	        h: Math.round(H),
	        s: Math.round(S),
	        v: Math.round(V)
	    }
	}

	function hsvToRgb(h, s, v) {
	    var vDec, vInc, vMin, index, a, r, g, b;
	    index = Math.floor(h % 360 / 60);
	    vMin = (100 - s) * v / 100;
	    a = (v - vMin) * (h % 60 / 60);
	    vInc = vMin + a;
	    vDec = v - a;
	    switch (index) {
	        case 0:
	            r = v;
	            g = vInc;
	            b = vMin;
	            break;
	        case 1:
	            r = vDec;
	            g = v;
	            b = vMin;
	            break;
	        case 2:
	            r = vMin;
	            g = v;
	            b = vInc;
	            break;
	        case 3:
	            r = vMin;
	            g = vDec;
	            b = v;
	            break;
	        case 4:
	            r = vInc;
	            g = vMin;
	            b = v;
	            break;
	        case 5:
	            r = v;
	            g = vMin;
	            b = vDec
	    }
	    return [Math.round(2.55 * r), Math.round(2.55 * g), Math.round(2.55 * b)]
	}

	function calculateHue(r, g, b, delta) {
	    var max = Math.max(r, g, b);
	    switch (max) {
	        case r:
	            return (g - b) / delta + (g < b ? 6 : 0);
	        case g:
	            return (b - r) / delta + 2;
	        case b:
	            return (r - g) / delta + 4
	    }
	}

	function toHslFromRgb(r, g, b) {
	    r = convertTo01Bounds(r, 255);
	    g = convertTo01Bounds(g, 255);
	    b = convertTo01Bounds(b, 255);
	    var h, s, max = Math.max(r, g, b),
	        min = Math.min(r, g, b),
	        maxMinSum = max + min,
	        l = maxMinSum / 2;
	    if (max === min) {
	        h = s = 0
	    } else {
	        var delta = max - min;
	        if (l > .5) {
	            s = delta / (2 - maxMinSum)
	        } else {
	            s = delta / maxMinSum
	        }
	        h = calculateHue(r, g, b, delta);
	        h /= 6
	    }
	    return {
	        h: _round(360 * h),
	        s: _round(100 * s),
	        l: _round(100 * l)
	    }
	}

	function makeColorTint(colorPart, h) {
	    var colorTint = h;
	    if ("r" === colorPart) {
	        colorTint = h + 1 / 3
	    }
	    if ("b" === colorPart) {
	        colorTint = h - 1 / 3
	    }
	    return colorTint
	}

	function modifyColorTint(colorTint) {
	    if (colorTint < 0) {
	        colorTint += 1
	    }
	    if (colorTint > 1) {
	        colorTint -= 1
	    }
	    return colorTint
	}

	function hueToRgb(p, q, colorTint) {
	    colorTint = modifyColorTint(colorTint);
	    if (colorTint < 1 / 6) {
	        return p + 6 * (q - p) * colorTint
	    }
	    if (colorTint < .5) {
	        return q
	    }
	    if (colorTint < 2 / 3) {
	        return p + (q - p) * (2 / 3 - colorTint) * 6
	    }
	    return p
	}

	function hslToRgb(h, s, l) {
	    var r, g, b;
	    h = convertTo01Bounds(h, 360);
	    s = convertTo01Bounds(s, 100);
	    l = convertTo01Bounds(l, 100);
	    if (0 === s) {
	        r = g = b = l
	    } else {
	        var q = l < .5 ? l * (1 + s) : l + s - l * s,
	            p = 2 * l - q;
	        r = hueToRgb(p, q, makeColorTint("r", h));
	        g = hueToRgb(p, q, makeColorTint("g", h));
	        b = hueToRgb(p, q, makeColorTint("b", h))
	    }
	    return [_round(255 * r), _round(255 * g), _round(255 * b)]
	}

	function convertTo01Bounds(n, max) {
	    n = Math.min(max, Math.max(0, parseFloat(n)));
	    if (Math.abs(n - max) < 1e-6) {
	        return 1
	    }
	    return n % max / parseFloat(max)
	}

	function isIntegerBetweenMinAndMax(number, min, max) {
	    min = min || 0;
	    max = max || 255;
	    if (number % 1 !== 0 || number < min || number > max || "number" !== typeof number || isNaN(number)) {
	        return false
	    }
	    return true
	}
	var _round = Math.round;
	Color.prototype = {
	    constructor: Color,
	    highlight: function(step) {
	        step = step || 10;
	        return this.alter(step).toHex()
	    },
	    darken: function(step) {
	        step = step || 10;
	        return this.alter(-step).toHex()
	    },
	    alter: function(step) {
	        var result = new Color;
	        result.r = normalize(this.r + step);
	        result.g = normalize(this.g + step);
	        result.b = normalize(this.b + step);
	        return result
	    },
	    blend: function(blendColor, opacity) {
	        var other = blendColor instanceof Color ? blendColor : new Color(blendColor),
	            result = new Color;
	        result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
	        result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
	        result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
	        return result
	    },
	    toHex: function() {
	        return toHexFromRgb(this.r, this.g, this.b)
	    },
	    getPureColor: function() {
	        var rgb = hsvToRgb(this.hsv.h, 100, 100);
	        return new Color("rgb(" + rgb.join(",") + ")")
	    },
	    isValidHex: function(hex) {
	        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex)
	    },
	    isValidRGB: function(r, g, b) {
	        if (!isIntegerBetweenMinAndMax(r) || !isIntegerBetweenMinAndMax(g) || !isIntegerBetweenMinAndMax(b)) {
	            return false
	        }
	        return true
	    },
	    isValidAlpha: function(a) {
	        if (isNaN(a) || a < 0 || a > 1 || "number" !== typeof a) {
	            return false
	        }
	        return true
	    },
	    colorIsInvalid: false
	};
	module.exports = Color;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (client_exporter/pdf_creator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    VERSION = __webpack_require__(12),
	    imageCreator = __webpack_require__(23).imageCreator,
	    isFunction = __webpack_require__(8).isFunction,
	    when = __webpack_require__(10).when,
	    mainPageTemplate = "%PDF-1.3\r\n2 0 obj\r\n<</ProcSet[/PDF/ImageB/ImageC/ImageI]/XObject<</I0 5 0 R>>>>\r\nendobj\r\n4 0 obj\r\n<</Type/Pages/Kids[1 0 R]/Count 1>>\r\nendobj\r\n7 0 obj\r\n<</OpenAction[1 0 R /FitH null]/Type/Catalog/Pages 4 0 R/PageLayout/OneColumn>>\r\nendobj\r\n1 0 obj\r\n<</Type/Page/Resources 2 0 R/MediaBox[0 0 _width_ _height_]/Contents 3 0 R/Parent 4 0 R>>\r\nendobj\r\n",
	    contentTemplate = "3 0 obj\r\n<</Length 52>>stream\r\n0.20 w\n0 G\nq _width_ 0 0 _height_ 0.00 0.00 cm /I0 Do Q\r\nendstream\r\nendobj\r\n",
	    infoTemplate = "6 0 obj\r\n<</CreationDate _date_/Producer(DevExtreme _version_)>>\r\nendobj\r\n",
	    imageStartTemplate = "5 0 obj\r\n<</Type/XObject/Subtype/Image/Width _width_/Height _height_/ColorSpace/DeviceRGB/BitsPerComponent 8/Filter/DCTDecode/Length _length_>>stream\r\n",
	    imageEndTemplate = "\r\nendstream\r\nendobj\r\n",
	    trailerTemplate = "trailer\r\n<<\r\n/Size 8\r\n/Root 7 0 R\r\n/Info 6 0 R\r\n>>\r\nstartxref\r\n_length_\r\n%%EOF",
	    xrefTemplate = "xref\r\n0 8\r\n0000000000 65535 f\r\n0000000241 00000 n\r\n0000000010 00000 n\r\n_main_ 00000 n\r\n0000000089 00000 n\r\n_image_ 00000 n\r\n_info_ 00000 n\r\n0000000143 00000 n\r\n",
	    DEFAULT_MARGIN_X = 60,
	    DEFAULT_MARGIN_Y = 40;
	var pad = function(str, len) {
	    return str.length < len ? pad("0" + str, len) : str
	};
	var composePdfString = function(imageString, options, curDate) {
	    var width = options.width + DEFAULT_MARGIN_X,
	        height = options.height + DEFAULT_MARGIN_Y,
	        widthPt = (.75 * width).toFixed(2),
	        heightPt = (.75 * height).toFixed(2);
	    var mainPage = mainPageTemplate.replace("_width_", widthPt).replace("_height_", heightPt),
	        content = contentTemplate.replace("_width_", widthPt).replace("_height_", heightPt),
	        info = infoTemplate.replace("_date_", curDate).replace("_version_", VERSION),
	        image = imageStartTemplate.replace("_width_", width).replace("_height_", height).replace("_length_", imageString.length) + imageString + imageEndTemplate,
	        xref = getXref(mainPage.length, content.length, info.length);
	    var mainContent = mainPage + content + info + image,
	        trailer = trailerTemplate.replace("_length_", mainContent.length);
	    return mainContent + xref + trailer
	};
	var getXref = function(mainPageLength, contentLength, infoLength) {
	    return xrefTemplate.replace("_main_", pad(mainPageLength + "", 10)).replace("_info_", pad(mainPageLength + contentLength + "", 10)).replace("_image_", pad(mainPageLength + contentLength + infoLength + "", 10))
	};
	var getCurDate = function() {
	    return new Date
	};
	var getBlob = function(binaryData) {
	    var i = 0,
	        dataArray = new Uint8Array(binaryData.length);
	    for (; i < binaryData.length; i++) {
	        dataArray[i] = binaryData.charCodeAt(i)
	    }
	    return new Blob([dataArray.buffer], {
	        type: "application/pdf"
	    })
	};
	var getBase64 = function(binaryData) {
	    return window.btoa(binaryData)
	};
	exports.getData = function(data, options, callback) {
	    var imageData = imageCreator.getImageData(data, $.extend({}, options, {
	            format: "jpeg"
	        })),
	        blob = $.Deferred();
	    blob.done(callback);
	    when(imageData).done(function(imageString) {
	        var binaryData = composePdfString(imageString, options, getCurDate()),
	            pdfData = isFunction(window.Blob) ? getBlob(binaryData) : getBase64(binaryData);
	        blob.resolve(pdfData)
	    })
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (client_exporter/svg_creator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    getSvgMarkup = __webpack_require__(27).getSvgMarkup,
	    when = __webpack_require__(10).when;
	exports.svgCreator = {
	    _markup: "",
	    _imageArray: {},
	    _imageDeferreds: [],
	    _getBinaryFile: function(src, callback) {
	        var xhr = new XMLHttpRequest;
	        xhr.onreadystatechange = function() {
	            if (xhr.readyState === xhr.DONE) {
	                if (200 === xhr.status && xhr.response) {
	                    callback(xhr.response)
	                } else {
	                    callback(false)
	                }
	            }
	        };
	        xhr.open("GET", src, true);
	        xhr.responseType = "arraybuffer";
	        xhr.send()
	    },
	    _loadImages: function() {
	        var that = this;
	        $.each(that._imageArray, function(src) {
	            var deferred = new $.Deferred;
	            that._imageDeferreds.push(deferred);
	            that._getBinaryFile(src, function(response) {
	                if (!response) {
	                    delete that._imageArray[src];
	                    deferred.resolve();
	                    return
	                }
	                var i, binary = "",
	                    bytes = new Uint8Array(response),
	                    length = bytes.byteLength;
	                for (i = 0; i < length; i++) {
	                    binary += String.fromCharCode(bytes[i])
	                }
	                that._imageArray[src] = "data:image/png;base64," + btoa(binary);
	                deferred.resolve()
	            })
	        })
	    },
	    _parseImages: function(element) {
	        var href, that = this;
	        if ("image" === element.tagName) {
	            href = $(element).attr("xlink:href");
	            if (!that._imageArray[href]) {
	                that._imageArray[href] = ""
	            }
	        }
	        $.each(element.childNodes, function(_, element) {
	            that._parseImages(element)
	        })
	    },
	    _prepareImages: function(svgElem) {
	        this._parseImages(svgElem);
	        this._loadImages();
	        return when.apply($, this._imageDeferreds)
	    },
	    getData: function(data, options) {
	        var markup, that = this,
	            xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>',
	            blob = $.Deferred(),
	            parser = new DOMParser,
	            elem = parser.parseFromString(data, "image/svg+xml"),
	            svgElem = elem.childNodes[0],
	            $svgObject = $(svgElem);
	        $svgObject.css("background-color", options.backgroundColor);
	        markup = xmlVersion + getSvgMarkup($svgObject.get(0));
	        that._prepareImages(svgElem).done(function() {
	            $.each(that._imageArray, function(href, dataURI) {
	                markup = markup.split(href).join(dataURI)
	            });
	            blob.resolve(commonUtils.isFunction(window.Blob) ? that._getBlob(markup) : that._getBase64(markup))
	        });
	        return blob
	    },
	    _getBlob: function(markup) {
	        return new Blob([markup], {
	            type: "image/svg+xml"
	        })
	    },
	    _getBase64: function(markup) {
	        return window.btoa(markup)
	    }
	};
	exports.getData = function(data, options, callback) {
	    exports.svgCreator.getData(data, options).done(callback)
	};


/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (core/utils/svg.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";

	function getMarkup(element) {
	    var temp = document.createElement("div");
	    temp.appendChild(element.cloneNode(true));
	    return temp.innerHTML
	}

	function fixIENamespaces(markup) {
	    var first = true;
	    markup = markup.replace(/xmlns="[\s\S]*?"/gi, function(match) {
	        if (!first) {
	            return ""
	        }
	        first = false;
	        return match
	    });
	    return markup.replace(/xmlns:NS1="[\s\S]*?"/gi, "").replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"')
	}

	function decodeHtmlEntities(markup) {
	    return markup.replace(/&quot;/gi, "&#34;").replace(/&amp;/gi, "&#38;").replace(/&apos;/gi, "&#39;").replace(/&lt;/gi, "&#60;").replace(/&gt;/gi, "&#62;").replace(/&nbsp;/gi, "&#160;").replace(/&shy;/gi, "&#173;")
	}
	exports.getSvgMarkup = function(element) {
	    return fixIENamespaces(decodeHtmlEntities(getMarkup(element)))
	};


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/dom_component.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    config = __webpack_require__(9),
	    errors = __webpack_require__(3),
	    windowResizeCallbacks = __webpack_require__(29).resizeCallbacks,
	    commonUtils = __webpack_require__(8),
	    publicComponentUtils = __webpack_require__(30),
	    Component = __webpack_require__(33),
	    abstract = Component.abstract;
	var RTL_DIRECTION_CLASS = "dx-rtl",
	    VISIBILITY_CHANGE_CLASS = "dx-visibility-change-handler",
	    VISIBILITY_CHANGE_EVENTNAMESPACE = "VisibilityChange";
	var DOMComponent = Component.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            width: void 0,
	            height: void 0,
	            rtlEnabled: config().rtlEnabled,
	            elementAttr: {},
	            disabled: false,
	            integrationOptions: {}
	        })
	    },
	    ctor: function(element, options) {
	        this._$element = $(element);
	        publicComponentUtils.attachInstanceToElement(this._$element, this, this._dispose);
	        this.callBase(options)
	    },
	    _visibilityChanged: abstract,
	    _dimensionChanged: abstract,
	    _init: function() {
	        this.callBase();
	        this._attachWindowResizeCallback()
	    },
	    _attachWindowResizeCallback: function() {
	        if (this._isDimensionChangeSupported()) {
	            var windowResizeCallBack = this._windowResizeCallBack = $.proxy(this._dimensionChanged, this);
	            windowResizeCallbacks.add(windowResizeCallBack)
	        }
	    },
	    _isDimensionChangeSupported: function() {
	        return this._dimensionChanged !== abstract
	    },
	    _render: function() {
	        this._renderElementAttributes();
	        this._toggleRTLDirection(this.option("rtlEnabled"));
	        this._renderVisibilityChange();
	        this._renderDimensions()
	    },
	    _renderElementAttributes: function() {
	        var attributes = $.extend({}, this.option("elementAttr")),
	            classNames = attributes.class;
	        delete attributes.class;
	        this.element().attr(attributes).addClass(classNames)
	    },
	    _renderVisibilityChange: function() {
	        if (this._isDimensionChangeSupported()) {
	            this._attachDimensionChangeHandlers()
	        }
	        if (!this._isVisibilityChangeSupported()) {
	            return
	        }
	        this.element().addClass(VISIBILITY_CHANGE_CLASS);
	        this._attachVisibilityChangeHandlers()
	    },
	    _renderDimensions: function() {
	        var width = this.option("width"),
	            height = this.option("height"),
	            $element = this.element();
	        $element.outerWidth(width);
	        $element.outerHeight(height)
	    },
	    _attachDimensionChangeHandlers: function() {
	        var that = this;
	        var resizeEventName = "dxresize." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
	        that.element().off(resizeEventName).on(resizeEventName, function() {
	            that._dimensionChanged()
	        })
	    },
	    _attachVisibilityChangeHandlers: function() {
	        var that = this;
	        var hidingEventName = "dxhiding." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
	        var shownEventName = "dxshown." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
	        that._isHidden = !that._isVisible();
	        that.element().off(hidingEventName).on(hidingEventName, function() {
	            that._checkVisibilityChanged("hiding")
	        }).off(shownEventName).on(shownEventName, function() {
	            that._checkVisibilityChanged("shown")
	        })
	    },
	    _isVisible: function() {
	        return this.element().is(":visible")
	    },
	    _checkVisibilityChanged: function(event) {
	        if ("hiding" === event && this._isVisible() && !this._isHidden) {
	            this._visibilityChanged(false);
	            this._isHidden = true
	        } else {
	            if ("shown" === event && this._isVisible() && this._isHidden) {
	                this._isHidden = false;
	                this._visibilityChanged(true)
	            }
	        }
	    },
	    _isVisibilityChangeSupported: function() {
	        return this._visibilityChanged !== abstract
	    },
	    _clean: $.noop,
	    _modelByElement: function() {
	        var modelByElement = this.option("modelByElement") || $.noop;
	        return modelByElement(this.element())
	    },
	    _invalidate: function() {
	        if (!this._updateLockCount) {
	            throw errors.Error("E0007")
	        }
	        this._requireRefresh = true
	    },
	    _refresh: function() {
	        this._clean();
	        this._render()
	    },
	    _dispose: function() {
	        this.callBase();
	        this._clean();
	        this._detachWindowResizeCallback()
	    },
	    _detachWindowResizeCallback: function() {
	        if (this._isDimensionChangeSupported()) {
	            windowResizeCallbacks.remove(this._windowResizeCallBack)
	        }
	    },
	    _toggleRTLDirection: function(rtl) {
	        this.element().toggleClass(RTL_DIRECTION_CLASS, rtl)
	    },
	    _createComponent: function(element, component, config) {
	        var that = this;
	        config = config || {};
	        var synchronizableOptions = $.grep(["rtlEnabled", "disabled"], function(value) {
	            return !(value in config)
	        });
	        var nestedComponentOptions = that.option("nestedComponentOptions") || $.noop;
	        that._extendConfig(config, $.extend({
	            integrationOptions: this.option("integrationOptions"),
	            rtlEnabled: this.option("rtlEnabled"),
	            disabled: this.option("disabled")
	        }, nestedComponentOptions(this)));
	        var instance;
	        if (commonUtils.isString(component)) {
	            var $element = $(element)[component](config);
	            instance = $element[component]("instance")
	        } else {
	            if (element) {
	                instance = component.getInstance(element);
	                if (instance) {
	                    instance.option(config)
	                } else {
	                    instance = new component(element, config)
	                }
	            }
	        }
	        if (instance) {
	            var optionChangedHandler = function(args) {
	                if ($.inArray(args.name, synchronizableOptions) >= 0) {
	                    instance.option(args.name, args.value)
	                }
	            };
	            that.on("optionChanged", optionChangedHandler);
	            instance.on("disposing", function() {
	                that.off("optionChanged", optionChangedHandler)
	            })
	        }
	        return instance
	    },
	    _extendConfig: function(config, extendConfig) {
	        $.each(extendConfig, function(key, value) {
	            config[key] = config.hasOwnProperty(key) ? config[key] : value
	        })
	    },
	    _defaultActionConfig: function() {
	        return $.extend(this.callBase(), {
	            context: this._modelByElement(this.element())
	        })
	    },
	    _defaultActionArgs: function() {
	        var element = this.element(),
	            model = this._modelByElement(this.element());
	        return $.extend(this.callBase(), {
	            element: element,
	            model: model
	        })
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "width":
	            case "height":
	                this._renderDimensions();
	                break;
	            case "rtlEnabled":
	            case "elementAttr":
	                this._invalidate();
	                break;
	            case "disabled":
	            case "integrationOptions":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    endUpdate: function() {
	        var requireRender = !this._initializing && !this._initialized;
	        this.callBase.apply(this, arguments);
	        if (!this._updateLockCount) {
	            if (requireRender) {
	                this._render()
	            } else {
	                if (this._requireRefresh) {
	                    this._requireRefresh = false;
	                    this._refresh()
	                }
	            }
	        }
	    },
	    element: function() {
	        return this._$element
	    }
	});
	DOMComponent.getInstance = function($element) {
	    return publicComponentUtils.getInstanceByElement($($element), this)
	};
	DOMComponent.defaultOptions = function(rule) {
	    this.prototype._customRules = this.prototype._customRules || [];
	    this.prototype._customRules.push(rule)
	};
	module.exports = DOMComponent;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/window.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var resizeCallbacks = function() {
	    var prevSize, callbacks = $.Callbacks(),
	        jqWindow = $(window),
	        resizeEventHandlerAttached = false,
	        originalCallbacksAdd = callbacks.add,
	        originalCallbacksRemove = callbacks.remove;
	    var formatSize = function() {
	        return {
	            width: jqWindow.width(),
	            height: jqWindow.height()
	        }
	    };
	    var handleResize = function() {
	        var now = formatSize();
	        if (now.width === prevSize.width && now.height === prevSize.height) {
	            return
	        }
	        var changedDimension;
	        if (now.width === prevSize.width) {
	            changedDimension = "height"
	        }
	        if (now.height === prevSize.height) {
	            changedDimension = "width"
	        }
	        prevSize = now;
	        setTimeout(function() {
	            callbacks.fire(changedDimension)
	        })
	    };
	    prevSize = formatSize();
	    callbacks.add = function() {
	        var result = originalCallbacksAdd.apply(callbacks, arguments);
	        if (!resizeEventHandlerAttached && callbacks.has()) {
	            jqWindow.on("resize", handleResize);
	            resizeEventHandlerAttached = true
	        }
	        return result
	    };
	    callbacks.remove = function() {
	        var result = originalCallbacksRemove.apply(callbacks, arguments);
	        if (!callbacks.has() && resizeEventHandlerAttached) {
	            jqWindow.off("resize", handleResize);
	            resizeEventHandlerAttached = false
	        }
	        return result
	    };
	    return callbacks
	}();
	var defaultScreenFactorFunc = function(width) {
	    if (width < 768) {
	        return "xs"
	    } else {
	        if (width < 992) {
	            return "sm"
	        } else {
	            if (width < 1200) {
	                return "md"
	            } else {
	                return "lg"
	            }
	        }
	    }
	};
	var getCurrentScreenFactor = function(screenFactorCallback) {
	    var screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
	    return screenFactorFunc($(window).width())
	};
	exports.resizeCallbacks = resizeCallbacks;
	exports.defaultScreenFactorFunc = defaultScreenFactorFunc;
	exports.getCurrentScreenFactor = getCurrentScreenFactor;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/public_component.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    WeakMap = __webpack_require__(31),
	    commonUtils = __webpack_require__(8),
	    removeEvent = __webpack_require__(32);
	var COMPONENT_NAMES_DATA_KEY = "dxComponents",
	    ANONYMOUS_COMPONENT_DATA_KEY = "dxPrivateComponent";
	var componentNames = new WeakMap,
	    nextAnonymousComponent = 0;
	var getName = exports.name = function(componentClass, newName) {
	    if (commonUtils.isDefined(newName)) {
	        componentNames.set(componentClass, newName);
	        return
	    }
	    if (!componentNames.has(componentClass)) {
	        var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
	        componentNames.set(componentClass, generatedName);
	        return generatedName
	    }
	    return componentNames.get(componentClass)
	};
	exports.attachInstanceToElement = function($element, componentInstance, disposeFn) {
	    var data = $.data($element.get(0)),
	        name = getName(componentInstance.constructor);
	    data[name] = componentInstance;
	    if (disposeFn) {
	        $element.one(removeEvent, function() {
	            disposeFn.call(componentInstance)
	        })
	    }
	    if (!data[COMPONENT_NAMES_DATA_KEY]) {
	        data[COMPONENT_NAMES_DATA_KEY] = []
	    }
	    data[COMPONENT_NAMES_DATA_KEY].push(name)
	};
	exports.getInstanceByElement = function($element, componentClass) {
	    var name = getName(componentClass);
	    return $.data($element.get(0), name)
	};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/polyfills/weak_map.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    WeakMap = window.WeakMap;
	if (!WeakMap) {
	    WeakMap = function() {
	        var keys = [],
	            values = [];
	        this.set = function(key, value) {
	            var index = $.inArray(key, keys);
	            if (index === -1) {
	                keys.push(key);
	                values.push(value)
	            } else {
	                values[index] = value
	            }
	        };
	        this.get = function(key) {
	            var index = $.inArray(key, keys);
	            if (index === -1) {
	                return
	            }
	            return values[index]
	        };
	        this.has = function(key) {
	            var index = $.inArray(key, keys);
	            if (index === -1) {
	                return false
	            }
	            return true
	        }
	    }
	}
	module.exports = WeakMap;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/remove_event.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    cleanData = $.cleanData,
	    specialEvents = $.event.special;
	var eventName = "dxremove",
	    eventPropName = "dxRemoveEvent";
	$.cleanData = function(elements) {
	    elements = [].slice.call(elements);
	    for (var i = 0; i < elements.length; i++) {
	        var $element = $(elements[i]);
	        if ($element.prop(eventPropName)) {
	            $element.removeProp(eventPropName);
	            $element.triggerHandler(eventName)
	        }
	    }
	    return cleanData(elements)
	};
	specialEvents[eventName] = {
	    noBubble: true,
	    setup: function() {
	        $(this).prop(eventPropName, true)
	    }
	};
	module.exports = eventName;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/component.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    Action = __webpack_require__(34),
	    errors = __webpack_require__(3),
	    coreDataUtils = __webpack_require__(35),
	    commonUtils = __webpack_require__(8),
	    EventsMixin = __webpack_require__(38),
	    publicComponentUtils = __webpack_require__(30),
	    devices = __webpack_require__(40);
	var cachedGetters = {};
	var cachedSetters = {};
	var Component = Class.inherit({
	    _setDeprecatedOptions: function() {
	        this._deprecatedOptions = {}
	    },
	    _getDeprecatedOptions: function() {
	        return this._deprecatedOptions
	    },
	    _getOptionAliasesByName: function(optionName) {
	        return $.map(this._deprecatedOptions, function(deprecate, aliasName) {
	            return optionName === deprecate.alias ? aliasName : void 0
	        })
	    },
	    _getDefaultOptions: function() {
	        return {
	            onInitialized: null,
	            onOptionChanged: null,
	            onDisposing: null,
	            defaultOptionsRules: null
	        }
	    },
	    _setDefaultOptions: function() {
	        this._options = this._getDefaultOptions()
	    },
	    _defaultOptionsRules: function() {
	        return []
	    },
	    _setOptionsByDevice: function(userRules) {
	        var rules = this._defaultOptionsRules();
	        if (this._customRules) {
	            rules = rules.concat(this._customRules)
	        }
	        if ($.isArray(userRules)) {
	            rules = rules.concat(userRules)
	        }
	        var rulesOptions = this._convertRulesToOptions(rules);
	        $.extend(true, this._options, rulesOptions);
	        for (var fieldName in this._optionsByReference) {
	            if (rulesOptions.hasOwnProperty(fieldName)) {
	                this._options[fieldName] = rulesOptions[fieldName]
	            }
	        }
	    },
	    _convertRulesToOptions: function(rules) {
	        var options = {};
	        var currentDevice = devices.current();
	        var deviceMatch = function(device, filter) {
	            filter = $.makeArray(filter);
	            return 1 === filter.length && $.isEmptyObject(filter[0]) || commonUtils.findBestMatches(device, filter).length > 0
	        };
	        for (var i = 0; i < rules.length; i++) {
	            var match, rule = rules[i],
	                deviceFilter = rule.device || {};
	            if ($.isFunction(deviceFilter)) {
	                match = deviceFilter(currentDevice)
	            } else {
	                match = deviceMatch(currentDevice, deviceFilter)
	            }
	            if (match) {
	                $.extend(options, rule.options)
	            }
	        }
	        return options
	    },
	    _isInitialOptionValue: function(name) {
	        var isCustomOption = this._customRules && this._convertRulesToOptions(this._customRules).hasOwnProperty(name),
	            optionValue = this.option(name),
	            initialOptionValue = this.initialOption(name),
	            isInitialOption = commonUtils.isFunction(optionValue) && commonUtils.isFunction(initialOptionValue) ? optionValue.toString() === initialOptionValue.toString() : commonUtils.equalByValue(optionValue, initialOptionValue);
	        return !isCustomOption && isInitialOption
	    },
	    _setOptionsByReference: function() {
	        this._optionsByReference = {}
	    },
	    _getOptionsByReference: function() {
	        return this._optionsByReference
	    },
	    ctor: function(options) {
	        this.NAME = publicComponentUtils.name(this.constructor);
	        options = options || {};
	        this._options = {};
	        this._updateLockCount = 0;
	        this._optionChangedCallbacks = options._optionChangedCallbacks || $.Callbacks();
	        this._disposingCallbacks = options._disposingCallbacks || $.Callbacks();
	        this.beginUpdate();
	        try {
	            this._suppressDeprecatedWarnings();
	            this._setOptionsByReference();
	            this._setDeprecatedOptions();
	            this._setDefaultOptions();
	            if (options && options.onInitializing) {
	                options.onInitializing.apply(this, [options])
	            }
	            this._setOptionsByDevice(options.defaultOptionsRules);
	            this._resumeDeprecatedWarnings();
	            this._initOptions(options)
	        } finally {
	            this.endUpdate()
	        }
	    },
	    _initOptions: function(options) {
	        this.option(options)
	    },
	    _optionValuesEqual: function(name, oldValue, newValue) {
	        oldValue = coreDataUtils.toComparable(oldValue, true);
	        newValue = coreDataUtils.toComparable(newValue, true);
	        if (oldValue && newValue && oldValue.jquery && newValue.jquery) {
	            return newValue.is(oldValue)
	        }
	        var oldValueIsNaN = oldValue !== oldValue,
	            newValueIsNaN = newValue !== newValue;
	        if (oldValueIsNaN && newValueIsNaN) {
	            return true
	        }
	        if (null === oldValue || "object" !== typeof oldValue) {
	            return oldValue === newValue
	        }
	        return false
	    },
	    _init: function() {
	        this._createOptionChangedAction();
	        this.on("disposing", function(args) {
	            this._disposingCallbacks.fireWith(this, [args])
	        })
	    },
	    _createOptionChangedAction: function() {
	        this._optionChangedAction = this._createActionByOption("onOptionChanged", {
	            excludeValidators: ["disabled", "readOnly", "designMode"]
	        })
	    },
	    _createDisposingAction: function() {
	        this._disposingAction = this._createActionByOption("onDisposing", {
	            excludeValidators: ["disabled", "readOnly", "designMode"]
	        })
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "onDisposing":
	            case "onInitialized":
	                break;
	            case "onOptionChanged":
	                this._createOptionChangedAction();
	                break;
	            case "defaultOptionsRules":
	        }
	    },
	    _dispose: function() {
	        this._optionChangedCallbacks.empty();
	        this._createDisposingAction();
	        this._disposingAction();
	        this._disposeEvents();
	        this._disposed = true
	    },
	    instance: function() {
	        return this
	    },
	    beginUpdate: function() {
	        this._updateLockCount++
	    },
	    endUpdate: function() {
	        this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
	        if (!this._updateLockCount) {
	            if (!this._initializing && !this._initialized) {
	                this._initializing = true;
	                try {
	                    this._init()
	                } finally {
	                    this._initializing = false;
	                    this._updateLockCount++;
	                    this._createActionByOption("onInitialized", {
	                        excludeValidators: ["disabled", "readOnly", "designMode"]
	                    })();
	                    this._updateLockCount--;
	                    this._initialized = true
	                }
	            }
	        }
	    },
	    _logWarningIfDeprecated: function(option) {
	        var info = this._deprecatedOptions[option];
	        if (info && !this._deprecatedOptionsSuppressed) {
	            this._logDeprecatedWarning(option, info)
	        }
	    },
	    _logDeprecatedWarningCount: 0,
	    _logDeprecatedWarning: function(option, info) {
	        var message = info.message || "Use the '" + info.alias + "' option instead";
	        errors.log("W0001", this.NAME, option, info.since, message);
	        ++this._logDeprecatedWarningCount
	    },
	    _suppressDeprecatedWarnings: function() {
	        this._deprecatedOptionsSuppressed = true
	    },
	    _resumeDeprecatedWarnings: function() {
	        this._deprecatedOptionsSuppressed = false
	    },
	    _optionChanging: $.noop,
	    _notifyOptionChanged: function(option, value, previousValue) {
	        var that = this;
	        if (this._initialized) {
	            var optionNames = [option].concat(that._getOptionAliasesByName(option));
	            for (var i = 0; i < optionNames.length; i++) {
	                var name = optionNames[i],
	                    args = {
	                        name: name.split(/[.\[]/)[0],
	                        fullName: name,
	                        value: value,
	                        previousValue: previousValue
	                    };
	                that._optionChangedCallbacks.fireWith(that, [$.extend(that._defaultActionArgs(), args)]);
	                that._optionChangedAction($.extend({}, args));
	                if (!that._disposed) {
	                    that._optionChanged(args)
	                }
	            }
	        }
	    },
	    initialOption: function(optionName) {
	        var currentOptions, currentInitialized = this._initialized;
	        if (!this._initialOptions) {
	            currentOptions = this._options;
	            this._options = {};
	            this._initialized = false;
	            this._setDefaultOptions();
	            this._setOptionsByDevice(currentOptions.defaultOptionsRules);
	            this._initialOptions = this._options;
	            this._options = currentOptions;
	            this._initialized = currentInitialized
	        }
	        return this._initialOptions[optionName]
	    },
	    _defaultActionConfig: function() {
	        return {
	            context: this,
	            component: this
	        }
	    },
	    _defaultActionArgs: function() {
	        return {
	            component: this
	        }
	    },
	    _createAction: function(actionSource, config) {
	        var action, that = this;
	        return function(e) {
	            if (!arguments.length) {
	                e = {}
	            }
	            if (!$.isPlainObject(e)) {
	                e = {
	                    actionValue: e
	                }
	            }
	            action = action || new Action(actionSource, $.extend(config, that._defaultActionConfig()));
	            return action.execute.call(action, $.extend(e, that._defaultActionArgs()))
	        }
	    },
	    _createActionByOption: function(optionName, config) {
	        var action, eventName, actionFunc, that = this;
	        var result = function() {
	            if (!eventName) {
	                config = config || {};
	                if ("string" !== typeof optionName) {
	                    throw errors.Error("E0008")
	                }
	                if (0 === optionName.indexOf("on")) {
	                    eventName = that._getEventName(optionName)
	                }
	                actionFunc = that.option(optionName)
	            }
	            if (!action && !actionFunc && !config.beforeExecute && !config.afterExecute && !that.hasEvent(eventName)) {
	                return
	            }
	            if (!action) {
	                var beforeExecute = config.beforeExecute;
	                config.beforeExecute = function(args) {
	                    that.fireEvent(eventName, args.args);
	                    beforeExecute && beforeExecute.apply(that, arguments)
	                };
	                that._suppressDeprecatedWarnings();
	                action = that._createAction(actionFunc, config);
	                that._resumeDeprecatedWarnings()
	            }
	            return action.apply(that, arguments)
	        };
	        var onActionCreated = that.option("onActionCreated") || $.noop;
	        result = onActionCreated(that, result, config) || result;
	        return result
	    },
	    _getEventName: function(actionName) {
	        return actionName.charAt(2).toLowerCase() + actionName.substr(3)
	    },
	    hasActionSubscription: function(actionName) {
	        return !!this.option(actionName) || this.hasEvent(this._getEventName(actionName))
	    },
	    isOptionDeprecated: function(name) {
	        var deprecatedOptions = this._getDeprecatedOptions();
	        return deprecatedOptions.hasOwnProperty(name)
	    },
	    option: function() {
	        var normalizeOptionName = function(that, name) {
	            var deprecate;
	            if (name) {
	                if (!that._cachedDeprecateNames) {
	                    that._cachedDeprecateNames = [];
	                    for (var optionName in that._deprecatedOptions) {
	                        that._cachedDeprecateNames.push(optionName)
	                    }
	                }
	                for (var i = 0; i < that._cachedDeprecateNames.length; i++) {
	                    if (that._cachedDeprecateNames[i] === name) {
	                        deprecate = that._deprecatedOptions[name];
	                        break
	                    }
	                }
	                if (deprecate) {
	                    that._logWarningIfDeprecated(name);
	                    var alias = deprecate.alias;
	                    if (alias) {
	                        name = alias
	                    }
	                }
	            }
	            return name
	        };
	        var getPreviousName = function(fullName) {
	            var splitNames = fullName.split(".");
	            splitNames.pop();
	            return splitNames.join(".")
	        };
	        var getFieldName = function(fullName) {
	            var splitNames = fullName.split(".");
	            return splitNames[splitNames.length - 1]
	        };
	        var getOptionValue = function(options, name, unwrapObservables) {
	            var getter = cachedGetters[name];
	            if (!getter) {
	                getter = cachedGetters[name] = coreDataUtils.compileGetter(name)
	            }
	            return getter(options, {
	                functionsAsIs: true,
	                unwrapObservables: unwrapObservables
	            })
	        };
	        var clearOptionsField = function(options, name) {
	            delete options[name];
	            var previousFieldName = getPreviousName(name),
	                fieldName = getFieldName(name),
	                fieldObject = previousFieldName ? getOptionValue(options, previousFieldName, false) : options;
	            if (fieldObject) {
	                delete fieldObject[fieldName]
	            }
	        };
	        var setOptionsField = function(options, fullName, value) {
	            var fieldObject, fieldName = "";
	            do {
	                if (fieldName) {
	                    fieldName = "." + fieldName
	                }
	                fieldName = getFieldName(fullName) + fieldName;
	                fullName = getPreviousName(fullName);
	                fieldObject = fullName ? getOptionValue(options, fullName, false) : options
	            } while (!fieldObject);
	            fieldObject[fieldName] = value
	        };
	        var normalizeOptionValue = function(that, options, name, value) {
	            if (name) {
	                var alias = normalizeOptionName(that, name);
	                if (alias && alias !== name) {
	                    setOptionsField(options, alias, value);
	                    clearOptionsField(options, name)
	                }
	            }
	        };
	        var prepareOption = function(that, options, name, value) {
	            if ($.isPlainObject(value)) {
	                for (var valueName in value) {
	                    prepareOption(that, options, name + "." + valueName, value[valueName])
	                }
	            }
	            normalizeOptionValue(that, options, name, value)
	        };
	        var setOptionValue = function(that, name, value) {
	            if (!cachedSetters[name]) {
	                cachedSetters[name] = coreDataUtils.compileSetter(name)
	            }
	            var path = name.split(/[.\[]/);
	            cachedSetters[name](that._options, value, {
	                functionsAsIs: true,
	                merge: !that._getOptionsByReference()[name],
	                unwrapObservables: path.length > 1 && !!that._getOptionsByReference()[path[0]]
	            })
	        };
	        var setOption = function(that, name, value) {
	            var previousValue = getOptionValue(that._options, name, false);
	            if (that._optionValuesEqual(name, previousValue, value)) {
	                return
	            }
	            if (that._initialized) {
	                that._optionChanging(name, previousValue, value)
	            }
	            setOptionValue(that, name, value);
	            that._notifyOptionChanged(name, value, previousValue)
	        };
	        return function(options, value) {
	            var that = this,
	                name = options;
	            if (arguments.length < 2 && "object" !== $.type(name)) {
	                name = normalizeOptionName(that, name);
	                return getOptionValue(that._options, name)
	            }
	            if ("string" === typeof name) {
	                options = {};
	                options[name] = value
	            }
	            that.beginUpdate();
	            try {
	                var optionName;
	                for (optionName in options) {
	                    prepareOption(that, options, optionName, options[optionName])
	                }
	                for (optionName in options) {
	                    setOption(that, optionName, options[optionName])
	                }
	            } finally {
	                that.endUpdate()
	            }
	        }
	    }()
	}).include(EventsMixin);
	module.exports = Component;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/action.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    config = __webpack_require__(9),
	    Class = __webpack_require__(18);
	var Action = Class.inherit({
	    ctor: function(action, config) {
	        config = config || {};
	        this._action = action;
	        this._context = config.context || window;
	        this._beforeExecute = config.beforeExecute;
	        this._afterExecute = config.afterExecute;
	        this._component = config.component;
	        this._validatingTargetName = config.validatingTargetName;
	        var excludeValidators = this._excludeValidators = {};
	        if (config.excludeValidators) {
	            for (var i = 0; i < config.excludeValidators.length; i++) {
	                excludeValidators[config.excludeValidators[i]] = true
	            }
	        }
	    },
	    execute: function() {
	        var e = {
	            action: this._action,
	            args: Array.prototype.slice.call(arguments),
	            context: this._context,
	            component: this._component,
	            validatingTargetName: this._validatingTargetName,
	            cancel: false,
	            handled: false
	        };
	        var beforeExecute = this._beforeExecute,
	            afterExecute = this._afterExecute;
	        if (!this._validateAction(e)) {
	            return
	        }
	        beforeExecute && beforeExecute.call(this._context, e);
	        if (e.cancel) {
	            return
	        }
	        var result = this._executeAction(e);
	        var argsBag = e.args[0];
	        if (argsBag && argsBag.cancel) {
	            return
	        }
	        afterExecute && afterExecute.call(this._context, e);
	        return result
	    },
	    _validateAction: function(e) {
	        var excludeValidators = this._excludeValidators,
	            executors = Action.executors;
	        for (var name in executors) {
	            if (!excludeValidators[name]) {
	                var executor = executors[name];
	                if (executor.validate) {
	                    executor.validate(e)
	                }
	                if (e.cancel) {
	                    return false
	                }
	            }
	        }
	        return true
	    },
	    _executeAction: function(e) {
	        var result, executors = Action.executors;
	        for (var name in executors) {
	            var executor = executors[name];
	            if (executor.execute) {
	                executor.execute(e)
	            }
	            if (e.handled) {
	                result = e.result;
	                break
	            }
	        }
	        return result
	    }
	});
	Action.executors = {};
	Action.registerExecutor = function(name, executor) {
	    if ($.isPlainObject(name)) {
	        $.each(name, Action.registerExecutor);
	        return
	    }
	    Action.executors[name] = executor
	};
	Action.unregisterExecutor = function() {
	    var args = $.makeArray(arguments);
	    $.each(args, function() {
	        delete Action.executors[this]
	    })
	};
	Action.registerExecutor({
	    undefined: {
	        execute: function(e) {
	            if (!e.action) {
	                e.result = void 0;
	                e.handled = true
	            }
	        }
	    },
	    func: {
	        execute: function(e) {
	            if ($.isFunction(e.action)) {
	                e.result = e.action.call(e.context, e.args[0]);
	                e.handled = true
	            }
	        }
	    }
	});
	var createValidatorByTargetElement = function(condition) {
	    return function(e) {
	        if (!e.args.length) {
	            return
	        }
	        var args = e.args[0],
	            element = args[e.validatingTargetName] || args.element;
	        if (element && condition(element)) {
	            e.cancel = true
	        }
	    }
	};
	Action.registerExecutor({
	    designMode: {
	        validate: function(e) {
	            if (config().designMode) {
	                e.cancel = true
	            }
	        }
	    },
	    disabled: {
	        validate: createValidatorByTargetElement(function($target) {
	            return $target.is(".dx-state-disabled, .dx-state-disabled *")
	        })
	    },
	    readOnly: {
	        validate: createValidatorByTargetElement(function($target) {
	            return $target.is(".dx-state-readonly, .dx-state-readonly *")
	        })
	    }
	});
	module.exports = Action;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/data.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    Class = __webpack_require__(18),
	    objectUtils = __webpack_require__(36),
	    variableWrapper = __webpack_require__(37),
	    unwrapVariable = variableWrapper.unwrap,
	    isWrapped = variableWrapper.isWrapped,
	    assign = variableWrapper.assign;
	var bracketsToDots = function(expr) {
	    return expr.replace(/\[/g, ".").replace(/\]/g, "")
	};
	var readPropValue = function(obj, propName) {
	    if ("this" === propName) {
	        return obj
	    }
	    return obj[propName]
	};
	var assignPropValue = function(obj, propName, value, options) {
	    if ("this" === propName) {
	        throw new errors.Error("E4016")
	    }
	    var propValue = obj[propName];
	    if (options.unwrapObservables && isWrapped(propValue)) {
	        assign(propValue, value)
	    } else {
	        obj[propName] = value
	    }
	};
	var prepareOptions = function(options) {
	    options = options || {};
	    options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;
	    return options
	};
	var unwrap = function(value, options) {
	    return options.unwrapObservables ? unwrapVariable(value) : value
	};
	var compileGetter = function(expr) {
	    if (arguments.length > 1) {
	        expr = $.makeArray(arguments)
	    }
	    if (!expr || "this" === expr) {
	        return function(obj) {
	            return obj
	        }
	    }
	    if ("string" === typeof expr) {
	        expr = bracketsToDots(expr);
	        var path = expr.split(".");
	        return function(obj, options) {
	            options = prepareOptions(options);
	            var functionAsIs = options.functionsAsIs,
	                current = unwrap(obj, options);
	            for (var i = 0; i < path.length; i++) {
	                if (!current) {
	                    break
	                }
	                var next = unwrap(current[path[i]], options);
	                if (!functionAsIs && $.isFunction(next)) {
	                    next = next.call(current)
	                }
	                current = next
	            }
	            return current
	        }
	    }
	    if ($.isArray(expr)) {
	        return combineGetters(expr)
	    }
	    if ($.isFunction(expr)) {
	        return expr
	    }
	};
	var combineGetters = function(getters) {
	    var compiledGetters = {};
	    for (var i = 0, l = getters.length; i < l; i++) {
	        var getter = getters[i];
	        compiledGetters[getter] = compileGetter(getter)
	    }
	    return function(obj, options) {
	        var result;
	        $.each(compiledGetters, function(name) {
	            var current, path, last, i, value = this(obj, options);
	            if (void 0 === value) {
	                return
	            }
	            current = result || (result = {});
	            path = name.split(".");
	            last = path.length - 1;
	            for (i = 0; i < last; i++) {
	                current = current[path[i]] = {}
	            }
	            current[path[i]] = value
	        });
	        return result
	    }
	};
	var compileSetter = function(expr) {
	    expr = expr || "this";
	    expr = bracketsToDots(expr);
	    var pos = expr.lastIndexOf("."),
	        targetGetter = compileGetter(expr.substr(0, pos)),
	        targetPropName = expr.substr(1 + pos);
	    return function(obj, value, options) {
	        options = prepareOptions(options);
	        var target = targetGetter(obj, {
	                functionsAsIs: options.functionsAsIs,
	                unwrapObservables: options.unwrapObservables
	            }),
	            prevTargetValue = readPropValue(target, targetPropName);
	        if (!options.functionsAsIs && $.isFunction(prevTargetValue) && !isWrapped(prevTargetValue)) {
	            target[targetPropName](value)
	        } else {
	            prevTargetValue = unwrap(prevTargetValue, options);
	            if (options.merge && $.isPlainObject(value) && (void 0 === prevTargetValue || $.isPlainObject(prevTargetValue)) && !(value instanceof $.Event)) {
	                if (!prevTargetValue) {
	                    assignPropValue(target, targetPropName, {}, options)
	                }
	                objectUtils.deepExtendArraySafe(unwrap(readPropValue(target, targetPropName), options), value)
	            } else {
	                assignPropValue(target, targetPropName, value, options)
	            }
	        }
	    }
	};
	var toComparable = function(value, caseSensitive) {
	    if (value instanceof Date) {
	        return value.getTime()
	    }
	    if (value && value instanceof Class && value.valueOf) {
	        return value.valueOf()
	    }
	    if (!caseSensitive && "string" === typeof value) {
	        return value.toLowerCase()
	    }
	    return value
	};
	exports.compileGetter = compileGetter;
	exports.compileSetter = compileSetter;
	exports.toComparable = toComparable;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/object.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    variableWrapper = __webpack_require__(37);
	var clone = function() {
	    function Clone() {}
	    return function(obj) {
	        Clone.prototype = obj;
	        return new Clone
	    }
	}();
	var extendFromObject = function(target, source, overrideExistingValues) {
	    target = target || {};
	    for (var prop in source) {
	        if (source.hasOwnProperty(prop)) {
	            var value = source[prop];
	            if (!(prop in target) || overrideExistingValues) {
	                target[prop] = value
	            }
	        }
	    }
	    return target
	};
	var orderEach = function(map, func) {
	    var key, i, keys = [];
	    for (key in map) {
	        if (map.hasOwnProperty(key)) {
	            keys.push(key)
	        }
	    }
	    keys.sort(function(x, y) {
	        var isNumberX = commonUtils.isNumber(x),
	            isNumberY = commonUtils.isNumber(y);
	        if (isNumberX && isNumberY) {
	            return x - y
	        }
	        if (isNumberX && !isNumberY) {
	            return -1
	        }
	        if (!isNumberX && isNumberY) {
	            return 1
	        }
	        if (x < y) {
	            return -1
	        }
	        if (x > y) {
	            return 1
	        }
	        return 0
	    });
	    for (i = 0; i < keys.length; i++) {
	        key = keys[i];
	        func(key, map[key])
	    }
	};
	var assignValueToProperty = function(target, property, value) {
	    if (variableWrapper.isWrapped(target[property])) {
	        variableWrapper.assign(target[property], value)
	    } else {
	        target[property] = value
	    }
	};
	var deepExtendArraySafe = function(target, changes) {
	    var prevValue, newValue;
	    for (var name in changes) {
	        prevValue = target[name];
	        newValue = changes[name];
	        if (target === newValue) {
	            continue
	        }
	        if ($.isPlainObject(newValue) && !(newValue instanceof $.Event)) {
	            assignValueToProperty(target, name, deepExtendArraySafe($.isPlainObject(prevValue) ? prevValue : {}, newValue))
	        } else {
	            if (void 0 !== newValue) {
	                assignValueToProperty(target, name, newValue)
	            }
	        }
	    }
	    return target
	};
	exports.clone = clone;
	exports.extendFromObject = extendFromObject;
	exports.orderEach = orderEach;
	exports.deepExtendArraySafe = deepExtendArraySafe;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/variable_wrapper.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var logger = __webpack_require__(6).logger,
	    dependencyInjector = __webpack_require__(21);
	module.exports = dependencyInjector({
	    isWrapped: function() {
	        return false
	    },
	    isWritableWrapped: function() {
	        return false
	    },
	    wrap: function(value) {
	        return value
	    },
	    unwrap: function(value) {
	        return value
	    },
	    assign: function() {
	        logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.")
	    }
	});


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/events_mixin.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    DefaultEventsStrategy = __webpack_require__(39);
	module.exports = {
	    ctor: function() {
	        this._events = {};
	        this.setEventsStrategy(new DefaultEventsStrategy(this))
	    },
	    setEventsStrategy: function(strategy) {
	        this._eventsStrategy = strategy
	    },
	    hasEvent: function(eventName) {
	        return this._eventsStrategy.hasEvent(eventName)
	    },
	    fireEvent: function(eventName, eventArgs) {
	        this._eventsStrategy.fireEvent(eventName, eventArgs);
	        return this
	    },
	    on: function(eventName, eventHandler) {
	        if ($.isPlainObject(eventName)) {
	            $.each(eventName, $.proxy(function(e, h) {
	                this.on(e, h)
	            }, this))
	        } else {
	            this._eventsStrategy.on(eventName, eventHandler)
	        }
	        return this
	    },
	    off: function(eventName, eventHandler) {
	        this._eventsStrategy.off(eventName, eventHandler);
	        return this
	    },
	    _disposeEvents: function() {
	        this._eventsStrategy.dispose()
	    }
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/events_strategy.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18);
	module.exports = Class.inherit({
	    ctor: function(owner) {
	        this._events = {};
	        this._owner = owner
	    },
	    hasEvent: function(eventName) {
	        var callbacks = this._events[eventName];
	        if (callbacks) {
	            return callbacks.has()
	        }
	        return false
	    },
	    fireEvent: function(eventName, eventArgs) {
	        var callbacks = this._events[eventName];
	        if (callbacks) {
	            callbacks.fireWith(this._owner, eventArgs)
	        }
	    },
	    on: function(eventName, eventHandler) {
	        var addFn, callbacks = this._events[eventName];
	        if (!callbacks) {
	            callbacks = $.Callbacks();
	            this._events[eventName] = callbacks
	        }
	        addFn = callbacks.originalAdd || callbacks.add;
	        addFn.call(callbacks, eventHandler)
	    },
	    off: function(eventName, eventHandler) {
	        var callbacks = this._events[eventName];
	        if (callbacks) {
	            if ($.isFunction(eventHandler)) {
	                callbacks.remove(eventHandler)
	            } else {
	                callbacks.empty()
	            }
	        }
	    },
	    dispose: function() {
	        $.each(this._events, function() {
	            this.empty()
	        })
	    }
	});


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/devices.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    errors = __webpack_require__(3),
	    resizeCallbacks = __webpack_require__(29).resizeCallbacks,
	    EventsMixin = __webpack_require__(38),
	    SessionStorage = __webpack_require__(41).sessionStorage,
	    viewPort = __webpack_require__(42),
	    Config = __webpack_require__(9);
	var KNOWN_UA_TABLE = {
	    iPhone: "iPhone",
	    iPhone5: "iPhone",
	    iPhone6: "iPhone",
	    iPhone6plus: "iPhone",
	    iPad: "iPad",
	    iPadMini: "iPad Mini",
	    androidPhone: "Android Mobile",
	    androidTablet: "Android",
	    win8: "MSAppHost",
	    win8Phone: "Windows Phone 8.0",
	    msSurface: "MSIE ARM Tablet PC",
	    desktop: "desktop",
	    win10Phone: "Windows Phone 10.0",
	    win10: "MSAppHost/3.0"
	};
	var DEFAULT_DEVICE = {
	    deviceType: "desktop",
	    platform: "generic",
	    version: [],
	    phone: false,
	    tablet: false,
	    android: false,
	    ios: false,
	    win: false,
	    generic: true,
	    grade: "A",
	    mac: false
	};
	var uaParsers = {
	    win: function(userAgent) {
	        var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/),
	            isTablet = !isPhone && /arm(.*)trident/i.test(userAgent),
	            isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
	        if (!(isPhone || isTablet || isDesktop)) {
	            return
	        }
	        var matches = userAgent.match(/windows phone (\d+).(\d+)/i) || userAgent.match(/windows nt (\d+).(\d+)/i),
	            version = [];
	        if (matches) {
	            version.push(parseInt(matches[1], 10), parseInt(matches[2], 10))
	        } else {
	            matches = userAgent.match(/msapphost(\/(\d+).(\d+))?/i);
	            matches && version.push(3 === parseInt(matches[2], 10) ? 10 : 8)
	        }
	        return {
	            deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
	            platform: "win",
	            version: version,
	            grade: "A"
	        }
	    },
	    ios: function(userAgent) {
	        if (!/ip(hone|od|ad)/i.test(userAgent)) {
	            return
	        }
	        var isPhone = /ip(hone|od)/i.test(userAgent),
	            matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i),
	            version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
	            isIPhone4 = 480 === window.screen.height,
	            grade = isIPhone4 ? "B" : "A";
	        return {
	            deviceType: isPhone ? "phone" : "tablet",
	            platform: "ios",
	            version: version,
	            grade: grade
	        }
	    },
	    android: function(userAgent) {
	        if (!/android|htc_|silk/i.test(userAgent)) {
	            return
	        }
	        var isPhone = /mobile/i.test(userAgent),
	            matches = userAgent.match(/android (\d+)\.(\d+)\.?(\d+)?/i),
	            version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
	            worseThan4_4 = version.length > 1 && (version[0] < 4 || 4 === version[0] && version[1] < 4),
	            grade = worseThan4_4 ? "B" : "A";
	        return {
	            deviceType: isPhone ? "phone" : "tablet",
	            platform: "android",
	            version: version,
	            grade: grade
	        }
	    }
	};
	var Devices = Class.inherit({
	    ctor: function(options) {
	        this._window = options && options.window || window;
	        this._realDevice = this._getDevice();
	        this._currentDevice = void 0;
	        this._currentOrientation = void 0;
	        this.changed = $.Callbacks();
	        this._recalculateOrientation();
	        resizeCallbacks.add($.proxy(this._recalculateOrientation, this))
	    },
	    current: function(deviceOrName) {
	        if (deviceOrName) {
	            this._currentDevice = this._getDevice(deviceOrName);
	            this._forced = true;
	            this.changed.fire();
	            if ("win" === this._currentDevice.platform && 8 === this._currentDevice.version[0]) {
	                errors.log("W0010", "the 'win8' theme", "16.1", "Use the 'win10' theme instead.")
	            }
	            return
	        }
	        if (!this._currentDevice) {
	            deviceOrName = void 0;
	            try {
	                deviceOrName = this._getDeviceOrNameFromWindowScope()
	            } catch (e) {
	                deviceOrName = this._getDeviceNameFromSessionStorage()
	            } finally {
	                if (!deviceOrName) {
	                    deviceOrName = this._getDeviceNameFromSessionStorage()
	                }
	                if (deviceOrName) {
	                    this._forced = true
	                }
	            }
	            this._currentDevice = this._getDevice(deviceOrName)
	        }
	        return this._currentDevice
	    },
	    real: function() {
	        return $.extend({}, this._realDevice)
	    },
	    orientation: function() {
	        return this._currentOrientation
	    },
	    isForced: function() {
	        return this._forced
	    },
	    isRippleEmulator: function() {
	        return !!this._window.tinyHippos
	    },
	    _getCssClasses: function(device) {
	        var result = [];
	        var realDevice = this._realDevice;
	        device = device || this.current();
	        if (device.deviceType) {
	            result.push("dx-device-" + device.deviceType);
	            if ("desktop" !== device.deviceType) {
	                result.push("dx-device-mobile")
	            }
	        }
	        result.push("dx-device-" + realDevice.platform);
	        if (realDevice.version && realDevice.version.length) {
	            result.push("dx-device-" + realDevice.platform + "-" + realDevice.version[0])
	        }
	        if (devices.isSimulator()) {
	            result.push("dx-simulator")
	        }
	        if (Config().rtlEnabled) {
	            result.push("dx-rtl")
	        }
	        return result
	    },
	    attachCssClasses: function(element, device) {
	        this._deviceClasses = this._getCssClasses(device).join(" ");
	        $(element).addClass(this._deviceClasses)
	    },
	    detachCssClasses: function(element) {
	        $(element).removeClass(this._deviceClasses)
	    },
	    isSimulator: function() {
	        try {
	            return this._isSimulator || this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator()
	        } catch (e) {
	            return false
	        }
	    },
	    forceSimulator: function() {
	        this._isSimulator = true
	    },
	    _getDevice: function(deviceName) {
	        if ("genericPhone" === deviceName) {
	            deviceName = {
	                deviceType: "phone",
	                platform: "generic",
	                generic: true
	            }
	        }
	        if ($.isPlainObject(deviceName)) {
	            return this._fromConfig(deviceName)
	        } else {
	            var ua;
	            if (deviceName) {
	                ua = KNOWN_UA_TABLE[deviceName];
	                if (!ua) {
	                    throw errors.Error("E0005")
	                }
	            } else {
	                ua = navigator.userAgent
	            }
	            return this._fromUA(ua)
	        }
	    },
	    _getDeviceOrNameFromWindowScope: function() {
	        var result;
	        if (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"]) {
	            result = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"]
	        }
	        return result
	    },
	    _getDeviceNameFromSessionStorage: function() {
	        var sessionStorage = SessionStorage();
	        if (!sessionStorage) {
	            return
	        }
	        var deviceOrName = sessionStorage.getItem("dx-force-device");
	        try {
	            return $.parseJSON(deviceOrName)
	        } catch (ex) {
	            return deviceOrName
	        }
	    },
	    _fromConfig: function(config) {
	        var result = $.extend({}, DEFAULT_DEVICE, this._currentDevice, config),
	            shortcuts = {
	                phone: "phone" === result.deviceType,
	                tablet: "tablet" === result.deviceType,
	                android: "android" === result.platform,
	                ios: "ios" === result.platform,
	                win: "win" === result.platform,
	                generic: "generic" === result.platform
	            };
	        return $.extend(result, shortcuts)
	    },
	    _fromUA: function(ua) {
	        var config;
	        $.each(uaParsers, function(platform, parser) {
	            config = parser(ua);
	            return !config
	        });
	        if (config) {
	            return this._fromConfig(config)
	        }
	        var isMac = /(mac os)/.test(ua.toLowerCase()),
	            deviceWithOS = DEFAULT_DEVICE;
	        deviceWithOS.mac = isMac;
	        return deviceWithOS
	    },
	    _changeOrientation: function() {
	        var $window = $(this._window),
	            orientation = $window.height() > $window.width() ? "portrait" : "landscape";
	        if (this._currentOrientation === orientation) {
	            return
	        }
	        this._currentOrientation = orientation;
	        this.fireEvent("orientationChanged", [{
	            orientation: orientation
	        }])
	    },
	    _recalculateOrientation: function() {
	        var windowWidth = $(this._window).width();
	        if (this._currentWidth === windowWidth) {
	            return
	        }
	        this._currentWidth = windowWidth;
	        this._changeOrientation()
	    }
	}).include(EventsMixin);
	var devices = new Devices;
	viewPort.changeCallback.add(function(viewPort, prevViewport) {
	    devices.detachCssClasses(prevViewport);
	    devices.attachCssClasses(viewPort)
	});
	if (!devices.isForced() && "win" === devices.current().platform) {
	    devices.current({
	        version: [10]
	    })
	}
	module.exports = devices;
	module.exports.default = module.exports;


/***/ },
/* 41 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (core/utils/storage.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var getSessionStorage = function() {
	    var sessionStorage;
	    try {
	        sessionStorage = window.sessionStorage
	    } catch (e) {}
	    return sessionStorage
	};
	exports.sessionStorage = getSessionStorage;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/view_port.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ready = __webpack_require__(43).ready,
	    changeCallback = $.Callbacks(),
	    $originalViewPort = $();
	var value = function() {
	    var $current;
	    return function(element) {
	        if (!arguments.length) {
	            return $current
	        }
	        var $element = $(element);
	        $originalViewPort = $element;
	        var isNewViewportFound = !!$element.length;
	        var prevViewPort = value();
	        $current = isNewViewportFound ? $element : $("body");
	        changeCallback.fire(isNewViewportFound ? value() : $(), prevViewPort)
	    }
	}();
	ready(function() {
	    value(".dx-viewport")
	});
	exports.value = value;
	exports.changeCallback = changeCallback;
	exports.originalViewPort = function() {
	    return $originalViewPort
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/dom.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    commonUtils = __webpack_require__(8);
	var resetActiveElement = function() {
	    var activeElement = document.activeElement;
	    if (activeElement && activeElement !== document.body && activeElement.blur) {
	        activeElement.blur()
	    }
	};
	var getSelection = function() {
	    if (window.getSelection) {
	        return window.getSelection()
	    }
	    if (document.selection) {
	        return document.selection
	    }
	    return null
	};
	var clearSelection = function() {
	    var selection = getSelection();
	    if (!selection) {
	        return
	    }
	    if ("Caret" === selection.type) {
	        return
	    }
	    if (selection.empty) {
	        selection.empty()
	    } else {
	        if (selection.removeAllRanges) {
	            selection.removeAllRanges()
	        }
	    }
	};
	var closestCommonParent = function(startTarget, endTarget) {
	    var $startParents = $(startTarget).parents().addBack(),
	        $endParents = $(endTarget).parents().addBack(),
	        startingParent = Math.min($startParents.length, $endParents.length) - 1;
	    for (var i = startingParent; i >= 0; i--) {
	        if ($startParents.eq(i).is($endParents.eq(i))) {
	            return $startParents.get(i)
	        }
	    }
	};
	var triggerVisibilityChangeEvent = function(eventName) {
	    var VISIBILITY_CHANGE_SELECTOR = ".dx-visibility-change-handler";
	    return function(element) {
	        var $element = $(element || "body");
	        var $changeHandlers = $element.find(VISIBILITY_CHANGE_SELECTOR).add($element.filter(VISIBILITY_CHANGE_SELECTOR));
	        $changeHandlers.each(function() {
	            $(this).triggerHandler(eventName)
	        })
	    }
	};
	var uniqueId = function() {
	    var counter = 0;
	    return function(prefix) {
	        return (prefix || "") + counter++
	    }
	}();
	var dataOptionsAttributeName = "data-options";
	var getElementOptions = function(element) {
	    var result, optionsString = $(element).attr(dataOptionsAttributeName);
	    if ("{" !== $.trim(optionsString).charAt(0)) {
	        optionsString = "{" + optionsString + "}"
	    }
	    try {
	        result = new Function("return " + optionsString)()
	    } catch (ex) {
	        throw errors.Error("E3018", ex, optionsString)
	    }
	    return result
	};
	var createComponents = function(elements, componentTypes) {
	    var result = [],
	        selector = "[" + dataOptionsAttributeName + "]";
	    elements.find(selector).addBack(selector).each(function(index, element) {
	        var $element = $(element),
	            options = getElementOptions(element);
	        for (var componentName in options) {
	            if (!componentTypes || $.inArray(componentName, componentTypes) > -1) {
	                if ($element[componentName]) {
	                    $element[componentName](options[componentName]);
	                    result.push($element[componentName]("instance"))
	                }
	            }
	        }
	    });
	    return result
	};
	var createMarkupFromString = function(str) {
	    if (!window.WinJS) {
	        return $(str)
	    }
	    var tempElement = $("<div />");
	    window.WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
	    return tempElement.contents()
	};
	var normalizeTemplateElement = function(element) {
	    var $element = commonUtils.isDefined(element) && (element.nodeType || element.jquery) ? $(element) : $("<div>").html(element).contents();
	    if (1 === $element.length) {
	        if ($element.is("script")) {
	            $element = normalizeTemplateElement($element.html())
	        } else {
	            if ($element.is("table")) {
	                $element = $element.contents()
	            }
	        }
	    }
	    return $element
	};
	var toggleAttr = function($target, attr, value) {
	    value ? $target.attr(attr, value) : $target.removeAttr(attr)
	};
	var clipboardText = function(event, text) {
	    var clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;
	    if (1 === arguments.length) {
	        return clipboard && clipboard.getData("Text")
	    }
	    clipboard && clipboard.setData("Text", text)
	};
	exports.ready = function(callback) {
	    if ("complete" === document.readyState) {
	        callback();
	        return
	    }
	    var loadedCallback = function() {
	        callback();
	        document.removeEventListener("DOMContentLoaded", loadedCallback)
	    };
	    document.addEventListener("DOMContentLoaded", loadedCallback)
	};
	exports.resetActiveElement = resetActiveElement;
	exports.createMarkupFromString = createMarkupFromString;
	exports.triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
	exports.triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
	exports.triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
	exports.getElementOptions = getElementOptions;
	exports.createComponents = createComponents;
	exports.normalizeTemplateElement = normalizeTemplateElement;
	exports.clearSelection = clearSelection;
	exports.getSelection = getSelection;
	exports.uniqueId = uniqueId;
	exports.closestCommonParent = closestCommonParent;
	exports.clipboardText = clipboardText;
	exports.toggleAttr = toggleAttr;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/component_registrator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    MemorizedCallbacks = __webpack_require__(45),
	    publicComponentUtils = __webpack_require__(30);
	var callbacks = new MemorizedCallbacks;
	var registerComponent = function(name, namespace, componentClass) {
	    if (!componentClass) {
	        componentClass = namespace
	    } else {
	        namespace[name] = componentClass
	    }
	    publicComponentUtils.name(componentClass, name);
	    callbacks.fire(name, componentClass)
	};
	registerComponent.callbacks = callbacks;
	var registerJQueryComponent = function(name, componentClass) {
	    $.fn[name] = function(options) {
	        var result, isMemberInvoke = "string" === typeof options;
	        if (isMemberInvoke) {
	            var memberName = options,
	                memberArgs = $.makeArray(arguments).slice(1);
	            this.each(function() {
	                var instance = componentClass.getInstance(this);
	                if (!instance) {
	                    throw errors.Error("E0009", name)
	                }
	                var member = instance[memberName],
	                    memberValue = member.apply(instance, memberArgs);
	                if (void 0 === result) {
	                    result = memberValue
	                }
	            })
	        } else {
	            this.each(function() {
	                var instance = componentClass.getInstance(this);
	                if (instance) {
	                    instance.option(options)
	                } else {
	                    new componentClass(this, options)
	                }
	            });
	            result = this
	        }
	        return result
	    }
	};
	callbacks.add(registerJQueryComponent);
	module.exports = registerComponent;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/memorized_callbacks.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var MemorizedCallbacks = function() {
	    var memory = [];
	    var callbacks = $.Callbacks();
	    this.add = function(fn) {
	        $.each(memory, function(_, item) {
	            fn.apply(fn, item)
	        });
	        callbacks.add(fn)
	    };
	    this.remove = function(fn) {
	        callbacks.remove(fn)
	    };
	    this.fire = function() {
	        memory.push(arguments);
	        callbacks.fire.apply(callbacks, arguments)
	    }
	};
	module.exports = MemorizedCallbacks;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (animation/frame.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    FRAME_ANIMATION_STEP_TIME = 1e3 / 60,
	    request = function(callback) {
	        return this.setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
	    },
	    cancel = function(requestID) {
	        this.clearTimeout(requestID)
	    },
	    nativeRequest = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame,
	    nativeCancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
	if (nativeRequest && nativeCancel) {
	    request = nativeRequest;
	    cancel = nativeCancel
	}
	if (nativeRequest && !nativeCancel) {
	    var canceledRequests = {};
	    request = function(callback) {
	        var requestId = nativeRequest.call(window, function() {
	            try {
	                if (requestId in canceledRequests) {
	                    return
	                }
	                callback.apply(this, arguments)
	            } finally {
	                delete canceledRequests[requestId]
	            }
	        });
	        return requestId
	    };
	    cancel = function(requestId) {
	        canceledRequests[requestId] = true
	    }
	}
	exports.requestAnimationFrame = $.proxy(request, window);
	exports.cancelAnimationFrame = $.proxy(cancel, window);


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (mobile/init_mobile_viewport/init_mobile_viewport.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    resizeCallbacks = __webpack_require__(29).resizeCallbacks,
	    support = __webpack_require__(48),
	    devices = __webpack_require__(40);
	var initMobileViewport = function(options) {
	    options = $.extend({}, options);
	    var realDevice = devices.real();
	    var allowZoom = options.allowZoom;
	    var allowPan = options.allowPan;
	    var allowSelection = "allowSelection" in options ? options.allowSelection : "generic" === realDevice.platform;
	    var metaSelector = "meta[name=viewport]";
	    if (!$(metaSelector).length) {
	        $("<meta />").attr("name", "viewport").appendTo("head")
	    }
	    var metaVerbs = ["width=device-width"],
	        msTouchVerbs = [];
	    if (allowZoom) {
	        msTouchVerbs.push("pinch-zoom")
	    } else {
	        metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0, user-scalable=no")
	    }
	    if (allowPan) {
	        msTouchVerbs.push("pan-x", "pan-y")
	    }
	    if (!allowPan && !allowZoom) {
	        $("html, body").css({
	            "-ms-content-zooming": "none",
	            "-ms-user-select": "none",
	            overflow: "hidden"
	        })
	    } else {
	        $("html").css("-ms-overflow-style", "-ms-autohiding-scrollbar")
	    }
	    if (!allowSelection && support.supportProp("user-select")) {
	        $(".dx-viewport").css(support.styleProp("user-select"), "none")
	    }
	    $(metaSelector).attr("content", metaVerbs.join());
	    $("html").css("-ms-touch-action", msTouchVerbs.join(" ") || "none");
	    realDevice = devices.real();
	    if (support.touch && !("win" === realDevice.platform && 10 === realDevice.version[0])) {
	        $(document).off(".dxInitMobileViewport").on("dxpointermove.dxInitMobileViewport", function(e) {
	            var count = e.pointers.length,
	                isTouchEvent = "touch" === e.pointerType,
	                zoomDisabled = !allowZoom && count > 1,
	                panDisabled = !allowPan && 1 === count && !e.isScrollingEvent;
	            if (isTouchEvent && (zoomDisabled || panDisabled)) {
	                e.preventDefault()
	            }
	        })
	    }
	    if (realDevice.ios) {
	        var isPhoneGap = "file:" === document.location.protocol;
	        if (!isPhoneGap) {
	            resizeCallbacks.add(function() {
	                var windowWidth = $(window).width();
	                $("body").width(windowWidth)
	            })
	        }
	    }
	    if (realDevice.android) {
	        resizeCallbacks.add(function() {
	            setTimeout(function() {
	                document.activeElement.scrollIntoViewIfNeeded()
	            })
	        })
	    }
	};
	exports.initMobileViewport = initMobileViewport;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/support.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    inflector = __webpack_require__(49),
	    devices = __webpack_require__(40);
	var camelize = inflector.camelize;
	var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"],
	    cssPrefixes = {
	        "": "",
	        Webkit: "-webkit-",
	        Moz: "-moz-",
	        O: "-o-",
	        ms: "-ms-"
	    },
	    styles = document.createElement("dx").style;
	var transitionEndEventNames = {
	    webkitTransition: "webkitTransitionEnd",
	    MozTransition: "transitionend",
	    OTransition: "oTransitionEnd",
	    msTransition: "MsTransitionEnd",
	    transition: "transitionend"
	};
	var forEachPrefixes = function(prop, callBack) {
	    prop = camelize(prop, true);
	    var result;
	    for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
	        var jsPrefix = jsPrefixes[i];
	        var prefixedProp = jsPrefix + prop;
	        var lowerPrefixedProp = camelize(prefixedProp);
	        result = callBack(lowerPrefixedProp, jsPrefix);
	        if (void 0 === result) {
	            result = callBack(prefixedProp, jsPrefix)
	        }
	        if (void 0 !== result) {
	            break
	        }
	    }
	    return result
	};
	var styleProp = function(prop) {
	    return forEachPrefixes(prop, function(specific) {
	        if (specific in styles) {
	            return specific
	        }
	    })
	};
	var stylePropPrefix = function(prop) {
	    return forEachPrefixes(prop, function(specific, jsPrefix) {
	        if (specific in styles) {
	            return cssPrefixes[jsPrefix]
	        }
	    })
	};
	var supportProp = function(prop) {
	    return !!styleProp(prop)
	};
	var isNativeScrollingSupported = function() {
	    var realDevice = devices.real(),
	        realPlatform = realDevice.platform,
	        realVersion = realDevice.version,
	        isObsoleteAndroid = realVersion && realVersion[0] < 4 && "android" === realPlatform,
	        isNativeScrollDevice = !isObsoleteAndroid && $.inArray(realPlatform, ["ios", "android", "win"]) > -1 || realDevice.mac;
	    return isNativeScrollDevice
	};
	var inputType = function(type) {
	    if ("text" === type) {
	        return true
	    }
	    var input = document.createElement("input");
	    try {
	        input.setAttribute("type", type);
	        input.value = "wrongValue";
	        return !input.value
	    } catch (e) {
	        return false
	    }
	};
	var touchEvents = "ontouchstart" in window && !("callPhantom" in window),
	    pointerEvents = !!window.navigator.pointerEnabled || !!window.navigator.msPointerEnabled,
	    touchPointersPresent = !!window.navigator.maxTouchPoints || !!window.navigator.msMaxTouchPoints;
	exports.touchEvents = touchEvents;
	exports.pointerEvents = pointerEvents;
	exports.touch = touchEvents || pointerEvents && touchPointersPresent;
	exports.transform = supportProp("transform");
	exports.transition = supportProp("transition");
	exports.transitionEndEventName = transitionEndEventNames[styleProp("transition")];
	exports.animation = supportProp("animation");
	exports.nativeScrolling = isNativeScrollingSupported();
	exports.styleProp = styleProp;
	exports.stylePropPrefix = stylePropPrefix;
	exports.supportProp = supportProp;
	exports.hasKo = !!window.ko;
	exports.inputType = inputType;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/inflector.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var _normalize = function(text) {
	    if (void 0 === text || null === text) {
	        return ""
	    }
	    return String(text)
	};
	var _upperCaseFirst = function(text) {
	    return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
	};
	var _chop = function(text) {
	    return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
	};
	var dasherize = function(text) {
	    return $.map(_chop(text), function(p) {
	        return p.toLowerCase()
	    }).join("-")
	};
	var underscore = function(text) {
	    return dasherize(text).replace(/-/g, "_")
	};
	var camelize = function(text, upperFirst) {
	    return $.map(_chop(text), function(p, i) {
	        p = p.toLowerCase();
	        if (upperFirst || i > 0) {
	            p = _upperCaseFirst(p)
	        }
	        return p
	    }).join("")
	};
	var humanize = function(text) {
	    return _upperCaseFirst(dasherize(text).replace(/-/g, " "))
	};
	var titleize = function(text) {
	    return $.map(_chop(text), function(p) {
	        return _upperCaseFirst(p.toLowerCase())
	    }).join(" ")
	};
	var captionize = function(name) {
	    var i, char, captionList = [],
	        isPrevCharNewWord = false,
	        isNewWord = false;
	    for (i = 0; i < name.length; i++) {
	        char = name.charAt(i);
	        isNewWord = char === char.toUpperCase() || char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
	        if ("_" === char || "." === char) {
	            char = " ";
	            isNewWord = true
	        } else {
	            if (0 === i) {
	                char = char.toUpperCase();
	                isNewWord = true
	            } else {
	                if (!isPrevCharNewWord && isNewWord) {
	                    if (captionList.length > 0) {
	                        captionList.push(" ")
	                    }
	                }
	            }
	        }
	        captionList.push(char);
	        isPrevCharNewWord = isNewWord
	    }
	    return captionList.join("")
	};
	exports.dasherize = dasherize;
	exports.camelize = camelize;
	exports.humanize = humanize;
	exports.titleize = titleize;
	exports.underscore = underscore;
	exports.captionize = captionize;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/queue.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var errors = __webpack_require__(3),
	    when = __webpack_require__(10).when;

	function createQueue(discardPendingTasks) {
	    var _tasks = [],
	        _busy = false;

	    function exec() {
	        while (_tasks.length) {
	            _busy = true;
	            var task = _tasks.shift(),
	                result = task();
	            if (void 0 === result) {
	                continue
	            }
	            if (result.then) {
	                when(result).always(exec);
	                return
	            }
	            throw errors.Error("E0015")
	        }
	        _busy = false
	    }

	    function add(task, removeTaskCallback) {
	        if (!discardPendingTasks) {
	            _tasks.push(task)
	        } else {
	            if (_tasks[0] && removeTaskCallback) {
	                removeTaskCallback(_tasks[0])
	            }
	            _tasks = [task]
	        }
	        if (!_busy) {
	            exec()
	        }
	    }

	    function busy() {
	        return _busy
	    }
	    return {
	        add: add,
	        busy: busy
	    }
	}
	exports.create = createQueue;
	exports.enqueue = createQueue().add;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/date.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    inflector = __webpack_require__(49),
	    isObject = commonUtils.isObject,
	    isString = commonUtils.isString,
	    isDate = commonUtils.isDate,
	    isDefined = commonUtils.isDefined,
	    camelize = inflector.camelize;
	var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
	var toMilliseconds = function(value) {
	    switch (value) {
	        case "millisecond":
	            return 1;
	        case "second":
	            return 1e3 * toMilliseconds("millisecond");
	        case "minute":
	            return 60 * toMilliseconds("second");
	        case "hour":
	            return 60 * toMilliseconds("minute");
	        case "day":
	            return 24 * toMilliseconds("hour");
	        case "week":
	            return 7 * toMilliseconds("day");
	        case "month":
	            return 30 * toMilliseconds("day");
	        case "quarter":
	            return 3 * toMilliseconds("month");
	        case "year":
	            return 365 * toMilliseconds("day");
	        default:
	            return 0
	    }
	};
	var getDatesInterval = function(startDate, endDate, intervalUnit) {
	    var delta = endDate.getTime() - startDate.getTime(),
	        millisecondCount = toMilliseconds(intervalUnit) || 1;
	    return Math.floor(delta / millisecondCount)
	};
	var getNextDateUnit = function(unit, withWeeks) {
	    var interval = getDateUnitInterval(unit);
	    switch (interval) {
	        case "millisecond":
	            return "second";
	        case "second":
	            return "minute";
	        case "minute":
	            return "hour";
	        case "hour":
	            return "day";
	        case "day":
	            return withWeeks ? "week" : "month";
	        case "week":
	            return "month";
	        case "month":
	            return "quarter";
	        case "quarter":
	            return "year";
	        case "year":
	            return "year";
	        default:
	            return 0
	    }
	};
	var convertMillisecondsToDateUnits = function(value) {
	    var i, dateUnitCount, dateUnitInterval, dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "month", "year"],
	        result = {};
	    for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
	        dateUnitInterval = dateUnitIntervals[i];
	        dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
	        if (dateUnitCount > 0) {
	            result[dateUnitInterval + "s"] = dateUnitCount;
	            value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
	        }
	    }
	    return result
	};
	var dateToMilliseconds = function(tickInterval) {
	    var milliseconds = 0;
	    if (isObject(tickInterval)) {
	        $.each(tickInterval, function(key, value) {
	            milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
	        })
	    }
	    if (isString(tickInterval)) {
	        milliseconds = convertDateUnitToMilliseconds(tickInterval, 1)
	    }
	    return milliseconds
	};
	var convertDateUnitToMilliseconds = function(dateUnit, count) {
	    return toMilliseconds(dateUnit) * count
	};
	var getDateUnitInterval = function(tickInterval) {
	    var i, maxInterval = -1;
	    if (isString(tickInterval)) {
	        return tickInterval
	    }
	    if (isObject(tickInterval)) {
	        $.each(tickInterval, function(key, value) {
	            for (i = 0; i < dateUnitIntervals.length; i++) {
	                if (value && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
	                    maxInterval = i
	                }
	            }
	        });
	        return dateUnitIntervals[maxInterval]
	    }
	    return ""
	};
	var tickIntervalToFormatMap = {
	    millisecond: "millisecond",
	    second: "longtime",
	    minute: "shorttime",
	    hour: "shorttime",
	    day: "day",
	    week: "day",
	    month: "month",
	    quarter: "quarter",
	    year: "year"
	};

	function getDateFormatByTickInterval(tickInterval) {
	    return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || ""
	}
	var getQuarter = function(month) {
	    return Math.floor(month / 3)
	};
	var getFirstQuarterMonth = function(month) {
	    return 3 * getQuarter(month)
	};
	var correctDateWithUnitBeginning = function(date, dateInterval, withCorrection) {
	    date = new Date(date.getTime());
	    var firstQuarterMonth, oldDate = new Date(date.getTime()),
	        dateUnitInterval = getDateUnitInterval(dateInterval);
	    switch (dateUnitInterval) {
	        case "second":
	            date.setMilliseconds(0);
	            break;
	        case "minute":
	            date.setSeconds(0, 0);
	            break;
	        case "hour":
	            date.setMinutes(0, 0, 0);
	            break;
	        case "year":
	            date.setMonth(0);
	        case "month":
	            date.setDate(1);
	        case "day":
	            date.setHours(0, 0, 0, 0);
	            break;
	        case "week":
	            date.setDate(date.getDate() - date.getDay());
	            date.setHours(0, 0, 0, 0);
	            break;
	        case "quarter":
	            firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
	            if (date.getMonth() !== firstQuarterMonth) {
	                date.setMonth(firstQuarterMonth)
	            }
	            date.setDate(1);
	            date.setHours(0, 0, 0, 0)
	    }
	    if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
	        fixTimezoneGap(oldDate, date)
	    }
	    return date
	};
	var trimTime = function(date) {
	    return dateUtils.correctDateWithUnitBeginning(date, "day")
	};
	var getDatesDifferences = function(date1, date2) {
	    var differences, counter = 0;
	    differences = {
	        year: date1.getFullYear() !== date2.getFullYear(),
	        month: date1.getMonth() !== date2.getMonth(),
	        day: date1.getDate() !== date2.getDate(),
	        hour: date1.getHours() !== date2.getHours(),
	        minute: date1.getMinutes() !== date2.getMinutes(),
	        second: date1.getSeconds() !== date2.getSeconds()
	    };
	    $.each(differences, function(key, value) {
	        if (value) {
	            counter++
	        }
	    });
	    differences.count = counter;
	    return differences
	};

	function addDateInterval(value, interval, dir) {
	    var result = new Date(value.getTime()),
	        intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : interval;
	    if (intervalObject.years) {
	        result.setFullYear(result.getFullYear() + intervalObject.years * dir)
	    }
	    if (intervalObject.quarters) {
	        result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir)
	    }
	    if (intervalObject.months) {
	        result.setMonth(result.getMonth() + intervalObject.months * dir)
	    }
	    if (intervalObject.weeks) {
	        result.setDate(result.getDate() + 7 * intervalObject.weeks * dir)
	    }
	    if (intervalObject.days) {
	        result.setDate(result.getDate() + intervalObject.days * dir)
	    }
	    if (intervalObject.hours) {
	        result.setHours(result.getHours() + intervalObject.hours * dir)
	    }
	    if (intervalObject.minutes) {
	        result.setMinutes(result.getMinutes() + intervalObject.minutes * dir)
	    }
	    if (intervalObject.seconds) {
	        result.setSeconds(result.getSeconds() + intervalObject.seconds * dir)
	    }
	    if (intervalObject.milliseconds) {
	        result.setMilliseconds(value.getMilliseconds() + intervalObject.milliseconds * dir)
	    }
	    return result
	}
	var addInterval = function(value, interval, isNegative) {
	    var dir = isNegative ? -1 : 1;
	    return isDate(value) ? addDateInterval(value, interval, dir) : value + interval * dir
	};
	var getSequenceByInterval = function(min, max, interval) {
	    var cur, intervals = [];
	    intervals.push(isDate(min) ? new Date(min.getTime()) : min);
	    cur = min;
	    while (cur < max) {
	        cur = addInterval(cur, interval);
	        intervals.push(cur)
	    }
	    return intervals
	};
	var getViewFirstCellDate = function(viewType, date) {
	    if ("month" === viewType) {
	        return new Date(date.getFullYear(), date.getMonth(), 1)
	    }
	    if ("year" === viewType) {
	        return new Date(date.getFullYear(), 0, date.getDate())
	    }
	    if ("decade" === viewType) {
	        return new Date(getFirstYearInDecade(date), date.getMonth(), date.getDate())
	    }
	    if ("century" === viewType) {
	        return new Date(getFirstDecadeInCentury(date), date.getMonth(), date.getDate())
	    }
	};
	var getViewLastCellDate = function(viewType, date) {
	    if ("month" === viewType) {
	        return new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date))
	    }
	    if ("year" === viewType) {
	        return new Date(date.getFullYear(), 11, date.getDate())
	    }
	    if ("decade" === viewType) {
	        return new Date(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate())
	    }
	    if ("century" === viewType) {
	        return new Date(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate())
	    }
	};
	var getViewMinBoundaryDate = function(viewType, date) {
	    var resultDate = new Date(date.getFullYear(), date.getMonth(), 1);
	    if ("month" === viewType) {
	        return resultDate
	    }
	    resultDate.setMonth(0);
	    if ("year" === viewType) {
	        return resultDate
	    }
	    if ("decade" === viewType) {
	        resultDate.setFullYear(getFirstYearInDecade(date))
	    }
	    if ("century" === viewType) {
	        resultDate.setFullYear(getFirstDecadeInCentury(date))
	    }
	    return resultDate
	};
	var getViewMaxBoundaryDate = function(viewType, date) {
	    var resultDate = new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
	    if ("month" === viewType) {
	        return resultDate
	    }
	    resultDate.setMonth(11);
	    resultDate.setDate(getLastMonthDay(resultDate));
	    if ("year" === viewType) {
	        return resultDate
	    }
	    if ("decade" === viewType) {
	        resultDate.setFullYear(getFirstYearInDecade(date) + 9)
	    }
	    if ("century" === viewType) {
	        resultDate.setFullYear(getFirstDecadeInCentury(date) + 99)
	    }
	    return resultDate
	};
	var getLastMonthDay = function(date) {
	    var resultDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
	    return resultDate.getDate()
	};
	var sameView = function(view, date1, date2) {
	    return dateUtils[camelize("same " + view)](date1, date2)
	};
	var getViewUp = function(typeView) {
	    switch (typeView) {
	        case "month":
	            return "year";
	        case "year":
	            return "decade";
	        case "decade":
	            return "century"
	    }
	};
	var getViewDown = function(typeView) {
	    switch (typeView) {
	        case "century":
	            return "decade";
	        case "decade":
	            return "year";
	        case "year":
	            return "month"
	    }
	};
	var getDifferenceInMonth = function(typeView) {
	    var difference = 1;
	    if ("year" === typeView) {
	        difference = 12
	    }
	    if ("decade" === typeView) {
	        difference = 120
	    }
	    if ("century" === typeView) {
	        difference = 1200
	    }
	    return difference
	};
	var getDifferenceInMonthForCells = function(typeView) {
	    var difference = 1;
	    if ("decade" === typeView) {
	        difference = 12
	    }
	    if ("century" === typeView) {
	        difference = 120
	    }
	    return difference
	};
	var getDateIntervalByString = function(intervalString) {
	    var result = {};
	    switch (intervalString) {
	        case "year":
	            result.years = 1;
	            break;
	        case "month":
	            result.months = 1;
	            break;
	        case "quarter":
	            result.months = 3;
	            break;
	        case "week":
	            result.days = 7;
	            break;
	        case "day":
	            result.days = 1;
	            break;
	        case "hour":
	            result.hours = 1;
	            break;
	        case "minute":
	            result.minutes = 1;
	            break;
	        case "second":
	            result.seconds = 1;
	            break;
	        case "millisecond":
	            result.milliseconds = 1
	    }
	    return result
	};
	var sameDate = function(date1, date2) {
	    return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate()
	};
	var sameMonthAndYear = function(date1, date2) {
	    return sameYear(date1, date2) && date1.getMonth() === date2.getMonth()
	};
	var sameYear = function(date1, date2) {
	    return date1 && date2 && date1.getFullYear() === date2.getFullYear()
	};
	var sameDecade = function(date1, date2) {
	    if (!isDefined(date1) || !isDefined(date2)) {
	        return
	    }
	    var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10,
	        startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
	    return date1 && date2 && startDecadeDate1 === startDecadeDate2
	};
	var sameCentury = function(date1, date2) {
	    if (!isDefined(date1) || !isDefined(date2)) {
	        return
	    }
	    var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100,
	        startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
	    return date1 && date2 && startCenturyDate1 === startCenturyDate2
	};
	var getFirstDecadeInCentury = function(date) {
	    return date && date.getFullYear() - date.getFullYear() % 100
	};
	var getFirstYearInDecade = function(date) {
	    return date && date.getFullYear() - date.getFullYear() % 10
	};
	var getShortDateFormat = function() {
	    return "yyyy/M/d"
	};
	var getFirstMonthDate = function(date) {
	    if (!isDefined(date)) {
	        return
	    }
	    var newDate = new Date(date.getFullYear(), date.getMonth(), 1);
	    return newDate
	};
	var getLastMonthDate = function(date) {
	    if (!isDefined(date)) {
	        return
	    }
	    var newDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
	    return newDate
	};
	var getFirstWeekDate = function(date, firstDayOfWeek) {
	    var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
	    var result = new Date(date);
	    result.setDate(date.getDate() - delta);
	    return result
	};
	var normalizeDateByWeek = function(date, currentDate) {
	    var differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day"),
	        resultDate = new Date(date);
	    if (differenceInDays >= 6) {
	        resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7))
	    }
	    return resultDate
	};
	var dateInRange = function(date, min, max, format) {
	    if ("date" === format) {
	        min = min && new Date(min.getFullYear(), min.getMonth(), min.getDate());
	        max = max && new Date(max.getFullYear(), max.getMonth(), max.getDate());
	        date = date && new Date(date.getFullYear(), date.getMonth(), date.getDate())
	    }
	    return normalizeDate(date, min, max) === date
	};
	var normalizeDate = function(date, min, max) {
	    var normalizedDate = date;
	    if (!isDefined(date)) {
	        return date
	    }
	    if (isDefined(min) && date < min) {
	        normalizedDate = min
	    }
	    if (isDefined(max) && date > max) {
	        normalizedDate = max
	    }
	    return normalizedDate
	};
	var fixTimezoneGap = function(oldDate, newDate) {
	    if (!isDefined(oldDate)) {
	        return
	    }
	    var sign, trial, diff = newDate.getHours() - oldDate.getHours();
	    if (0 === diff) {
	        return
	    }
	    sign = 1 === diff || diff === -23 ? -1 : 1;
	    trial = new Date(newDate.getTime() + 36e5 * sign);
	    if (sign > 0 || trial.getDate() === newDate.getDate()) {
	        newDate.setTime(trial.getTime())
	    }
	};
	var getTimezonesDifference = function(min, max) {
	    return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3
	};
	var makeDate = function(date) {
	    return new Date(date)
	};
	var NUMBER_SERIALIZATION_FORMAT = "number",
	    DATE_SERIALIZATION_FORMAT = "yyyy'/'MM'/'dd",
	    DATETIME_SERIALIZATION_FORMAT = "yyyy'/'MM'/'dd HH:mm:ss";
	var getDateSerializationFormat = function(value) {
	    if (commonUtils.isNumber(value)) {
	        return NUMBER_SERIALIZATION_FORMAT
	    } else {
	        if (commonUtils.isString(value)) {
	            if (value.indexOf(":") >= 0) {
	                return DATETIME_SERIALIZATION_FORMAT
	            } else {
	                return DATE_SERIALIZATION_FORMAT
	            }
	        }
	    }
	};
	var deserializeDate = function(value, serializationFormat, localizationParseFunc) {
	    var parsedValue;
	    if (!serializationFormat || serializationFormat === NUMBER_SERIALIZATION_FORMAT || serializationFormat === DATE_SERIALIZATION_FORMAT || serializationFormat === DATETIME_SERIALIZATION_FORMAT) {
	        parsedValue = serializationFormat === NUMBER_SERIALIZATION_FORMAT ? value : !isDate(value) && Date.parse(value);
	        return parsedValue ? new Date(parsedValue) : value
	    }
	    if (void 0 !== value) {
	        return localizationParseFunc(value, serializationFormat)
	    }
	};
	var serializeDate = function(value, serializationFormat, localizationFormatFunc) {
	    if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
	        return value && value.valueOf && value.valueOf()
	    }
	    if (serializationFormat) {
	        return localizationFormatFunc(value, serializationFormat) || null
	    }
	    return value
	};
	var dateUtils = {
	    dateUnitIntervals: dateUnitIntervals,
	    convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
	    dateToMilliseconds: dateToMilliseconds,
	    getNextDateUnit: getNextDateUnit,
	    convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
	    getDateUnitInterval: getDateUnitInterval,
	    getDateFormatByTickInterval: getDateFormatByTickInterval,
	    getDatesDifferences: getDatesDifferences,
	    correctDateWithUnitBeginning: correctDateWithUnitBeginning,
	    trimTime: trimTime,
	    addDateInterval: addDateInterval,
	    addInterval: addInterval,
	    getSequenceByInterval: getSequenceByInterval,
	    getDateIntervalByString: getDateIntervalByString,
	    sameDate: sameDate,
	    sameMonthAndYear: sameMonthAndYear,
	    sameMonth: sameMonthAndYear,
	    sameYear: sameYear,
	    sameDecade: sameDecade,
	    sameCentury: sameCentury,
	    sameView: sameView,
	    getDifferenceInMonth: getDifferenceInMonth,
	    getDifferenceInMonthForCells: getDifferenceInMonthForCells,
	    getFirstYearInDecade: getFirstYearInDecade,
	    getFirstDecadeInCentury: getFirstDecadeInCentury,
	    getShortDateFormat: getShortDateFormat,
	    getViewFirstCellDate: getViewFirstCellDate,
	    getViewLastCellDate: getViewLastCellDate,
	    getViewDown: getViewDown,
	    getViewUp: getViewUp,
	    getLastMonthDay: getLastMonthDay,
	    getLastMonthDate: getLastMonthDate,
	    getFirstMonthDate: getFirstMonthDate,
	    getFirstWeekDate: getFirstWeekDate,
	    normalizeDateByWeek: normalizeDateByWeek,
	    getQuarter: getQuarter,
	    getFirstQuarterMonth: getFirstQuarterMonth,
	    dateInRange: dateInRange,
	    normalizeDate: normalizeDate,
	    getViewMinBoundaryDate: getViewMinBoundaryDate,
	    getViewMaxBoundaryDate: getViewMaxBoundaryDate,
	    fixTimezoneGap: fixTimezoneGap,
	    getTimezonesDifference: getTimezonesDifference,
	    makeDate: makeDate,
	    deserializeDate: deserializeDate,
	    serializeDate: serializeDate,
	    getDateSerializationFormat: getDateSerializationFormat,
	    getDatesInterval: getDatesInterval
	};
	module.exports = dateUtils;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (mobile/process_hardware_back_button.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    hardwareBack = $.Callbacks();
	module.exports = function() {
	    hardwareBack.fire()
	};
	module.exports.processCallback = hardwareBack;
	module.exports.default = module.exports;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (mobile/hide_top_overlay.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var hideCallback = function() {
	    var callbacks = [];
	    return {
	        add: function(callback) {
	            var indexOfCallback = $.inArray(callback, callbacks);
	            if (indexOfCallback === -1) {
	                callbacks.push(callback)
	            }
	        },
	        remove: function(callback) {
	            var indexOfCallback = $.inArray(callback, callbacks);
	            if (indexOfCallback !== -1) {
	                callbacks.splice(indexOfCallback, 1)
	            }
	        },
	        fire: function() {
	            var callback = callbacks.pop(),
	                result = !!callback;
	            if (result) {
	                callback()
	            }
	            return result
	        },
	        hasCallback: function() {
	            return callbacks.length > 0
	        }
	    }
	}();
	module.exports = function() {
	    return hideCallback.fire()
	};
	module.exports.hideCallback = hideCallback;
	module.exports.default = module.exports;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (format_helper.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    dateUtils = __webpack_require__(51),
	    numberLocalization = __webpack_require__(20),
	    dateLocalization = __webpack_require__(55),
	    dependencyInjector = __webpack_require__(21),
	    logger = __webpack_require__(6).logger;
	__webpack_require__(22);
	module.exports = dependencyInjector({
	    format: function(value, format, precision) {
	        var formatIsValid = commonUtils.isString(format) && "" !== format || $.isPlainObject(format) || commonUtils.isFunction(format),
	            valueIsValid = commonUtils.isNumber(value) || commonUtils.isDate(value);
	        if (!formatIsValid || !valueIsValid) {
	            return commonUtils.isDefined(value) ? value.toString() : ""
	        }
	        if (commonUtils.isFunction(format)) {
	            return format(value)
	        }
	        if (void 0 !== precision) {
	            logger.warn("Option 'precision' is deprecated. Use field 'precision' of a format object instead.")
	        }
	        if (commonUtils.isString(format)) {
	            format = {
	                type: format,
	                precision: precision
	            }
	        }
	        if (commonUtils.isNumber(value)) {
	            return numberLocalization.format(value, format)
	        }
	        if (commonUtils.isDate(value)) {
	            return dateLocalization.format(value, format)
	        }
	    },
	    getTimeFormat: function(showSecond) {
	        return showSecond ? "longtime" : "shorttime"
	    },
	    _normalizeFormat: function(format) {
	        if (!commonUtils.isArray(format)) {
	            return format
	        }
	        if (1 === format.length) {
	            return format[0]
	        }
	        return function(date) {
	            return format.map(function(formatPart) {
	                return dateLocalization.format(date, formatPart)
	            }).join(" ")
	        }
	    },
	    getDateFormatByDifferences: function(dateDifferences) {
	        var resultFormat = [];
	        if (dateDifferences.millisecond) {
	            resultFormat.push("millisecond")
	        }
	        if (dateDifferences.hour || dateDifferences.minute || dateDifferences.second) {
	            resultFormat.unshift(this.getTimeFormat(dateDifferences.second))
	        }
	        if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
	            resultFormat.unshift("shortdate");
	            return this._normalizeFormat(resultFormat)
	        }
	        if (dateDifferences.year && dateDifferences.month) {
	            return "monthandyear"
	        }
	        if (dateDifferences.year && dateDifferences.quarter) {
	            return "quarterandyear"
	        }
	        if (dateDifferences.year) {
	            return "year"
	        }
	        if (dateDifferences.quarter) {
	            return "quarter"
	        }
	        if (dateDifferences.month && dateDifferences.day) {
	            resultFormat.unshift("monthandday");
	            return this._normalizeFormat(resultFormat)
	        }
	        if (dateDifferences.month) {
	            return "month"
	        }
	        if (dateDifferences.day) {
	            var dayFormatter = function(date) {
	                return dateLocalization.format(date, "dayofweek") + ", " + dateLocalization.format(date, "day")
	            };
	            resultFormat.unshift(dayFormatter);
	            return this._normalizeFormat(resultFormat)
	        }
	        return this._normalizeFormat(resultFormat)
	    },
	    getDateFormatByTicks: function(ticks) {
	        var resultFormat, maxDiff, currentDiff, i;
	        if (ticks.length > 1) {
	            maxDiff = dateUtils.getDatesDifferences(ticks[0], ticks[1]);
	            for (i = 1; i < ticks.length - 1; i++) {
	                currentDiff = dateUtils.getDatesDifferences(ticks[i], ticks[i + 1]);
	                if (maxDiff.count < currentDiff.count) {
	                    maxDiff = currentDiff
	                }
	            }
	        } else {
	            maxDiff = {
	                year: true,
	                month: true,
	                day: true,
	                hour: ticks[0].getHours() > 0,
	                minute: ticks[0].getMinutes() > 0,
	                second: ticks[0].getSeconds() > 0
	            }
	        }
	        resultFormat = this.getDateFormatByDifferences(maxDiff);
	        return resultFormat
	    },
	    getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
	        var resultFormat, dateDifferences, dateUnitInterval, dateDifferencesConverter = {
	                week: "day"
	            },
	            correctDateDifferences = function(dateDifferences, tickInterval, value) {
	                switch (tickInterval) {
	                    case "year":
	                    case "quarter":
	                        dateDifferences.month = value;
	                    case "month":
	                        dateDifferences.day = value;
	                    case "week":
	                    case "day":
	                        dateDifferences.hour = value;
	                    case "hour":
	                        dateDifferences.minute = value;
	                    case "minute":
	                        dateDifferences.second = value;
	                    case "second":
	                        dateDifferences.millisecond = value
	                }
	            },
	            correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
	                if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
	                    if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
	                        differences.millisecond = true;
	                        differences.second = false
	                    }
	                } else {
	                    if (!maxDate.getSeconds() && maxDate.getMinutes()) {
	                        if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
	                            differences.second = true;
	                            differences.minute = false
	                        }
	                    } else {
	                        if (!maxDate.getMinutes() && maxDate.getHours()) {
	                            if (maxDate.getHours() - minDate.getHours() === 1) {
	                                differences.minute = true;
	                                differences.hour = false
	                            }
	                        } else {
	                            if (!maxDate.getHours() && maxDate.getDate() > 1) {
	                                if (maxDate.getDate() - minDate.getDate() === 1) {
	                                    differences.hour = true;
	                                    differences.day = false
	                                }
	                            } else {
	                                if (1 === maxDate.getDate() && maxDate.getMonth()) {
	                                    if (maxDate.getMonth() - minDate.getMonth() === 1) {
	                                        differences.day = true;
	                                        differences.month = false
	                                    }
	                                } else {
	                                    if (!maxDate.getMonth() && maxDate.getFullYear()) {
	                                        if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
	                                            differences.month = true;
	                                            differences.year = false
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            };
	        tickInterval = commonUtils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
	        dateDifferences = dateUtils.getDatesDifferences(startValue, endValue);
	        if (startValue !== endValue) {
	            correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue)
	        }
	        dateUnitInterval = dateUtils.getDateUnitInterval(dateDifferences);
	        correctDateDifferences(dateDifferences, dateUnitInterval, true);
	        dateUnitInterval = dateUtils.getDateUnitInterval(tickInterval || "second");
	        correctDateDifferences(dateDifferences, dateUnitInterval, false);
	        dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
	        resultFormat = this.getDateFormatByDifferences(dateDifferences);
	        return resultFormat
	    }
	});


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (localization/date.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    numberLocalization = __webpack_require__(20),
	    dependencyInjector = __webpack_require__(21),
	    errors = __webpack_require__(3);
	__webpack_require__(56);
	var FORMATS_TO_PATTERN_MAP = {
	    shortdate: "M/d/y",
	    shorttime: "h:mm a",
	    longdate: "EEEE, MMMM d, y",
	    longtime: "h:mm:ss a",
	    monthandday: "MMMM d",
	    monthandyear: "MMMM y",
	    quarterandyear: "QQQ y",
	    day: "d",
	    year: "y",
	    shortdateshorttime: "M/d/y, h:mm a",
	    mediumdatemediumtime: "MMMM d, h:mm a",
	    longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
	    month: "LLLL",
	    shortyear: "yy",
	    dayofweek: "EEEE",
	    quarter: "QQQ",
	    hour: "HH",
	    minute: "mm",
	    second: "ss",
	    millisecond: "SSS",
	    "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
	};
	var parseTime = function(text) {
	    var now = new Date,
	        parts = text.split(" "),
	        time = parts[0].split(":"),
	        hours = Number(time[0]),
	        minutes = Number(time[1]),
	        second = Number(time[2]) || 0;
	    if (/^pm$/i.test(parts[1])) {
	        hours += 12
	    }
	    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, second)
	};
	var removeTimezoneOffset = function(date) {
	    return new Date(date.valueOf() + 60 * date.getTimezoneOffset() * 1e3)
	};
	var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	    days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
	var amPm = function(date) {
	    return date.getHours() >= 12 ? "PM" : "AM"
	};
	var getTwelveHourTimeFormat = function(hours) {
	    return hours % 12 || 12
	};
	var formatNumber = function(number, precision) {
	    return numberLocalization.format(number, {
	        type: "decimal",
	        precision: precision
	    })
	};
	var FORMATTERS = {
	    millisecond: function(date) {
	        return formatNumber(date.getMilliseconds(date), 3)
	    },
	    second: function(date) {
	        return formatNumber(date.getSeconds(), 2)
	    },
	    minute: function(date) {
	        return formatNumber(date.getMinutes(), 2)
	    },
	    h: function(date) {
	        return formatNumber(getTwelveHourTimeFormat(date.getHours()), 1)
	    },
	    hh: function(date) {
	        return formatNumber(getTwelveHourTimeFormat(date.getHours()), 2)
	    },
	    hour: function(date) {
	        return formatNumber(date.getHours(), 2)
	    },
	    day: function(date) {
	        return date.getDate()
	    },
	    dayofweek: function(date) {
	        return days[date.getDay()]
	    },
	    M: function(date) {
	        return date.getMonth() + 1
	    },
	    MM: function(date) {
	        return formatNumber(date.getMonth() + 1, 2)
	    },
	    month: function(date) {
	        return months[date.getMonth()]
	    },
	    year: function(date) {
	        return date.getFullYear()
	    },
	    shortyear: function(date) {
	        return String(date.getFullYear()).substr(2, 2)
	    },
	    shorttime: function(date) {
	        return FORMATTERS.h(date) + ":" + FORMATTERS.minute(date) + " " + amPm(date)
	    },
	    shortdate: function(date) {
	        return [FORMATTERS.M(date), FORMATTERS.day(date), FORMATTERS.year(date)].join("/")
	    },
	    shortdateshorttime: function(date) {
	        return [FORMATTERS.shortdate(date), FORMATTERS.shorttime(date)].join(", ")
	    },
	    mediumdatemediumtime: function(date) {
	        return [FORMATTERS.monthandday(date), FORMATTERS.shorttime(date)].join(", ")
	    },
	    monthandyear: function(date) {
	        return [FORMATTERS.month(date), FORMATTERS.year(date)].join(" ")
	    },
	    monthandday: function(date) {
	        return [FORMATTERS.month(date), FORMATTERS.day(date)].join(" ")
	    },
	    longdate: function(date) {
	        return FORMATTERS.dayofweek(date) + ", " + FORMATTERS.month(date) + " " + FORMATTERS.day(date) + ", " + FORMATTERS.year(date)
	    },
	    longtime: function(date) {
	        return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":") + " " + amPm(date)
	    },
	    longdatelongtime: function(date) {
	        return [FORMATTERS.longdate(date), FORMATTERS.longtime(date)].join(", ")
	    },
	    d: function(date) {
	        return formatNumber(FORMATTERS.day(date), 1)
	    },
	    dd: function(date) {
	        return formatNumber(FORMATTERS.day(date), 2)
	    },
	    "d MMMM": function(date) {
	        return FORMATTERS.day(date) + " " + FORMATTERS.month(date)
	    },
	    "yyyy/M/d": function(date) {
	        return [FORMATTERS.year(date), FORMATTERS.M(date), FORMATTERS.day(date)].join("/")
	    },
	    "yyyy/MM/dd": function(date) {
	        return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("/")
	    },
	    "dd.MM.yyyy": function(date) {
	        return [FORMATTERS.dd(date), FORMATTERS.MM(date), FORMATTERS.year(date)].join(".")
	    },
	    "HH:mm": function(date) {
	        return [FORMATTERS.hour(date), FORMATTERS.minute(date)].join(":")
	    },
	    "HH:mm:ss": function(date) {
	        return [FORMATTERS["HH:mm"](date), FORMATTERS.second(date)].join(":")
	    },
	    "h:mm:ss": function(date) {
	        return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":")
	    },
	    "h:mm:ss:SSS": function(date) {
	        return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date), FORMATTERS.SSS(date)].join(":")
	    },
	    "yyyy/MM/dd HH:mm:ss": function(date) {
	        return [FORMATTERS["yyyy/MM/dd"](date), FORMATTERS["HH:mm:ss"](date)].join(" ")
	    },
	    "yyyy-MM-dd hh:mm:ss.SSS a": function(date) {
	        return [
	            [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("-"), [FORMATTERS.hh(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":") + "." + FORMATTERS.SSS(date), amPm(date)
	        ].join(" ")
	    },
	    "yyyy-MM-dd": function(date) {
	        return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("-")
	    },
	    yyyyMMddTHHmmss: function(date) {
	        return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date), "T", FORMATTERS.hour(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join("")
	    },
	    "datetime-local": function(date) {
	        return FORMATTERS["yyyy-MM-dd"](date) + "T" + FORMATTERS["HH:mm:ss"](date)
	    },
	    "yyyy-MM-ddTHH:mm:ssZ": function(date) {
	        return FORMATTERS["datetime-local"](date) + "Z"
	    },
	    "yyyy-MM-ddTHH:mmZ": function(date) {
	        return FORMATTERS["yyyy-MM-dd"](date) + "T" + FORMATTERS.hour(date) + ":" + FORMATTERS.minute(date) + "Z"
	    },
	    "dd/MM/yyyy": function(date) {
	        return [FORMATTERS.dd(date), FORMATTERS.MM(date), FORMATTERS.year(date)].join("/")
	    },
	    "yyyy MMMM d": function(date) {
	        return [FORMATTERS.year(date), FORMATTERS.month(date), FORMATTERS.day(date)].join(" ")
	    },
	    "EEEE, d": function(date) {
	        return [FORMATTERS.dayofweek(date), FORMATTERS.d(date)].join(", ")
	    },
	    "EEEE MM yy": function(date) {
	        return [FORMATTERS.dayofweek(date), FORMATTERS.MM(date), FORMATTERS.shortyear(date)].join(" ")
	    },
	    "d MMMM yyyy": function(date) {
	        return [FORMATTERS.day(date), FORMATTERS.month(date), FORMATTERS.year(date)].join(" ")
	    },
	    E: function(date) {
	        return cutCaptions([FORMATTERS.dayofweek(date)], "abbreviated")[0]
	    },
	    EEE: function(date) {
	        return FORMATTERS.E(date)
	    },
	    "EEE hh": function(date) {
	        return [FORMATTERS.EEE(date), FORMATTERS.hh(date)].join(" ")
	    },
	    "ss SSS": function(date) {
	        return [FORMATTERS.second(date), FORMATTERS.SSS(date)].join(" ")
	    },
	    quarter: function(date) {
	        var month = date.getMonth();
	        if (month >= 0 && month < 3) {
	            return "Q1"
	        }
	        if (month > 2 && month < 6) {
	            return "Q2"
	        }
	        if (month > 5 && month < 9) {
	            return "Q3"
	        }
	        return "Q4"
	    },
	    quarterandyear: function(date) {
	        return FORMATTERS.quarter(date) + " " + FORMATTERS.year(date)
	    }
	};
	var parseWithoutTimezone = function(text) {
	    if ("Z" !== text.slice(-1)) {
	        text += "Z"
	    }
	    return removeTimezoneOffset(new Date(text))
	};
	var PARSERS = {
	    day: function(text) {
	        var now = new Date;
	        return new Date(now.getFullYear(), now.getMonth(), Number(text))
	    },
	    hour: function(text) {
	        var now = new Date;
	        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), Number(text))
	    },
	    minute: function(text) {
	        var now = new Date;
	        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), Number(text))
	    },
	    month: function(text) {
	        return new Date((new Date).getFullYear(), $.inArray(text, months))
	    },
	    monthandday: function(text) {
	        var parts = text.split(" "),
	            result = PARSERS.month(parts[0]);
	        result.setDate(Number(parts[1]));
	        return result
	    },
	    monthandyear: function(text) {
	        var parts = text.split(" "),
	            result = PARSERS.month(parts[0]);
	        result.setYear(Number(parts[1]));
	        return result
	    },
	    year: function(text) {
	        var date = new Date(new Date(0));
	        date.setUTCFullYear(Number(text));
	        return removeTimezoneOffset(date)
	    },
	    shortyear: function(text) {
	        var MAX_YEAR_IN_XXI_CENTURY = 36;
	        var year = Number(text);
	        if (year > MAX_YEAR_IN_XXI_CENTURY) {
	            year += 1900
	        } else {
	            year += 2e3
	        }
	        return PARSERS.year(year)
	    },
	    shortdate: function(text) {
	        var parts = text.split("/");
	        if (3 !== parts.length) {
	            return
	        }
	        return new Date(Number(parts[2]), Number(parts[0]) - 1, Number(parts[1]))
	    },
	    longtime: function(text) {
	        return parseTime(text)
	    },
	    shorttime: function(text) {
	        return parseTime(text)
	    },
	    millisecond: function(text) {
	        return new Date(Number(text))
	    },
	    "yyyy MMMM d": function(text) {
	        var parts = text.split(" ");
	        if (3 !== parts.length) {
	            return
	        }
	        return new Date(Number(parts[0]), $.inArray(parts[1], months), Number(parts[2]))
	    },
	    "HH:mm": function(text) {
	        var parts = text.split(":");
	        return new Date(0, 0, 0, Number(parts[0]), Number(parts[1]), 0, 0)
	    },
	    "yyyy-MM-ddTHH:mm:ssZ": parseWithoutTimezone,
	    "yyyy-MM-ddTHH:mmZ": parseWithoutTimezone,
	    "datetime-local": parseWithoutTimezone,
	    mediumdatemediumtime: function(text) {
	        var parts = text.split(", "),
	            dateParts = parts[0].split(" "),
	            timeParts = parts[1].split(" ");
	        var amPm = 2 === timeParts.length ? timeParts.pop() : void 0;
	        var result = PARSERS.month(dateParts[0]);
	        result.setDate(Number(dateParts[1]));
	        timeParts = timeParts[0].split(":");
	        var hours = Number(timeParts[0]);
	        switch (String(amPm).toLowerCase()) {
	            case "am":
	                hours = 12 === hours ? 0 : hours;
	                break;
	            case "pm":
	                hours = 12 === hours ? 12 : hours + 12
	        }
	        result.setHours(hours);
	        result.setMinutes(Number(timeParts[1]));
	        return result
	    }
	};
	$.each(FORMATS_TO_PATTERN_MAP, function(key, value) {
	    value = value.replace(/'/g, "");
	    FORMATTERS[value] = FORMATTERS[key];
	    PARSERS[value] = PARSERS[key]
	});
	var getByFormat = function(obj, format) {
	    return obj[format.toLowerCase()] || obj[format.replace(/'/g, "")]
	};
	var cutCaptions = function(captions, format) {
	    var lengthByFormat = {
	        abbreviated: 3,
	        "short": 2,
	        narrow: 1
	    };
	    return $.map(captions, function(caption) {
	        return caption.substr(0, lengthByFormat[format])
	    })
	};
	var possiblePartPatterns = {
	    year: ["y", "yy", "yyyy"],
	    day: ["d", "dd"],
	    month: ["M", "MM", "MMM", "MMMM"],
	    hours: ["H", "HH", "h", "hh"],
	    minutes: ["m", "mm"],
	    seconds: ["s", "ss"],
	    milliseconds: ["S", "SS", "SSS"]
	};
	var dateLocalization = dependencyInjector({
	    _getPatternByFormat: function(format) {
	        return FORMATS_TO_PATTERN_MAP[format.toLowerCase()]
	    },
	    _expandPattern: function(pattern) {
	        return this._getPatternByFormat(pattern) || pattern
	    },
	    formatUsesMonthName: function(format) {
	        return this._expandPattern(format).indexOf("MMMM") !== -1
	    },
	    formatUsesDayName: function(format) {
	        return this._expandPattern(format).indexOf("EEEE") !== -1
	    },
	    getFormatParts: function(format) {
	        var pattern = this._getPatternByFormat(format) || format,
	            result = [];
	        $.each(pattern.split(/\W+/), function(_, formatPart) {
	            $.each(possiblePartPatterns, function(partName, possiblePatterns) {
	                if ($.inArray(formatPart, possiblePatterns) > -1) {
	                    result.push(partName)
	                }
	            })
	        });
	        return result
	    },
	    getMonthNames: function(format) {
	        return cutCaptions(months, format)
	    },
	    getDayNames: function(format) {
	        return cutCaptions(days, format)
	    },
	    getTimeSeparator: function() {
	        return ":"
	    },
	    format: function(date, format) {
	        if (!date) {
	            return
	        }
	        if (!format) {
	            return date
	        }
	        var formatter;
	        if ("function" === typeof format) {
	            formatter = format
	        } else {
	            if (format.formatter) {
	                formatter = format.formatter
	            } else {
	                format = format.type || format;
	                formatter = getByFormat(FORMATTERS, format)
	            }
	        }
	        if (!formatter) {
	            return
	        }
	        return formatter(date)
	    },
	    parse: function(text, format) {
	        var result, parser;
	        if (!text) {
	            return
	        }
	        if (!format) {
	            return new Date(text)
	        }
	        if (format.parser) {
	            return format.parser(text)
	        }
	        if (format.type || format.formatter) {
	            format = format.type
	        }
	        if (format && "function" !== typeof format) {
	            parser = getByFormat(PARSERS, format)
	        }
	        if (parser) {
	            result = parser(text)
	        } else {
	            errors.log("W0012");
	            result = new Date(text)
	        }
	        if (!result || isNaN(result.getTime())) {
	            return
	        }
	        return result
	    },
	    firstDayOfWeekIndex: function() {
	        return 0
	    }
	});
	module.exports = dateLocalization;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (localization/core.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var dependencyInjector = __webpack_require__(21);
	module.exports = dependencyInjector({
	    locale: function() {
	        var currentLocale = "en";
	        return function(locale) {
	            if (!locale) {
	                return currentLocale
	            }
	            currentLocale = locale
	        }
	    }()
	});


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (animation/presets/presets.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Component = __webpack_require__(33),
	    devices = __webpack_require__(40),
	    fx = __webpack_require__(58);
	var directionPostfixes = {
	    forward: " dx-forward",
	    backward: " dx-backward",
	    none: " dx-no-direction",
	    undefined: " dx-no-direction"
	};
	var optionPrefix = "preset_";
	var AnimationPresetCollection = Component.inherit({
	    ctor: function() {
	        this.callBase.apply(this, arguments);
	        this._customRules = [];
	        this._registeredPresets = [];
	        this.resetToDefaults()
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            defaultAnimationDuration: 400,
	            defaultAnimationDelay: 0,
	            defaultStaggerAnimationDuration: 300,
	            defaultStaggerAnimationDelay: 40,
	            defaultStaggerAnimationStartDelay: 500
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function(device) {
	                return device.phone
	            },
	            options: {
	                defaultStaggerAnimationDuration: 350,
	                defaultStaggerAnimationDelay: 50,
	                defaultStaggerAnimationStartDelay: 0
	            }
	        }, {
	            device: function() {
	                return devices.current().android || devices.real.android
	            },
	            options: {
	                defaultAnimationDelay: 100
	            }
	        }])
	    },
	    _getPresetOptionName: function(animationName) {
	        return optionPrefix + animationName
	    },
	    _createAndroidSlideAnimationConfig: function(throughOpacity, widthMultiplier) {
	        var that = this;
	        var createBaseConfig = function(configModifier) {
	            return {
	                type: "slide",
	                delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
	                duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
	            }
	        };
	        return {
	            enter: function($element, configModifier) {
	                var width = $element.parent().width() * widthMultiplier,
	                    direction = configModifier.direction,
	                    config = createBaseConfig(configModifier);
	                config.to = {
	                    left: 0,
	                    opacity: 1
	                };
	                if ("forward" === direction) {
	                    config.from = {
	                        left: width,
	                        opacity: throughOpacity
	                    }
	                } else {
	                    if ("backward" === direction) {
	                        config.from = {
	                            left: -width,
	                            opacity: throughOpacity
	                        }
	                    } else {
	                        config.from = {
	                            left: 0,
	                            opacity: 0
	                        }
	                    }
	                }
	                return fx.createAnimation($element, config)
	            },
	            leave: function($element, configModifier) {
	                var width = $element.parent().width() * widthMultiplier,
	                    direction = configModifier.direction,
	                    config = createBaseConfig(configModifier);
	                config.from = {
	                    left: 0,
	                    opacity: 1
	                };
	                if ("forward" === direction) {
	                    config.to = {
	                        left: -width,
	                        opacity: throughOpacity
	                    }
	                } else {
	                    if ("backward" === direction) {
	                        config.to = {
	                            left: width,
	                            opacity: throughOpacity
	                        }
	                    } else {
	                        config.to = {
	                            left: 0,
	                            opacity: 0
	                        }
	                    }
	                }
	                return fx.createAnimation($element, config)
	            }
	        }
	    },
	    _createOpenDoorConfig: function() {
	        var that = this;
	        var createBaseConfig = function(configModifier) {
	            return {
	                type: "css",
	                extraCssClasses: "dx-opendoor-animation",
	                delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
	                duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
	            }
	        };
	        return {
	            enter: function($element, configModifier) {
	                var direction = configModifier.direction,
	                    config = createBaseConfig(configModifier);
	                config.delay = "none" === direction ? config.delay : config.duration;
	                config.from = "dx-enter dx-opendoor-animation" + directionPostfixes[direction];
	                config.to = "dx-enter-active";
	                return fx.createAnimation($element, config)
	            },
	            leave: function($element, configModifier) {
	                var direction = configModifier.direction,
	                    config = createBaseConfig(configModifier);
	                config.from = "dx-leave dx-opendoor-animation" + directionPostfixes[direction];
	                config.to = "dx-leave-active";
	                return fx.createAnimation($element, config)
	            }
	        }
	    },
	    _createWinPopConfig: function() {
	        var that = this,
	            baseConfig = {
	                type: "css",
	                extraCssClasses: "dx-win-pop-animation",
	                duration: that.option("defaultAnimationDuration")
	            };
	        return {
	            enter: function($element, configModifier) {
	                var config = baseConfig,
	                    direction = configModifier.direction;
	                config.delay = "none" === direction ? that.option("defaultAnimationDelay") : that.option("defaultAnimationDuration") / 2;
	                config.from = "dx-enter dx-win-pop-animation" + directionPostfixes[direction];
	                config.to = "dx-enter-active";
	                return fx.createAnimation($element, config)
	            },
	            leave: function($element, configModifier) {
	                var config = baseConfig,
	                    direction = configModifier.direction;
	                config.delay = that.option("defaultAnimationDelay");
	                config.from = "dx-leave dx-win-pop-animation" + directionPostfixes[direction];
	                config.to = "dx-leave-active";
	                return fx.createAnimation($element, config)
	            }
	        }
	    },
	    resetToDefaults: function() {
	        this.clear();
	        this.registerDefaultPresets();
	        this.applyChanges()
	    },
	    clear: function(name) {
	        var that = this,
	            newRegisteredPresets = [];
	        $.each(this._registeredPresets, function(index, preset) {
	            if (!name || name === preset.name) {
	                that.option(that._getPresetOptionName(preset.name), void 0)
	            } else {
	                newRegisteredPresets.push(preset)
	            }
	        });
	        this._registeredPresets = newRegisteredPresets;
	        this.applyChanges()
	    },
	    registerPreset: function(name, config) {
	        this._registeredPresets.push({
	            name: name,
	            config: config
	        })
	    },
	    applyChanges: function() {
	        var that = this;
	        this._customRules.length = 0;
	        $.each(this._registeredPresets, function(index, preset) {
	            var rule = {
	                device: preset.config.device,
	                options: {}
	            };
	            rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
	            that._customRules.push(rule)
	        });
	        this._setOptionsByDevice()
	    },
	    getPreset: function(name) {
	        var result = name;
	        while ("string" === typeof result) {
	            result = this.option(this._getPresetOptionName(result))
	        }
	        return result
	    },
	    registerDefaultPresets: function() {
	        this.registerPreset("pop", {
	            animation: {
	                extraCssClasses: "dx-android-pop-animation",
	                delay: this.option("defaultAnimationDelay"),
	                duration: this.option("defaultAnimationDuration")
	            }
	        });
	        this.registerPreset("openDoor", {
	            animation: this._createOpenDoorConfig()
	        });
	        this.registerPreset("win-pop", {
	            animation: this._createWinPopConfig()
	        });
	        this.registerPreset("fade", {
	            animation: {
	                extraCssClasses: "dx-fade-animation",
	                delay: this.option("defaultAnimationDelay"),
	                duration: this.option("defaultAnimationDuration")
	            }
	        });
	        this.registerPreset("slide", {
	            device: function() {
	                return devices.current().android || devices.real.android
	            },
	            animation: this._createAndroidSlideAnimationConfig(1, 1)
	        });
	        this.registerPreset("slide", {
	            device: function() {
	                return !devices.current().android && !devices.real.android
	            },
	            animation: {
	                extraCssClasses: "dx-slide-animation",
	                delay: this.option("defaultAnimationDelay"),
	                duration: this.option("defaultAnimationDuration")
	            }
	        });
	        this.registerPreset("ios7-slide", {
	            animation: {
	                extraCssClasses: "dx-ios7-slide-animation",
	                delay: this.option("defaultAnimationDelay"),
	                duration: this.option("defaultAnimationDuration")
	            }
	        });
	        this.registerPreset("overflow", {
	            animation: {
	                extraCssClasses: "dx-overflow-animation",
	                delay: this.option("defaultAnimationDelay"),
	                duration: this.option("defaultAnimationDuration")
	            }
	        });
	        this.registerPreset("ios7-toolbar", {
	            device: function() {
	                return !devices.current().android && !devices.real.android
	            },
	            animation: {
	                extraCssClasses: "dx-ios7-toolbar-animation",
	                delay: this.option("defaultAnimationDelay"),
	                duration: this.option("defaultAnimationDuration")
	            }
	        });
	        this.registerPreset("ios7-toolbar", {
	            device: function() {
	                return devices.current().android || devices.real.android
	            },
	            animation: this._createAndroidSlideAnimationConfig(0, .4)
	        });
	        this.registerPreset("stagger-fade", {
	            animation: {
	                extraCssClasses: "dx-fade-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        });
	        this.registerPreset("stagger-slide", {
	            animation: {
	                extraCssClasses: "dx-slide-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        });
	        this.registerPreset("stagger-fade-slide", {
	            animation: {
	                extraCssClasses: "dx-fade-slide-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        });
	        this.registerPreset("stagger-drop", {
	            animation: {
	                extraCssClasses: "dx-drop-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        });
	        this.registerPreset("stagger-fade-drop", {
	            animation: {
	                extraCssClasses: "dx-fade-drop-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        });
	        this.registerPreset("stagger-fade-rise", {
	            animation: {
	                extraCssClasses: "dx-fade-rise-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        });
	        this.registerPreset("stagger-3d-drop", {
	            animation: {
	                extraCssClasses: "dx-3d-drop-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        });
	        this.registerPreset("stagger-fade-zoom", {
	            animation: {
	                extraCssClasses: "dx-fade-zoom-animation",
	                staggerDelay: this.option("defaultStaggerAnimationDelay"),
	                duration: this.option("defaultStaggerAnimationDuration"),
	                delay: this.option("defaultStaggerAnimationStartDelay")
	            }
	        })
	    }
	});
	exports.PresetCollection = AnimationPresetCollection;
	var animationPresets = new AnimationPresetCollection;
	exports.presets = animationPresets;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (animation/fx.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    translator = __webpack_require__(59),
	    animationFrame = __webpack_require__(46),
	    support = __webpack_require__(48),
	    positionUtils = __webpack_require__(60),
	    removeEvent = __webpack_require__(32),
	    eventUtils = __webpack_require__(61),
	    when = __webpack_require__(10).when,
	    transitionEndEventName = support.transitionEndEventName + ".dxFX",
	    removeEventName = eventUtils.addNamespace(removeEvent, "dxFX");
	var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,
	    RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i,
	    ANIM_DATA_KEY = "dxAnimData",
	    ANIM_QUEUE_KEY = "dxAnimQueue",
	    TRANSFORM_PROP = "transform";
	var TransitionAnimationStrategy = {
	    initAnimation: function($element, config) {
	        $element.css({
	            transitionProperty: "none"
	        });
	        if ("string" === typeof config.from) {
	            $element.addClass(config.from)
	        } else {
	            setProps($element, config.from)
	        }
	        var that = this,
	            deferred = $.Deferred(),
	            cleanupWhen = config.cleanupWhen;
	        config.transitionAnimation = {
	            deferred: deferred,
	            finish: function() {
	                that._finishTransition($element);
	                if (cleanupWhen) {
	                    when(deferred, cleanupWhen).always(function() {
	                        that._cleanup($element, config)
	                    })
	                } else {
	                    that._cleanup($element, config)
	                }
	                deferred.resolveWith($element, [config, $element])
	            }
	        };
	        this._completeAnimationCallback($element, config).done(function() {
	            config.transitionAnimation.finish()
	        }).fail(function() {
	            deferred.rejectWith($element, [config, $element])
	        });
	        if (!config.duration) {
	            config.transitionAnimation.finish()
	        }
	        $element.css("transform")
	    },
	    animate: function($element, config) {
	        this._startAnimation($element, config);
	        return config.transitionAnimation.deferred.promise()
	    },
	    _completeAnimationCallback: function($element, config) {
	        var simulatedEndEventTimer, waitForJSCompleteTimer, that = this,
	            startTime = $.now() + config.delay,
	            deferred = $.Deferred(),
	            transitionEndFired = $.Deferred(),
	            simulatedTransitionEndFired = $.Deferred();
	        config.transitionAnimation.cleanup = function() {
	            clearTimeout(simulatedEndEventTimer);
	            clearTimeout(waitForJSCompleteTimer);
	            $element.off(transitionEndEventName);
	            $element.off(removeEventName)
	        };
	        $element.one(transitionEndEventName, function() {
	            if ($.now() - startTime >= config.duration) {
	                transitionEndFired.reject()
	            }
	        }).off(removeEventName).on(removeEventName, function() {
	            that.stop($element, config);
	            deferred.reject()
	        });
	        waitForJSCompleteTimer = setTimeout(function() {
	            simulatedEndEventTimer = setTimeout(function() {
	                simulatedTransitionEndFired.reject()
	            }, config.duration + config.delay + fx._simulatedTransitionEndDelay);
	            when(transitionEndFired, simulatedTransitionEndFired).fail($.proxy(function() {
	                deferred.resolve()
	            }, this))
	        });
	        return deferred.promise()
	    },
	    _startAnimation: function($element, config) {
	        $element.css({
	            transitionProperty: "all",
	            transitionDelay: config.delay + "ms",
	            transitionDuration: config.duration + "ms",
	            transitionTimingFunction: config.easing
	        });
	        if ("string" === typeof config.to) {
	            $element[0].className += " " + config.to
	        } else {
	            if (config.to) {
	                setProps($element, config.to)
	            }
	        }
	    },
	    _finishTransition: function($element) {
	        $element.css("transition", "none")
	    },
	    _cleanup: function($element, config) {
	        config.transitionAnimation.cleanup();
	        if ("string" === typeof config.from) {
	            $element.removeClass(config.from);
	            $element.removeClass(config.to)
	        }
	    },
	    stop: function($element, config, jumpToEnd) {
	        if (!config) {
	            return
	        }
	        if (jumpToEnd) {
	            config.transitionAnimation.finish()
	        } else {
	            if ($.isPlainObject(config.to)) {
	                $.each(config.to, function(key) {
	                    $element.css(key, $element.css(key))
	                })
	            }
	            this._finishTransition($element);
	            this._cleanup($element, config)
	        }
	    }
	};
	var FrameAnimationStrategy = {
	    initAnimation: function($element, config) {
	        setProps($element, config.from)
	    },
	    animate: function($element, config) {
	        var deferred = $.Deferred(),
	            that = this;
	        if (!config) {
	            return deferred.reject().promise()
	        }
	        $.each(config.to, function(prop) {
	            if (void 0 === config.from[prop]) {
	                config.from[prop] = that._normalizeValue($element.css(prop))
	            }
	        });
	        if (config.to[TRANSFORM_PROP]) {
	            config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
	            config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP])
	        }
	        config.frameAnimation = {
	            to: config.to,
	            from: config.from,
	            currentValue: config.from,
	            easing: convertTransitionTimingFuncToJQueryEasing(config.easing),
	            duration: config.duration,
	            startTime: (new Date).valueOf(),
	            finish: function() {
	                this.currentValue = this.to;
	                this.draw();
	                animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId);
	                deferred.resolve()
	            },
	            draw: function() {
	                if (config.draw) {
	                    config.draw(this.currentValue);
	                    return
	                }
	                var currentValue = $.extend({}, this.currentValue);
	                if (currentValue[TRANSFORM_PROP]) {
	                    currentValue[TRANSFORM_PROP] = $.map(currentValue[TRANSFORM_PROP], function(value, prop) {
	                        if ("translate" === prop) {
	                            return translator.getTranslateCss(value)
	                        } else {
	                            if ("scale" === prop) {
	                                return "scale(" + value + ")"
	                            } else {
	                                if ("rotate" === prop.substr(0, prop.length - 1)) {
	                                    return prop + "(" + value + "deg)"
	                                }
	                            }
	                        }
	                    }).join(" ")
	                }
	                $element.css(currentValue)
	            }
	        };
	        if (config.delay) {
	            config.frameAnimation.startTime += config.delay;
	            config.frameAnimation.delayTimeout = setTimeout(function() {
	                that._startAnimation($element, config)
	            }, config.delay)
	        } else {
	            that._startAnimation($element, config)
	        }
	        return deferred.promise()
	    },
	    _startAnimation: function($element, config) {
	        $element.off(removeEventName).on(removeEventName, function() {
	            if (config.frameAnimation) {
	                animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId)
	            }
	        });
	        this._animationStep($element, config)
	    },
	    _parseTransform: function(transformString) {
	        var result = {};
	        $.each(transformString.match(/(\w|\d)+\([^\)]*\)\s*/g), function(i, part) {
	            var translateData = translator.parseTranslate(part),
	                scaleData = part.match(/scale\((.+?)\)/),
	                rotateData = part.match(/(rotate.)\((.+)deg\)/);
	            if (translateData) {
	                result.translate = translateData
	            }
	            if (scaleData && scaleData[1]) {
	                result.scale = parseFloat(scaleData[1])
	            }
	            if (rotateData && rotateData[1]) {
	                result[rotateData[1]] = parseFloat(rotateData[2])
	            }
	        });
	        return result
	    },
	    stop: function($element, config, jumpToEnd) {
	        var frameAnimation = config && config.frameAnimation;
	        if (!frameAnimation) {
	            return
	        }
	        animationFrame.cancelAnimationFrame(frameAnimation.animationFrameId);
	        clearTimeout(frameAnimation.delayTimeout);
	        if (jumpToEnd) {
	            frameAnimation.finish()
	        }
	        delete config.frameAnimation
	    },
	    _animationStep: function($element, config) {
	        var frameAnimation = config && config.frameAnimation;
	        if (!frameAnimation) {
	            return
	        }
	        var now = (new Date).valueOf();
	        if (now >= frameAnimation.startTime + frameAnimation.duration) {
	            frameAnimation.finish();
	            return
	        }
	        frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
	        frameAnimation.draw();
	        var that = this;
	        frameAnimation.animationFrameId = animationFrame.requestAnimationFrame(function() {
	            that._animationStep($element, config)
	        })
	    },
	    _calcStepValue: function(frameAnimation, currentDuration) {
	        var calcValueRecursively = function(from, to) {
	            var result = $.isArray(to) ? [] : {};
	            var calcEasedValue = function(propName) {
	                var x = currentDuration / frameAnimation.duration,
	                    t = currentDuration,
	                    b = 1 * from[propName],
	                    c = to[propName] - from[propName],
	                    d = frameAnimation.duration;
	                return $.easing[frameAnimation.easing](x, t, b, c, d)
	            };
	            $.each(to, function(propName, endPropValue) {
	                if ("string" === typeof endPropValue && false === parseFloat(endPropValue, 10)) {
	                    return true
	                }
	                result[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
	            });
	            return result
	        };
	        return calcValueRecursively(frameAnimation.from, frameAnimation.to)
	    },
	    _normalizeValue: function(value) {
	        var numericValue = parseFloat(value, 10);
	        if (false === numericValue) {
	            return value
	        }
	        return numericValue
	    }
	};
	var FallbackToNoAnimationStrategy = {
	    initAnimation: function() {},
	    animate: function() {
	        return $.Deferred().resolve().promise()
	    },
	    stop: $.noop,
	    isSynchronous: true
	};
	var animationStrategies = {
	    transition: support.transition ? TransitionAnimationStrategy : FrameAnimationStrategy,
	    frame: FrameAnimationStrategy,
	    noAnimation: FallbackToNoAnimationStrategy
	};
	var getAnimationStrategy = function(config) {
	    config = config || {};
	    var strategy = config.strategy || "transition";
	    if ("css" === config.type && !support.transition) {
	        strategy = "noAnimation"
	    }
	    return animationStrategies[strategy]
	};
	var TransitionTimingFuncMap = {
	    linear: "cubic-bezier(0, 0, 1, 1)",
	    ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
	    "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
	    "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
	    "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
	};
	var convertTransitionTimingFuncToJQueryEasing = function(cssTransitionEasing) {
	    cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
	    var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
	    if (!coeffs) {
	        return "linear"
	    }
	    coeffs = coeffs.slice(1, 5);
	    $.each(coeffs, function(index, value) {
	        coeffs[index] = parseFloat(value)
	    });
	    var easingName = "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
	    if (!$.isFunction($.easing[easingName])) {
	        var polynomBezier = function(x1, y1, x2, y2) {
	            var Cx = 3 * x1,
	                Bx = 3 * (x2 - x1) - Cx,
	                Ax = 1 - Cx - Bx,
	                Cy = 3 * y1,
	                By = 3 * (y2 - y1) - Cy,
	                Ay = 1 - Cy - By;
	            var bezierX = function(t) {
	                return t * (Cx + t * (Bx + t * Ax))
	            };
	            var bezierY = function(t) {
	                return t * (Cy + t * (By + t * Ay))
	            };
	            var findXFor = function(t) {
	                var z, x = t,
	                    i = 0;
	                while (i < 14) {
	                    z = bezierX(x) - t;
	                    if (Math.abs(z) < .001) {
	                        break
	                    }
	                    x -= z / derivativeX(x);
	                    i++
	                }
	                return x
	            };
	            var derivativeX = function(t) {
	                return Cx + t * (2 * Bx + 3 * t * Ax)
	            };
	            return function(t) {
	                return bezierY(findXFor(t))
	            }
	        };
	        $.easing[easingName] = function(x, t, b, c, d) {
	            return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b
	        }
	    }
	    return easingName
	};
	var baseConfigValidator = function(config, animationType, validate, typeMessage) {
	    $.each(["from", "to"], function() {
	        if (!validate(config[this])) {
	            throw errors.Error("E0010", animationType, this, typeMessage)
	        }
	    })
	};
	var isObjectConfigValidator = function(config, animationType) {
	    return baseConfigValidator(config, animationType, function(target) {
	        return $.isPlainObject(target)
	    }, "a plain object")
	};
	var isStringConfigValidator = function(config, animationType) {
	    return baseConfigValidator(config, animationType, function(target) {
	        return "string" === typeof target
	    }, "a string")
	};
	var CustomAnimationConfigurator = {
	    setup: function() {}
	};
	var CssAnimationConfigurator = {
	    validateConfig: function(config) {
	        isStringConfigValidator(config, "css")
	    },
	    setup: function() {}
	};
	var positionAliases = {
	    top: {
	        my: "bottom center",
	        at: "top center"
	    },
	    bottom: {
	        my: "top center",
	        at: "bottom center"
	    },
	    right: {
	        my: "left center",
	        at: "right center"
	    },
	    left: {
	        my: "right center",
	        at: "left center"
	    }
	};
	var SlideAnimationConfigurator = {
	    validateConfig: function(config) {
	        isObjectConfigValidator(config, "slide")
	    },
	    setup: function($element, config) {
	        var location = translator.locate($element);
	        if ("slide" !== config.type) {
	            var positioningConfig = "slideIn" === config.type ? config.from : config.to;
	            positioningConfig.position = $.extend({
	                of: window
	            }, positionAliases[config.direction]);
	            setupPosition($element, positioningConfig)
	        }
	        this._setUpConfig(location, config.from);
	        this._setUpConfig(location, config.to);
	        translator.clearCache($element);
	        if (!support.transform && "static" === $element.css("position")) {
	            $element.css("position", "relative")
	        }
	    },
	    _setUpConfig: function(location, config) {
	        config.left = "left" in config ? config.left : "+=0";
	        config.top = "top" in config ? config.top : "+=0";
	        this._initNewPosition(location, config)
	    },
	    _initNewPosition: function(location, config) {
	        var position = {
	            left: config.left,
	            top: config.top
	        };
	        delete config.left;
	        delete config.top;
	        var relativeValue = this._getRelativeValue(position.left);
	        if (void 0 !== relativeValue) {
	            position.left = relativeValue + location.left
	        } else {
	            config.left = 0
	        }
	        relativeValue = this._getRelativeValue(position.top);
	        if (void 0 !== relativeValue) {
	            position.top = relativeValue + location.top
	        } else {
	            config.top = 0
	        }
	        var translate = {
	            x: 0,
	            y: 0
	        };
	        if (support.transform) {
	            translate = {
	                x: position.left,
	                y: position.top
	            }
	        } else {
	            config.left = position.left;
	            config.top = position.top
	        }
	        config[TRANSFORM_PROP] = translator.getTranslateCss(translate)
	    },
	    _getRelativeValue: function(value) {
	        var relativeValue;
	        if ("string" === typeof value && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
	            return parseInt(relativeValue[1] + "1") * relativeValue[2]
	        }
	    }
	};
	var FadeAnimationConfigurator = {
	    setup: function($element, config) {
	        var toOpacity, from = config.from,
	            fromOpacity = $.isPlainObject(from) ? config.skipElementInitialStyles ? 0 : $element.css("opacity") : String(from);
	        switch (config.type) {
	            case "fadeIn":
	                toOpacity = 1;
	                break;
	            case "fadeOut":
	                toOpacity = 0;
	                break;
	            default:
	                toOpacity = String(config.to)
	        }
	        config.from = {
	            visibility: "visible",
	            opacity: fromOpacity
	        };
	        config.to = {
	            opacity: toOpacity
	        }
	    }
	};
	var PopAnimationConfigurator = {
	    validateConfig: function(config) {
	        isObjectConfigValidator(config, "pop")
	    },
	    setup: function($element, config) {
	        var from = config.from,
	            to = config.to,
	            fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity"),
	            toOpacity = "opacity" in to ? to.opacity : 1,
	            fromScale = "scale" in from ? from.scale : 0,
	            toScale = "scale" in to ? to.scale : 1;
	        config.from = {
	            opacity: fromOpacity
	        };
	        var translate = translator.getTranslate($element);
	        config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
	        config.to = {
	            opacity: toOpacity
	        };
	        config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale)
	    },
	    _getCssTransform: function(translate, scale) {
	        return translator.getTranslateCss(translate) + "scale(" + scale + ")"
	    }
	};
	var animationConfigurators = {
	    custom: CustomAnimationConfigurator,
	    slide: SlideAnimationConfigurator,
	    slideIn: SlideAnimationConfigurator,
	    slideOut: SlideAnimationConfigurator,
	    fade: FadeAnimationConfigurator,
	    fadeIn: FadeAnimationConfigurator,
	    fadeOut: FadeAnimationConfigurator,
	    pop: PopAnimationConfigurator,
	    css: CssAnimationConfigurator
	};
	var getAnimationConfigurator = function(config) {
	    var result = animationConfigurators[config.type];
	    if (!result) {
	        throw errors.Error("E0011", config.type)
	    }
	    return result
	};
	var defaultJSConfig = {
	        type: "custom",
	        from: {},
	        to: {},
	        duration: 400,
	        start: $.noop,
	        complete: $.noop,
	        easing: "ease",
	        delay: 0
	    },
	    defaultCssConfig = {
	        duration: 400,
	        easing: "ease",
	        delay: 0
	    };
	var setupAnimationOnElement = function() {
	    var animation = this,
	        $element = animation.element,
	        config = animation.config;
	    setupPosition($element, config.from);
	    setupPosition($element, config.to);
	    animation.configurator.setup($element, config);
	    $element.data(ANIM_DATA_KEY, animation);
	    if (fx.off) {
	        config.duration = 0;
	        config.delay = 0
	    }
	    animation.strategy.initAnimation($element, config);
	    if (config.start) {
	        config.start.apply(this, [$element, config])
	    }
	};
	var onElementAnimationComplete = function(animation) {
	    var $element = animation.element,
	        config = animation.config;
	    $element.removeData(ANIM_DATA_KEY);
	    if (config.complete) {
	        config.complete.apply(this, [$element, config])
	    }
	    animation.deferred.resolveWith(this, [$element, config])
	};
	var startAnimationOnElement = function() {
	    var animation = this,
	        $element = animation.element,
	        config = animation.config;
	    animation.isStarted = true;
	    return animation.strategy.animate($element, config).done(function() {
	        onElementAnimationComplete(animation)
	    }).fail(function() {
	        animation.deferred.rejectWith(this, [$element, config])
	    })
	};
	var stopAnimationOnElement = function(jumpToEnd) {
	    var animation = this,
	        $element = animation.element,
	        config = animation.config;
	    clearTimeout(animation.startTimeout);
	    if (!animation.isStarted) {
	        animation.start()
	    }
	    animation.strategy.stop($element, config, jumpToEnd)
	};
	var scopedRemoveEvent = eventUtils.addNamespace(removeEvent, "dxFXStartAnimation");
	var subscribeToRemoveEvent = function(animation) {
	    animation.element.off(scopedRemoveEvent).on(scopedRemoveEvent, function() {
	        fx.stop(animation.element)
	    });
	    animation.deferred.always(function() {
	        animation.element.off(scopedRemoveEvent)
	    })
	};
	var createAnimation = function(element, initialConfig) {
	    var defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig,
	        config = $.extend(true, {}, defaultConfig, initialConfig),
	        configurator = getAnimationConfigurator(config),
	        strategy = getAnimationStrategy(config),
	        animation = {
	            element: $(element),
	            config: config,
	            configurator: configurator,
	            strategy: strategy,
	            isSynchronous: strategy.isSynchronous,
	            setup: setupAnimationOnElement,
	            start: startAnimationOnElement,
	            stop: stopAnimationOnElement,
	            deferred: $.Deferred()
	        };
	    if ($.isFunction(configurator.validateConfig)) {
	        configurator.validateConfig(config)
	    }
	    subscribeToRemoveEvent(animation);
	    return animation
	};
	var animate = function(element, config) {
	    var $element = $(element);
	    if (!$element.length) {
	        return $.Deferred().resolve().promise()
	    }
	    var animation = createAnimation($element, config);
	    pushInAnimationQueue($element, animation);
	    return animation.deferred.promise()
	};
	var pushInAnimationQueue = function($element, animation) {
	    var queueData = getAnimQueueData($element);
	    writeAnimQueueData($element, queueData);
	    queueData.push(animation);
	    if (!isAnimating($element)) {
	        shiftFromAnimationQueue($element, queueData)
	    }
	};
	var getAnimQueueData = function($element) {
	    return $element.data(ANIM_QUEUE_KEY) || []
	};
	var writeAnimQueueData = function($element, queueData) {
	    $element.data(ANIM_QUEUE_KEY, queueData)
	};
	var destroyAnimQueueData = function($element) {
	    $element.removeData(ANIM_QUEUE_KEY)
	};
	var isAnimating = function($element) {
	    return !!$element.data(ANIM_DATA_KEY)
	};
	var shiftFromAnimationQueue = function($element, queueData) {
	    queueData = getAnimQueueData($element);
	    if (!queueData.length) {
	        return
	    }
	    var animation = queueData.shift();
	    if (0 === queueData.length) {
	        destroyAnimQueueData($element)
	    }
	    executeAnimation(animation).done(function() {
	        if (!isAnimating($element)) {
	            shiftFromAnimationQueue($element)
	        }
	    })
	};
	var executeAnimation = function(animation) {
	    animation.setup();
	    if (fx.off || animation.isSynchronous) {
	        animation.start()
	    } else {
	        animation.startTimeout = setTimeout(function() {
	            animation.start()
	        })
	    }
	    return animation.deferred.promise()
	};
	var setupPosition = function($element, config) {
	    if (!config || !config.position) {
	        return
	    }
	    var position = positionUtils.calculate($element, config.position),
	        offset = $element.offset(),
	        currentPosition = $element.position();
	    $.extend(config, {
	        left: position.h.location - offset.left + currentPosition.left,
	        top: position.v.location - offset.top + currentPosition.top
	    });
	    delete config.position
	};
	var setProps = function($element, props) {
	    $.each(props, function(key, value) {
	        try {
	            $element.css(key, value)
	        } catch (e) {}
	    })
	};
	var stop = function(element, jumpToEnd) {
	    var $element = $(element),
	        queueData = getAnimQueueData($element);
	    $.each(queueData, function(_, animation) {
	        animation.config.delay = 0;
	        animation.config.duration = 0;
	        animation.isSynchronous = true
	    });
	    if (!isAnimating($element)) {
	        shiftFromAnimationQueue($element, queueData)
	    }
	    var animation = $element.data(ANIM_DATA_KEY);
	    if (animation) {
	        animation.stop(jumpToEnd)
	    }
	    $element.removeData(ANIM_DATA_KEY);
	    destroyAnimQueueData($element)
	};
	var fx = {
	    off: false,
	    animationTypes: animationConfigurators,
	    animate: animate,
	    createAnimation: createAnimation,
	    isAnimating: isAnimating,
	    stop: stop,
	    _simulatedTransitionEndDelay: 100
	};
	module.exports = fx;
	module.exports.default = module.exports;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (animation/translator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    support = __webpack_require__(48);
	var TRANSLATOR_DATA_KEY = "dxTranslator",
	    TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/,
	    TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
	var locate = function($element) {
	    var translate = support.transform ? getTranslate($element) : getTranslateFallback($element);
	    return {
	        left: translate.x,
	        top: translate.y
	    }
	};
	var move = function($element, position) {
	    if (!support.transform) {
	        $element.css(position);
	        return
	    }
	    var translate, left = position.left,
	        top = position.top;
	    if (void 0 === left) {
	        translate = getTranslate($element);
	        translate.y = top || 0
	    } else {
	        if (void 0 === top) {
	            translate = getTranslate($element);
	            translate.x = left || 0
	        } else {
	            translate = {
	                x: left || 0,
	                y: top || 0,
	                z: 0
	            };
	            cacheTranslate($element, translate)
	        }
	    }
	    $element.css({
	        transform: getTranslateCss(translate)
	    });
	    if (isPercentValue(left) || isPercentValue(top)) {
	        clearCache($element)
	    }
	};
	var isPercentValue = function(value) {
	    return "string" === $.type(value) && "%" === value[value.length - 1]
	};
	var getTranslateFallback = function($element) {
	    var result;
	    try {
	        var originalTop = $element.css("top"),
	            originalLeft = $element.css("left");
	        var position = $element.position();
	        $element.css({
	            transform: "none",
	            top: 0,
	            left: 0
	        });
	        clearCache($element);
	        var finalPosition = $element.position();
	        result = {
	            x: position.left - finalPosition.left || parseInt(originalLeft) || 0,
	            y: position.top - finalPosition.top || parseInt(originalTop) || 0
	        };
	        $element.css({
	            top: originalTop,
	            left: originalLeft
	        })
	    } catch (e) {
	        result = {
	            x: 0,
	            y: 0
	        }
	    }
	    return result
	};
	var getTranslate = function($element) {
	    var result = $element.length ? $.data($element.get(0), TRANSLATOR_DATA_KEY) : null;
	    if (!result) {
	        var transformValue = $element.css("transform") || getTranslateCss({
	                x: 0,
	                y: 0
	            }),
	            matrix = transformValue.match(TRANSFORM_MATRIX_REGEX),
	            is3D = matrix && matrix[1];
	        if (matrix) {
	            matrix = matrix[2].split(",");
	            if ("3d" === is3D) {
	                matrix = matrix.slice(12, 15)
	            } else {
	                matrix.push(0);
	                matrix = matrix.slice(4, 7)
	            }
	        } else {
	            matrix = [0, 0, 0]
	        }
	        result = {
	            x: parseFloat(matrix[0]),
	            y: parseFloat(matrix[1]),
	            z: parseFloat(matrix[2])
	        };
	        cacheTranslate($element, result)
	    }
	    return result
	};
	var cacheTranslate = function($element, translate) {
	    if ($element.length) {
	        $.data($element.get(0), TRANSLATOR_DATA_KEY, translate)
	    }
	};
	var clearCache = function($element) {
	    if ($element.length) {
	        $.removeData($element.get(0), TRANSLATOR_DATA_KEY)
	    }
	};
	var resetPosition = function($element) {
	    $element.css({
	        left: 0,
	        top: 0,
	        transform: "none"
	    });
	    clearCache($element)
	};
	var parseTranslate = function(translateString) {
	    var result = translateString.match(TRANSLATE_REGEX);
	    if (!result || !result[1]) {
	        return
	    }
	    result = result[1].split(",");
	    result = {
	        x: parseFloat(result[0]),
	        y: parseFloat(result[1]),
	        z: parseFloat(result[2])
	    };
	    return result
	};
	var getTranslateCss = function(translate) {
	    translate.x = translate.x || 0;
	    translate.y = translate.y || 0;
	    var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
	    var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
	    return "translate(" + xValueString + ", " + yValueString + ")"
	};
	exports.move = move;
	exports.locate = locate;
	exports.clearCache = clearCache;
	exports.parseTranslate = parseTranslate;
	exports.getTranslate = getTranslate;
	exports.getTranslateCss = getTranslateCss;
	exports.resetPosition = resetPosition;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (animation/position.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    stringUtils = __webpack_require__(7),
	    translator = __webpack_require__(59),
	    support = __webpack_require__(48);
	var horzRe = /left|right/,
	    vertRe = /top|bottom/,
	    collisionRe = /fit|flip|none/;
	var normalizeAlign = function(raw) {
	    var result = {
	        h: "center",
	        v: "center"
	    };
	    var pair = commonUtils.splitPair(raw);
	    if (pair) {
	        $.each(pair, function() {
	            var w = String(this).toLowerCase();
	            if (horzRe.test(w)) {
	                result.h = w
	            } else {
	                if (vertRe.test(w)) {
	                    result.v = w
	                }
	            }
	        })
	    }
	    return result
	};
	var normalizeOffset = function(raw) {
	    return stringUtils.pairToObject(raw)
	};
	var normalizeCollision = function(raw) {
	    var pair = commonUtils.splitPair(raw),
	        h = String(pair && pair[0]).toLowerCase(),
	        v = String(pair && pair[1]).toLowerCase();
	    if (!collisionRe.test(h)) {
	        h = "none"
	    }
	    if (!collisionRe.test(v)) {
	        v = h
	    }
	    return {
	        h: h,
	        v: v
	    }
	};
	var getAlignFactor = function(align) {
	    switch (align) {
	        case "center":
	            return .5;
	        case "right":
	        case "bottom":
	            return 1;
	        default:
	            return 0
	    }
	};
	var inverseAlign = function(align) {
	    switch (align) {
	        case "left":
	            return "right";
	        case "right":
	            return "left";
	        case "top":
	            return "bottom";
	        case "bottom":
	            return "top";
	        default:
	            return align
	    }
	};
	var calculateOversize = function(data, bounds) {
	    var oversize = 0;
	    if (data.myLocation < bounds.min) {
	        oversize += bounds.min - data.myLocation
	    }
	    if (data.myLocation > bounds.max) {
	        oversize += data.myLocation - bounds.max
	    }
	    return oversize
	};
	var collisionSide = function(direction, data, bounds) {
	    if (data.myLocation < bounds.min) {
	        return "h" === direction ? "left" : "top"
	    }
	    if (data.myLocation > bounds.max) {
	        return "h" === direction ? "right" : "bottom"
	    }
	    return "none"
	};
	var initMyLocation = function(data) {
	    data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
	};
	var collisionResolvers = {
	    fit: function(data, bounds) {
	        var result = false;
	        if (data.myLocation > bounds.max) {
	            data.myLocation = bounds.max;
	            result = true
	        }
	        if (data.myLocation < bounds.min) {
	            data.myLocation = bounds.min;
	            result = true
	        }
	        data.fit = result
	    },
	    flip: function(data, bounds) {
	        data.flip = false;
	        if ("center" === data.myAlign && "center" === data.atAlign) {
	            return
	        }
	        if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
	            var inverseData = $.extend({}, data, {
	                myAlign: inverseAlign(data.myAlign),
	                atAlign: inverseAlign(data.atAlign),
	                offset: -data.offset
	            });
	            initMyLocation(inverseData);
	            inverseData.oversize = calculateOversize(inverseData, bounds);
	            if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
	                data.myLocation = inverseData.myLocation;
	                data.oversize = inverseData.oversize;
	                data.flip = true
	            }
	        }
	    },
	    flipfit: function(data, bounds) {
	        this.flip(data, bounds);
	        this.fit(data, bounds)
	    },
	    none: function(data) {
	        data.oversize = 0
	    }
	};
	var scrollbarWidth;
	var calculateScrollbarWidth = function() {
	    var $scrollDiv = $("<div>").css({
	            width: 100,
	            height: 100,
	            overflow: "scroll",
	            position: "absolute",
	            top: -9999
	        }).appendTo($("body")),
	        result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
	    $scrollDiv.remove();
	    scrollbarWidth = result
	};
	var defaultPositionResult = {
	    h: {
	        location: 0,
	        flip: false,
	        fit: false,
	        oversize: 0
	    },
	    v: {
	        location: 0,
	        flip: false,
	        fit: false,
	        oversize: 0
	    }
	};
	var calculatePosition = function(what, options) {
	    var $what = $(what),
	        currentOffset = $what.offset(),
	        result = $.extend(true, {}, defaultPositionResult, {
	            h: {
	                location: currentOffset.left
	            },
	            v: {
	                location: currentOffset.top
	            }
	        });
	    if (!options) {
	        return result
	    }
	    var my = normalizeAlign(options.my),
	        at = normalizeAlign(options.at),
	        of = options.of || window,
	        offset = normalizeOffset(options.offset),
	        collision = normalizeCollision(options.collision),
	        boundary = options.boundary,
	        boundaryOffset = normalizeOffset(options.boundaryOffset);
	    var h = {
	        mySize: $what.outerWidth(),
	        myAlign: my.h,
	        atAlign: at.h,
	        offset: offset.h,
	        collision: collision.h,
	        boundaryOffset: boundaryOffset.h
	    };
	    var v = {
	        mySize: $what.outerHeight(),
	        myAlign: my.v,
	        atAlign: at.v,
	        offset: offset.v,
	        collision: collision.v,
	        boundaryOffset: boundaryOffset.v
	    };
	    if (of.preventDefault) {
	        h.atLocation = of.pageX;
	        v.atLocation = of.pageY;
	        h.atSize = 0;
	        v.atSize = 0
	    } else {
	        of = $(of);
	        if ($.isWindow(of[0])) {
	            h.atLocation = of.scrollLeft();
	            v.atLocation = of.scrollTop();
	            h.atSize = of.width();
	            v.atSize = of.height()
	        } else {
	            if (9 === of[0].nodeType) {
	                h.atLocation = 0;
	                v.atLocation = 0;
	                h.atSize = of.width();
	                v.atSize = of.height()
	            } else {
	                var o = of.offset();
	                h.atLocation = o.left;
	                v.atLocation = o.top;
	                h.atSize = of.outerWidth();
	                v.atSize = of.outerHeight()
	            }
	        }
	    }
	    initMyLocation(h);
	    initMyLocation(v);
	    var bounds = function() {
	        var win = $(window),
	            windowWidth = win.width(),
	            windowHeight = win.height(),
	            left = win.scrollLeft(),
	            top = win.scrollTop(),
	            hScrollbar = document.width > document.documentElement.clientWidth,
	            vScrollbar = document.height > document.documentElement.clientHeight,
	            hZoomLevel = support.touch ? document.documentElement.clientWidth / (vScrollbar ? windowWidth - scrollbarWidth : windowWidth) : 1,
	            vZoomLevel = support.touch ? document.documentElement.clientHeight / (hScrollbar ? windowHeight - scrollbarWidth : windowHeight) : 1;
	        if (void 0 === scrollbarWidth) {
	            calculateScrollbarWidth()
	        }
	        var boundaryWidth = windowWidth,
	            boundaryHeight = windowHeight;
	        if (boundary) {
	            var $boundary = $(boundary),
	                boundaryPosition = $boundary.offset();
	            left = boundaryPosition.left;
	            top = boundaryPosition.top;
	            boundaryWidth = $boundary.width();
	            boundaryHeight = $boundary.height()
	        }
	        return {
	            h: {
	                min: left + h.boundaryOffset,
	                max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
	            },
	            v: {
	                min: top + v.boundaryOffset,
	                max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
	            }
	        }
	    }();
	    h.oversize = calculateOversize(h, bounds.h);
	    v.oversize = calculateOversize(v, bounds.v);
	    h.collisionSide = collisionSide("h", h, bounds.h);
	    v.collisionSide = collisionSide("v", v, bounds.v);
	    if (collisionResolvers[h.collision]) {
	        collisionResolvers[h.collision](h, bounds.h)
	    }
	    if (collisionResolvers[v.collision]) {
	        collisionResolvers[v.collision](v, bounds.v)
	    }
	    var preciser = function(number) {
	        return options.precise ? number : Math.round(number)
	    };
	    $.extend(true, result, {
	        h: {
	            location: preciser(h.myLocation),
	            oversize: preciser(h.oversize),
	            fit: h.fit,
	            flip: h.flip,
	            collisionSide: h.collisionSide
	        },
	        v: {
	            location: preciser(v.myLocation),
	            oversize: preciser(v.oversize),
	            fit: v.fit,
	            flip: v.flip,
	            collisionSide: v.collisionSide
	        },
	        precise: options.precise
	    });
	    return result
	};
	var position = function(what, options) {
	    var $what = $(what);
	    if (!options) {
	        return $what.offset()
	    }
	    translator.resetPosition($what);
	    var offset = $what.offset(),
	        targetPosition = options.h && options.v ? options : calculatePosition($what, options);
	    var preciser = function(number) {
	        return options.precise ? number : Math.round(number)
	    };
	    translator.move($what, {
	        left: targetPosition.h.location - preciser(offset.left),
	        top: targetPosition.v.location - preciser(offset.top)
	    });
	    return targetPosition
	};
	var offset = function(element) {
	    element = $(element).get(0);
	    if ($.isWindow(element)) {
	        return null
	    } else {
	        if (element instanceof $.Event) {
	            return {
	                top: element.pageY,
	                left: element.pageX
	            }
	        }
	    }
	    return $(element).offset()
	};
	$.extend(position, {
	    inverseAlign: inverseAlign,
	    normalizeAlign: normalizeAlign
	});
	module.exports = {
	    calculateScrollbarWidth: calculateScrollbarWidth,
	    calculate: calculatePosition,
	    setup: position,
	    offset: offset
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/utils.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    copyEvent = __webpack_require__(62).copy;
	var eventSource = function() {
	    var EVENT_SOURCES_REGEX = {
	        dx: /^dx/i,
	        mouse: /(mouse|wheel)/i,
	        touch: /^touch/i,
	        keyboard: /^key/i,
	        pointer: /^(ms)?pointer/i
	    };
	    return function(e) {
	        var result = "other";
	        $.each(EVENT_SOURCES_REGEX, function(key) {
	            if (this.test(e.type)) {
	                result = key;
	                return false
	            }
	        });
	        return result
	    }
	}();
	var isDxEvent = function(e) {
	    return "dx" === eventSource(e)
	};
	var isNativeMouseEvent = function(e) {
	    return "mouse" === eventSource(e)
	};
	var isNativeTouchEvent = function(e) {
	    return "touch" === eventSource(e)
	};
	var isPointerEvent = function(e) {
	    return "pointer" === eventSource(e)
	};
	var isMouseEvent = function(e) {
	    return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType
	};
	var isTouchEvent = function(e) {
	    return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType
	};
	var isKeyboardEvent = function(e) {
	    return "keyboard" === eventSource(e)
	};
	var isFakeClickEvent = function(e) {
	    return 0 === e.screenX && !e.offsetX && 0 === e.pageX
	};
	var eventData = function(e) {
	    return {
	        x: e.pageX,
	        y: e.pageY,
	        time: e.timeStamp
	    }
	};
	var eventDelta = function(from, to) {
	    return {
	        x: to.x - from.x,
	        y: to.y - from.y,
	        time: to.time - from.time || 1
	    }
	};
	var hasTouches = function(e) {
	    if (isNativeTouchEvent(e)) {
	        return (e.originalEvent.touches || []).length
	    }
	    if (isDxEvent(e)) {
	        return (e.pointers || []).length
	    }
	    return 0
	};
	var needSkipEvent = function(e) {
	    var $target = $(e.target),
	        touchInInput = $target.is("input, textarea, select");
	    if ($target.is(".dx-skip-gesture-event *, .dx-skip-gesture-event")) {
	        return true
	    }
	    if ("dxmousewheel" === e.type) {
	        return $target.is("input[type='number'], textarea, select") && $target.is(":focus")
	    }
	    if (isMouseEvent(e)) {
	        return touchInInput || e.which > 1
	    }
	    if (isTouchEvent(e)) {
	        return touchInInput && $target.is(":focus")
	    }
	};
	var createEvent = function(originalEvent, args) {
	    var event = copyEvent(originalEvent);
	    if (args) {
	        $.extend(event, args)
	    }
	    return event
	};
	var fireEvent = function(props) {
	    var event = createEvent(props.originalEvent, props);
	    $.event.trigger(event, null, props.delegateTarget || event.target);
	    return event
	};
	var addNamespace = function(eventNames, namespace) {
	    if (!namespace) {
	        throw errors.Error("E0017")
	    }
	    if ("string" === typeof eventNames) {
	        if (eventNames.indexOf(" ") === -1) {
	            return eventNames + "." + namespace
	        }
	        return addNamespace(eventNames.split(/\s+/g), namespace)
	    }
	    $.each(eventNames, function(index, eventName) {
	        eventNames[index] = eventName + "." + namespace
	    });
	    return eventNames.join(" ")
	};
	module.exports = {
	    eventSource: eventSource,
	    isPointerEvent: isPointerEvent,
	    isMouseEvent: isMouseEvent,
	    isTouchEvent: isTouchEvent,
	    isKeyboardEvent: isKeyboardEvent,
	    isFakeClickEvent: isFakeClickEvent,
	    hasTouches: hasTouches,
	    eventData: eventData,
	    eventDelta: eventDelta,
	    needSkipEvent: needSkipEvent,
	    createEvent: createEvent,
	    fireEvent: fireEvent,
	    addNamespace: addNamespace
	};


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/core/hooks.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    compareVersion = __webpack_require__(11).compare,
	    registerEvent = __webpack_require__(63);
	var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
	var touchPropHook = function(name, event) {
	    if (event[name] || !event.touches) {
	        return event[name]
	    }
	    var touches = event.touches.length ? event.touches : event.changedTouches;
	    if (!touches.length) {
	        return
	    }
	    return touches[0][name]
	};
	if (compareVersion($.fn.jquery, [3]) < 0) {
	    var POINTER_TYPE_MAP = {
	        2: "touch",
	        3: "pen",
	        4: "mouse"
	    };
	    $.each(["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel", "MSPointerOver", "MSPointerOut", "mouseenter", "mouseleave", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerout", "pointerenter", "pointerleave"], function() {
	        $.event.fixHooks[this] = {
	            filter: function(event, originalEvent) {
	                var pointerType = originalEvent.pointerType;
	                if ($.isNumeric(pointerType)) {
	                    event.pointerType = POINTER_TYPE_MAP[pointerType]
	                }
	                return event
	            },
	            props: $.event.mouseHooks.props.concat(["pointerId", "pointerType", "originalTarget", "width", "height", "pressure", "result", "tiltX", "charCode", "tiltY", "detail", "isPrimary", "prevValue"])
	        }
	    });
	    $.each(["touchstart", "touchmove", "touchend", "touchcancel"], function() {
	        $.event.fixHooks[this] = {
	            filter: function(event, originalEvent) {
	                $.each(touchPropsToHook, function(_, name) {
	                    event[name] = touchPropHook(name, originalEvent)
	                });
	                return event
	            },
	            props: $.event.mouseHooks.props.concat(["touches", "changedTouches", "targetTouches", "detail", "result", "originalTarget", "charCode", "prevValue"])
	        }
	    });
	    $.event.fixHooks.wheel = $.event.mouseHooks;
	    var DX_EVENT_HOOKS = {
	        props: $.event.mouseHooks.props.concat(["pointerType", "pointerId", "pointers"])
	    };
	    registerEvent.callbacks.add(function(name) {
	        $.event.fixHooks[name] = DX_EVENT_HOOKS
	    });
	    var fix = function(event) {
	        var originalEvent = event.originalEvent;
	        var fixHook = $.event.fixHooks[originalEvent.type] || $.event.mouseHooks;
	        var props = fixHook.props ? $.event.props.concat(fixHook.props) : $.event.props,
	            propIndex = props.length;
	        while (propIndex--) {
	            var prop = props[propIndex];
	            event[prop] = originalEvent[prop]
	        }
	        return fixHook.filter ? fixHook.filter(event, originalEvent) : event
	    };
	    exports.copy = function(originalEvent) {
	        return fix($.Event(originalEvent))
	    }
	} else {
	    $.each(touchPropsToHook, function(_, name) {
	        $.event.addProp(name, function(event) {
	            return touchPropHook(name, event)
	        })
	    });
	    exports.copy = function(originalEvent) {
	        return $.Event(originalEvent, originalEvent)
	    }
	}


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/core/event_registrator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    MemorizedCallbacks = __webpack_require__(45);
	var callbacks = new MemorizedCallbacks;
	var registerEvent = function(name, eventObject) {
	    var strategy = {};
	    if ("noBubble" in eventObject) {
	        strategy.noBubble = eventObject.noBubble
	    }
	    if ("bindType" in eventObject) {
	        strategy.bindType = eventObject.bindType
	    }
	    if ("delegateType" in eventObject) {
	        strategy.delegateType = eventObject.delegateType
	    }
	    $.each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
	        if (!eventObject[methodName]) {
	            return
	        }
	        strategy[methodName] = function() {
	            var args = $.makeArray(arguments);
	            args.unshift(this);
	            return eventObject[methodName].apply(eventObject, args)
	        }
	    });
	    callbacks.fire(name, strategy)
	};
	registerEvent.callbacks = callbacks;
	var registerJQueryEvent = function(name, eventObject) {
	    $.event.special[name] = eventObject
	};
	callbacks.add(registerJQueryEvent);
	module.exports = registerEvent;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (animation/transition_executor/transition_executor.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    fx = __webpack_require__(58),
	    animationPresetsModule = __webpack_require__(57),
	    when = __webpack_require__(10).when;
	var directionPostfixes = {
	        forward: " dx-forward",
	        backward: " dx-backward",
	        none: " dx-no-direction",
	        undefined: " dx-no-direction"
	    },
	    DX_ANIMATING_CLASS = "dx-animating";
	var TransitionExecutor = Class.inherit({
	    ctor: function() {
	        this._accumulatedDelays = {
	            enter: 0,
	            leave: 0
	        };
	        this._animations = [];
	        this.reset()
	    },
	    _createAnimations: function($elements, initialConfig, configModifier, type) {
	        var animationConfig, that = this,
	            result = [];
	        configModifier = configModifier || {};
	        animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
	        if (animationConfig) {
	            $elements.each(function() {
	                var animation = that._createAnimation($(this), animationConfig, configModifier);
	                if (animation) {
	                    animation.element.addClass(DX_ANIMATING_CLASS);
	                    animation.setup();
	                    result.push(animation)
	                }
	            })
	        }
	        return result
	    },
	    _prepareElementAnimationConfig: function(config, configModifier, type) {
	        var result;
	        if ("string" === typeof config) {
	            var presetName = config;
	            config = animationPresetsModule.presets.getPreset(presetName)
	        }
	        if (!config) {
	            result = void 0
	        } else {
	            if ($.isFunction(config[type])) {
	                result = config[type]
	            } else {
	                result = $.extend({
	                    skipElementInitialStyles: true,
	                    cleanupWhen: this._completePromise
	                }, config, configModifier);
	                if (!result.type || "css" === result.type) {
	                    var cssClass = "dx-" + type,
	                        extraCssClasses = (result.extraCssClasses ? " " + result.extraCssClasses : "") + directionPostfixes[result.direction];
	                    result.type = "css";
	                    result.from = (result.from || cssClass) + extraCssClasses;
	                    result.to = result.to || cssClass + "-active"
	                }
	                result.staggerDelay = result.staggerDelay || 0;
	                result.delay = result.delay || 0;
	                if (result.staggerDelay) {
	                    result.delay += this._accumulatedDelays[type];
	                    this._accumulatedDelays[type] += result.staggerDelay
	                }
	            }
	        }
	        return result
	    },
	    _createAnimation: function($element, animationConfig, configModifier) {
	        var result;
	        if ($.isPlainObject(animationConfig)) {
	            result = fx.createAnimation($element, animationConfig)
	        } else {
	            if ($.isFunction(animationConfig)) {
	                result = animationConfig($element, configModifier)
	            }
	        }
	        return result
	    },
	    _startAnimations: function() {
	        var animations = this._animations;
	        for (var i = 0; i < animations.length; i++) {
	            animations[i].start()
	        }
	    },
	    _stopAnimations: function(jumpToEnd) {
	        var animations = this._animations;
	        for (var i = 0; i < animations.length; i++) {
	            animations[i].stop(jumpToEnd)
	        }
	    },
	    _clearAnimations: function() {
	        var animations = this._animations;
	        for (var i = 0; i < animations.length; i++) {
	            animations[i].element.removeClass(DX_ANIMATING_CLASS)
	        }
	        this._animations.length = 0
	    },
	    reset: function() {
	        this._accumulatedDelays.enter = 0;
	        this._accumulatedDelays.leave = 0;
	        this._clearAnimations();
	        this._completeDeferred = $.Deferred();
	        this._completePromise = this._completeDeferred.promise()
	    },
	    enter: function($elements, animationConfig, configModifier) {
	        var animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
	        this._animations.push.apply(this._animations, animations)
	    },
	    leave: function($elements, animationConfig, configModifier) {
	        var animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
	        this._animations.push.apply(this._animations, animations)
	    },
	    start: function() {
	        var result, that = this;
	        if (!this._animations.length) {
	            that.reset();
	            result = $.Deferred().resolve().promise()
	        } else {
	            var animationDeferreds = $.map(this._animations, function(animation) {
	                var result = $.Deferred();
	                animation.deferred.always(function() {
	                    result.resolve()
	                });
	                return result.promise()
	            });
	            result = when.apply($, animationDeferreds).always(function() {
	                that._completeDeferred.resolve();
	                that.reset()
	            });
	            commonUtils.executeAsync(function() {
	                that._startAnimations()
	            })
	        }
	        return result
	    },
	    stop: function(jumpToEnd) {
	        this._stopAnimations(jumpToEnd)
	    }
	});
	exports.TransitionExecutor = TransitionExecutor;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/click.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    domUtils = __webpack_require__(43),
	    animationFrame = __webpack_require__(46),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    Emitter = __webpack_require__(73),
	    registerEmitter = __webpack_require__(74),
	    compareVersions = __webpack_require__(11).compare;
	var CLICK_EVENT_NAME = "dxclick",
	    TOUCH_BOUNDARY = 10,
	    abs = Math.abs;
	var isInput = function(element) {
	    return $(element).is("input, textarea, select, button ,:focus, :focus *")
	};
	var misc = {
	    requestAnimationFrame: animationFrame.requestAnimationFrame
	};
	var ClickEmitter = Emitter.inherit({
	    ctor: function(element) {
	        this.callBase(element);
	        this._makeElementClickable($(element))
	    },
	    _makeElementClickable: function($element) {
	        if (!$element.attr("onclick")) {
	            $element.attr("onclick", "void(0)")
	        }
	    },
	    start: function(e) {
	        this._blurPrevented = e.isDefaultPrevented();
	        this._startTarget = e.target;
	        this._startEventData = eventUtils.eventData(e)
	    },
	    end: function(e) {
	        if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === pointerEvents.cancel) {
	            this._cancel(e);
	            return
	        }
	        if (!isInput(e.target) && !this._blurPrevented) {
	            domUtils.resetActiveElement()
	        }
	        this._accept(e);
	        misc.requestAnimationFrame($.proxy(function() {
	            this._fireClickEvent(e)
	        }, this))
	    },
	    _eventOutOfElement: function(e, element) {
	        var target = e.target,
	            targetChanged = !$.contains(element, target) && element !== target,
	            gestureDelta = eventUtils.eventDelta(eventUtils.eventData(e), this._startEventData),
	            boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
	        return targetChanged || boundsExceeded
	    },
	    _fireClickEvent: function(e) {
	        this._fireEvent(CLICK_EVENT_NAME, e, {
	            target: domUtils.closestCommonParent(this._startTarget, e.target)
	        })
	    }
	});
	! function() {
	    var NATIVE_CLICK_CLASS = "dx-native-click";
	    var realDevice = devices.real(),
	        useNativeClick = realDevice.generic || realDevice.ios && compareVersions(realDevice.version, [9, 3]) >= 0 || realDevice.android && compareVersions(realDevice.version, [5]) >= 0;
	    var isNativeClickEvent = function(e) {
	        return useNativeClick || $(e.target).closest("." + NATIVE_CLICK_CLASS).length
	    };
	    var prevented = null,
	        lastFiredEvent = null;
	    var clickHandler = function(e) {
	        var originalEvent = e.originalEvent,
	            eventAlreadyFired = lastFiredEvent !== originalEvent,
	            leftButton = !e.which || 1 === e.which;
	        if (leftButton && !prevented && isNativeClickEvent(e) && eventAlreadyFired) {
	            lastFiredEvent = originalEvent;
	            eventUtils.fireEvent({
	                type: CLICK_EVENT_NAME,
	                originalEvent: e
	            })
	        }
	    };
	    ClickEmitter = ClickEmitter.inherit({
	        _makeElementClickable: function($element) {
	            this.callBase($element);
	            $element.on("click", clickHandler)
	        },
	        configure: function(data) {
	            this.callBase(data);
	            if (data.useNative) {
	                this.getElement().addClass(NATIVE_CLICK_CLASS)
	            }
	        },
	        start: function(e) {
	            prevented = null;
	            if (!isNativeClickEvent(e)) {
	                this.callBase(e)
	            }
	        },
	        end: function(e) {
	            if (!isNativeClickEvent(e)) {
	                this.callBase(e)
	            }
	        },
	        cancel: function() {
	            prevented = true
	        },
	        dispose: function() {
	            this.callBase();
	            this.getElement().off("click", clickHandler)
	        }
	    })
	}();
	! function() {
	    var desktopDevice = devices.real().generic;
	    if (!desktopDevice) {
	        var startTarget = null,
	            blurPrevented = false;
	        var pointerDownHandler = function(e) {
	            startTarget = e.target;
	            blurPrevented = e.isDefaultPrevented()
	        };
	        var clickHandler = function(e) {
	            var $target = $(e.target);
	            if (!blurPrevented && startTarget && !$target.is(startTarget) && !$(startTarget).is("label") && isInput($target)) {
	                domUtils.resetActiveElement()
	            }
	            startTarget = null;
	            blurPrevented = false
	        };
	        var NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
	        $(document).on(eventUtils.addNamespace(pointerEvents.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler).on(eventUtils.addNamespace("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler)
	    }
	}();
	registerEmitter({
	    emitter: ClickEmitter,
	    bubble: true,
	    events: [CLICK_EVENT_NAME]
	});
	exports.name = CLICK_EVENT_NAME;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/pointer.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    support = __webpack_require__(48),
	    devices = __webpack_require__(40),
	    registerEvent = __webpack_require__(63),
	    TouchStrategy = __webpack_require__(67),
	    MsPointerStrategy = __webpack_require__(69),
	    MouseStrategy = __webpack_require__(71),
	    MouseAndTouchStrategy = __webpack_require__(72);
	var EventStrategy = function() {
	    if (support.pointerEvents) {
	        return MsPointerStrategy
	    }
	    var device = devices.real();
	    if (support.touch && !(device.tablet || device.phone)) {
	        return MouseAndTouchStrategy
	    }
	    if (support.touch) {
	        return TouchStrategy
	    }
	    return MouseStrategy
	}();
	$.each(EventStrategy.map, function(pointerEvent, originalEvents) {
	    registerEvent(pointerEvent, new EventStrategy(pointerEvent, originalEvents))
	});
	module.exports = {
	    down: "dxpointerdown",
	    up: "dxpointerup",
	    move: "dxpointermove",
	    cancel: "dxpointercancel",
	    enter: "dxpointerenter",
	    leave: "dxpointerleave",
	    over: "dxpointerover",
	    out: "dxpointerout"
	};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/pointer/touch.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    BaseStrategy = __webpack_require__(68);
	var eventMap = {
	    dxpointerdown: "touchstart",
	    dxpointermove: "touchmove",
	    dxpointerup: "touchend",
	    dxpointercancel: "touchcancel",
	    dxpointerover: "",
	    dxpointerout: "",
	    dxpointerenter: "",
	    dxpointerleave: ""
	};
	var normalizeTouchEvent = function(e) {
	    var pointers = [];
	    $.each(e.touches, function(_, touch) {
	        pointers.push($.extend({
	            pointerId: touch.identifier
	        }, touch))
	    });
	    return {
	        pointers: pointers,
	        pointerId: e.changedTouches[0].identifier
	    }
	};
	var skipTouchWithSameIdentifier = function(pointerEvent) {
	    return "ios" === devices.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent)
	};
	var TouchStrategy = BaseStrategy.inherit({
	    ctor: function() {
	        this.callBase.apply(this, arguments);
	        this._pointerId = 0
	    },
	    _handler: function(e) {
	        if (skipTouchWithSameIdentifier(this._eventName)) {
	            var touch = e.changedTouches[0];
	            if (this._pointerId === touch.identifier && 0 !== this._pointerId) {
	                return
	            }
	            this._pointerId = touch.identifier
	        }
	        return this.callBase.apply(this, arguments)
	    },
	    _fireEvent: function(args) {
	        return this.callBase($.extend(normalizeTouchEvent(args.originalEvent), args))
	    }
	});
	TouchStrategy.map = eventMap;
	TouchStrategy.normalize = normalizeTouchEvent;
	module.exports = TouchStrategy;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/pointer/base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    browser = __webpack_require__(16),
	    Class = __webpack_require__(18),
	    eventUtils = __webpack_require__(61);
	var POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
	var BaseStrategy = Class.inherit({
	    ctor: function(eventName, originalEvents) {
	        this._eventName = eventName;
	        this._originalEvents = eventUtils.addNamespace(originalEvents, POINTER_EVENTS_NAMESPACE);
	        this._handlerCount = 0;
	        this.noBubble = this._isNoBubble()
	    },
	    _isNoBubble: function() {
	        var eventName = this._eventName;
	        return "dxpointerenter" === eventName || "dxpointerleave" === eventName
	    },
	    _handler: function(e) {
	        var delegateTarget = this._getDelegateTarget(e);
	        return this._fireEvent({
	            type: this._eventName,
	            pointerType: e.pointerType || eventUtils.eventSource(e),
	            originalEvent: e,
	            delegateTarget: delegateTarget,
	            timeStamp: browser.mozilla ? (new Date).getTime() : e.timeStamp
	        })
	    },
	    _getDelegateTarget: function(e) {
	        var delegateTarget;
	        if (this.noBubble) {
	            delegateTarget = e.delegateTarget
	        }
	        return delegateTarget
	    },
	    _fireEvent: function(args) {
	        return eventUtils.fireEvent(args)
	    },
	    setup: function() {
	        return true
	    },
	    add: function(element, handleObj) {
	        if (this._handlerCount <= 0 || this.noBubble) {
	            this._selector = handleObj.selector;
	            element = this.noBubble ? element : document;
	            var that = this;
	            $(element).on(this._originalEvents, this._selector, function(e) {
	                that._handler(e)
	            })
	        }
	        if (!this.noBubble) {
	            this._handlerCount++
	        }
	    },
	    remove: function() {
	        if (!this.noBubble) {
	            this._handlerCount--
	        }
	    },
	    teardown: function(element) {
	        if (this._handlerCount && !this.noBubble) {
	            return
	        }
	        element = this.noBubble ? element : document;
	        if (this._originalEvents !== "." + POINTER_EVENTS_NAMESPACE) {
	            $(element).off(this._originalEvents, this._selector)
	        }
	    },
	    dispose: function(element) {
	        element = this.noBubble ? element : document;
	        $(element).off(this._originalEvents)
	    }
	});
	module.exports = BaseStrategy;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/pointer/mspointer.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    BaseStrategy = __webpack_require__(68),
	    Observer = __webpack_require__(70),
	    browser = __webpack_require__(16);
	var isIE10 = browser.msie && 10 === parseInt(browser.version);
	var eventMap = {
	    dxpointerdown: "MSPointerDown pointerdown",
	    dxpointermove: "MSPointerMove pointermove",
	    dxpointerup: "MSPointerUp pointerup",
	    dxpointercancel: "MSPointerCancel pointercancel",
	    dxpointerover: "MSPointerOver pointerover",
	    dxpointerout: "MSPointerOut pointerout",
	    dxpointerenter: isIE10 ? "mouseenter" : "MSPointerEnter pointerenter",
	    dxpointerleave: isIE10 ? "mouseleave" : "MSPointerLeave pointerleave"
	};
	var observer;
	var activated = false;
	var activateStrategy = function() {
	    if (activated) {
	        return
	    }
	    observer = new Observer(eventMap, function(a, b) {
	        return a.pointerId === b.pointerId
	    }, function(e) {
	        if (e.isPrimary) {
	            observer.reset()
	        }
	    });
	    activated = true
	};
	var MsPointerStrategy = BaseStrategy.inherit({
	    ctor: function() {
	        this.callBase.apply(this, arguments);
	        activateStrategy()
	    },
	    _fireEvent: function(args) {
	        return this.callBase($.extend({
	            pointers: observer.pointers(),
	            pointerId: args.originalEvent.pointerId
	        }, args))
	    }
	});
	MsPointerStrategy.map = eventMap;
	MsPointerStrategy.resetObserver = function() {
	    observer.reset()
	};
	module.exports = MsPointerStrategy;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/pointer/observer.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var addEventsListener = function(events, handler) {
	    events = events.split(" ");
	    $.each(events, function(_, event) {
	        if (document.addEventListener) {
	            document.addEventListener(event, handler, true)
	        } else {
	            document.attachEvent("on" + event, handler)
	        }
	    })
	};
	var Observer = function(eventMap, pointerEquals, onPointerAdding) {
	    onPointerAdding = onPointerAdding || function() {};
	    var pointers = [];
	    var getPointerIndex = function(e) {
	        var index = -1;
	        $.each(pointers, function(i, pointer) {
	            if (!pointerEquals(e, pointer)) {
	                return true
	            }
	            index = i;
	            return false
	        });
	        return index
	    };
	    var addPointer = function(e) {
	        if (getPointerIndex(e) === -1) {
	            onPointerAdding(e);
	            pointers.push(e)
	        }
	    };
	    var removePointer = function(e) {
	        var index = getPointerIndex(e);
	        if (index > -1) {
	            pointers.splice(index, 1)
	        }
	    };
	    var updatePointer = function(e) {
	        pointers[getPointerIndex(e)] = e
	    };
	    addEventsListener(eventMap.dxpointerdown, addPointer);
	    addEventsListener(eventMap.dxpointermove, updatePointer);
	    addEventsListener(eventMap.dxpointerup, removePointer);
	    addEventsListener(eventMap.dxpointercancel, removePointer);
	    this.pointers = function() {
	        return pointers
	    };
	    this.reset = function() {
	        pointers = []
	    }
	};
	module.exports = Observer;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/pointer/mouse.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    BaseStrategy = __webpack_require__(68),
	    Observer = __webpack_require__(70);
	var eventMap = {
	    dxpointerdown: "mousedown",
	    dxpointermove: "mousemove",
	    dxpointerup: "mouseup",
	    dxpointercancel: "",
	    dxpointerover: "mouseover",
	    dxpointerout: "mouseout",
	    dxpointerenter: "mouseenter",
	    dxpointerleave: "mouseleave"
	};
	var normalizeMouseEvent = function(e) {
	    e.pointerId = 1;
	    return {
	        pointers: observer.pointers(),
	        pointerId: 1
	    }
	};
	var observer;
	var activated = false;
	var activateStrategy = function() {
	    if (activated) {
	        return
	    }
	    observer = new Observer(eventMap, function() {
	        return true
	    });
	    activated = true
	};
	var MouseStrategy = BaseStrategy.inherit({
	    ctor: function() {
	        this.callBase.apply(this, arguments);
	        activateStrategy()
	    },
	    _fireEvent: function(args) {
	        return this.callBase($.extend(normalizeMouseEvent(args.originalEvent), args))
	    }
	});
	MouseStrategy.map = eventMap;
	MouseStrategy.normalize = normalizeMouseEvent;
	MouseStrategy.activate = activateStrategy;
	MouseStrategy.resetObserver = function() {
	    observer.reset()
	};
	module.exports = MouseStrategy;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/pointer/mouse_and_touch.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    BaseStrategy = __webpack_require__(68),
	    MouseStrategy = __webpack_require__(71),
	    TouchStrategy = __webpack_require__(67),
	    eventUtils = __webpack_require__(61);
	var eventMap = {
	    dxpointerdown: "touchstart mousedown",
	    dxpointermove: "touchmove mousemove",
	    dxpointerup: "touchend mouseup",
	    dxpointercancel: "touchcancel",
	    dxpointerover: "mouseover",
	    dxpointerout: "mouseout",
	    dxpointerenter: "mouseenter",
	    dxpointerleave: "mouseleave"
	};
	var activated = false;
	var activateStrategy = function() {
	    if (activated) {
	        return
	    }
	    MouseStrategy.activate();
	    activated = true
	};
	var MouseAndTouchStrategy = BaseStrategy.inherit({
	    EVENT_LOCK_TIMEOUT: 100,
	    ctor: function() {
	        this.callBase.apply(this, arguments);
	        activateStrategy()
	    },
	    _handler: function(e) {
	        var isMouseEvent = eventUtils.isMouseEvent(e);
	        if (!isMouseEvent) {
	            this._skipNextEvents = true
	        }
	        if (isMouseEvent && this._mouseLocked) {
	            return
	        }
	        if (isMouseEvent && this._skipNextEvents) {
	            this._skipNextEvents = false;
	            this._mouseLocked = true;
	            clearTimeout(this._unlockMouseTimer);
	            var that = this;
	            this._unlockMouseTimer = setTimeout(function() {
	                that._mouseLocked = false
	            }, this.EVENT_LOCK_TIMEOUT);
	            return
	        }
	        return this.callBase(e)
	    },
	    _fireEvent: function(args) {
	        var isMouseEvent = eventUtils.isMouseEvent(args.originalEvent),
	            normalizer = isMouseEvent ? MouseStrategy.normalize : TouchStrategy.normalize;
	        return this.callBase($.extend(normalizer(args.originalEvent), args))
	    },
	    dispose: function() {
	        this.callBase();
	        this._skipNextEvents = false;
	        this._mouseLocked = false;
	        clearTimeout(this._unlockMouseTimer)
	    }
	});
	MouseAndTouchStrategy.map = eventMap;
	MouseAndTouchStrategy.resetObserver = MouseStrategy.resetObserver;
	module.exports = MouseAndTouchStrategy;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/core/emitter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    eventUtils = __webpack_require__(61);
	var Emitter = Class.inherit({
	    ctor: function(element) {
	        this._$element = $(element);
	        this._cancelCallback = $.Callbacks();
	        this._acceptCallback = $.Callbacks()
	    },
	    getElement: function() {
	        return this._$element
	    },
	    validate: function(e) {
	        return "dxmousewheel" !== e.type
	    },
	    validatePointers: function(e) {
	        return 1 === eventUtils.hasTouches(e)
	    },
	    allowInterruptionByMouseWheel: function() {
	        return true
	    },
	    configure: function(data) {
	        $.extend(this, data)
	    },
	    addCancelCallback: function(callback) {
	        this._cancelCallback.add(callback)
	    },
	    removeCancelCallback: function() {
	        this._cancelCallback.empty()
	    },
	    _cancel: function(e) {
	        this._cancelCallback.fire(this, e)
	    },
	    addAcceptCallback: function(callback) {
	        this._acceptCallback.add(callback)
	    },
	    removeAcceptCallback: function() {
	        this._acceptCallback.empty()
	    },
	    _accept: function(e) {
	        this._acceptCallback.fire(this, e)
	    },
	    _requestAccept: function(e) {
	        this._acceptRequestEvent = e
	    },
	    _forgetAccept: function() {
	        this._accept(this._acceptRequestEvent);
	        this._acceptRequestEvent = null
	    },
	    start: $.noop,
	    move: $.noop,
	    end: $.noop,
	    cancel: $.noop,
	    reset: function() {
	        if (this._acceptRequestEvent) {
	            this._accept(this._acceptRequestEvent)
	        }
	    },
	    _fireEvent: function(eventName, e, params) {
	        var eventData = $.extend({
	            type: eventName,
	            originalEvent: e,
	            target: this._getEmitterTarget(e),
	            delegateTarget: this.getElement().get(0)
	        }, params);
	        e = eventUtils.fireEvent(eventData);
	        if (e.cancel) {
	            this._cancel(e)
	        }
	        return e
	    },
	    _getEmitterTarget: function(e) {
	        return (this.delegateSelector ? $(e.target).closest(this.delegateSelector) : this.getElement()).get(0)
	    },
	    dispose: $.noop
	});
	module.exports = Emitter;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/core/emitter_registrator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    registerEvent = __webpack_require__(63),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    wheelEvent = __webpack_require__(75);
	var MANAGER_EVENT = "dxEventManager",
	    EMITTER_DATA = "dxEmitter";
	var EventManager = Class.inherit({
	    ctor: function() {
	        this._attachHandlers();
	        this.reset();
	        this._proxiedCancelHandler = $.proxy(this._cancelHandler, this);
	        this._proxiedAcceptHandler = $.proxy(this._acceptHandler, this)
	    },
	    _attachHandlers: function() {
	        $(document).on(eventUtils.addNamespace(pointerEvents.down, MANAGER_EVENT), $.proxy(this._pointerDownHandler, this)).on(eventUtils.addNamespace(pointerEvents.move, MANAGER_EVENT), $.proxy(this._pointerMoveHandler, this)).on(eventUtils.addNamespace([pointerEvents.up, pointerEvents.cancel].join(" "), MANAGER_EVENT), $.proxy(this._pointerUpHandler, this)).on(eventUtils.addNamespace(wheelEvent.name, MANAGER_EVENT), $.proxy(this._mouseWheelHandler, this))
	    },
	    _eachEmitter: function(callback) {
	        var activeEmitters = this._activeEmitters || [];
	        var i = 0;
	        while (activeEmitters.length > i) {
	            var emitter = activeEmitters[i];
	            if (false === callback(emitter)) {
	                break
	            }
	            if (activeEmitters[i] === emitter) {
	                i++
	            }
	        }
	    },
	    _applyToEmitters: function(method, arg) {
	        this._eachEmitter(function(emitter) {
	            emitter[method].call(emitter, arg)
	        })
	    },
	    reset: function() {
	        this._eachEmitter(this._proxiedCancelHandler);
	        this._activeEmitters = []
	    },
	    resetEmitter: function(emitter) {
	        this._proxiedCancelHandler(emitter)
	    },
	    _pointerDownHandler: function(e) {
	        if (eventUtils.isMouseEvent(e) && e.which > 1) {
	            return
	        }
	        this._updateEmitters(e)
	    },
	    _updateEmitters: function(e) {
	        if (!this._isSetChanged(e)) {
	            return
	        }
	        this._cleanEmitters(e);
	        this._fetchEmitters(e)
	    },
	    _isSetChanged: function(e) {
	        var currentSet = this._closestEmitter(e);
	        var previousSet = this._emittersSet || [];
	        var setChanged = currentSet.length !== previousSet.length;
	        $.each(currentSet, function(index, emitter) {
	            setChanged = setChanged || previousSet[index] !== emitter;
	            return !setChanged
	        });
	        this._emittersSet = currentSet;
	        return setChanged
	    },
	    _closestEmitter: function(e) {
	        var that = this,
	            result = [],
	            $element = $(e.target);

	        function handleEmitter(_, emitter) {
	            if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
	                emitter.addCancelCallback(that._proxiedCancelHandler);
	                emitter.addAcceptCallback(that._proxiedAcceptHandler);
	                result.push(emitter)
	            }
	        }
	        while ($element.length) {
	            var emitters = $.data($element.get(0), EMITTER_DATA) || [];
	            $.each(emitters, handleEmitter);
	            $element = $element.parent()
	        }
	        return result
	    },
	    _acceptHandler: function(acceptedEmitter, e) {
	        var that = this;
	        this._eachEmitter(function(emitter) {
	            if (emitter !== acceptedEmitter) {
	                that._cancelEmitter(emitter, e)
	            }
	        })
	    },
	    _cancelHandler: function(canceledEmitter, e) {
	        this._cancelEmitter(canceledEmitter, e)
	    },
	    _cancelEmitter: function(emitter, e) {
	        var activeEmitters = this._activeEmitters;
	        if (e) {
	            emitter.cancel(e)
	        } else {
	            emitter.reset()
	        }
	        emitter.removeCancelCallback();
	        emitter.removeAcceptCallback();
	        var emitterIndex = $.inArray(emitter, activeEmitters);
	        if (emitterIndex > -1) {
	            activeEmitters.splice(emitterIndex, 1)
	        }
	    },
	    _cleanEmitters: function(e) {
	        this._applyToEmitters("end", e);
	        this.reset(e)
	    },
	    _fetchEmitters: function(e) {
	        this._activeEmitters = this._emittersSet.slice();
	        this._applyToEmitters("start", e)
	    },
	    _pointerMoveHandler: function(e) {
	        this._applyToEmitters("move", e)
	    },
	    _pointerUpHandler: function(e) {
	        this._updateEmitters(e)
	    },
	    _mouseWheelHandler: function(e) {
	        if (!this._allowInterruptionByMouseWheel()) {
	            return
	        }
	        e.pointers = [null];
	        this._pointerDownHandler(e);
	        this._adjustWheelEvent(e);
	        this._pointerMoveHandler(e);
	        e.pointers = [];
	        this._pointerUpHandler(e)
	    },
	    _allowInterruptionByMouseWheel: function() {
	        var allowInterruption = true;
	        this._eachEmitter(function(emitter) {
	            allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
	            return allowInterruption
	        });
	        return allowInterruption
	    },
	    _adjustWheelEvent: function(e) {
	        var closestGestureEmitter = null;
	        this._eachEmitter(function(emitter) {
	            if (!emitter.gesture) {
	                return
	            }
	            var direction = emitter.getDirection(e);
	            if ("horizontal" !== direction && !e.shiftKey || "vertical" !== direction && e.shiftKey) {
	                closestGestureEmitter = emitter;
	                return false
	            }
	        });
	        if (!closestGestureEmitter) {
	            return
	        }
	        var direction = closestGestureEmitter.getDirection(e),
	            verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction,
	            prop = verticalGestureDirection ? "pageY" : "pageX";
	        e[prop] += e.delta
	    },
	    isActive: function(element) {
	        var result = false;
	        this._eachEmitter(function(emitter) {
	            result = result || emitter.getElement().is(element)
	        });
	        return result
	    }
	});
	var eventManager = new EventManager;
	var EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
	var registerEmitter = function(emitterConfig) {
	    var emitterClass = emitterConfig.emitter,
	        emitterName = emitterConfig.events[0],
	        emitterEvents = emitterConfig.events;
	    $.each(emitterEvents, function(_, eventName) {
	        registerEvent(eventName, {
	            noBubble: !emitterConfig.bubble,
	            setup: function(element) {
	                var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA) || {},
	                    emitters = $.data(element, EMITTER_DATA) || {},
	                    emitter = emitters[emitterName] || new emitterClass(element);
	                subscriptions[eventName] = true;
	                emitters[emitterName] = emitter;
	                $.data(element, EMITTER_DATA, emitters);
	                $.data(element, EMITTER_SUBSCRIPTION_DATA, subscriptions)
	            },
	            add: function(element, handleObj) {
	                var emitters = $.data(element, EMITTER_DATA),
	                    emitter = emitters[emitterName];
	                emitter.configure($.extend({
	                    delegateSelector: handleObj.selector
	                }, handleObj.data), handleObj.type)
	            },
	            teardown: function(element) {
	                var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA),
	                    emitters = $.data(element, EMITTER_DATA),
	                    emitter = emitters[emitterName];
	                delete subscriptions[eventName];
	                var disposeEmitter = true;
	                $.each(emitterEvents, function(_, eventName) {
	                    disposeEmitter = disposeEmitter && !subscriptions[eventName];
	                    return disposeEmitter
	                });
	                if (disposeEmitter) {
	                    if (eventManager.isActive(element)) {
	                        eventManager.resetEmitter(emitter)
	                    }
	                    emitter && emitter.dispose();
	                    delete emitters[emitterName]
	                }
	            }
	        })
	    })
	};
	module.exports = registerEmitter;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/core/wheel.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerEvent = __webpack_require__(63),
	    eventUtils = __webpack_require__(61);
	var EVENT_NAME = "dxmousewheel",
	    EVENT_NAMESPACE = "dxWheel";
	var wheelEvent = void 0 !== document.onwheel ? "wheel" : "mousewheel";
	var wheel = {
	    setup: function(element) {
	        var $element = $(element);
	        $element.on(eventUtils.addNamespace(wheelEvent, EVENT_NAMESPACE), $.proxy(wheel._wheelHandler, wheel))
	    },
	    teardown: function(element) {
	        var $element = $(element);
	        $element.off("." + EVENT_NAMESPACE)
	    },
	    _wheelHandler: function(e) {
	        var delta = this._getWheelDelta(e.originalEvent);
	        eventUtils.fireEvent({
	            type: EVENT_NAME,
	            originalEvent: e,
	            delta: delta,
	            pointerType: "mouse"
	        });
	        e.stopPropagation()
	    },
	    _getWheelDelta: function(event) {
	        return event.wheelDelta ? event.wheelDelta : 30 * -event.deltaY
	    }
	};
	registerEvent(EVENT_NAME, wheel);
	exports.name = EVENT_NAME;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/gesture/emitter.gesture.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    support = __webpack_require__(48),
	    browser = __webpack_require__(16),
	    domUtils = __webpack_require__(43),
	    mathUtils = __webpack_require__(77),
	    commonUtils = __webpack_require__(8),
	    eventUtils = __webpack_require__(61),
	    Emitter = __webpack_require__(73),
	    sign = mathUtils.sign,
	    abs = Math.abs;
	var SLEEP = 0,
	    INITED = 1,
	    STARTED = 2,
	    TOUCH_BOUNDARY = 10,
	    IMMEDIATE_TOUCH_BOUNDARY = 0,
	    IMMEDIATE_TIMEOUT = 180;
	var isMouseWheelEvent = function(e) {
	    return e && "dxmousewheel" === e.type
	};
	var supportPointerEvents = function() {
	    var cssSupport = support.styleProp("pointer-events");
	    var msieLess11 = browser.msie && parseInt(browser.version, 10) < 11;
	    return cssSupport && !msieLess11
	};
	var gestureCover = function() {
	    var GESTURE_COVER_CLASS = "dx-gesture-cover";
	    var isDesktop = "generic" === devices.real().platform;
	    if (!supportPointerEvents() || !isDesktop) {
	        return $.noop
	    }
	    var $cover = $("<div>").addClass(GESTURE_COVER_CLASS).css("pointerEvents", "none");
	    $cover.on("dxmousewheel", function(e) {
	        e.preventDefault()
	    });
	    domUtils.ready(function() {
	        $cover.appendTo("body")
	    });
	    return function(toggle, cursor) {
	        $cover.css("pointerEvents", toggle ? "all" : "none");
	        toggle && $cover.css("cursor", cursor)
	    }
	}();
	var GestureEmitter = Emitter.inherit({
	    gesture: true,
	    configure: function(data) {
	        this.getElement().css("msTouchAction", data.immediate ? "pinch-zoom" : "");
	        this.callBase(data)
	    },
	    allowInterruptionByMouseWheel: function() {
	        return this._stage !== STARTED
	    },
	    getDirection: function() {
	        return this.direction
	    },
	    _cancel: function() {
	        this.callBase.apply(this, arguments);
	        this._toggleGestureCover(false);
	        this._stage = SLEEP
	    },
	    start: function(e) {
	        if (eventUtils.needSkipEvent(e)) {
	            this._cancel(e);
	            return
	        }
	        this._startEvent = eventUtils.createEvent(e);
	        this._startEventData = eventUtils.eventData(e);
	        this._stage = INITED;
	        this._init(e);
	        this._setupImmediateTimer()
	    },
	    _setupImmediateTimer: function() {
	        clearTimeout(this._immediateTimer);
	        this._immediateAccepted = false;
	        if (!this.immediate) {
	            return
	        }
	        this._immediateTimer = setTimeout($.proxy(function() {
	            this._immediateAccepted = true
	        }, this), IMMEDIATE_TIMEOUT)
	    },
	    move: function(e) {
	        if (this._stage === INITED && this._directionConfirmed(e)) {
	            this._stage = STARTED;
	            this._resetActiveElement();
	            this._toggleGestureCover(true);
	            this._clearSelection(e);
	            this._adjustStartEvent(e);
	            this._start(this._startEvent);
	            if (this._stage === SLEEP) {
	                return
	            }
	            this._requestAccept(e);
	            this._move(e);
	            this._forgetAccept()
	        } else {
	            if (this._stage === STARTED) {
	                this._clearSelection(e);
	                this._move(e)
	            }
	        }
	    },
	    _directionConfirmed: function(e) {
	        var touchBoundary = this._getTouchBoundary(e),
	            delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e)),
	            deltaX = abs(delta.x),
	            deltaY = abs(delta.y);
	        var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY),
	            verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
	        var direction = this.getDirection(e),
	            bothAccepted = "both" === direction && (horizontalMove || verticalMove),
	            horizontalAccepted = "horizontal" === direction && horizontalMove,
	            verticalAccepted = "vertical" === direction && verticalMove;
	        return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted
	    },
	    _validateMove: function(touchBoundary, mainAxis, crossAxis) {
	        return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)
	    },
	    _getTouchBoundary: function(e) {
	        return this.immediate || isMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY
	    },
	    _adjustStartEvent: function(e) {
	        var touchBoundary = this._getTouchBoundary(e),
	            delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
	        this._startEvent.pageX += sign(delta.x) * touchBoundary;
	        this._startEvent.pageY += sign(delta.y) * touchBoundary
	    },
	    _resetActiveElement: function() {
	        if ("ios" === devices.real().platform && $(":focus", this.getElement()).length) {
	            domUtils.resetActiveElement()
	        }
	    },
	    _toggleGestureCover: function(toggle) {
	        var isStarted = this._stage === STARTED;
	        if (isStarted) {
	            gestureCover(toggle, this.getElement().css("cursor"))
	        }
	    },
	    _clearSelection: function(e) {
	        if (isMouseWheelEvent(e) || eventUtils.isTouchEvent(e)) {
	            return
	        }
	        domUtils.clearSelection()
	    },
	    end: function(e) {
	        this._toggleGestureCover(false);
	        if (this._stage === STARTED) {
	            this._end(e)
	        } else {
	            if (this._stage === INITED) {
	                this._stop(e)
	            }
	        }
	        this._stage = SLEEP
	    },
	    dispose: function() {
	        clearTimeout(this._immediateTimer);
	        this.callBase.apply(this, arguments);
	        this._toggleGestureCover(false)
	    },
	    _init: $.noop,
	    _start: $.noop,
	    _move: $.noop,
	    _stop: $.noop,
	    _end: $.noop
	});
	GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
	GestureEmitter.touchBoundary = function(newBoundary) {
	    if (commonUtils.isDefined(newBoundary)) {
	        TOUCH_BOUNDARY = newBoundary;
	        return
	    }
	    return TOUCH_BOUNDARY
	};
	module.exports = GestureEmitter;


/***/ },
/* 77 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (core/utils/math.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var sign = function(value) {
	    if (0 === value) {
	        return 0
	    }
	    return value / Math.abs(value)
	};
	var fitIntoRange = function(value, minValue, maxValue) {
	    return Math.min(Math.max(value, minValue), maxValue)
	};
	exports.sign = sign;
	exports.fitIntoRange = fitIntoRange;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (localization.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	exports.locale = __webpack_require__(56).locale;
	exports.loadMessages = __webpack_require__(79).load;
	exports.message = __webpack_require__(79);
	exports.number = __webpack_require__(20);
	exports.date = __webpack_require__(55);
	exports.currency = __webpack_require__(22);


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (localization/message.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    dependencyInjector = __webpack_require__(21),
	    stringFormat = __webpack_require__(7).format,
	    humanize = __webpack_require__(49).humanize,
	    coreLocalization = __webpack_require__(56);
	__webpack_require__(56);
	var baseDictionary = $.extend(true, {}, __webpack_require__(80));
	var newMessages = {};
	var messageLocalization = dependencyInjector({
	    _dictionary: baseDictionary,
	    load: function(messages) {
	        $.extend(true, this._dictionary, messages)
	    },
	    _localizablePrefix: "@",
	    setup: function(localizablePrefix) {
	        this._localizablePrefix = localizablePrefix
	    },
	    localizeString: function(text) {
	        var that = this,
	            regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g"),
	            escapeString = that._localizablePrefix + that._localizablePrefix;
	        return text.replace(regex, function(str, prefix, escape, localizationKey) {
	            var result, defaultResult = that._localizablePrefix + localizationKey;
	            if (escape !== escapeString) {
	                result = that.format(localizationKey)
	            }
	            if (!result) {
	                newMessages[localizationKey] = humanize(localizationKey)
	            }
	            return prefix + (result || defaultResult)
	        })
	    },
	    _messageLoaded: function(key, locale) {
	        return void 0 !== this._dictionary[locale || coreLocalization.locale()][key]
	    },
	    localizeNode: function(node) {
	        var that = this;
	        $(node).each(function(index, nodeItem) {
	            if (!nodeItem.nodeType) {
	                return
	            }
	            if (3 === nodeItem.nodeType) {
	                nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue)
	            } else {
	                if (!$(nodeItem).is("iframe")) {
	                    $.each(nodeItem.attributes || [], function(index, attr) {
	                        if ("string" === typeof attr.value) {
	                            var localizedValue = that.localizeString(attr.value);
	                            if (attr.value !== localizedValue) {
	                                attr.value = localizedValue
	                            }
	                        }
	                    });
	                    $(nodeItem).contents().each(function(index, node) {
	                        that.localizeNode(node)
	                    })
	                }
	            }
	        })
	    },
	    getMessagesByLocales: function() {
	        return this._dictionary
	    },
	    getDictionary: function(onlyNew) {
	        if (onlyNew) {
	            return newMessages
	        }
	        return $.extend({}, newMessages, this.getMessagesByLocales()[coreLocalization.locale()])
	    },
	    getFormatter: function(key) {
	        return this._getFormatterBase(key) || this._getFormatterBase(key, "en")
	    },
	    _getFormatterBase: function(key, locale) {
	        var localeMessages = this._dictionary[locale || coreLocalization.locale()],
	            message = localeMessages && localeMessages[key];
	        if (message) {
	            return function() {
	                var args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
	                args.unshift(message);
	                return stringFormat.apply(this, args)
	            }
	        }
	    },
	    format: function(key) {
	        var formatter = this.getFormatter(key);
	        return formatter && formatter() || ""
	    }
	});
	module.exports = messageLocalization;


/***/ },
/* 80 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (localization/default_messages.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = {
	    en: {
	        Yes: "Yes",
	        No: "No",
	        Cancel: "Cancel",
	        Clear: "Clear",
	        Done: "Done",
	        Loading: "Loading...",
	        Select: "Select...",
	        Search: "Search",
	        Back: "Back",
	        OK: "OK",
	        "dxCollectionWidget-noDataText": "No data to display",
	        "validation-required": "Required",
	        "validation-required-formatted": "{0} is required",
	        "validation-numeric": "Value must be a number",
	        "validation-numeric-formatted": "{0} must be a number",
	        "validation-range": "Value is out of range",
	        "validation-range-formatted": "{0} is out of range",
	        "validation-stringLength": "The length of the value is not correct",
	        "validation-stringLength-formatted": "The length of {0} is not correct",
	        "validation-custom": "Value is invalid",
	        "validation-custom-formatted": "{0} is invalid",
	        "validation-compare": "Values do not match",
	        "validation-compare-formatted": "{0} does not match",
	        "validation-pattern": "Value does not match pattern",
	        "validation-pattern-formatted": "{0} does not match pattern",
	        "validation-email": "Email is invalid",
	        "validation-email-formatted": "{0} is invalid",
	        "validation-mask": "Value is invalid",
	        "dxLookup-searchPlaceholder": "Minimum character number: {0}",
	        "dxList-pullingDownText": "Pull down to refresh...",
	        "dxList-pulledDownText": "Release to refresh...",
	        "dxList-refreshingText": "Refreshing...",
	        "dxList-pageLoadingText": "Loading...",
	        "dxList-nextButtonText": "More",
	        "dxList-selectAll": "Select All",
	        "dxListEditDecorator-delete": "Delete",
	        "dxListEditDecorator-more": "More",
	        "dxScrollView-pullingDownText": "Pull down to refresh...",
	        "dxScrollView-pulledDownText": "Release to refresh...",
	        "dxScrollView-refreshingText": "Refreshing...",
	        "dxScrollView-reachBottomText": "Loading...",
	        "dxDateBox-simulatedDataPickerTitleTime": "Select time",
	        "dxDateBox-simulatedDataPickerTitleDate": "Select date",
	        "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
	        "dxDateBox-validation-datetime": "Value must be a date or time",
	        "dxFileUploader-selectFile": "Select file",
	        "dxFileUploader-dropFile": "or Drop file here",
	        "dxFileUploader-bytes": "bytes",
	        "dxFileUploader-kb": "kb",
	        "dxFileUploader-Mb": "Mb",
	        "dxFileUploader-Gb": "Gb",
	        "dxFileUploader-upload": "Upload",
	        "dxFileUploader-uploaded": "Uploaded",
	        "dxFileUploader-readyToUpload": "Ready to upload",
	        "dxFileUploader-uploadFailedMessage": "Upload failed",
	        "dxRangeSlider-ariaFrom": "From",
	        "dxRangeSlider-ariaTill": "Till",
	        "dxSwitch-onText": "ON",
	        "dxSwitch-offText": "OFF",
	        "dxForm-optionalMark": "optional",
	        "dxForm-requiredMessage": "{0} is required",
	        "dxNumberBox-invalidValueMessage": "Value must be a number",
	        "dxDataGrid-columnChooserTitle": "Column Chooser",
	        "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
	        "dxDataGrid-groupContinuesMessage": "Continues on the next page",
	        "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
	        "dxDataGrid-groupHeaderText": "Group by This Column",
	        "dxDataGrid-ungroupHeaderText": "Ungroup",
	        "dxDataGrid-ungroupAllText": "Ungroup All",
	        "dxDataGrid-editingEditRow": "Edit",
	        "dxDataGrid-editingSaveRowChanges": "Save",
	        "dxDataGrid-editingCancelRowChanges": "Cancel",
	        "dxDataGrid-editingDeleteRow": "Delete",
	        "dxDataGrid-editingUndeleteRow": "Undelete",
	        "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
	        "dxDataGrid-validationCancelChanges": "Cancel changes",
	        "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
	        "dxDataGrid-noDataText": "No data",
	        "dxDataGrid-searchPanelPlaceholder": "Search...",
	        "dxDataGrid-filterRowShowAllText": "(All)",
	        "dxDataGrid-filterRowResetOperationText": "Reset",
	        "dxDataGrid-filterRowOperationEquals": "Equals",
	        "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
	        "dxDataGrid-filterRowOperationLess": "Less than",
	        "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
	        "dxDataGrid-filterRowOperationGreater": "Greater than",
	        "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
	        "dxDataGrid-filterRowOperationStartsWith": "Starts with",
	        "dxDataGrid-filterRowOperationContains": "Contains",
	        "dxDataGrid-filterRowOperationNotContains": "Does not contain",
	        "dxDataGrid-filterRowOperationEndsWith": "Ends with",
	        "dxDataGrid-filterRowOperationBetween": "Between",
	        "dxDataGrid-filterRowOperationBetweenStartText": "Start",
	        "dxDataGrid-filterRowOperationBetweenEndText": "End",
	        "dxDataGrid-applyFilterText": "Apply filter",
	        "dxDataGrid-trueText": "true",
	        "dxDataGrid-falseText": "false",
	        "dxDataGrid-sortingAscendingText": "Sort Ascending",
	        "dxDataGrid-sortingDescendingText": "Sort Descending",
	        "dxDataGrid-sortingClearText": "Clear Sorting",
	        "dxDataGrid-editingSaveAllChanges": "Save changes",
	        "dxDataGrid-editingCancelAllChanges": "Discard changes",
	        "dxDataGrid-editingAddRow": "Add a row",
	        "dxDataGrid-summaryMin": "Min: {0}",
	        "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
	        "dxDataGrid-summaryMax": "Max: {0}",
	        "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
	        "dxDataGrid-summaryAvg": "Avg: {0}",
	        "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
	        "dxDataGrid-summarySum": "Sum: {0}",
	        "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
	        "dxDataGrid-summaryCount": "Count: {0}",
	        "dxDataGrid-columnFixingFix": "Fix",
	        "dxDataGrid-columnFixingUnfix": "Unfix",
	        "dxDataGrid-columnFixingLeftPosition": "To the left",
	        "dxDataGrid-columnFixingRightPosition": "To the right",
	        "dxDataGrid-exportTo": "Export",
	        "dxDataGrid-exportToExcel": "Export to Excel file",
	        "dxDataGrid-excelFormat": "Excel file",
	        "dxDataGrid-selectedRows": "Selected rows",
	        "dxDataGrid-exportSelectedRows": "Export selected rows",
	        "dxDataGrid-exportAll": "Export all data",
	        "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
	        "dxDataGrid-headerFilterOK": "OK",
	        "dxDataGrid-headerFilterCancel": "Cancel",
	        "dxDataGrid-ariaColumn": "Column",
	        "dxDataGrid-ariaValue": "Value",
	        "dxDataGrid-ariaFilterCell": "Filter cell",
	        "dxDataGrid-ariaCollapse": "Collapse",
	        "dxDataGrid-ariaExpand": "Expand",
	        "dxDataGrid-ariaDataGrid": "Data grid",
	        "dxDataGrid-ariaSearchInGrid": "Search in data grid",
	        "dxDataGrid-ariaSelectAll": "Select all",
	        "dxDataGrid-ariaSelectRow": "Select row",
	        "dxPager-infoText": "Page {0} of {1} ({2} items)",
	        "dxPager-pagesCountText": "of",
	        "dxPivotGrid-grandTotal": "Grand Total",
	        "dxPivotGrid-total": "{0} Total",
	        "dxPivotGrid-fieldChooserTitle": "Field Chooser",
	        "dxPivotGrid-showFieldChooser": "Show Field Chooser",
	        "dxPivotGrid-expandAll": "Expand All",
	        "dxPivotGrid-collapseAll": "Collapse All",
	        "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
	        "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
	        "dxPivotGrid-removeAllSorting": "Remove All Sorting",
	        "dxPivotGrid-rowFields": "Row Fields",
	        "dxPivotGrid-columnFields": "Column Fields",
	        "dxPivotGrid-dataFields": "Data Fields",
	        "dxPivotGrid-filterFields": "Filter Fields",
	        "dxPivotGrid-allFields": "All Fields",
	        "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
	        "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
	        "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
	        "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
	        "dxScheduler-editorLabelTitle": "Subject",
	        "dxScheduler-editorLabelStartDate": "Start Date",
	        "dxScheduler-editorLabelEndDate": "End Date",
	        "dxScheduler-editorLabelDescription": "Description",
	        "dxScheduler-editorLabelRecurrence": "Repeat",
	        "dxScheduler-openAppointment": "Open appointment",
	        "dxScheduler-recurrenceNever": "Never",
	        "dxScheduler-recurrenceDaily": "Daily",
	        "dxScheduler-recurrenceWeekly": "Weekly",
	        "dxScheduler-recurrenceMonthly": "Monthly",
	        "dxScheduler-recurrenceYearly": "Yearly",
	        "dxScheduler-recurrenceEvery": "Every",
	        "dxScheduler-recurrenceEnd": "End repeat",
	        "dxScheduler-recurrenceAfter": "After",
	        "dxScheduler-recurrenceOn": "On",
	        "dxScheduler-recurrenceRepeatDaily": "day(s)",
	        "dxScheduler-recurrenceRepeatWeekly": "week(s)",
	        "dxScheduler-recurrenceRepeatMonthly": "month(s)",
	        "dxScheduler-recurrenceRepeatYearly": "year(s)",
	        "dxScheduler-switcherDay": "Day",
	        "dxScheduler-switcherWeek": "Week",
	        "dxScheduler-switcherWorkWeek": "Work Week",
	        "dxScheduler-switcherMonth": "Month",
	        "dxScheduler-switcherAgenda": "Agenda",
	        "dxScheduler-switcherTimelineDay": "Timeline Day",
	        "dxScheduler-switcherTimelineWeek": "Timeline Week",
	        "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
	        "dxScheduler-switcherTimelineMonth": "Timeline Month",
	        "dxScheduler-recurrenceRepeatOnDate": "on date",
	        "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
	        "dxScheduler-allDay": "All day",
	        "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
	        "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
	        "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
	        "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
	        "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
	        "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
	        "dxScheduler-noTimezoneTitle": "No timezone",
	        "dxCalendar-todayButtonText": "Today",
	        "dxCalendar-ariaWidgetName": "Calendar",
	        "dxColorView-ariaRed": "Red",
	        "dxColorView-ariaGreen": "Green",
	        "dxColorView-ariaBlue": "Blue",
	        "dxColorView-ariaAlpha": "Transparency",
	        "dxColorView-ariaHex": "Color code",
	        "vizExport-printingButtonText": "Print",
	        "vizExport-titleMenuText": "Exporting/Printing",
	        "vizExport-exportButtonText": "{0} file"
	    }
	};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var ko = __webpack_require__(82);
	if (ko) {
	    var errors = __webpack_require__(3),
	        compareVersion = __webpack_require__(11).compare;
	    if (compareVersion(ko.version, [2, 3]) < 0) {
	        throw errors.Error("E0013")
	    }
	    __webpack_require__(83);
	    __webpack_require__(102);
	    __webpack_require__(103);
	    __webpack_require__(105);
	    __webpack_require__(107);
	    __webpack_require__(108);
	    __webpack_require__(109)
	}


/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = window.ko;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/component_registrator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ko = __webpack_require__(82),
	    registerComponent = __webpack_require__(44),
	    Widget = __webpack_require__(84),
	    KoTemplate = __webpack_require__(94),
	    Editor = __webpack_require__(95),
	    Locker = __webpack_require__(101);
	var LOCKS_DATA_KEY = "dxKoLocks",
	    CREATED_WITH_KO_DATA_KEY = "dxKoCreation",
	    DX_POLYMORPH_WIDGET_TEMPLATE = "<!-- ko dxPolymorphWidget: { name: $data.widget, options: $data.options } --><!-- /ko -->";
	var editorsBindingHandlers = [];
	var registerComponentKoBinding = function(componentName, componentClass) {
	    if (componentClass.subclassOf(Editor)) {
	        editorsBindingHandlers.push(componentName)
	    }
	    ko.bindingHandlers[componentName] = {
	        init: function(domNode, valueAccessor) {
	            var component, $element = $(domNode),
	                optionChangedCallbacks = $.Callbacks(),
	                optionsByReference = {},
	                ctorOptions = {
	                    onInitializing: function() {
	                        optionsByReference = this._getOptionsByReference();
	                        ko.computed(function() {
	                            var model = ko.unwrap(valueAccessor());
	                            if (component) {
	                                component.beginUpdate()
	                            }
	                            unwrapModel(model);
	                            if (component) {
	                                component.endUpdate()
	                            }
	                        }, null, {
	                            disposeWhenNodeIsRemoved: domNode
	                        });
	                        component = this
	                    },
	                    modelByElement: function($element) {
	                        if ($element.length) {
	                            return ko.dataFor($element.get(0))
	                        }
	                    },
	                    nestedComponentOptions: function(component) {
	                        return {
	                            modelByElement: component.option("modelByElement"),
	                            nestedComponentOptions: component.option("nestedComponentOptions")
	                        }
	                    },
	                    _optionChangedCallbacks: optionChangedCallbacks,
	                    integrationOptions: {
	                        watchMethod: function(fn, callback, options) {
	                            options = options || {};
	                            var skipCallback = options.skipImmediate;
	                            var watcher = ko.computed(function() {
	                                var newValue = ko.unwrap(fn());
	                                if (!skipCallback) {
	                                    callback(newValue)
	                                }
	                                skipCallback = false
	                            });
	                            return function() {
	                                watcher.dispose()
	                            }
	                        },
	                        templates: {
	                            "dx-polymorph-widget": new KoTemplate(DX_POLYMORPH_WIDGET_TEMPLATE, this)
	                        },
	                        createTemplate: function(element) {
	                            return new KoTemplate(element)
	                        }
	                    }
	                },
	                optionNameToModelMap = {};
	            var applyModelValueToOption = function(optionName, modelValue) {
	                var locks = $element.data(LOCKS_DATA_KEY),
	                    optionValue = ko.unwrap(modelValue);
	                if (ko.isWriteableObservable(modelValue)) {
	                    optionNameToModelMap[optionName] = modelValue
	                }
	                if (component) {
	                    if (locks.locked(optionName)) {
	                        return
	                    }
	                    locks.obtain(optionName);
	                    try {
	                        if (ko.ignoreDependencies) {
	                            ko.ignoreDependencies(component.option, component, [optionName, optionValue])
	                        } else {
	                            component.option(optionName, optionValue)
	                        }
	                    } finally {
	                        locks.release(optionName)
	                    }
	                } else {
	                    ctorOptions[optionName] = optionValue
	                }
	            };
	            var handleOptionChanged = function(args) {
	                var optionName = args.fullName,
	                    optionValue = args.value;
	                if (!(optionName in optionNameToModelMap)) {
	                    return
	                }
	                var $element = this._$element,
	                    locks = $element.data(LOCKS_DATA_KEY);
	                if (locks.locked(optionName)) {
	                    return
	                }
	                locks.obtain(optionName);
	                try {
	                    optionNameToModelMap[optionName](optionValue)
	                } finally {
	                    locks.release(optionName)
	                }
	            };
	            var createComponent = function() {
	                optionChangedCallbacks.add(handleOptionChanged);
	                $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new Locker)[componentName](ctorOptions);
	                ctorOptions = null
	            };
	            var unwrapModelValue = function(currentModel, propertyName, propertyPath) {
	                var unwrappedPropertyValue;
	                ko.computed(function() {
	                    var propertyValue = currentModel[propertyName];
	                    applyModelValueToOption(propertyPath, propertyValue);
	                    unwrappedPropertyValue = ko.unwrap(propertyValue)
	                }, null, {
	                    disposeWhenNodeIsRemoved: domNode
	                });
	                if ($.isPlainObject(unwrappedPropertyValue)) {
	                    if (!optionsByReference[propertyPath]) {
	                        unwrapModel(unwrappedPropertyValue, propertyPath)
	                    }
	                }
	            };
	            var unwrapModel = function(model, propertyPath) {
	                for (var propertyName in model) {
	                    if (model.hasOwnProperty(propertyName)) {
	                        unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join(".") : propertyName)
	                    }
	                }
	            };
	            createComponent();
	            return {
	                controlsDescendantBindings: componentClass.subclassOf(Widget)
	            }
	        }
	    };
	    if ("dxValidator" === componentName) {
	        ko.bindingHandlers.dxValidator.after = editorsBindingHandlers
	    }
	};
	registerComponent.callbacks.add(function(name, componentClass) {
	    registerComponentKoBinding(name, componentClass)
	});


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/ui.widget.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(15),
	    Action = __webpack_require__(34),
	    commonUtils = __webpack_require__(8),
	    domUtils = __webpack_require__(43),
	    devices = __webpack_require__(40),
	    DOMComponent = __webpack_require__(28),
	    Template = __webpack_require__(85),
	    FunctionTemplate = __webpack_require__(87),
	    EmptyTemplate = __webpack_require__(88),
	    ChildDefaultTemplate = __webpack_require__(89),
	    KeyboardProcessor = __webpack_require__(90),
	    selectors = __webpack_require__(91),
	    eventUtils = __webpack_require__(61),
	    hoverEvents = __webpack_require__(92),
	    feedbackEvents = __webpack_require__(93),
	    clickEvent = __webpack_require__(65),
	    inflector = __webpack_require__(49);
	var UI_FEEDBACK = "UIFeedback",
	    WIDGET_CLASS = "dx-widget",
	    ACTIVE_STATE_CLASS = "dx-state-active",
	    DISABLED_STATE_CLASS = "dx-state-disabled",
	    INVISIBLE_STATE_CLASS = "dx-state-invisible",
	    HOVER_STATE_CLASS = "dx-state-hover",
	    FOCUSED_STATE_CLASS = "dx-state-focused",
	    FEEDBACK_SHOW_TIMEOUT = 30,
	    FEEDBACK_HIDE_TIMEOUT = 400,
	    FOCUS_NAMESPACE = "Focus",
	    ANONYMOUS_TEMPLATE_NAME = "template",
	    TEXT_NODE = 3,
	    TEMPLATE_SELECTOR = "[data-options*='dxTemplate']",
	    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
	var DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate(function(options) {
	    var widgetName = options.model.widget;
	    if (widgetName) {
	        var widgetElement = $("<div>"),
	            widgetOptions = options.model.options || {};
	        if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
	            var deprecatedName = widgetName;
	            widgetName = inflector.camelize("dx-" + widgetName);
	            errors.log("W0001", "dxToolbar - 'widget' item field", deprecatedName, "16.1", "Use: '" + widgetName + "' instead")
	        }
	        widgetElement[widgetName](widgetOptions);
	        return widgetElement
	    }
	    return $()
	});
	var beforeActivateExists = void 0 !== document.onbeforeactivate;
	var Widget = DOMComponent.inherit({
	    _supportedKeys: function() {
	        return {}
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            disabled: false,
	            visible: true,
	            hint: void 0,
	            activeStateEnabled: false,
	            onContentReady: null,
	            hoverStateEnabled: false,
	            focusStateEnabled: false,
	            tabIndex: 0,
	            accessKey: null,
	            onFocusIn: null,
	            onFocusOut: null,
	            integrationOptions: {
	                watchMethod: function(fn, callback, options) {
	                    options = options || {};
	                    if (!options.skipImmediate) {
	                        callback(fn())
	                    }
	                    return $.noop
	                },
	                templates: {
	                    "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
	                },
	                createTemplate: function(element) {
	                    return new Template(element)
	                }
	            },
	            _keyboardProcessor: void 0
	        })
	    },
	    _feedbackShowTimeout: FEEDBACK_SHOW_TIMEOUT,
	    _feedbackHideTimeout: FEEDBACK_HIDE_TIMEOUT,
	    _init: function() {
	        this.callBase();
	        this._tempTemplates = [];
	        this._defaultTemplates = {};
	        this._initTemplates();
	        this._initContentReadyAction()
	    },
	    _initTemplates: function() {
	        this._extractTemplates();
	        this._extractAnonymousTemplate()
	    },
	    _extractTemplates: function() {
	        var templates = this.option("integrationOptions.templates"),
	            templateElements = this.element().contents().filter(TEMPLATE_SELECTOR);
	        var templatesMap = {};
	        templateElements.each(function(_, template) {
	            var templateOptions = domUtils.getElementOptions(template).dxTemplate;
	            if (!templateOptions) {
	                return
	            }
	            if (!templateOptions.name) {
	                throw errors.Error("E0023")
	            }
	            $(template).addClass(TEMPLATE_WRAPPER_CLASS).detach();
	            templatesMap[templateOptions.name] = templatesMap[templateOptions.name] || [];
	            templatesMap[templateOptions.name].push(template)
	        });
	        $.each(templatesMap, $.proxy(function(templateName, value) {
	            var deviceTemplate = this._findTemplateByDevice(value);
	            if (deviceTemplate) {
	                templates[templateName] = this._createTemplate(deviceTemplate)
	            }
	        }, this))
	    },
	    _findTemplateByDevice: function(templates) {
	        var suitableTemplate = commonUtils.findBestMatches(devices.current(), templates, function(template) {
	            return domUtils.getElementOptions(template).dxTemplate
	        })[0];
	        $.each(templates, function(index, template) {
	            if (template !== suitableTemplate) {
	                $(template).remove()
	            }
	        });
	        return suitableTemplate
	    },
	    _extractAnonymousTemplate: function() {
	        var templates = this.option("integrationOptions.templates"),
	            anonymousTemplateName = this._getAnonymousTemplateName(),
	            $anonymousTemplate = this.element().contents().detach();
	        var $notJunkTemplateContent = $anonymousTemplate.filter(function(_, element) {
	                var isTextNode = element.nodeType === TEXT_NODE,
	                    isEmptyText = $.trim($(element).text()).length < 1;
	                return !(isTextNode && isEmptyText)
	            }),
	            onlyJunkTemplateContent = $notJunkTemplateContent.length < 1;
	        if (!templates[anonymousTemplateName] && !onlyJunkTemplateContent) {
	            templates[anonymousTemplateName] = this._createTemplate($anonymousTemplate)
	        }
	    },
	    _getAriaTarget: function() {
	        return this._focusTarget()
	    },
	    _getAnonymousTemplateName: function() {
	        return ANONYMOUS_TEMPLATE_NAME
	    },
	    _getTemplateByOption: function(optionName) {
	        return this._getTemplate(this.option(optionName))
	    },
	    _getTemplate: function(templateSource) {
	        if ($.isFunction(templateSource)) {
	            return new FunctionTemplate(function(options) {
	                var templateSourceResult = templateSource.apply(this, this._getNormalizedTemplateArgs(options));
	                if (!commonUtils.isDefined(templateSourceResult)) {
	                    return new EmptyTemplate
	                }
	                var dispose = false;
	                var template = this._acquireTemplate(templateSourceResult, function(templateSource) {
	                    if (templateSource.nodeType || templateSource.jquery && !$(templateSource).is("script")) {
	                        return new FunctionTemplate(function() {
	                            return templateSource
	                        })
	                    }
	                    dispose = true;
	                    return this._createTemplate(templateSource)
	                }.bind(this));
	                var result = template.render(options);
	                dispose && template.dispose && template.dispose();
	                return result
	            }.bind(this))
	        }
	        return this._acquireTemplate(templateSource, function(templateSource) {
	            var template = this._createTemplate(templateSource);
	            this._tempTemplates.push(template);
	            return template
	        }.bind(this))
	    },
	    _acquireTemplate: function(templateSource, createTemplate) {
	        if (null == templateSource) {
	            return new EmptyTemplate
	        }
	        if (templateSource instanceof ChildDefaultTemplate) {
	            return this._defaultTemplates[templateSource.name]
	        }
	        if (commonUtils.isFunction(templateSource.render)) {
	            return templateSource
	        }
	        if (templateSource.nodeType || templateSource.jquery) {
	            templateSource = $(templateSource);
	            return createTemplate(templateSource)
	        }
	        if ("string" === typeof templateSource) {
	            var userTemplate = this.option("integrationOptions.templates")[templateSource];
	            if (userTemplate) {
	                return userTemplate
	            }
	            var dynamicTemplate = this._defaultTemplates[templateSource];
	            if (dynamicTemplate) {
	                return dynamicTemplate
	            }
	            return createTemplate(templateSource)
	        }
	        return this._acquireTemplate(templateSource.toString(), createTemplate)
	    },
	    _createTemplate: function(templateSource) {
	        templateSource = "string" === typeof templateSource ? domUtils.normalizeTemplateElement(templateSource) : templateSource;
	        return this.option("integrationOptions.createTemplate")(templateSource)
	    },
	    _getNormalizedTemplateArgs: function(options) {
	        var args = [];
	        if ("model" in options) {
	            args.push(options.model)
	        }
	        if ("index" in options) {
	            args.push(options.index)
	        }
	        args.push(options.container);
	        return args
	    },
	    _cleanTemplates: function() {
	        $.each(this._tempTemplates, function(_, template) {
	            template.dispose && template.dispose()
	        })
	    },
	    _initContentReadyAction: function() {
	        this._contentReadyAction = this._createActionByOption("onContentReady", {
	            excludeValidators: ["designMode", "disabled", "readOnly"]
	        })
	    },
	    _render: function() {
	        this.element().addClass(WIDGET_CLASS);
	        this.callBase();
	        this._toggleDisabledState(this.option("disabled"));
	        this._toggleVisibility(this.option("visible"));
	        this._renderHint();
	        this._renderContent();
	        this._renderFocusState();
	        this._attachFeedbackEvents();
	        this._attachHoverEvents()
	    },
	    _renderHint: function() {
	        domUtils.toggleAttr(this.element(), "title", this.option("hint"))
	    },
	    _renderContent: function() {
	        var that = this;
	        commonUtils.deferRender(function() {
	            that._renderContentImpl()
	        });
	        that._fireContentReadyAction()
	    },
	    _renderContentImpl: $.noop,
	    _fireContentReadyAction: function() {
	        this._contentReadyAction()
	    },
	    _dispose: function() {
	        this._cleanTemplates();
	        this._contentReadyAction = null;
	        this.callBase()
	    },
	    _clean: function() {
	        this._cleanFocusState();
	        this.callBase();
	        this.element().empty()
	    },
	    _toggleVisibility: function(visible) {
	        this.element().toggleClass(INVISIBLE_STATE_CLASS, !visible);
	        this.setAria("hidden", !visible || void 0)
	    },
	    _renderFocusState: function() {
	        if (!this.option("focusStateEnabled") || this.option("disabled")) {
	            return
	        }
	        this._renderFocusTarget();
	        this._attachFocusEvents();
	        this._attachKeyboardEvents();
	        this._renderAccessKey()
	    },
	    _renderAccessKey: function() {
	        var focusTarget = this._focusTarget();
	        focusTarget.attr("accesskey", this.option("accessKey"));
	        var clickNamespace = eventUtils.addNamespace(clickEvent.name, UI_FEEDBACK);
	        focusTarget.off(clickNamespace);
	        this.option("accessKey") && focusTarget.on(clickNamespace, $.proxy(function(e) {
	            if (eventUtils.isFakeClickEvent(e)) {
	                e.stopImmediatePropagation();
	                this.focus()
	            }
	        }, this))
	    },
	    _eventBindingTarget: function() {
	        return this.element()
	    },
	    _focusTarget: function() {
	        return this._getActiveElement()
	    },
	    _getActiveElement: function() {
	        var activeElement = this._eventBindingTarget();
	        if (this._activeStateUnit) {
	            activeElement = activeElement.find(this._activeStateUnit).not("." + DISABLED_STATE_CLASS)
	        }
	        return activeElement
	    },
	    _renderFocusTarget: function() {
	        this._focusTarget().attr("tabindex", this.option("tabIndex"))
	    },
	    _keyboardEventBindingTarget: function() {
	        return this._eventBindingTarget()
	    },
	    _detachFocusEvents: function() {
	        var $element = this._focusTarget(),
	            namespace = this.NAME + FOCUS_NAMESPACE,
	            focusEvents = eventUtils.addNamespace("focusin", namespace);
	        focusEvents = focusEvents + " " + eventUtils.addNamespace("focusout", namespace);
	        if (beforeActivateExists) {
	            focusEvents = focusEvents + " " + eventUtils.addNamespace("beforeactivate", namespace)
	        }
	        $element.off(focusEvents)
	    },
	    _attachFocusEvents: function() {
	        var namespace = this.NAME + FOCUS_NAMESPACE,
	            focusInEvent = eventUtils.addNamespace("focusin", namespace),
	            focusOutEvent = eventUtils.addNamespace("focusout", namespace);
	        this._focusTarget().on(focusInEvent, $.proxy(this._focusInHandler, this)).on(focusOutEvent, $.proxy(this._focusOutHandler, this));
	        if (beforeActivateExists) {
	            var beforeActivateEvent = eventUtils.addNamespace("beforeactivate", namespace);
	            this._focusTarget().on(beforeActivateEvent, function(e) {
	                if (!$(e.target).is(selectors.focusable)) {
	                    e.preventDefault()
	                }
	            })
	        }
	    },
	    _refreshFocusEvent: function() {
	        this._detachFocusEvents();
	        this._attachFocusEvents()
	    },
	    _focusInHandler: function(e) {
	        var that = this;
	        that._createActionByOption("onFocusIn", {
	            beforeExecute: function() {
	                that._updateFocusState(e, true)
	            },
	            excludeValidators: ["readOnly"]
	        })({
	            jQueryEvent: e
	        })
	    },
	    _focusOutHandler: function(e) {
	        var that = this;
	        that._createActionByOption("onFocusOut", {
	            beforeExecute: function() {
	                that._updateFocusState(e, false)
	            },
	            excludeValidators: ["readOnly", "disabled"]
	        })({
	            jQueryEvent: e
	        })
	    },
	    _updateFocusState: function(e, isFocused) {
	        var target = e.target;
	        if ($.inArray(target, this._focusTarget()) !== -1) {
	            this._toggleFocusClass(isFocused, $(target))
	        }
	    },
	    _toggleFocusClass: function(isFocused, $element) {
	        var $focusTarget = $element && $element.length ? $element : this._focusTarget();
	        $focusTarget.toggleClass(FOCUSED_STATE_CLASS, isFocused)
	    },
	    _hasFocusClass: function(element) {
	        var $focusTarget = $(element || this._focusTarget());
	        return $focusTarget.hasClass(FOCUSED_STATE_CLASS)
	    },
	    _attachKeyboardEvents: function() {
	        var processor = this.option("_keyboardProcessor") || new KeyboardProcessor({
	            element: this._keyboardEventBindingTarget(),
	            focusTarget: this._focusTarget()
	        });
	        this._keyboardProcessor = processor.reinitialize(this._keyboardHandler, this)
	    },
	    _keyboardHandler: function(options) {
	        var e = options.originalEvent,
	            key = options.key;
	        var keys = this._supportedKeys(),
	            func = keys[key];
	        if (void 0 !== func) {
	            var handler = $.proxy(func, this);
	            return handler(e) || false
	        } else {
	            return true
	        }
	    },
	    _refreshFocusState: function() {
	        this._cleanFocusState();
	        this._renderFocusState()
	    },
	    _cleanFocusState: function() {
	        var $element = this._focusTarget();
	        this._detachFocusEvents();
	        this._toggleFocusClass(false);
	        $element.removeAttr("tabindex");
	        if (this._keyboardProcessor) {
	            this._keyboardProcessor.dispose()
	        }
	    },
	    _attachHoverEvents: function() {
	        var that = this,
	            hoverableSelector = that._activeStateUnit,
	            nameStart = eventUtils.addNamespace(hoverEvents.start, UI_FEEDBACK),
	            nameEnd = eventUtils.addNamespace(hoverEvents.end, UI_FEEDBACK);
	        that._eventBindingTarget().off(nameStart, hoverableSelector).off(nameEnd, hoverableSelector);
	        if (that.option("hoverStateEnabled")) {
	            var startAction = new Action(function(args) {
	                that._hoverStartHandler(args.event);
	                var $target = args.element;
	                that._refreshHoveredElement($target)
	            }, {
	                excludeValidators: ["readOnly"]
	            });
	            that._eventBindingTarget().on(nameStart, hoverableSelector, function(e) {
	                startAction.execute({
	                    element: $(e.target),
	                    event: e
	                })
	            }).on(nameEnd, hoverableSelector, function(e) {
	                that._hoverEndHandler(e);
	                that._forgetHoveredElement()
	            })
	        } else {
	            that._toggleHoverClass(false)
	        }
	    },
	    _hoverStartHandler: $.noop,
	    _hoverEndHandler: $.noop,
	    _attachFeedbackEvents: function() {
	        var feedbackAction, feedbackActionDisabled, that = this,
	            feedbackSelector = that._activeStateUnit,
	            activeEventName = eventUtils.addNamespace(feedbackEvents.active, UI_FEEDBACK),
	            inactiveEventName = eventUtils.addNamespace(feedbackEvents.inactive, UI_FEEDBACK);
	        that._eventBindingTarget().off(activeEventName, feedbackSelector).off(inactiveEventName, feedbackSelector);
	        if (that.option("activeStateEnabled")) {
	            var feedbackActionHandler = function(args) {
	                var $element = args.element,
	                    value = args.value,
	                    jQueryEvent = args.jQueryEvent;
	                that._toggleActiveState($element, value, jQueryEvent)
	            };
	            that._eventBindingTarget().on(activeEventName, feedbackSelector, {
	                timeout: that._feedbackShowTimeout
	            }, function(e) {
	                feedbackAction = feedbackAction || new Action(feedbackActionHandler);
	                feedbackAction.execute({
	                    element: $(e.currentTarget),
	                    value: true,
	                    jQueryEvent: e
	                })
	            }).on(inactiveEventName, feedbackSelector, {
	                timeout: that._feedbackHideTimeout
	            }, function(e) {
	                feedbackActionDisabled = feedbackActionDisabled || new Action(feedbackActionHandler, {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                feedbackActionDisabled.execute({
	                    element: $(e.currentTarget),
	                    value: false,
	                    jQueryEvent: e
	                })
	            })
	        }
	    },
	    _toggleActiveState: function($element, value) {
	        this._toggleHoverClass(!value);
	        $element.toggleClass(ACTIVE_STATE_CLASS, value)
	    },
	    _refreshHoveredElement: function(hoveredElement) {
	        var selector = this._activeStateUnit || this._eventBindingTarget();
	        this._forgetHoveredElement();
	        this._hoveredElement = hoveredElement.closest(selector);
	        this._toggleHoverClass(true)
	    },
	    _forgetHoveredElement: function() {
	        this._toggleHoverClass(false);
	        delete this._hoveredElement
	    },
	    _toggleHoverClass: function(value) {
	        if (this._hoveredElement) {
	            this._hoveredElement.toggleClass(HOVER_STATE_CLASS, value && this.option("hoverStateEnabled"))
	        }
	    },
	    _toggleDisabledState: function(value) {
	        this.element().toggleClass(DISABLED_STATE_CLASS, Boolean(value));
	        this._toggleHoverClass(!value);
	        this.setAria("disabled", value || void 0)
	    },
	    _setWidgetOption: function(widgetName, args) {
	        if (!this[widgetName]) {
	            return
	        }
	        if ($.isPlainObject(args[0])) {
	            $.each(args[0], $.proxy(function(option, value) {
	                this._setWidgetOption(widgetName, [option, value])
	            }, this));
	            return
	        }
	        var optionName = args[0];
	        var value = args[1];
	        if (1 === args.length) {
	            value = this.option(optionName)
	        }
	        var widgetOptionMap = this[widgetName + "OptionMap"];
	        this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "disabled":
	                this._toggleDisabledState(args.value);
	                this._refreshFocusState();
	                break;
	            case "hint":
	                this._renderHint();
	                break;
	            case "activeStateEnabled":
	                this._attachFeedbackEvents();
	                break;
	            case "hoverStateEnabled":
	                this._attachHoverEvents();
	                break;
	            case "tabIndex":
	            case "_keyboardProcessor":
	            case "focusStateEnabled":
	                this._refreshFocusState();
	                break;
	            case "onFocusIn":
	            case "onFocusOut":
	                break;
	            case "accessKey":
	                this._renderAccessKey();
	                break;
	            case "visible":
	                var visible = args.value;
	                this._toggleVisibility(visible);
	                if (this._isVisibilityChangeSupported()) {
	                    this._checkVisibilityChanged(args.value ? "shown" : "hiding")
	                }
	                break;
	            case "onContentReady":
	                this._initContentReadyAction();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _isVisible: function() {
	        return this.callBase() && this.option("visible")
	    },
	    beginUpdate: function() {
	        this._ready(false);
	        this.callBase()
	    },
	    endUpdate: function() {
	        this.callBase();
	        if (this._initialized) {
	            this._ready(true)
	        }
	    },
	    _ready: function(value) {
	        if (0 === arguments.length) {
	            return this._isReady
	        }
	        this._isReady = value
	    },
	    setAria: function() {
	        var setAttribute = function(option) {
	            var attrName = "role" === option.name || "id" === option.name ? option.name : "aria-" + option.name,
	                attrValue = option.value;
	            if (null === attrValue || void 0 === attrValue) {
	                attrValue = void 0
	            } else {
	                attrValue = attrValue.toString()
	            }
	            domUtils.toggleAttr(option.target, attrName, attrValue)
	        };
	        if (!$.isPlainObject(arguments[0])) {
	            setAttribute({
	                name: arguments[0],
	                value: arguments[1],
	                target: arguments[2] || this._getAriaTarget()
	            })
	        } else {
	            var $target = arguments[1] || this._getAriaTarget();
	            $.each(arguments[0], function(key, value) {
	                setAttribute({
	                    name: key,
	                    value: value,
	                    target: $target
	                })
	            })
	        }
	    },
	    isReady: function() {
	        return this._ready()
	    },
	    repaint: function() {
	        this._refresh()
	    },
	    focus: function() {
	        this._focusTarget().focus()
	    },
	    registerKeyHandler: function(key, handler) {
	        var currentKeys = this._supportedKeys(),
	            addingKeys = {};
	        addingKeys[key] = handler;
	        this._supportedKeys = function() {
	            return $.extend(currentKeys, addingKeys)
	        }
	    }
	});
	module.exports = Widget;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/jquery.template.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    commonUtils = __webpack_require__(8),
	    TemplateBase = __webpack_require__(86),
	    domUtils = __webpack_require__(43);
	var templateEngines = {};
	var registerTemplateEngine = function(name, templateEngine) {
	    templateEngines[name] = templateEngine
	};
	var outerHtml = function(element) {
	    element = $(element);
	    var templateTag = element.length && element[0].nodeName.toLowerCase();
	    if ("script" === templateTag) {
	        return element.html()
	    } else {
	        element = $("<div>").append(element);
	        return element.html()
	    }
	};
	registerTemplateEngine("default", {
	    compile: function(element) {
	        return domUtils.normalizeTemplateElement(element)
	    },
	    render: function(template) {
	        return template.clone()
	    }
	});
	registerTemplateEngine("jquery-tmpl", {
	    compile: function(element) {
	        return outerHtml(element)
	    },
	    render: function(template, data) {
	        return $.tmpl(template, data)
	    }
	});
	registerTemplateEngine("jsrender", {
	    compile: function(element) {
	        return $.templates(outerHtml(element))
	    },
	    render: function(template, data) {
	        return template.render(data)
	    }
	});
	registerTemplateEngine("mustache", {
	    compile: function(element) {
	        return Mustache.compile(outerHtml(element))
	    },
	    render: function(template, data) {
	        return template(data)
	    }
	});
	registerTemplateEngine("hogan", {
	    compile: function(element) {
	        return Hogan.compile(outerHtml(element))
	    },
	    render: function(template, data) {
	        return template.render(data)
	    }
	});
	registerTemplateEngine("underscore", {
	    compile: function(element) {
	        return _.template(outerHtml(element))
	    },
	    render: function(template, data) {
	        return template(data)
	    }
	});
	registerTemplateEngine("handlebars", {
	    compile: function(element) {
	        return Handlebars.compile(outerHtml(element))
	    },
	    render: function(template, data) {
	        return template(data)
	    }
	});
	registerTemplateEngine("doT", {
	    compile: function(element) {
	        return doT.template(outerHtml(element))
	    },
	    render: function(template, data) {
	        return template(data)
	    }
	});
	var currentTemplateEngine;
	var setTemplateEngine = function(templateEngine) {
	    if (commonUtils.isString(templateEngine)) {
	        currentTemplateEngine = templateEngines[templateEngine];
	        if (!currentTemplateEngine) {
	            throw errors.Error("E0020", templateEngine)
	        }
	    } else {
	        currentTemplateEngine = templateEngine
	    }
	};
	setTemplateEngine("default");
	var Template = TemplateBase.inherit({
	    ctor: function(element) {
	        this._element = element;
	        this._compiledTemplate = currentTemplateEngine.compile(element)
	    },
	    _renderCore: function(options) {
	        return $("<div>").append(currentTemplateEngine.render(this._compiledTemplate, options.model)).contents()
	    },
	    source: function() {
	        return $(this._element).clone()
	    }
	});
	module.exports = Template;
	module.exports.setTemplateEngine = setTemplateEngine;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/ui.template_base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    triggerShownEvent = __webpack_require__(43).triggerShownEvent,
	    Class = __webpack_require__(18),
	    abstract = Class.abstract;
	var renderedCallbacks = $.Callbacks();
	var TemplateBase = Class.inherit({
	    render: function(options) {
	        options = options || {};
	        var $result = this._renderCore(options);
	        this._ensureResultInContainer($result, options.container);
	        renderedCallbacks.fire($result, options.container);
	        return $result
	    },
	    _ensureResultInContainer: function($result, $container) {
	        if (!$container) {
	            return
	        }
	        var resultInContainer = $.contains($container.get(0), $result.get(0));
	        $container.append($result);
	        if (resultInContainer) {
	            return
	        }
	        var resultInBody = $.contains(document.body, $container.get(0));
	        if (!resultInBody) {
	            return
	        }
	        triggerShownEvent($result)
	    },
	    _renderCore: abstract
	});
	module.exports = TemplateBase;
	module.exports.renderedCallbacks = renderedCallbacks;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/function_template.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var TemplateBase = __webpack_require__(86),
	    domUtils = __webpack_require__(43);
	var FunctionTemplate = TemplateBase.inherit({
	    ctor: function(render) {
	        this._render = render
	    },
	    _renderCore: function(options) {
	        return domUtils.normalizeTemplateElement(this._render(options))
	    }
	});
	module.exports = FunctionTemplate;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/empty_template.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    TemplateBase = __webpack_require__(86);
	var EmptyTemplate = TemplateBase.inherit({
	    _renderCore: function() {
	        return $()
	    }
	});
	module.exports = EmptyTemplate;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/child_default_template.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var TemplateBase = __webpack_require__(86);
	module.exports = TemplateBase.inherit({
	    ctor: function(name) {
	        this.name = name
	    }
	});


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/ui.keyboard_processor.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    eventUtils = __webpack_require__(61);
	var KeyboardProcessor = Class.inherit({
	    _keydown: eventUtils.addNamespace("keydown", "KeyboardProcessor"),
	    codes: {
	        8: "backspace",
	        9: "tab",
	        13: "enter",
	        27: "escape",
	        33: "pageUp",
	        34: "pageDown",
	        35: "end",
	        36: "home",
	        37: "leftArrow",
	        38: "upArrow",
	        39: "rightArrow",
	        40: "downArrow",
	        46: "del",
	        32: "space",
	        70: "F",
	        65: "A",
	        106: "asterisk",
	        109: "minus"
	    },
	    ctor: function(options) {
	        var _this = this;
	        options = options || {};
	        if (options.element) {
	            this._element = $(options.element)
	        }
	        if (options.focusTarget) {
	            this._focusTarget = options.focusTarget
	        }
	        this._handler = options.handler;
	        this._context = options.context;
	        this._childProcessors = [];
	        if (this._element) {
	            this._processFunction = function(e) {
	                _this.process(e)
	            };
	            this._element.on(this._keydown, this._processFunction)
	        }
	    },
	    dispose: function() {
	        if (this._element) {
	            this._element.off(this._keydown, this._processFunction)
	        }
	        this._element = void 0;
	        this._handler = void 0;
	        this._context = void 0;
	        this._childProcessors = void 0
	    },
	    clearChildren: function() {
	        this._childProcessors = []
	    },
	    push: function(child) {
	        if (!this._childProcessors) {
	            this.clearChildren()
	        }
	        this._childProcessors.push(child);
	        return child
	    },
	    attachChildProcessor: function() {
	        var childProcessor = new KeyboardProcessor;
	        this._childProcessors.push(childProcessor);
	        return childProcessor
	    },
	    reinitialize: function(childHandler, childContext) {
	        this._context = childContext;
	        this._handler = childHandler;
	        return this
	    },
	    process: function(e) {
	        if (this._focusTarget && this._focusTarget !== e.target && $.inArray(e.target, this._focusTarget) < 0) {
	            return false
	        }
	        var args = {
	            key: this.codes[e.which] || e.which,
	            ctrl: e.ctrlKey,
	            shift: e.shiftKey,
	            alt: e.altKey,
	            originalEvent: e
	        };
	        var handlerResult = this._handler && this._handler.call(this._context, args);
	        if (handlerResult && this._childProcessors) {
	            $.each(this._childProcessors, function(index, childProcessor) {
	                childProcessor.process(e)
	            })
	        }
	    }
	});
	module.exports = KeyboardProcessor;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/jquery.selectors.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var focusable = function(element, tabIndex) {
	    var nodeName = element.nodeName.toLowerCase(),
	        isTabIndexNotNaN = !isNaN(tabIndex),
	        isVisible = visible(element),
	        isDisabled = element.disabled,
	        isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName),
	        isHyperlink = "a" === nodeName,
	        isFocusable = true;
	    if (isDefaultFocus) {
	        isFocusable = !isDisabled
	    } else {
	        if (isHyperlink) {
	            isFocusable = element.href || isTabIndexNotNaN
	        } else {
	            isFocusable = isTabIndexNotNaN
	        }
	    }
	    return isVisible ? isFocusable : false
	};
	var visible = function(element) {
	    var $element = $(element);
	    return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility")
	};
	var icontains = function(elem, text) {
	    var result = false;
	    $.each($(elem).contents(), function(index, content) {
	        if (3 === content.nodeType && (content.textContent || content.nodeValue || "").toLowerCase().indexOf((text || "").toLowerCase()) > -1) {
	            result = true;
	            return false
	        }
	    });
	    return result
	};
	$.extend($.expr[":"], {
	    "dx-focusable": function(element) {
	        return focusable(element, $.attr(element, "tabindex"))
	    },
	    "dx-tabbable": function(element) {
	        var tabIndex = $.attr(element, "tabindex");
	        return (isNaN(tabIndex) || tabIndex >= 0) && focusable(element, tabIndex)
	    },
	    "dx-icontains": $.expr.createPseudo(function(text) {
	        return function(elem) {
	            return icontains(elem, text)
	        }
	    })
	});
	module.exports = {
	    focusable: ":dx-focusable",
	    tabbable: ":dx-tabbable",
	    icontains: ":dx-icontains"
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/hover.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    devices = __webpack_require__(40),
	    registerEvent = __webpack_require__(63),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66);
	var HOVERSTART_NAMESPACE = "dxHoverStart",
	    HOVERSTART = "dxhoverstart",
	    POINTERENTER_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.enter, HOVERSTART_NAMESPACE),
	    HOVEREND_NAMESPACE = "dxHoverEnd",
	    HOVEREND = "dxhoverend",
	    POINTERLEAVE_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.leave, HOVEREND_NAMESPACE);
	var Hover = Class.inherit({
	    noBubble: true,
	    ctor: function() {
	        this._handlerArrayKeyPath = this._eventNamespace + "_HandlerStore"
	    },
	    setup: function(element) {
	        $.data(element, this._handlerArrayKeyPath, {})
	    },
	    add: function(element, handleObj) {
	        var that = this,
	            $element = $(element),
	            handler = function(e) {
	                that._handler(e)
	            };
	        $element.on(this._originalEventName, handleObj.selector, handler);
	        $.data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler
	    },
	    _handler: function(e) {
	        if (eventUtils.isTouchEvent(e) || devices.isSimulator()) {
	            return
	        }
	        eventUtils.fireEvent({
	            type: this._eventName,
	            originalEvent: e,
	            delegateTarget: e.delegateTarget
	        })
	    },
	    remove: function(element, handleObj) {
	        var handler = $.data(element, this._handlerArrayKeyPath)[handleObj.guid];
	        $(element).off(this._originalEventName, handleObj.selector, handler)
	    },
	    teardown: function(element) {
	        $.removeData(element, this._handlerArrayKeyPath)
	    }
	});
	var HoverStart = Hover.inherit({
	    ctor: function() {
	        this._eventNamespace = HOVERSTART_NAMESPACE;
	        this._eventName = HOVERSTART;
	        this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
	        this.callBase()
	    },
	    _handler: function(e) {
	        var pointers = e.pointers || [];
	        if (!pointers.length) {
	            this.callBase(e)
	        }
	    }
	});
	var HoverEnd = Hover.inherit({
	    ctor: function() {
	        this._eventNamespace = HOVEREND_NAMESPACE;
	        this._eventName = HOVEREND;
	        this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
	        this.callBase()
	    }
	});
	registerEvent(HOVERSTART, new HoverStart);
	registerEvent(HOVEREND, new HoverEnd);
	exports.start = HOVERSTART;
	exports.end = HOVEREND;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/core/emitter.feedback.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    devices = __webpack_require__(40),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    Emitter = __webpack_require__(73),
	    registerEmitter = __webpack_require__(74);
	var ACTIVE_EVENT_NAME = "dxactive",
	    INACTIVE_EVENT_NAME = "dxinactive",
	    ACTIVE_TIMEOUT = 30,
	    INACTIVE_TIMEOUT = 400;
	var FeedbackEvent = Class.inherit({
	    ctor: function(timeout, fire) {
	        this._timeout = timeout;
	        this._fire = fire
	    },
	    start: function() {
	        var that = this;
	        this._schedule(function() {
	            that.force()
	        })
	    },
	    _schedule: function(fn) {
	        this._timer = window.setTimeout(fn, this._timeout)
	    },
	    stop: function() {
	        clearTimeout(this._timer)
	    },
	    force: function() {
	        if (this._fired) {
	            return
	        }
	        this.stop();
	        this._fire();
	        this._fired = true
	    },
	    fired: function() {
	        return this._fired
	    }
	});
	var activeFeedback;
	var FeedbackEmitter = Emitter.inherit({
	    ctor: function() {
	        this.callBase.apply(this, arguments);
	        this._active = new FeedbackEvent(0, $.noop);
	        this._inactive = new FeedbackEvent(0, $.noop)
	    },
	    configure: function(data, eventName) {
	        switch (eventName) {
	            case ACTIVE_EVENT_NAME:
	                data.activeTimeout = data.timeout;
	                break;
	            case INACTIVE_EVENT_NAME:
	                data.inactiveTimeout = data.timeout
	        }
	        this.callBase(data)
	    },
	    start: function(e) {
	        if (activeFeedback) {
	            var activeChildExists = $.contains(this.getElement().get(0), activeFeedback.getElement().get(0));
	            var childJustActivated = !activeFeedback._active.fired();
	            if (activeChildExists && childJustActivated) {
	                this._cancel();
	                return
	            }
	            activeFeedback._inactive.force()
	        }
	        activeFeedback = this;
	        this._initEvents(e);
	        this._active.start()
	    },
	    _initEvents: function(e) {
	        var that = this,
	            eventTarget = this._getEmitterTarget(e),
	            mouseEvent = eventUtils.isMouseEvent(e),
	            isSimulator = devices.isSimulator(),
	            deferFeedback = isSimulator || !mouseEvent,
	            activeTimeout = commonUtils.ensureDefined(this.activeTimeout, ACTIVE_TIMEOUT),
	            inactiveTimeout = commonUtils.ensureDefined(this.inactiveTimeout, INACTIVE_TIMEOUT);
	        this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
	            that._fireEvent(ACTIVE_EVENT_NAME, e, {
	                target: eventTarget
	            })
	        });
	        this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
	            that._fireEvent(INACTIVE_EVENT_NAME, e, {
	                target: eventTarget
	            });
	            activeFeedback = null
	        })
	    },
	    cancel: function(e) {
	        this.end(e)
	    },
	    end: function(e) {
	        var skipTimers = e.type !== pointerEvents.up;
	        if (skipTimers) {
	            this._active.stop()
	        } else {
	            this._active.force()
	        }
	        this._inactive.start();
	        if (skipTimers) {
	            this._inactive.force()
	        }
	    },
	    dispose: function() {
	        this._active.stop();
	        this._inactive.stop();
	        this.callBase()
	    },
	    lockInactive: function() {
	        this._active.force();
	        this._inactive.stop();
	        activeFeedback = null;
	        this._cancel();
	        return $.proxy(this._inactive.force, this._inactive)
	    }
	});
	FeedbackEmitter.lock = function(deferred) {
	    var lockInactive = activeFeedback ? activeFeedback.lockInactive() : $.noop;
	    deferred.done(lockInactive)
	};
	registerEmitter({
	    emitter: FeedbackEmitter,
	    events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
	});
	exports.lock = FeedbackEmitter.lock;
	exports.active = ACTIVE_EVENT_NAME;
	exports.inactive = INACTIVE_EVENT_NAME;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/template.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ko = __webpack_require__(82),
	    TemplateBase = __webpack_require__(86),
	    domUtils = __webpack_require__(43);
	var KoTemplate = TemplateBase.inherit({
	    ctor: function(element) {
	        this._element = element;
	        this._template = $("<div>").append(domUtils.normalizeTemplateElement(element));
	        this._registerKoTemplate()
	    },
	    _registerKoTemplate: function() {
	        var template = this._template.get(0);
	        new ko.templateSources.anonymousTemplate(template).nodes(template)
	    },
	    _prepareDataForContainer: function(data, container) {
	        var containerElement, containerContext, result = data;
	        if (container.length) {
	            containerElement = container.get(0);
	            data = void 0 !== data ? data : ko.dataFor(containerElement) || {};
	            containerContext = ko.contextFor(containerElement);
	            if (containerContext) {
	                result = data === containerContext.$data ? containerContext : containerContext.createChildContext(data)
	            } else {
	                result = data
	            }
	        }
	        return result
	    },
	    _renderCore: function(options) {
	        var model = options.model;
	        if (options.container) {
	            model = this._prepareDataForContainer(model, options.container)
	        }
	        var $placeholder = $("<div>").appendTo(options.container);
	        var $result;
	        ko.renderTemplate(this._template.get(0), model, {
	            afterRender: function(nodes) {
	                $result = $(nodes)
	            }
	        }, $placeholder.get(0), "replaceNode");
	        return $result
	    },
	    source: function() {
	        return $(this._element).clone()
	    },
	    dispose: function() {
	        this._template.remove()
	    }
	});
	module.exports = KoTemplate;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/editor/editor.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    Widget = __webpack_require__(84),
	    ValidationMixin = __webpack_require__(96),
	    Overlay = __webpack_require__(97);
	var READONLY_STATE_CLASS = "dx-state-readonly",
	    INVALID_CLASS = "dx-invalid",
	    INVALID_MESSAGE = "dx-invalid-message",
	    INVALID_MESSAGE_AUTO = "dx-invalid-message-auto",
	    INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always",
	    VALIDATION_TARGET = "dx-validation-target",
	    VALIDATION_MESSAGE_MIN_WIDTH = 100;
	var Editor = Widget.inherit({
	    _init: function() {
	        this.callBase();
	        this.validationRequest = $.Callbacks();
	        var $element = this.element();
	        if ($element) {
	            $.data($element[0], VALIDATION_TARGET, this)
	        }
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            value: null,
	            name: "",
	            onValueChanged: null,
	            readOnly: false,
	            isValid: true,
	            validationError: null,
	            validationMessageMode: "auto",
	            validationBoundary: void 0,
	            validationMessageOffset: {
	                h: 0,
	                v: 0
	            }
	        })
	    },
	    _attachKeyboardEvents: function() {
	        if (this.option("readOnly")) {
	            return
	        }
	        this.callBase();
	        this._attachChildKeyboardEvents()
	    },
	    _attachChildKeyboardEvents: $.noop,
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            validationError: true
	        })
	    },
	    _createValueChangeAction: function() {
	        this._valueChangeAction = this._createActionByOption("onValueChanged", {
	            excludeValidators: ["disabled", "readOnly"]
	        })
	    },
	    _suppressValueChangeAction: function() {
	        this._valueChangeActionSuppressed = true
	    },
	    _resumeValueChangeAction: function() {
	        this._valueChangeActionSuppressed = false
	    },
	    _render: function() {
	        this.callBase();
	        this._renderValidationState();
	        this._toggleReadOnlyState();
	        this._setSubmitElementName(this.option("name"))
	    },
	    _raiseValueChangeAction: function(value, previousValue) {
	        if (!this._valueChangeAction) {
	            this._createValueChangeAction()
	        }
	        this._valueChangeAction(this._valueChangeArgs(value, previousValue))
	    },
	    _valueChangeArgs: function(value, previousValue) {
	        return {
	            value: value,
	            previousValue: previousValue,
	            jQueryEvent: this._valueChangeEventInstance
	        }
	    },
	    _saveValueChangeEvent: function(e) {
	        this._valueChangeEventInstance = e
	    },
	    _renderValidationState: function() {
	        var isValid = this.option("isValid"),
	            validationError = this.option("validationError"),
	            validationMessageMode = this.option("validationMessageMode"),
	            $element = this.element();
	        $element.toggleClass(INVALID_CLASS, !isValid);
	        this.setAria("invalid", !isValid || void 0);
	        if (this._$validationMessage) {
	            this._$validationMessage.remove();
	            this._$validationMessage = null
	        }
	        if (!isValid && validationError && validationError.message) {
	            this._$validationMessage = $("<div/>", {
	                "class": INVALID_MESSAGE
	            }).html(validationError.message).appendTo($element);
	            this._validationMessage = this._createComponent(this._$validationMessage, Overlay, {
	                templatesRenderAsynchronously: false,
	                target: this._getValidationMessageTarget(),
	                shading: false,
	                width: "auto",
	                height: "auto",
	                container: $element,
	                position: this._getValidationMessagePosition("below"),
	                closeOnOutsideClick: false,
	                closeOnTargetScroll: false,
	                animation: null,
	                visible: true,
	                propagateOutsideClick: true,
	                _checkParentVisibility: false
	            });
	            this._$validationMessage.toggleClass(INVALID_MESSAGE_AUTO, "auto" === validationMessageMode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === validationMessageMode);
	            this._setValidationMessageMaxWidth()
	        }
	    },
	    _setValidationMessageMaxWidth: function() {
	        if (!this._validationMessage) {
	            return
	        }
	        if (0 === this._getValidationMessageTarget().outerWidth()) {
	            this._validationMessage.option("maxWidth", "100%");
	            return
	        }
	        var validationMessageMaxWidth = Math.max(VALIDATION_MESSAGE_MIN_WIDTH, this._getValidationMessageTarget().outerWidth());
	        this._validationMessage.option("maxWidth", validationMessageMaxWidth)
	    },
	    _getValidationMessageTarget: function() {
	        return this.element()
	    },
	    _getValidationMessagePosition: function(positionRequest) {
	        var rtlEnabled = this.option("rtlEnabled"),
	            messagePositionSide = commonUtils.getDefaultAlignment(rtlEnabled),
	            messageOriginalOffset = this.option("validationMessageOffset"),
	            messageOffset = {
	                h: messageOriginalOffset.h,
	                v: messageOriginalOffset.v
	            },
	            verticalPositions = "below" === positionRequest ? [" top", " bottom"] : [" bottom", " top"];
	        if (rtlEnabled) {
	            messageOffset.h = -messageOffset.h
	        }
	        if ("below" !== positionRequest) {
	            messageOffset.v = -messageOffset.v
	        }
	        return {
	            offset: messageOffset,
	            boundary: this.option("validationBoundary"),
	            my: messagePositionSide + verticalPositions[0],
	            at: messagePositionSide + verticalPositions[1],
	            collision: "none flip"
	        }
	    },
	    _toggleReadOnlyState: function() {
	        this.element().toggleClass(READONLY_STATE_CLASS, !!this.option("readOnly"));
	        this.setAria("readonly", this.option("readOnly") || void 0)
	    },
	    _dispose: function() {
	        var element = this.element()[0];
	        $.data(element, VALIDATION_TARGET, null);
	        this.callBase()
	    },
	    _setSubmitElementName: function(name) {
	        var $submitElement = this._getSubmitElement();
	        $submitElement && $submitElement.attr("name", name)
	    },
	    _getSubmitElement: function() {
	        return null
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "onValueChanged":
	                this._createValueChangeAction();
	                break;
	            case "isValid":
	            case "validationError":
	            case "validationBoundary":
	            case "validationMessageMode":
	                this._renderValidationState();
	                break;
	            case "readOnly":
	                this._toggleReadOnlyState();
	                this._refreshFocusState();
	                break;
	            case "value":
	                if (!this._valueChangeActionSuppressed) {
	                    this._raiseValueChangeAction(args.value, args.previousValue);
	                    this._saveValueChangeEvent(void 0)
	                }
	                if (args.value != args.previousValue) {
	                    this.validationRequest.fire({
	                        value: args.value,
	                        editor: this
	                    })
	                }
	                break;
	            case "width":
	                this.callBase(args);
	                this._setValidationMessageMaxWidth();
	                break;
	            case "name":
	                this._setSubmitElementName(args.value);
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    reset: function() {
	        this.option("value", null)
	    }
	}).include(ValidationMixin);
	module.exports = Editor;


/***/ },
/* 96 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (ui/validation/validation_mixin.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var ValidationMixin = {
	    _findGroup: function() {
	        var $dxGroup, group = this.option("validationGroup");
	        if (!group) {
	            $dxGroup = this.element().parents(".dx-validationgroup:first");
	            if ($dxGroup.length) {
	                group = $dxGroup.dxValidationGroup("instance")
	            } else {
	                group = this._modelByElement(this.element())
	            }
	        }
	        return group
	    }
	};
	module.exports = ValidationMixin;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/overlay.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    fx = __webpack_require__(58),
	    translator = __webpack_require__(59),
	    compareVersions = __webpack_require__(11).compare,
	    viewPortUtils = __webpack_require__(42),
	    viewPort = viewPortUtils.value,
	    viewPortChanged = viewPortUtils.changeCallback,
	    hideTopOverlayCallback = __webpack_require__(53).hideCallback,
	    positionUtils = __webpack_require__(60),
	    fitIntoRange = __webpack_require__(77).fitIntoRange,
	    domUtils = __webpack_require__(43),
	    commonUtils = __webpack_require__(8),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    Widget = __webpack_require__(84),
	    KeyboardProcessor = __webpack_require__(90),
	    selectors = __webpack_require__(91),
	    dragEvents = __webpack_require__(98),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    Resizable = __webpack_require__(100),
	    EmptyTemplate = __webpack_require__(88);
	var OVERLAY_CLASS = "dx-overlay",
	    OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper",
	    OVERLAY_CONTENT_CLASS = "dx-overlay-content",
	    OVERLAY_SHADER_CLASS = "dx-overlay-shader",
	    OVERLAY_MODAL_CLASS = "dx-overlay-modal",
	    INVISIBLE_STATE_CLASS = "dx-state-invisible",
	    ANONYMOUS_TEMPLATE_NAME = "content",
	    RTL_DIRECTION_CLASS = "dx-rtl",
	    ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"],
	    FIRST_Z_INDEX = 1500,
	    OVERLAY_STACK = [],
	    DISABLED_STATE_CLASS = "dx-state-disabled",
	    TAB_KEY = 9;
	var realDevice = devices.real(),
	    realVersion = realDevice.version,
	    iOS = "ios" === realDevice.platform,
	    iOS7_0andBelow = iOS && compareVersions(realVersion, [7, 1]) < 0,
	    android4_0nativeBrowser = "android" === realDevice.platform && 0 === compareVersions(realVersion, [4, 0], 2) && navigator.userAgent.indexOf("Chrome") === -1;
	var forceRepaint = function($element) {
	    if (iOS7_0andBelow) {
	        $element.width()
	    }
	    if (android4_0nativeBrowser) {
	        var $parents = $element.parents(),
	            inScrollView = $parents.is(".dx-scrollable-native");
	        if (!inScrollView) {
	            $parents.css("backface-visibility", "hidden");
	            $parents.css("backface-visibility");
	            $parents.css("backface-visibility", "visible")
	        }
	    }
	};
	var getElement = function(value) {
	    return value && $(value instanceof $.Event ? value.target : value)
	};
	$(document).on(pointerEvents.down, function(e) {
	    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
	        if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
	            return
	        }
	    }
	});
	var Overlay = Widget.inherit({
	    _supportedKeys: function() {
	        var offsetSize = 5,
	            move = function(top, left, e) {
	                if (!this.option("dragEnabled")) {
	                    return
	                }
	                e.preventDefault();
	                e.stopPropagation();
	                var allowedOffsets = this._allowedOffsets();
	                var offset = {
	                    top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
	                    left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
	                };
	                this._changePosition(offset)
	            };
	        return $.extend(this.callBase(), {
	            escape: function() {
	                this.hide()
	            },
	            upArrow: $.proxy(move, this, -offsetSize, 0),
	            downArrow: $.proxy(move, this, offsetSize, 0),
	            leftArrow: $.proxy(move, this, 0, -offsetSize),
	            rightArrow: $.proxy(move, this, 0, offsetSize)
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            activeStateEnabled: false,
	            visible: false,
	            deferRendering: true,
	            shading: true,
	            shadingColor: "",
	            position: {
	                my: "center",
	                at: "center"
	            },
	            width: function() {
	                return .8 * $(window).width()
	            },
	            minWidth: null,
	            maxWidth: null,
	            height: function() {
	                return .8 * $(window).height()
	            },
	            minHeight: null,
	            maxHeight: null,
	            animation: {
	                show: {
	                    type: "pop",
	                    duration: 300,
	                    from: {
	                        scale: .55
	                    }
	                },
	                hide: {
	                    type: "pop",
	                    duration: 300,
	                    to: {
	                        opacity: 0,
	                        scale: .55
	                    },
	                    from: {
	                        opacity: 1,
	                        scale: 1
	                    }
	                }
	            },
	            closeOnOutsideClick: false,
	            closeOnBackButton: true,
	            onShowing: null,
	            onShown: null,
	            onHiding: null,
	            onHidden: null,
	            contentTemplate: "content",
	            dragEnabled: false,
	            resizeEnabled: false,
	            onResizeStart: null,
	            onResize: null,
	            onResizeEnd: null,
	            onContentReady: null,
	            target: void 0,
	            container: void 0,
	            hideTopOverlayHandler: void 0,
	            closeOnTargetScroll: false,
	            onPositioned: null,
	            boundaryOffset: {
	                h: 0,
	                v: 0
	            },
	            propagateOutsideClick: false,
	            _checkParentVisibility: true
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                var realDevice = devices.real(),
	                    realPlatform = realDevice.platform,
	                    realVersion = realDevice.version;
	                return "android" === realPlatform && compareVersions(realVersion, [4, 2]) < 0
	            },
	            options: {
	                animation: {
	                    show: {
	                        type: "fade",
	                        duration: 400
	                    },
	                    hide: {
	                        type: "fade",
	                        duration: 400,
	                        to: {
	                            opacity: 0
	                        },
	                        from: {
	                            opacity: 1
	                        }
	                    }
	                }
	            }
	        }])
	    },
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            animation: true
	        })
	    },
	    _getAnonymousTemplateName: function() {
	        return ANONYMOUS_TEMPLATE_NAME
	    },
	    _wrapper: function() {
	        return this._$wrapper
	    },
	    _container: function() {
	        return this._$content
	    },
	    _eventBindingTarget: function() {
	        return this._$content
	    },
	    _init: function() {
	        this.callBase();
	        this._initActions();
	        this._initCloseOnOutsideClickHandler();
	        this._initTabTerminatorHandler();
	        this._$wrapper = $("<div>").addClass(OVERLAY_WRAPPER_CLASS);
	        this._$content = $("<div>").addClass(OVERLAY_CONTENT_CLASS);
	        var $element = this.element();
	        this._$wrapper.addClass($element.attr("class"));
	        $element.addClass(OVERLAY_CLASS);
	        this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
	        this._$wrapper.on("MSPointerDown", $.noop);
	        this._$wrapper.on("focusin", function(e) {
	            e.stopPropagation()
	        });
	        this._toggleViewPortSubscription(true)
	    },
	    _initOptions: function(options) {
	        this._initTarget(options.target);
	        this._initContainer(options.container);
	        this._initHideTopOverlayHandler(options.hideTopOverlayHandler);
	        this.callBase(options)
	    },
	    _initTarget: function(target) {
	        if (!commonUtils.isDefined(target)) {
	            return
	        }
	        var options = this.option();
	        $.each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], function(_, path) {
	            var pathParts = path.split(".");
	            var option = options;
	            while (option) {
	                if (1 === pathParts.length) {
	                    if ($.isPlainObject(option)) {
	                        option[pathParts.shift()] = target
	                    }
	                    break
	                } else {
	                    option = option[pathParts.shift()]
	                }
	            }
	        })
	    },
	    _initContainer: function(container) {
	        container = void 0 === container ? viewPort() : container;
	        var $element = this.element(),
	            $container = $element.closest(container);
	        if (!$container.length) {
	            $container = $(container).first()
	        }
	        this._$container = $container.length ? $container : $element.parent()
	    },
	    _initHideTopOverlayHandler: function(handler) {
	        this._hideTopOverlayHandler = void 0 !== handler ? handler : $.proxy(this._defaultHideTopOverlayHandler, this)
	    },
	    _defaultHideTopOverlayHandler: function() {
	        this.hide()
	    },
	    _initActions: function() {
	        this._actions = {};
	        $.each(ACTIONS, $.proxy(function(_, action) {
	            this._actions[action] = this._createActionByOption(action, {
	                excludeValidators: ["disabled", "readOnly"]
	            }) || $.noop
	        }, this))
	    },
	    _initCloseOnOutsideClickHandler: function() {
	        var that = this;
	        this._proxiedDocumentDownHandler = function() {
	            return that._documentDownHandler.apply(that, arguments)
	        }
	    },
	    _documentDownHandler: function(e) {
	        if (this._showAnimationProcessing) {
	            this._stopAnimation();
	            return
	        }
	        var closeOnOutsideClick = this.option("closeOnOutsideClick");
	        if ($.isFunction(closeOnOutsideClick)) {
	            closeOnOutsideClick = closeOnOutsideClick(e)
	        }
	        if (closeOnOutsideClick) {
	            var $container = this._$content,
	                outsideClick = !$container.is(e.target) && !$.contains($container.get(0), e.target);
	            if (outsideClick) {
	                if (this.option("shading")) {
	                    e.preventDefault()
	                }
	                this.hide()
	            }
	        }
	        return this.option("propagateOutsideClick")
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.content = new EmptyTemplate(this)
	    },
	    _isTopOverlay: function() {
	        var overlayStack = this._overlayStack();
	        return overlayStack[overlayStack.length - 1] === this
	    },
	    _overlayStack: function() {
	        return OVERLAY_STACK
	    },
	    _zIndexInitValue: function() {
	        return FIRST_Z_INDEX
	    },
	    _toggleViewPortSubscription: function(toggle) {
	        viewPortChanged.remove(this._viewPortChangeHandle);
	        if (toggle) {
	            this._viewPortChangeHandle = $.proxy(this._viewPortChangeHandler, this);
	            viewPortChanged.add(this._viewPortChangeHandle)
	        }
	    },
	    _viewPortChangeHandler: function() {
	        this._initContainer(this.option("container"));
	        this._refresh()
	    },
	    _renderVisibilityAnimate: function(visible) {
	        this._stopAnimation();
	        return visible ? this._show() : this._hide()
	    },
	    _normalizePosition: function() {
	        this._position = this.option("position")
	    },
	    _getAnimationConfig: function() {
	        var animation = this.option("animation");
	        if ($.isFunction(animation)) {
	            animation = animation.call(this)
	        }
	        return animation
	    },
	    _show: function() {
	        var that = this,
	            deferred = $.Deferred();
	        this._parentHidden = this._isParentHidden();
	        deferred.done(function() {
	            delete that._parentHidden
	        });
	        if (this._parentHidden) {
	            return deferred.resolve()
	        }
	        if (this._currentVisible) {
	            return $.Deferred().resolve().promise()
	        }
	        this._currentVisible = true;
	        this._normalizePosition();
	        var animation = that._getAnimationConfig() || {},
	            showAnimation = this._normalizeAnimation(animation.show, "to"),
	            startShowAnimation = showAnimation && showAnimation.start || $.noop,
	            completeShowAnimation = showAnimation && showAnimation.complete || $.noop;
	        if (this._isHidingActionCanceled) {
	            delete this._isHidingActionCanceled;
	            deferred.resolve()
	        } else {
	            var show = function() {
	                this._renderVisibility(true);
	                this._animate(showAnimation, function() {
	                    if (that.option("focusStateEnabled")) {
	                        that._focusTarget().focus()
	                    }
	                    completeShowAnimation.apply(this, arguments);
	                    that._showAnimationProcessing = false;
	                    that._actions.onShown();
	                    deferred.resolve()
	                }, function() {
	                    startShowAnimation.apply(this, arguments);
	                    that._showAnimationProcessing = true
	                })
	            }.bind(this);
	            if (this.option("templatesRenderAsynchronously")) {
	                this._asyncShowTimeout = setTimeout(show)
	            } else {
	                show()
	            }
	        }
	        return deferred.promise()
	    },
	    _normalizeAnimation: function(animation, prop) {
	        if (animation && animation[prop]) {
	            animation = $.extend({
	                type: "slide"
	            }, animation);
	            $.extend(animation[prop], {
	                position: this._position
	            })
	        }
	        return animation
	    },
	    _hide: function() {
	        if (!this._currentVisible) {
	            return $.Deferred().resolve().promise()
	        }
	        this._currentVisible = false;
	        var that = this,
	            deferred = $.Deferred(),
	            animation = that._getAnimationConfig() || {},
	            hideAnimation = this._normalizeAnimation(animation.hide, "from"),
	            completeHideAnimation = hideAnimation && hideAnimation.complete || $.noop,
	            hidingArgs = {
	                cancel: false
	            };
	        this._actions.onHiding(hidingArgs);
	        if (hidingArgs.cancel) {
	            this._isHidingActionCanceled = true;
	            this.option("visible", true);
	            deferred.resolve()
	        } else {
	            this._forceFocusLost();
	            this._toggleShading(false);
	            this._toggleSubscriptions(false);
	            this._animate(hideAnimation, function() {
	                that._renderVisibility(false);
	                completeHideAnimation.apply(this, arguments);
	                that._actions.onHidden();
	                deferred.resolve()
	            })
	        }
	        return deferred.promise()
	    },
	    _forceFocusLost: function() {
	        document.activeElement && this._$content.find(document.activeElement).length && document.activeElement.blur()
	    },
	    _animate: function(animation, completeCallback, startCallback) {
	        if (animation) {
	            startCallback = startCallback || animation.start || $.noop;
	            var $content = this._$content;
	            fx.animate(this._$content, $.extend({}, animation, {
	                start: function() {
	                    $content.css("pointer-events", "none");
	                    startCallback.apply(this, arguments)
	                },
	                complete: function() {
	                    $content.css("pointer-events", "");
	                    completeCallback.apply(this, arguments)
	                }
	            }))
	        } else {
	            completeCallback()
	        }
	    },
	    _stopAnimation: function() {
	        fx.stop(this._$content, true)
	    },
	    _renderVisibility: function(visible) {
	        if (visible && this._isParentHidden()) {
	            return
	        }
	        this._currentVisible = visible;
	        this._stopAnimation();
	        clearTimeout(this._asyncShowTimeout);
	        if (!visible) {
	            domUtils.triggerHidingEvent(this._$content)
	        }
	        this._toggleVisibility(visible);
	        this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
	        this._updateZIndexStackPosition(visible);
	        if (visible) {
	            this._renderContent();
	            this._actions.onShowing();
	            this._moveToContainer();
	            this._renderGeometry();
	            domUtils.triggerShownEvent(this._$content);
	            domUtils.triggerResizeEvent(this._$content)
	        } else {
	            this._moveFromContainer()
	        }
	        this._toggleShading(visible);
	        this._toggleSubscriptions(visible)
	    },
	    _updateZIndexStackPosition: function(pushToStack) {
	        var overlayStack = this._overlayStack(),
	            index = $.inArray(this, overlayStack);
	        if (pushToStack) {
	            if (index === -1) {
	                var length = overlayStack.length;
	                this._zIndex = (length ? overlayStack[length - 1]._zIndex : this._zIndexInitValue()) + 1;
	                overlayStack.push(this)
	            }
	            this._$wrapper.css("z-index", this._zIndex);
	            this._$content.css("z-index", this._zIndex)
	        } else {
	            if (index !== -1) {
	                overlayStack.splice(index, 1)
	            }
	        }
	    },
	    _toggleShading: function(visible) {
	        this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
	        this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option("shading"));
	        this._$wrapper.css("background-color", this.option("shading") ? this.option("shadingColor") : "");
	        this._toggleTabTerminator(visible && this.option("shading"))
	    },
	    _initTabTerminatorHandler: function() {
	        var that = this;
	        this._proxiedTabTerminatorHandler = function() {
	            that._tabKeyHandler.apply(that, arguments)
	        }
	    },
	    _toggleTabTerminator: function(enabled) {
	        var eventName = eventUtils.addNamespace("keydown", this.NAME);
	        if (enabled) {
	            $(document).on(eventName, this._proxiedTabTerminatorHandler)
	        } else {
	            $(document).off(eventName, this._proxiedTabTerminatorHandler)
	        }
	    },
	    _tabKeyHandler: function(e) {
	        if (e.keyCode !== TAB_KEY || !this._isTopOverlay()) {
	            return
	        }
	        var tabbableElements = this._$wrapper.find(selectors.tabbable),
	            $firstTabbable = tabbableElements.first(),
	            $lastTabbable = tabbableElements.last(),
	            isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0),
	            isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0),
	            isEmptyTabList = 0 === tabbableElements.length,
	            isOutsideTarget = $.inArray(e.target, tabbableElements) === -1;
	        if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
	            e.preventDefault();
	            (e.shiftKey ? $lastTabbable : $firstTabbable).focusin().focus()
	        }
	    },
	    _toggleSubscriptions: function(enabled) {
	        this._toggleHideTopOverlayCallback(enabled);
	        this._toggleParentsScrollSubscription(enabled)
	    },
	    _toggleHideTopOverlayCallback: function(subscribe) {
	        if (!this._hideTopOverlayHandler) {
	            return
	        }
	        if (subscribe && this.option("closeOnBackButton")) {
	            hideTopOverlayCallback.add(this._hideTopOverlayHandler)
	        } else {
	            hideTopOverlayCallback.remove(this._hideTopOverlayHandler)
	        }
	    },
	    _toggleParentsScrollSubscription: function(subscribe) {
	        if (!this._position) {
	            return
	        }
	        var target = this._position.of || $(),
	            closeOnScroll = this.option("closeOnTargetScroll"),
	            $parents = getElement(target).parents(),
	            scrollEvent = eventUtils.addNamespace("scroll", this.NAME);
	        if ("generic" === devices.real().platform) {
	            $parents = $parents.add(window)
	        }
	        this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || $.proxy(function(e) {
	            this._targetParentsScrollHandler(e)
	        }, this);
	        $().add(this._$prevTargetParents).off(scrollEvent, this._proxiedTargetParentsScrollHandler);
	        if (subscribe && closeOnScroll) {
	            $parents.on(scrollEvent, this._proxiedTargetParentsScrollHandler);
	            this._$prevTargetParents = $parents
	        }
	    },
	    _targetParentsScrollHandler: function(e) {
	        var closeHandled = false,
	            closeOnScroll = this.option("closeOnTargetScroll");
	        if ($.isFunction(closeOnScroll)) {
	            closeHandled = closeOnScroll(e)
	        }
	        if (!closeHandled && !this._showAnimationProcessing) {
	            this.hide()
	        }
	    },
	    _render: function() {
	        this.callBase();
	        this._$content.appendTo(this.element());
	        this._renderVisibilityAnimate(this.option("visible"))
	    },
	    _renderContent: function() {
	        var shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
	        var isParentHidden = this.option("visible") && this._isParentHidden();
	        if (isParentHidden) {
	            this._isHidden = true;
	            return
	        }
	        if (this._contentAlreadyRendered || shouldDeferRendering) {
	            return
	        }
	        this._contentAlreadyRendered = true;
	        this.callBase()
	    },
	    _isParentHidden: function() {
	        if (!this.option("_checkParentVisibility")) {
	            return false
	        }
	        if (void 0 !== this._parentHidden) {
	            return this._parentHidden
	        }
	        var $parent = this.element().parent();
	        if ($parent.is(":visible")) {
	            return false
	        }
	        var isHidden = false;
	        $parent.add($parent.parents()).each(function() {
	            var $element = $(this);
	            if ("none" === $element.css("display")) {
	                isHidden = true;
	                return false
	            }
	        });
	        return isHidden || !$.contains(document, $parent.get(0))
	    },
	    _renderContentImpl: function() {
	        var $element = this.element();
	        this._$content.appendTo($element);
	        var contentTemplate = this._getTemplate(this.option("contentTemplate"));
	        contentTemplate && contentTemplate.render({
	            container: this.content(),
	            noModel: true
	        });
	        this._renderDrag();
	        this._renderResize();
	        this._renderScrollTerminator()
	    },
	    _renderDrag: function() {
	        var $dragTarget = this._getDragTarget();
	        if (!$dragTarget) {
	            return
	        }
	        var startEventName = eventUtils.addNamespace(dragEvents.start, this.NAME),
	            updateEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
	        $dragTarget.off(startEventName).off(updateEventName);
	        if (!this.option("dragEnabled")) {
	            return
	        }
	        $dragTarget.on(startEventName, $.proxy(this._dragStartHandler, this)).on(updateEventName, $.proxy(this._dragUpdateHandler, this))
	    },
	    _renderResize: function() {
	        this._createComponent(this._$content, Resizable, {
	            handles: this.option("resizeEnabled") ? "all" : "none",
	            onResizeEnd: $.proxy(this._resizeEndHandler, this),
	            onResize: $.proxy(this._actions.onResize, this),
	            onResizeStart: $.proxy(this._actions.onResizeStart, this),
	            minHeight: 100,
	            minWidth: 100,
	            area: this._$container
	        })
	    },
	    _resizeEndHandler: function() {
	        this._positionChangeHandled = true;
	        this._dimensionChangeHandled = true;
	        this._actions.onResizeEnd()
	    },
	    _renderScrollTerminator: function() {
	        var $scrollTerminator = this._wrapper();
	        var terminatorEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
	        $scrollTerminator.off(terminatorEventName).on(terminatorEventName, {
	            validate: function() {
	                return true
	            },
	            getDirection: function() {
	                return "both"
	            },
	            _toggleGestureCover: $.noop,
	            _clearSelection: $.noop,
	            isNative: true
	        }, function(e) {
	            if ("mousemove" !== e.originalEvent.originalEvent.type) {
	                e.preventDefault()
	            }
	        })
	    },
	    _getDragTarget: function() {
	        return this.content()
	    },
	    _dragStartHandler: function(e) {
	        e.targetElements = [];
	        this._prevOffset = {
	            x: 0,
	            y: 0
	        };
	        var allowedOffsets = this._allowedOffsets();
	        e.maxTopOffset = allowedOffsets.top;
	        e.maxBottomOffset = allowedOffsets.bottom;
	        e.maxLeftOffset = allowedOffsets.left;
	        e.maxRightOffset = allowedOffsets.right
	    },
	    _deltaSize: function() {
	        var $content = this._$content,
	            $container = this._$container;
	        var contentWidth = $content.outerWidth(),
	            contentHeight = $content.outerHeight(),
	            containerWidth = $container.width(),
	            containerHeight = $container.height();
	        return {
	            width: containerWidth - contentWidth,
	            height: containerHeight - contentHeight
	        }
	    },
	    _dragUpdateHandler: function(e) {
	        var offset = e.offset,
	            prevOffset = this._prevOffset,
	            targetOffset = {
	                top: offset.y - prevOffset.y,
	                left: offset.x - prevOffset.x
	            };
	        this._changePosition(targetOffset);
	        this._prevOffset = offset
	    },
	    _changePosition: function(offset) {
	        var position = translator.locate(this._$content);
	        translator.move(this._$content, {
	            left: position.left + offset.left,
	            top: position.top + offset.top
	        });
	        this._positionChangeHandled = true
	    },
	    _allowedOffsets: function() {
	        var position = translator.locate(this._$content),
	            deltaSize = this._deltaSize(),
	            isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0,
	            boundaryOffset = this.option("boundaryOffset");
	        return {
	            top: isAllowedDrag ? position.top + boundaryOffset.v : 0,
	            bottom: isAllowedDrag ? -position.top + deltaSize.height - boundaryOffset.v : 0,
	            left: isAllowedDrag ? position.left + boundaryOffset.h : 0,
	            right: isAllowedDrag ? -position.left + deltaSize.width - boundaryOffset.h : 0
	        }
	    },
	    _fireContentReadyAction: function() {
	        if (this.option("visible")) {
	            this._moveToContainer()
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _moveFromContainer: function() {
	        this._$content.appendTo(this.element());
	        this._detachWrapperToContainer()
	    },
	    _detachWrapperToContainer: function() {
	        this._$wrapper.detach()
	    },
	    _moveToContainer: function() {
	        this._attachWrapperToContainer();
	        this._$content.appendTo(this._$wrapper)
	    },
	    _attachWrapperToContainer: function() {
	        var $element = this.element();
	        if (this._$container && this._$container[0] !== $element.parent()[0]) {
	            this._$wrapper.appendTo(this._$container)
	        } else {
	            this._$wrapper.appendTo($element)
	        }
	    },
	    _renderGeometry: function() {
	        if (this.option("visible")) {
	            this._renderGeometryImpl()
	        }
	    },
	    _renderGeometryImpl: function() {
	        this._stopAnimation();
	        this._normalizePosition();
	        this._renderShading();
	        this._renderDimensions();
	        var resultPosition = this._renderPosition();
	        this._actions.onPositioned({
	            position: resultPosition
	        })
	    },
	    _renderShading: function() {
	        var $wrapper = this._$wrapper,
	            $container = this._getContainer();
	        $wrapper.css("position", this._isWindow($container) && !iOS ? "fixed" : "absolute");
	        this._renderShadingDimensions();
	        this._renderShadingPosition()
	    },
	    _renderShadingPosition: function() {
	        if (this.option("shading")) {
	            var $container = this._getContainer();
	            positionUtils.setup(this._$wrapper, {
	                my: "top left",
	                at: "top left",
	                of: $container
	            })
	        }
	    },
	    _renderShadingDimensions: function() {
	        var wrapperWidth, wrapperHeight;
	        if (this.option("shading")) {
	            var $container = this._getContainer();
	            wrapperWidth = this._isWindow($container) ? "100%" : $container.outerWidth(), wrapperHeight = this._isWindow($container) ? "100%" : $container.outerHeight()
	        } else {
	            wrapperWidth = "";
	            wrapperHeight = ""
	        }
	        this._$wrapper.css({
	            width: wrapperWidth,
	            height: wrapperHeight
	        })
	    },
	    _isWindow: function($element) {
	        return !!$element && $.isWindow($element.get(0))
	    },
	    _getContainer: function() {
	        var position = this._position,
	            container = this.option("container"),
	            positionOf = position ? position.of || window : null;
	        return getElement(container || positionOf)
	    },
	    _renderDimensions: function() {
	        this._$content.css({
	            minWidth: this.option("minWidth"),
	            maxWidth: this.option("maxWidth"),
	            minHeight: this.option("minHeight"),
	            maxHeight: this.option("maxHeight")
	        });
	        if (this._dimensionChangeHandled) {
	            var $content = this._$content,
	                $container = this._$container;
	            $content.outerWidth(Math.min($content[0].offsetWidth, $container.width())).outerHeight(Math.min($content[0].offsetHeight, $container.height()))
	        } else {
	            this._$content.outerWidth(this.option("width")).outerHeight(this.option("height"))
	        }
	    },
	    _renderPosition: function() {
	        if (this._positionChangeHandled) {
	            var allowedOffsets = this._allowedOffsets();
	            this._changePosition({
	                top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),
	                left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)
	            })
	        } else {
	            this._renderOverlayBoundaryOffset();
	            translator.resetPosition(this._$content);
	            var resultPosition = positionUtils.setup(this._$content, this._position);
	            forceRepaint(this._$content);
	            this._actions.onPositioning();
	            return resultPosition
	        }
	    },
	    _renderOverlayBoundaryOffset: function() {
	        var boundaryOffset = this.option("boundaryOffset");
	        this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px")
	    },
	    _focusTarget: function() {
	        return this._$content
	    },
	    _attachKeyboardEvents: function() {
	        this._keyboardProcessor = new KeyboardProcessor({
	            element: this._$content,
	            handler: this._keyboardHandler,
	            context: this
	        })
	    },
	    _keyboardHandler: function(options) {
	        var e = options.originalEvent,
	            $target = $(e.target);
	        if ($target.is(this._$content)) {
	            this.callBase.apply(this, arguments)
	        }
	    },
	    _isVisible: function() {
	        return this.option("visible")
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            if (this.option("visible")) {
	                this._renderVisibilityAnimate(visible)
	            }
	        } else {
	            this._renderVisibilityAnimate(visible)
	        }
	    },
	    _dimensionChanged: function() {
	        this._renderGeometry()
	    },
	    _clean: function() {
	        if (!this._contentAlreadyRendered) {
	            this.content().empty()
	        }
	        this._renderVisibility(false);
	        this._cleanFocusState()
	    },
	    _dispose: function() {
	        fx.stop(this._$content, false);
	        clearTimeout(this._deferShowTimer);
	        this._toggleViewPortSubscription(false);
	        this._toggleSubscriptions(false);
	        this._updateZIndexStackPosition(false);
	        this._toggleTabTerminator(false);
	        this._actions = null;
	        this.callBase();
	        this._$wrapper.remove();
	        this._$content.remove()
	    },
	    _toggleDisabledState: function(value) {
	        this.callBase.apply(this, arguments);
	        this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value))
	    },
	    _toggleRTLDirection: function(rtl) {
	        this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl)
	    },
	    _optionChanged: function(args) {
	        var value = args.value;
	        if ($.inArray(args.name, ACTIONS) > -1) {
	            this._initActions();
	            return
	        }
	        switch (args.name) {
	            case "dragEnabled":
	                this._renderDrag();
	                this._renderGeometry();
	                break;
	            case "resizeEnabled":
	                this._renderResize();
	                this._renderGeometry();
	                break;
	            case "shading":
	            case "shadingColor":
	                this._toggleShading(this.option("visible"));
	                break;
	            case "width":
	            case "minWidth":
	            case "maxWidth":
	            case "height":
	            case "minHeight":
	            case "maxHeight":
	            case "position":
	            case "boundaryOffset":
	                this._renderGeometry();
	                break;
	            case "visible":
	                this._renderVisibilityAnimate(value).done($.proxy(function() {
	                    if (!this._animateDeferred) {
	                        return
	                    }
	                    this._animateDeferred.resolveWith(this)
	                }, this));
	                break;
	            case "target":
	                this._initTarget(value);
	                this._invalidate();
	                break;
	            case "container":
	                this._initContainer(value);
	                this._invalidate();
	                break;
	            case "deferRendering":
	            case "contentTemplate":
	                this._contentAlreadyRendered = false;
	                this._invalidate();
	                break;
	            case "closeOnBackButton":
	                this._toggleHideTopOverlayCallback(this.option("visible"));
	                break;
	            case "closeOnTargetScroll":
	                this._toggleParentsScrollSubscription(this.option("visible"));
	                break;
	            case "closeOnOutsideClick":
	            case "animation":
	            case "propagateOutsideClick":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    toggle: function(showing) {
	        showing = void 0 === showing ? !this.option("visible") : showing;
	        if (showing === this.option("visible")) {
	            return $.Deferred().resolve().promise()
	        }
	        var animateDeferred = $.Deferred();
	        this._animateDeferred = animateDeferred;
	        this.option("visible", showing);
	        return animateDeferred.promise().done($.proxy(function() {
	            delete this._animateDeferred
	        }, this))
	    },
	    show: function() {
	        return this.toggle(true)
	    },
	    hide: function() {
	        return this.toggle(false)
	    },
	    content: function() {
	        return this._$content
	    },
	    repaint: function() {
	        this._renderGeometry()
	    }
	});
	Overlay.baseZIndex = function(zIndex) {
	    FIRST_Z_INDEX = zIndex
	};
	registerComponent("dxOverlay", Overlay);
	module.exports = Overlay;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/drag.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    wrapToArray = __webpack_require__(99).wrapToArray,
	    registerEvent = __webpack_require__(63),
	    eventUtils = __webpack_require__(61),
	    GestureEmitter = __webpack_require__(76),
	    registerEmitter = __webpack_require__(74);
	var DRAG_START_EVENT = "dxdragstart",
	    DRAG_EVENT = "dxdrag",
	    DRAG_END_EVENT = "dxdragend",
	    DRAG_ENTER_EVENT = "dxdragenter",
	    DRAG_LEAVE_EVENT = "dxdragleave",
	    DROP_EVENT = "dxdrop";
	var knownDropTargets = [],
	    knownDropTargetSelectors = [],
	    knownDropTargetConfigs = [];
	var dropTargetRegistration = {
	    setup: function(element, data) {
	        var knownDropTarget = $.inArray(element, knownDropTargets) !== -1;
	        if (!knownDropTarget) {
	            knownDropTargets.push(element);
	            knownDropTargetSelectors.push([]);
	            knownDropTargetConfigs.push(data || {})
	        }
	    },
	    add: function(element, handleObj) {
	        var index = $.inArray(element, knownDropTargets);
	        var selector = handleObj.selector;
	        if ($.inArray(selector, knownDropTargetSelectors[index]) === -1) {
	            knownDropTargetSelectors[index].push(selector)
	        }
	    },
	    teardown: function(element) {
	        var elementEvents = $._data(element, "events"),
	            handlersCount = 0;
	        $.each([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT], function(_, eventName) {
	            var eventHandlers = elementEvents[eventName];
	            if (eventHandlers) {
	                handlersCount += eventHandlers.length
	            }
	        });
	        if (!handlersCount) {
	            var index = $.inArray(element, knownDropTargets);
	            knownDropTargets.splice(index, 1);
	            knownDropTargetSelectors.splice(index, 1);
	            knownDropTargetConfigs.splice(index, 1)
	        }
	    }
	};
	registerEvent(DRAG_ENTER_EVENT, dropTargetRegistration);
	registerEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);
	registerEvent(DROP_EVENT, dropTargetRegistration);
	var getItemDelegatedTargets = function($element) {
	    var dropTargetIndex = $.inArray($element.get(0), knownDropTargets),
	        dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex];
	    var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
	    if ($.inArray(void 0, dropTargetSelectors) !== -1) {
	        $delegatedTargets = $delegatedTargets.addBack()
	    }
	    return $delegatedTargets
	};
	var getItemConfig = function($element) {
	    var dropTargetIndex = $.inArray($element.get(0), knownDropTargets);
	    return knownDropTargetConfigs[dropTargetIndex]
	};
	var getItemPosition = function(dropTargetConfig, $element) {
	    if (dropTargetConfig.itemPositionFunc) {
	        return dropTargetConfig.itemPositionFunc($element)
	    } else {
	        return $element.offset()
	    }
	};
	var getItemSize = function(dropTargetConfig, $element) {
	    if (dropTargetConfig.itemSizeFunc) {
	        return dropTargetConfig.itemSizeFunc($element)
	    }
	    return {
	        width: $element.width(),
	        height: $element.height()
	    }
	};
	var DragEmitter = GestureEmitter.inherit({
	    ctor: function(element) {
	        this.callBase(element);
	        this.direction = "both"
	    },
	    _init: function(e) {
	        this._initEvent = e
	    },
	    _start: function(e) {
	        e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
	        this._maxLeftOffset = e.maxLeftOffset;
	        this._maxRightOffset = e.maxRightOffset;
	        this._maxTopOffset = e.maxTopOffset;
	        this._maxBottomOffset = e.maxBottomOffset;
	        var dropTargets = wrapToArray(e.targetElements || (null === e.targetElements ? [] : knownDropTargets));
	        this._dropTargets = $.map(dropTargets, function(element) {
	            return $(element).get(0)
	        })
	    },
	    _move: function(e) {
	        var eventData = eventUtils.eventData(e),
	            dragOffset = this._calculateOffset(eventData);
	        this._fireEvent(DRAG_EVENT, e, {
	            offset: dragOffset
	        });
	        this._processDropTargets(e);
	        e.preventDefault()
	    },
	    _calculateOffset: function(eventData) {
	        return {
	            x: this._calculateXOffset(eventData),
	            y: this._calculateYOffset(eventData)
	        }
	    },
	    _calculateXOffset: function(eventData) {
	        if ("vertical" !== this.direction) {
	            var offset = eventData.x - this._startEventData.x;
	            return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)
	        }
	        return 0
	    },
	    _calculateYOffset: function(eventData) {
	        if ("horizontal" !== this.direction) {
	            var offset = eventData.y - this._startEventData.y;
	            return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)
	        }
	        return 0
	    },
	    _fitOffset: function(offset, minOffset, maxOffset) {
	        if (null != minOffset) {
	            offset = Math.max(offset, -minOffset)
	        }
	        if (null != maxOffset) {
	            offset = Math.min(offset, maxOffset)
	        }
	        return offset
	    },
	    _processDropTargets: function(e) {
	        var target = this._findDropTarget(e),
	            sameTarget = target === this._currentDropTarget;
	        if (!sameTarget) {
	            this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
	            this._currentDropTarget = target;
	            this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)
	        }
	    },
	    _fireDropTargetEvent: function(event, eventName) {
	        if (!this._currentDropTarget) {
	            return
	        }
	        var eventData = {
	            type: eventName,
	            originalEvent: event,
	            draggingElement: this._$element.get(0),
	            target: this._currentDropTarget
	        };
	        eventUtils.fireEvent(eventData)
	    },
	    _findDropTarget: function(e) {
	        var result, that = this;
	        $.each(knownDropTargets, function(_, target) {
	            if (!that._checkDropTargetActive(target)) {
	                return
	            }
	            var $target = $(target);
	            $.each(getItemDelegatedTargets($target), function(_, delegatedTarget) {
	                var $delegatedTarget = $(delegatedTarget);
	                if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, e)) {
	                    result = delegatedTarget
	                }
	            })
	        });
	        return result
	    },
	    _checkDropTargetActive: function(target) {
	        var active = false;
	        $.each(this._dropTargets, function(_, activeTarget) {
	            active = active || activeTarget === target || $.contains(activeTarget, target);
	            return !active
	        });
	        return active
	    },
	    _checkDropTarget: function(config, $target, e) {
	        var isDraggingElement = $target.get(0) === this._$element.get(0);
	        if (isDraggingElement) {
	            return false
	        }
	        var targetPosition = getItemPosition(config, $target);
	        if (e.pageX < targetPosition.left) {
	            return false
	        }
	        if (e.pageY < targetPosition.top) {
	            return false
	        }
	        var targetSize = getItemSize(config, $target);
	        if (e.pageX > targetPosition.left + targetSize.width) {
	            return false
	        }
	        if (e.pageY > targetPosition.top + targetSize.height) {
	            return false
	        }
	        return $target
	    },
	    _end: function(e) {
	        var eventData = eventUtils.eventData(e);
	        this._fireEvent(DRAG_END_EVENT, e, {
	            offset: this._calculateOffset(eventData)
	        });
	        this._fireDropTargetEvent(e, DROP_EVENT);
	        delete this._currentDropTarget
	    }
	});
	registerEmitter({
	    emitter: DragEmitter,
	    events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
	});
	exports.move = DRAG_EVENT;
	exports.start = DRAG_START_EVENT;
	exports.end = DRAG_END_EVENT;
	exports.enter = DRAG_ENTER_EVENT;
	exports.leave = DRAG_LEAVE_EVENT;
	exports.drop = DROP_EVENT;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/array.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    objectUtils = __webpack_require__(36);
	var isEmpty = function(entity) {
	    return $.isArray(entity) && !entity.length
	};
	var wrapToArray = function(entity) {
	    return $.isArray(entity) ? entity : [entity]
	};
	var intersection = function(a, b) {
	    if (!$.isArray(a) || 0 === a.length || !$.isArray(b) || 0 === b.length) {
	        return []
	    }
	    var result = [];
	    $.each(a, function(_, value) {
	        var index = $.inArray(value, b);
	        if (index !== -1) {
	            result.push(value)
	        }
	    });
	    return result
	};
	var removeDuplicates = function(from, what) {
	    if (!$.isArray(from) || 0 === from.length) {
	        return []
	    }
	    if (!$.isArray(what) || 0 === what.length) {
	        return from.slice()
	    }
	    var result = [];
	    $.each(from, function(_, value) {
	        var index = $.inArray(value, what);
	        if (index === -1) {
	            result.push(value)
	        }
	    });
	    return result
	};
	var normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
	    var indexedItems = {},
	        parameterIndex = 0;
	    $.each(items, function(index, item) {
	        index = item[indexParameterName];
	        if (commonUtils.isDefined(index)) {
	            indexedItems[index] = indexedItems[index] || [];
	            if (item === currentItem) {
	                indexedItems[index].unshift(item)
	            } else {
	                indexedItems[index].push(item)
	            }
	            delete item[indexParameterName]
	        }
	    });
	    objectUtils.orderEach(indexedItems, function(index, items) {
	        $.each(items, function() {
	            if (index >= 0) {
	                this[indexParameterName] = parameterIndex++
	            }
	        })
	    });
	    $.each(items, function() {
	        if (!commonUtils.isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
	            this[indexParameterName] = parameterIndex++
	        }
	    });
	    return parameterIndex
	};
	exports.isEmpty = isEmpty;
	exports.wrapToArray = wrapToArray;
	exports.intersection = intersection;
	exports.removeDuplicates = removeDuplicates;
	exports.normalizeIndexes = normalizeIndexes;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/resizable.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    stringUtils = __webpack_require__(7),
	    translator = __webpack_require__(59),
	    fitIntoRange = __webpack_require__(77).fitIntoRange,
	    DOMComponent = __webpack_require__(28),
	    eventUtils = __webpack_require__(61),
	    dragEvents = __webpack_require__(98);
	var RESIZABLE = "dxResizable",
	    RESIZABLE_CLASS = "dx-resizable",
	    RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing",
	    RESIZABLE_HANDLE_CLASS = "dx-resizable-handle",
	    RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top",
	    RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom",
	    RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left",
	    RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right",
	    RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner",
	    DRAGSTART_START_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, RESIZABLE),
	    DRAGSTART_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, RESIZABLE),
	    DRAGSTART_END_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, RESIZABLE);
	var Resizable = DOMComponent.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            handles: "all",
	            step: "1",
	            stepPrecision: "simple",
	            area: void 0,
	            minWidth: 30,
	            maxWidth: 1 / 0,
	            minHeight: 30,
	            maxHeight: 1 / 0,
	            onResizeStart: null,
	            onResize: null,
	            onResizeEnd: null
	        })
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(RESIZABLE_CLASS)
	    },
	    _render: function() {
	        this.callBase();
	        this._renderActions();
	        this._renderHandles()
	    },
	    _renderActions: function() {
	        this._resizeStartAction = this._createActionByOption("onResizeStart");
	        this._resizeEndAction = this._createActionByOption("onResizeEnd");
	        this._resizeAction = this._createActionByOption("onResize")
	    },
	    _renderHandles: function() {
	        var handles = this.option("handles");
	        if ("none" === handles) {
	            return
	        }
	        var directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
	        $.each(directions, $.proxy(function(index, handleName) {
	            this._renderHandle(handleName)
	        }, this));
	        $.inArray("bottom", directions) + 1 && $.inArray("right", directions) + 1 && this._renderHandle("corner-bottom-right");
	        $.inArray("bottom", directions) + 1 && $.inArray("left", directions) + 1 && this._renderHandle("corner-bottom-left");
	        $.inArray("top", directions) + 1 && $.inArray("right", directions) + 1 && this._renderHandle("corner-top-right");
	        $.inArray("top", directions) + 1 && $.inArray("left", directions) + 1 && this._renderHandle("corner-top-left")
	    },
	    _renderHandle: function(handleName) {
	        var $element = this.element(),
	            $handle = $("<div>");
	        $handle.addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo($element);
	        this._attachEventHandlers($handle)
	    },
	    _attachEventHandlers: function($handle) {
	        if (this.option("disabled")) {
	            return
	        }
	        var handlers = {};
	        handlers[DRAGSTART_START_EVENT_NAME] = $.proxy(this._dragStartHandler, this);
	        handlers[DRAGSTART_EVENT_NAME] = $.proxy(this._dragHandler, this);
	        handlers[DRAGSTART_END_EVENT_NAME] = $.proxy(this._dragEndHandler, this);
	        $handle.on(handlers, {
	            direction: "both",
	            immediate: true
	        })
	    },
	    _dragStartHandler: function(e) {
	        var $element = this.element();
	        if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
	            e.cancel = true;
	            return
	        }
	        this._toggleResizingClass(true);
	        this._movingSides = this._getMovingSides(e);
	        this._elementLocation = translator.locate($element);
	        this._elementSize = {
	            width: $element.outerWidth(),
	            height: $element.outerHeight()
	        };
	        this._renderDragOffsets(e);
	        this._resizeStartAction({
	            jQueryEvent: e,
	            width: this._elementSize.width,
	            height: this._elementSize.height,
	            handles: this._movingSides
	        });
	        e.targetElements = null
	    },
	    _toggleResizingClass: function(value) {
	        this.element().toggleClass(RESIZABLE_RESIZING_CLASS, value)
	    },
	    _renderDragOffsets: function(e) {
	        var area = this._getArea();
	        if (!area) {
	            return
	        }
	        var $handle = $(e.target).closest("." + RESIZABLE_HANDLE_CLASS),
	            handleWidth = $handle.outerWidth(),
	            handleHeight = $handle.outerHeight(),
	            handleOffset = $handle.offset(),
	            areaOffset = area.offset;
	        e.maxLeftOffset = handleOffset.left - areaOffset.left;
	        e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth;
	        e.maxTopOffset = handleOffset.top - areaOffset.top;
	        e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight
	    },
	    _getBorderWidth: function($element, direction) {
	        var borderWidth = $element.css("border-" + direction + "-width");
	        return parseInt(borderWidth) || 0
	    },
	    _dragHandler: function(e) {
	        var $element = this.element(),
	            sides = this._movingSides;
	        var location = this._elementLocation,
	            size = this._elementSize,
	            offset = this._getOffset(e);
	        var width = size.width + offset.x * (sides.left ? -1 : 1),
	            height = size.height + offset.y * (sides.top ? -1 : 1);
	        if (offset.x || "strict" === this.option("stepPrecision")) {
	            this._renderWidth(width)
	        }
	        if (offset.y || "strict" === this.option("stepPrecision")) {
	            this._renderHeight(height)
	        }
	        var offsetTop = offset.y - ((this.element().outerHeight() || height) - height),
	            offsetLeft = offset.x - ((this.element().outerWidth() || width) - width);
	        translator.move($element, {
	            top: location.top + (sides.top ? offsetTop : 0),
	            left: location.left + (sides.left ? offsetLeft : 0)
	        });
	        this._resizeAction({
	            jQueryEvent: e,
	            width: width,
	            height: height,
	            handles: this._movingSides
	        })
	    },
	    _getOffset: function(e) {
	        var offset = e.offset,
	            steps = stringUtils.pairToObject(this.option("step")),
	            sides = this._getMovingSides(e),
	            strictPrecision = "strict" === this.option("stepPrecision");
	        if (!sides.left && !sides.right) {
	            offset.x = 0
	        }
	        if (!sides.top && !sides.bottom) {
	            offset.y = 0
	        }
	        return strictPrecision ? this._getStrictOffset(offset, steps, sides) : this._getSimpleOffset(offset, steps)
	    },
	    _getSimpleOffset: function(offset, steps) {
	        return {
	            x: offset.x - offset.x % steps.h,
	            y: offset.y - offset.y % steps.v
	        }
	    },
	    _getStrictOffset: function(offset, steps, sides) {
	        var location = this._elementLocation,
	            size = this._elementSize,
	            xPos = sides.left ? location.left : location.left + size.width,
	            yPos = sides.top ? location.top : location.top + size.height,
	            newXShift = (xPos + offset.x) % steps.h,
	            newYShift = (yPos + offset.y) % steps.v,
	            sign = Math.sign || function(x) {
	                x = +x;
	                if (0 === x || isNaN(x)) {
	                    return x
	                }
	                return x > 0 ? 1 : -1
	            },
	            separatorOffset = function(steps, offset) {
	                return (1 + .2 * sign(offset)) % 1 * steps
	            },
	            isSmallOffset = function(offset, steps) {
	                return Math.abs(offset) < .2 * steps
	            };
	        var newOffsetX = offset.x - newXShift,
	            newOffsetY = offset.y - newYShift;
	        if (newXShift > separatorOffset(steps.h, offset.x)) {
	            newOffsetX += steps.h
	        }
	        if (newYShift > separatorOffset(steps.v, offset.y)) {
	            newOffsetY += steps.v
	        }
	        return {
	            x: (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0,
	            y: (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0
	        }
	    },
	    _getMovingSides: function(e) {
	        var $target = $(e.target),
	            hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left"),
	            hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right"),
	            hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left"),
	            hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right");
	        return {
	            top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
	            left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
	            bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
	            right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
	        }
	    },
	    _getArea: function() {
	        var area = this.option("area");
	        if ($.isFunction(area)) {
	            area = area.call(this)
	        }
	        if ($.isPlainObject(area)) {
	            return this._getAreaFromObject(area)
	        }
	        return this._getAreaFromElement(area)
	    },
	    _getAreaFromObject: function(area) {
	        var result = {
	            width: area.right - area.left,
	            height: area.bottom - area.top,
	            offset: {
	                left: area.left,
	                top: area.top
	            }
	        };
	        this._correctAreaGeometry(result);
	        return result
	    },
	    _getAreaFromElement: function(area) {
	        var result, $area = $(area);
	        if ($area.length) {
	            result = {};
	            result.width = $area.innerWidth();
	            result.height = $area.innerHeight();
	            result.offset = $area.offset();
	            this._correctAreaGeometry(result, $area)
	        }
	        return result
	    },
	    _correctAreaGeometry: function(result, $area) {
	        var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0,
	            areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
	        result.offset.left += areaBorderLeft + this._getBorderWidth(this.element(), "left");
	        result.offset.top += areaBorderTop + this._getBorderWidth(this.element(), "top");
	        result.width -= this.element().outerWidth() - this.element().innerWidth();
	        result.height -= this.element().outerHeight() - this.element().innerHeight()
	    },
	    _dragEndHandler: function(e) {
	        var $element = this.element();
	        this._resizeEndAction({
	            jQueryEvent: e,
	            width: $element.outerWidth(),
	            height: $element.outerHeight(),
	            handles: this._movingSides
	        });
	        this._toggleResizingClass(false)
	    },
	    _renderWidth: function(width) {
	        this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")))
	    },
	    _renderHeight: function(height) {
	        this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")))
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "disabled":
	            case "handles":
	                this._invalidate();
	                break;
	            case "minWidth":
	            case "maxWidth":
	                this._renderWidth(this.element().outerWidth());
	                break;
	            case "minHeight":
	            case "maxHeight":
	                this._renderHeight(this.element().outerHeight());
	                break;
	            case "onResize":
	            case "onResizeStart":
	            case "onResizeEnd":
	                this._renderActions();
	                break;
	            case "area":
	            case "stepPrecision":
	            case "step":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _clean: function() {
	        this.element().find("." + RESIZABLE_HANDLE_CLASS).remove()
	    }
	});
	registerComponent(RESIZABLE, Resizable);
	module.exports = Resizable;
	module.exports.default = module.exports;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/locker.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var errors = __webpack_require__(3);
	var Locker = function() {
	    var info = {};
	    var currentCount = function(lockName) {
	        return info[lockName] || 0
	    };
	    return {
	        obtain: function(lockName) {
	            info[lockName] = currentCount(lockName) + 1
	        },
	        release: function(lockName) {
	            var count = currentCount(lockName);
	            if (count < 1) {
	                throw errors.Error("E0014")
	            }
	            if (1 === count) {
	                delete info[lockName]
	            } else {
	                info[lockName] = count - 1
	            }
	        },
	        locked: function(lockName) {
	            return currentCount(lockName) > 0
	        }
	    }
	};
	module.exports = Locker;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/event_registrator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ko = __webpack_require__(82),
	    eventRegistrator = __webpack_require__(63),
	    eventUtils = __webpack_require__(61);
	eventRegistrator.callbacks.add(function(name) {
	    var koBindingEventName = eventUtils.addNamespace(name, name + "Binding");
	    ko.bindingHandlers[name] = {
	        update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
	            var $element = $(element),
	                unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
	                eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
	            $element.off(koBindingEventName).on(koBindingEventName, $.isPlainObject(unwrappedValue) ? unwrappedValue : {}, function(e) {
	                eventSource.call(viewModel, viewModel, e)
	            })
	        }
	    }
	});


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/components.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    Action = __webpack_require__(34),
	    compileGetter = __webpack_require__(35).compileGetter,
	    ko = __webpack_require__(82),
	    iconUtils = __webpack_require__(104),
	    inflector = __webpack_require__(49),
	    clickEvent = __webpack_require__(65);
	ko.bindingHandlers.dxAction = {
	    update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
	        var $element = $(element);
	        var unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
	            actionSource = unwrappedValue,
	            actionOptions = {
	                context: element
	            };
	        if (unwrappedValue.execute) {
	            actionSource = unwrappedValue.execute;
	            $.extend(actionOptions, unwrappedValue)
	        }
	        var action = new Action(actionSource, actionOptions);
	        $element.off(".dxActionBinding").on(clickEvent.name + ".dxActionBinding", function(e) {
	            action.execute({
	                element: $element,
	                model: viewModel,
	                evaluate: function(expression) {
	                    var context = viewModel;
	                    if (expression.length > 0 && "$" === expression[0]) {
	                        context = ko.contextFor(element)
	                    }
	                    var getter = compileGetter(expression);
	                    return getter(context)
	                },
	                jQueryEvent: e
	            });
	            if (!actionOptions.bubbling) {
	                e.stopPropagation()
	            }
	        })
	    }
	};
	ko.bindingHandlers.dxControlsDescendantBindings = {
	    init: function(_, valueAccessor) {
	        return {
	            controlsDescendantBindings: ko.unwrap(valueAccessor())
	        }
	    }
	};
	ko.bindingHandlers.dxPolymorphWidget = {
	    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	        var widgetName = ko.utils.unwrapObservable(valueAccessor()).name;
	        if (!widgetName) {
	            return
	        }
	        ko.virtualElements.emptyNode(element);
	        if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
	            var deprecatedName = widgetName;
	            widgetName = inflector.camelize("dx-" + widgetName);
	            errors.log("W0001", "dxToolbar - 'widget' item field", deprecatedName, "16.1", "Use: '" + widgetName + "' instead")
	        }
	        var markup = $('<div data-bind="' + widgetName + ': options">').get(0);
	        ko.virtualElements.prepend(element, markup);
	        var innerBindingContext = bindingContext.extend(valueAccessor);
	        ko.applyBindingsToDescendants(innerBindingContext, element);
	        return {
	            controlsDescendantBindings: true
	        }
	    }
	};
	ko.virtualElements.allowedBindings.dxPolymorphWidget = true;
	ko.bindingHandlers.dxIcon = {
	    init: function(element, valueAccessor) {
	        var options = ko.utils.unwrapObservable(valueAccessor()) || {},
	            iconElement = iconUtils.getImageContainer(options);
	        ko.virtualElements.emptyNode(element);
	        if (iconElement) {
	            ko.virtualElements.prepend(element, iconElement.get(0))
	        }
	    },
	    update: function(element, valueAccessor) {
	        var options = ko.utils.unwrapObservable(valueAccessor()) || {},
	            iconElement = iconUtils.getImageContainer(options);
	        ko.virtualElements.emptyNode(element);
	        if (iconElement) {
	            ko.virtualElements.prepend(element, iconElement.get(0))
	        }
	    }
	};
	ko.virtualElements.allowedBindings.dxIcon = true;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/utils/icon.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var getImageSourceType = function(source) {
	    if (!source || "string" !== typeof source) {
	        return false
	    }
	    if (/data:.*base64|\.|\//.test(source)) {
	        return "image"
	    }
	    if (/^[\w-_]+$/.test(source)) {
	        return "dxIcon"
	    }
	    return "fontIcon"
	};
	var getImageContainer = function(source) {
	    var imageType = getImageSourceType(source),
	        ICON_CLASS = "dx-icon";
	    switch (imageType) {
	        case "image":
	            return $("<img>", {
	                src: source
	            }).addClass(ICON_CLASS);
	        case "fontIcon":
	            return $("<i>", {
	                "class": ICON_CLASS + " " + source
	            });
	        case "dxIcon":
	            return $("<i>", {
	                "class": ICON_CLASS + " " + ICON_CLASS + "-" + source
	            });
	        default:
	            return null
	    }
	};
	exports.getImageSourceType = getImageSourceType;
	exports.getImageContainer = getImageContainer;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/validation.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    EventsMixin = __webpack_require__(38),
	    ValidationEngine = __webpack_require__(106),
	    ko = __webpack_require__(82);
	var koDxValidator = Class.inherit({
	    ctor: function(target, option) {
	        var that = this;
	        that.target = target;
	        that.validationRules = option.validationRules;
	        that.name = option.name;
	        that.isValid = ko.observable(true);
	        that.validationError = ko.observable();
	        $.each(this.validationRules, function(_, rule) {
	            rule.validator = that
	        })
	    },
	    validate: function() {
	        var result = ValidationEngine.validate(this.target(), this.validationRules, this.name);
	        this._applyValidationResult(result);
	        return result
	    },
	    reset: function() {
	        this.target(null);
	        var result = {
	            isValid: true,
	            brokenRule: null
	        };
	        this._applyValidationResult(result);
	        return result
	    },
	    _applyValidationResult: function(result) {
	        result.validator = this;
	        this.target.dxValidator.isValid(result.isValid);
	        this.target.dxValidator.validationError(result.brokenRule);
	        this.fireEvent("validated", [result])
	    }
	}).include(EventsMixin);
	ko.extenders.dxValidator = function(target, option) {
	    target.dxValidator = new koDxValidator(target, option);
	    target.subscribe($.proxy(target.dxValidator.validate, target.dxValidator));
	    return target
	};
	ValidationEngine.registerModelForValidation = function(model) {
	    $.each(model, function(name, member) {
	        if (ko.isObservable(member) && member.dxValidator) {
	            ValidationEngine.registerValidatorInGroup(model, member.dxValidator)
	        }
	    })
	};
	ValidationEngine.unregisterModelForValidation = function(model) {
	    $.each(model, function(name, member) {
	        if (ko.isObservable(member) && member.dxValidator) {
	            ValidationEngine.removeRegisteredValidator(model, member.dxValidator)
	        }
	    })
	};
	ValidationEngine.validateModel = ValidationEngine.validateGroup;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/validation_engine.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    EventsMixin = __webpack_require__(38),
	    errors = __webpack_require__(3),
	    commonUtils = __webpack_require__(8),
	    numberLocalization = __webpack_require__(20),
	    messageLocalization = __webpack_require__(79);
	var rulesValidators = {
	    required: {
	        validate: function(value, rule) {
	            if (!commonUtils.isDefined(value)) {
	                return false
	            }
	            if (false === value) {
	                return false
	            }
	            value = String(value);
	            if (rule.trim || !commonUtils.isDefined(rule.trim)) {
	                value = $.trim(value)
	            }
	            return "" !== value
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-required")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-required-formatted")(value)
	        }
	    },
	    numeric: {
	        validate: function(value, rule) {
	            if (!rulesValidators.required.validate(value, {})) {
	                return true
	            }
	            if (rule.useCultureSettings && commonUtils.isString(value)) {
	                return !isNaN(numberLocalization.parse(value))
	            } else {
	                return $.isNumeric(value)
	            }
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-numeric")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-numeric-formatted")(value)
	        }
	    },
	    range: {
	        validate: function(value, rule) {
	            if (!rulesValidators.required.validate(value, {})) {
	                return true
	            }
	            var validNumber = rulesValidators.numeric.validate(value, rule),
	                validValue = commonUtils.isDefined(value),
	                number = validNumber ? parseFloat(value) : validValue && value.valueOf(),
	                min = rule.min,
	                max = rule.max;
	            if (!(validNumber || commonUtils.isDate(value)) && !validValue) {
	                return false
	            }
	            if (commonUtils.isDefined(min)) {
	                if (commonUtils.isDefined(max)) {
	                    return number >= min && number <= max
	                }
	                return number >= min
	            } else {
	                if (commonUtils.isDefined(max)) {
	                    return number <= max
	                } else {
	                    throw errors.Error("E0101")
	                }
	            }
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-range")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-range-formatted")(value)
	        }
	    },
	    stringLength: {
	        validate: function(value, rule) {
	            value = commonUtils.isDefined(value) ? String(value) : "";
	            if (rule.trim || !commonUtils.isDefined(rule.trim)) {
	                value = $.trim(value)
	            }
	            return rulesValidators.range.validate(value.length, $.extend({}, rule))
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-stringLength")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-stringLength-formatted")(value)
	        }
	    },
	    custom: {
	        validate: function(value, rule) {
	            return rule.validationCallback({
	                value: value,
	                validator: rule.validator,
	                rule: rule
	            })
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-custom")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-custom-formatted")(value)
	        }
	    },
	    compare: {
	        validate: function(value, rule) {
	            if (!rule.comparisonTarget) {
	                throw errors.Error("E0102")
	            }
	            $.extend(rule, {
	                reevaluate: true
	            });
	            var otherValue = rule.comparisonTarget(),
	                type = rule.comparisonType || "==";
	            switch (type) {
	                case "==":
	                    return value == otherValue;
	                case "!=":
	                    return value != otherValue;
	                case "===":
	                    return value === otherValue;
	                case "!==":
	                    return value !== otherValue;
	                case ">":
	                    return value > otherValue;
	                case ">=":
	                    return value >= otherValue;
	                case "<":
	                    return value < otherValue;
	                case "<=":
	                    return value <= otherValue
	            }
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-compare")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-compare-formatted")(value)
	        }
	    },
	    pattern: {
	        validate: function(value, rule) {
	            if (!rulesValidators.required.validate(value, {})) {
	                return true
	            }
	            var pattern = rule.pattern;
	            if (commonUtils.isString(pattern)) {
	                pattern = new RegExp(pattern)
	            }
	            return pattern.test(value)
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-pattern")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-pattern-formatted")(value)
	        }
	    },
	    email: {
	        validate: function(value, rule) {
	            if (!rulesValidators.required.validate(value, {})) {
	                return true
	            }
	            return rulesValidators.pattern.validate(value, $.extend({}, rule, {
	                pattern: /^[\d\w\._\-]+@([\d\w\._\-]+\.)+[\w]+$/i
	            }))
	        },
	        defaultMessage: function(value) {
	            return messageLocalization.getFormatter("validation-email")(value)
	        },
	        defaultFormattedMessage: function(value) {
	            return messageLocalization.getFormatter("validation-email-formatted")(value)
	        }
	    }
	};
	var GroupConfig = Class.inherit({
	    ctor: function(group) {
	        this.group = group;
	        this.validators = []
	    },
	    validate: function() {
	        var result = {
	            isValid: true,
	            brokenRules: [],
	            validators: []
	        };
	        $.each(this.validators, function(_, validator) {
	            var validatorResult = validator.validate();
	            result.isValid = result.isValid && validatorResult.isValid;
	            if (validatorResult.brokenRule) {
	                result.brokenRules.push(validatorResult.brokenRule)
	            }
	            result.validators.push(validator)
	        });
	        this.fireEvent("validated", [{
	            validators: result.validators,
	            brokenRules: result.brokenRules,
	            isValid: result.isValid
	        }]);
	        return result
	    },
	    reset: function() {
	        $.each(this.validators, function(_, validator) {
	            validator.reset()
	        })
	    }
	}).include(EventsMixin);
	var ValidationEngine = {
	    groups: [],
	    getGroupConfig: function(group) {
	        var result = $.grep(this.groups, function(config) {
	            return config.group === group
	        });
	        if (result.length) {
	            return result[0]
	        }
	    },
	    initGroups: function() {
	        this.groups = [];
	        this.addGroup()
	    },
	    addGroup: function(group) {
	        var config = this.getGroupConfig(group);
	        if (!config) {
	            config = new GroupConfig(group);
	            this.groups.push(config)
	        }
	        return config
	    },
	    removeGroup: function(group) {
	        var config = this.getGroupConfig(group),
	            index = $.inArray(config, this.groups);
	        if (index > -1) {
	            this.groups.splice(index, 1)
	        }
	        return config
	    },
	    _setDefaultMessage: function(rule, validator, name) {
	        if (!commonUtils.isDefined(rule.message)) {
	            if (validator.defaultFormattedMessage && commonUtils.isDefined(name)) {
	                rule.message = validator.defaultFormattedMessage(name)
	            } else {
	                rule.message = validator.defaultMessage()
	            }
	        }
	    },
	    validate: function(value, rules, name) {
	        var result = {
	                name: name,
	                value: value,
	                brokenRule: null,
	                isValid: true,
	                validationRules: rules
	            },
	            that = this;
	        $.each(rules || [], function(_, rule) {
	            var ruleValidationResult, ruleValidator = rulesValidators[rule.type];
	            if (ruleValidator) {
	                if (commonUtils.isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {
	                    if (!rule.isValid) {
	                        result.isValid = false;
	                        result.brokenRule = rule;
	                        return false
	                    }
	                    return true
	                }
	                rule.value = value;
	                ruleValidationResult = ruleValidator.validate(value, rule);
	                rule.isValid = ruleValidationResult;
	                if (!ruleValidationResult) {
	                    result.isValid = false;
	                    that._setDefaultMessage(rule, ruleValidator, name);
	                    result.brokenRule = rule
	                }
	                if (!rule.isValid) {
	                    return false
	                }
	            } else {
	                throw errors.Error("E0100")
	            }
	        });
	        return result
	    },
	    registerValidatorInGroup: function(group, validator) {
	        var groupConfig = ValidationEngine.addGroup(group);
	        if ($.inArray(validator, groupConfig.validators) < 0) {
	            groupConfig.validators.push(validator)
	        }
	    },
	    removeRegisteredValidator: function(group, validator) {
	        var config = ValidationEngine.getGroupConfig(group),
	            validatorsInGroup = config && config.validators;
	        var index = $.inArray(validator, validatorsInGroup);
	        if (index > -1) {
	            validatorsInGroup.splice(index, 1)
	        }
	    },
	    validateGroup: function(group) {
	        var groupConfig = ValidationEngine.getGroupConfig(group);
	        if (!groupConfig) {
	            throw errors.Error("E0110")
	        }
	        return groupConfig.validate()
	    },
	    resetGroup: function(group) {
	        var groupConfig = ValidationEngine.getGroupConfig(group);
	        if (!groupConfig) {
	            throw errors.Error("E0110")
	        }
	        return groupConfig.reset()
	    }
	};
	ValidationEngine.initGroups();
	module.exports = ValidationEngine;
	module.exports.default = module.exports;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/variable_wrapper_utils.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var ko = __webpack_require__(82),
	    variableWrapper = __webpack_require__(37);
	variableWrapper.inject({
	    isWrapped: ko.isObservable,
	    isWritableWrapped: ko.isWritableObservable,
	    wrap: ko.observable,
	    unwrap: function(value) {
	        if (ko.isObservable(value)) {
	            return ko.utils.unwrapObservable(value)
	        }
	        return this.callBase(value)
	    },
	    assign: function(variable, value) {
	        if (ko.isObservable(variable)) {
	            variable(value)
	        } else {
	            this.callBase(variable, value)
	        }
	    }
	});


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/clean_node.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ko = __webpack_require__(82),
	    cleanData = $.cleanData,
	    compareVersion = __webpack_require__(11).compare;
	if (compareVersion($.fn.jquery, [2, 0]) >= 0) {
	    $.cleanData = function(nodes) {
	        var result = cleanData(nodes);
	        for (var i = 0; i < nodes.length; i++) {
	            nodes[i].cleanedByJquery = true
	        }
	        for (i = 0; i < nodes.length; i++) {
	            if (!nodes[i].cleanedByKo) {
	                ko.cleanNode(nodes[i])
	            }
	            delete nodes[i].cleanedByKo
	        }
	        for (i = 0; i < nodes.length; i++) {
	            delete nodes[i].cleanedByJquery
	        }
	        return result
	    };
	    ko.utils.domNodeDisposal.cleanExternalData = function(node) {
	        node.cleanedByKo = true;
	        if (!node.cleanedByJquery) {
	            $.cleanData([node])
	        }
	    }
	}


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (integration/knockout/clean_node_old.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ko = __webpack_require__(82),
	    compareVersion = __webpack_require__(11).compare;
	if (compareVersion($.fn.jquery, [2, 0]) < 0) {
	    var cleanKoData = function(element, andSelf) {
	        var cleanNode = function() {
	            ko.cleanNode(this)
	        };
	        if (andSelf) {
	            element.each(cleanNode)
	        } else {
	            element.find("*").each(cleanNode)
	        }
	    };
	    var originalEmpty = $.fn.empty;
	    $.fn.empty = function() {
	        cleanKoData(this, false);
	        return originalEmpty.apply(this, arguments)
	    };
	    var originalRemove = $.fn.remove;
	    $.fn.remove = function(selector, keepData) {
	        if (!keepData) {
	            var subject = this;
	            if (selector) {
	                subject = subject.filter(selector)
	            }
	            cleanKoData(subject, true)
	        }
	        return originalRemove.call(this, selector, keepData)
	    };
	    var originalHtml = $.fn.html;
	    $.fn.html = function(value) {
	        if ("string" === typeof value) {
	            cleanKoData(this, false)
	        }
	        return originalHtml.apply(this, arguments)
	    };
	    var originalReplaceWith = $.fn.replaceWith;
	    $.fn.replaceWith = function() {
	        var result = originalReplaceWith.apply(this, arguments);
	        if (!this.parent().length) {
	            cleanKoData(this, true)
	        }
	        return result
	    }
	}


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (bundles/modules/ui.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	__webpack_require__(2);
	module.exports = DevExpress.ui = {};
	DevExpress.ui.templateRendered = __webpack_require__(86).renderedCallbacks;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/dialog.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Component = __webpack_require__(33),
	    Action = __webpack_require__(34),
	    domUtils = __webpack_require__(43),
	    viewPortUtils = __webpack_require__(42),
	    devices = __webpack_require__(40),
	    themes = __webpack_require__(112),
	    errors = __webpack_require__(15),
	    messageLocalization = __webpack_require__(79),
	    Popup = __webpack_require__(113),
	    config = __webpack_require__(9);
	var DEFAULT_BUTTON = {
	    text: "OK",
	    onClick: function() {
	        return true
	    }
	};
	var DX_DIALOG_CLASSNAME = "dx-dialog",
	    DX_DIALOG_WRAPPER_CLASSNAME = DX_DIALOG_CLASSNAME + "-wrapper",
	    DX_DIALOG_ROOT_CLASSNAME = DX_DIALOG_CLASSNAME + "-root",
	    DX_DIALOG_CONTENT_CLASSNAME = DX_DIALOG_CLASSNAME + "-content",
	    DX_DIALOG_MESSAGE_CLASSNAME = DX_DIALOG_CLASSNAME + "-message",
	    DX_DIALOG_BUTTONS_CLASSNAME = DX_DIALOG_CLASSNAME + "-buttons",
	    DX_DIALOG_BUTTON_CLASSNAME = DX_DIALOG_CLASSNAME + "-button";
	var FakeDialogComponent = Component.inherit({
	    ctor: function(element, options) {
	        this.callBase(options)
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: {
	                platform: "ios"
	            },
	            options: {
	                width: 276
	            }
	        }, {
	            device: {
	                platform: "android"
	            },
	            options: {
	                lWidth: "60%",
	                pWidth: "80%"
	            }
	        }, {
	            device: function(device) {
	                var currentTheme = (themes.current() || "").split(".")[0];
	                return !device.phone && "win8" === currentTheme
	            },
	            options: {
	                width: function() {
	                    return $(window).width()
	                }
	            }
	        }, {
	            device: function(device) {
	                var currentTheme = (themes.current() || "").split(".")[0];
	                return device.phone && "win8" === currentTheme
	            },
	            options: {
	                position: {
	                    my: "top center",
	                    at: "top center",
	                    of: window,
	                    offset: "0 0"
	                }
	            }
	        }])
	    }
	});
	var dialog = function(options) {
	    var deferred = $.Deferred();
	    var defaultOptions = (new FakeDialogComponent).option();
	    options = $.extend(defaultOptions, options);
	    var $element = $("<div>").addClass(DX_DIALOG_CLASSNAME).appendTo(viewPortUtils.value());
	    var $message = $("<div>").addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(String(options.message));
	    var popupToolbarItems = [];
	    var toolbarItemsOption = options.buttons;
	    if (toolbarItemsOption) {
	        errors.log("W0001", "DevExpress.ui.dialog", "buttons", "16.1", "Use the 'toolbarItems' option instead")
	    } else {
	        toolbarItemsOption = options.toolbarItems
	    }
	    $.each(toolbarItemsOption || [DEFAULT_BUTTON], function() {
	        var action = new Action(this.onClick, {
	            context: popupInstance
	        });
	        popupToolbarItems.push({
	            toolbar: "bottom",
	            location: devices.current().android ? "after" : "center",
	            widget: "dxButton",
	            options: $.extend({}, this, {
	                onClick: function() {
	                    var result = action.execute(arguments);
	                    hide(result)
	                }
	            })
	        })
	    });
	    var popupInstance = new Popup($element, {
	        title: options.title || this.title,
	        showTitle: function() {
	            var isTitle = void 0 === options.showTitle ? true : options.showTitle;
	            return isTitle
	        }(),
	        height: "auto",
	        width: function() {
	            var isPortrait = $(window).height() > $(window).width(),
	                key = (isPortrait ? "p" : "l") + "Width",
	                widthOption = options.hasOwnProperty(key) ? options[key] : options.width;
	            return $.isFunction(widthOption) ? widthOption() : widthOption
	        },
	        showCloseButton: options.showCloseButton || false,
	        focusStateEnabled: false,
	        onContentReady: function(args) {
	            args.component.content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message)
	        },
	        onShowing: function(e) {
	            e.component.bottomToolbar().addClass(DX_DIALOG_BUTTONS_CLASSNAME).find(".dx-button").addClass(DX_DIALOG_BUTTON_CLASSNAME);
	            domUtils.resetActiveElement()
	        },
	        onShown: function(e) {
	            e.component.bottomToolbar().find(".dx-button").first().focus()
	        },
	        onHiding: function() {
	            deferred.reject()
	        },
	        toolbarItems: popupToolbarItems,
	        animation: {
	            show: {
	                type: "pop",
	                duration: 400
	            },
	            hide: {
	                type: "pop",
	                duration: 400,
	                to: {
	                    opacity: 0,
	                    scale: 0
	                },
	                from: {
	                    opacity: 1,
	                    scale: 1
	                }
	            }
	        },
	        rtlEnabled: config().rtlEnabled,
	        boundaryOffset: {
	            h: 10,
	            v: 0
	        }
	    });
	    popupInstance._wrapper().addClass(DX_DIALOG_WRAPPER_CLASSNAME);
	    if (options.position) {
	        popupInstance.option("position", options.position)
	    }
	    popupInstance._wrapper().addClass(DX_DIALOG_ROOT_CLASSNAME);

	    function show() {
	        popupInstance.show();
	        return deferred.promise()
	    }

	    function hide(value) {
	        deferred.resolve(value);
	        popupInstance.hide().done(function() {
	            popupInstance.element().remove()
	        })
	    }
	    return {
	        show: show,
	        hide: hide
	    }
	};
	var alert = function(message, title, showTitle) {
	    var dialogInstance, options = $.isPlainObject(message) ? message : {
	        title: title,
	        message: message,
	        showTitle: showTitle
	    };
	    dialogInstance = this.custom(options);
	    return dialogInstance.show()
	};
	var confirm = function(message, title, showTitle) {
	    var dialogInstance, options = $.isPlainObject(message) ? message : {
	        title: title,
	        message: message,
	        showTitle: showTitle,
	        toolbarItems: [{
	            text: messageLocalization.format("Yes"),
	            onClick: function() {
	                return true
	            }
	        }, {
	            text: messageLocalization.format("No"),
	            onClick: function() {
	                return false
	            }
	        }]
	    };
	    dialogInstance = this.custom(options);
	    return dialogInstance.show()
	};
	exports.custom = dialog;
	exports.alert = alert;
	exports.confirm = confirm;
	exports.FakeDialogComponent = FakeDialogComponent;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/themes.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(15),
	    domUtils = __webpack_require__(43),
	    devices = __webpack_require__(40),
	    viewPortUtils = __webpack_require__(42),
	    viewPort = viewPortUtils.value,
	    viewPortChanged = viewPortUtils.changeCallback;
	var DX_LINK_SELECTOR = "link[rel=dx-theme]",
	    THEME_ATTR = "data-theme",
	    ACTIVE_ATTR = "data-active",
	    DX_HAIRLINES_CLASS = "dx-hairlines";
	var context, $activeThemeLink, knownThemes, currentThemeName, pendingThemeName;
	var THEME_MARKER_PREFIX = "dx.";

	function readThemeMarker() {
	    var result, element = $("<div></div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
	    try {
	        result = element.css("font-family");
	        if (!result) {
	            return null
	        }
	        result = result.replace(/["']/g, "");
	        if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
	            return null
	        }
	        return result.substr(THEME_MARKER_PREFIX.length)
	    } finally {
	        element.remove()
	    }
	}

	function waitForThemeLoad(themeName, callback) {
	    var timerId, waitStartTime;
	    pendingThemeName = themeName;

	    function handleLoaded() {
	        pendingThemeName = null;
	        callback()
	    }
	    if (isPendingThemeLoaded()) {
	        handleLoaded()
	    } else {
	        waitStartTime = $.now();
	        timerId = setInterval(function() {
	            var isLoaded = isPendingThemeLoaded(),
	                isTimeout = !isLoaded && $.now() - waitStartTime > 15e3;
	            if (isTimeout) {
	                errors.log("W0004", pendingThemeName)
	            }
	            if (isLoaded || isTimeout) {
	                clearInterval(timerId);
	                handleLoaded()
	            }
	        }, 10)
	    }
	}

	function isPendingThemeLoaded() {
	    return !pendingThemeName || readThemeMarker() === pendingThemeName
	}

	function processMarkup() {
	    var $allThemeLinks = $(DX_LINK_SELECTOR, context);
	    if (!$allThemeLinks.length) {
	        return
	    }
	    knownThemes = {};
	    $activeThemeLink = $(domUtils.createMarkupFromString("<link rel=stylesheet>"), context);
	    $allThemeLinks.each(function() {
	        var link = $(this, context),
	            fullThemeName = link.attr(THEME_ATTR),
	            url = link.attr("href"),
	            isActive = "true" === link.attr(ACTIVE_ATTR);
	        knownThemes[fullThemeName] = {
	            url: url,
	            isActive: isActive
	        }
	    });
	    $allThemeLinks.last().after($activeThemeLink);
	    $allThemeLinks.remove()
	}

	function resolveFullThemeName(desiredThemeName) {
	    var desiredThemeParts = desiredThemeName.split("."),
	        result = null;
	    if (knownThemes) {
	        $.each(knownThemes, function(knownThemeName, themeData) {
	            var knownThemeParts = knownThemeName.split(".");
	            if (knownThemeParts[0] !== desiredThemeParts[0]) {
	                return
	            }
	            if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
	                return
	            }
	            if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
	                return
	            }
	            if (!result || themeData.isActive) {
	                result = knownThemeName
	            }
	            if (themeData.isActive) {
	                return false
	            }
	        })
	    }
	    return result
	}

	function initContext(newContext) {
	    try {
	        if (newContext !== context) {
	            knownThemes = null
	        }
	    } catch (x) {
	        knownThemes = null
	    }
	    context = newContext
	}

	function init(options) {
	    options = options || {};
	    initContext(options.context || document);
	    processMarkup();
	    currentThemeName = void 0;
	    current(options)
	}

	function current(options) {
	    if (!arguments.length) {
	        currentThemeName = currentThemeName || readThemeMarker();
	        return currentThemeName
	    }
	    detachCssClasses(viewPort());
	    options = options || {};
	    if ("string" === typeof options) {
	        options = {
	            theme: options
	        }
	    }
	    var currentThemeData, isAutoInit = options._autoInit,
	        loadCallback = options.loadCallback;
	    currentThemeName = options.theme || currentThemeName;
	    if (isAutoInit && !currentThemeName) {
	        currentThemeName = themeNameFromDevice(devices.current())
	    }
	    currentThemeName = resolveFullThemeName(currentThemeName);
	    if (currentThemeName) {
	        currentThemeData = knownThemes[currentThemeName]
	    }
	    if (currentThemeData) {
	        $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
	        if (loadCallback) {
	            waitForThemeLoad(currentThemeName, loadCallback)
	        } else {
	            if (pendingThemeName) {
	                pendingThemeName = currentThemeName
	            }
	        }
	    } else {
	        if (isAutoInit) {
	            if (loadCallback) {
	                loadCallback()
	            }
	        } else {
	            throw errors.Error("E0021", currentThemeName)
	        }
	    }
	    attachCssClasses(viewPortUtils.originalViewPort(), currentThemeName)
	}

	function themeNameFromDevice(device) {
	    var themeName = device.platform;
	    var majorVersion = device.version && device.version[0];
	    switch (themeName) {
	        case "ios":
	            themeName += "7";
	            break;
	        case "android":
	            themeName += "5";
	            break;
	        case "win":
	            themeName += majorVersion && 8 === majorVersion ? "8" : "10"
	    }
	    return themeName
	}

	function getCssClasses(themeName) {
	    themeName = themeName || current();
	    var result = [],
	        themeNameParts = themeName && themeName.split(".");
	    if (themeNameParts) {
	        result.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
	        if (themeNameParts.length > 1) {
	            result.push("dx-color-scheme-" + themeNameParts[1])
	        }
	    }
	    return result
	}
	var themeClasses;

	function attachCssClasses(element, themeName) {
	    themeClasses = getCssClasses(themeName).join(" ");
	    $(element).addClass(themeClasses);
	    var activateHairlines = function() {
	        var pixelRatio = window.devicePixelRatio;
	        if (!pixelRatio || pixelRatio < 2) {
	            return
	        }
	        var $tester = $("<div>");
	        $tester.css("border", ".5px solid transparent");
	        $("body").append($tester);
	        if (1 === $tester.outerHeight()) {
	            $(element).addClass(DX_HAIRLINES_CLASS);
	            themeClasses += " " + DX_HAIRLINES_CLASS
	        }
	        $tester.remove()
	    };
	    activateHairlines()
	}

	function detachCssClasses(element) {
	    $(element).removeClass(themeClasses)
	}
	$.holdReady(true);
	init({
	    _autoInit: true,
	    loadCallback: function() {
	        $.holdReady(false)
	    }
	});
	domUtils.ready(function() {
	    if ($(DX_LINK_SELECTOR, context).length) {
	        throw errors.Error("E0022")
	    }
	});
	viewPortChanged.add(function(viewPort, prevViewPort) {
	    detachCssClasses(prevViewPort);
	    attachCssClasses(viewPort)
	});
	devices.changed.add(function() {
	    init({
	        _autoInit: true
	    })
	});
	exports.current = current;
	exports.init = init;
	exports.attachCssClasses = attachCssClasses;
	exports.detachCssClasses = detachCssClasses;
	exports.themeNameFromDevice = themeNameFromDevice;
	exports.waitForThemeLoad = waitForThemeLoad;
	exports.resetTheme = function() {
	    $activeThemeLink && $activeThemeLink.attr("href", "about:blank");
	    currentThemeName = null;
	    pendingThemeName = null
	};
	module.exports.default = module.exports;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/popup.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    translator = __webpack_require__(59),
	    camelize = __webpack_require__(49).camelize,
	    commonUtils = __webpack_require__(8),
	    messageLocalization = __webpack_require__(79),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    Button = __webpack_require__(114),
	    themes = __webpack_require__(112),
	    Overlay = __webpack_require__(97),
	    EmptyTemplate = __webpack_require__(88),
	    domUtils = __webpack_require__(43);
	__webpack_require__(116);
	var POPUP_CLASS = "dx-popup",
	    POPUP_WRAPPER_CLASS = "dx-popup-wrapper",
	    POPUP_FULL_SCREEN_CLASS = "dx-popup-fullscreen",
	    POPUP_FULL_SCREEN_WIDTH_CLASS = "dx-popup-fullscreen-width",
	    POPUP_NORMAL_CLASS = "dx-popup-normal",
	    POPUP_CONTENT_CLASS = "dx-popup-content",
	    POPUP_DRAGGABLE_CLASS = "dx-popup-draggable",
	    POPUP_TITLE_CLASS = "dx-popup-title",
	    POPUP_TITLE_CLOSEBUTTON_CLASS = "dx-closebutton",
	    POPUP_BOTTOM_CLASS = "dx-popup-bottom",
	    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
	    ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
	var getButtonPlace = function(name) {
	    var device = devices.current(),
	        platform = device.platform,
	        toolbar = "bottom",
	        location = "before";
	    if ("ios" === platform) {
	        switch (name) {
	            case "cancel":
	                toolbar = "top";
	                break;
	            case "clear":
	                toolbar = "top";
	                location = "after";
	                break;
	            case "done":
	                location = "after"
	        }
	    } else {
	        if ("win" === platform) {
	            location = "after"
	        } else {
	            if ("android" === platform && device.version && parseInt(device.version[0]) > 4) {
	                switch (name) {
	                    case "cancel":
	                        location = "after";
	                        break;
	                    case "done":
	                        location = "after"
	                }
	            } else {
	                if ("android" === platform) {
	                    location = "center"
	                }
	            }
	        }
	    }
	    return {
	        toolbar: toolbar,
	        location: location
	    }
	};
	var Popup = Overlay.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            fullScreen: false,
	            title: "",
	            showTitle: true,
	            titleTemplate: "title",
	            onTitleRendered: null,
	            dragEnabled: false,
	            toolbarItems: [],
	            showCloseButton: false,
	            bottomTemplate: "bottom"
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                var currentTheme = (themes.current() || "").split(".")[0];
	                return "win8" === currentTheme
	            },
	            options: {
	                width: function() {
	                    return $(window).width()
	                }
	            }
	        }, {
	            device: function(device) {
	                var currentTheme = (themes.current() || "").split(".")[0];
	                return device.phone && "win8" === currentTheme
	            },
	            options: {
	                position: {
	                    my: "top center",
	                    at: "top center",
	                    offset: "0 0"
	                }
	            }
	        }, {
	            device: {
	                platform: "ios"
	            },
	            options: {
	                animation: this._iosAnimation
	            }
	        }, {
	            device: {
	                platform: "android"
	            },
	            options: {
	                animation: this._androidAnimation
	            }
	        }, {
	            device: {
	                platform: "generic"
	            },
	            options: {
	                showCloseButton: true
	            }
	        }, {
	            device: function(device) {
	                return "generic" === devices.real().platform && "generic" === device.platform
	            },
	            options: {
	                dragEnabled: true
	            }
	        }, {
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }])
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            buttons: {
	                since: "16.1",
	                alias: "toolbarItems"
	            }
	        })
	    },
	    _iosAnimation: {
	        show: {
	            type: "slide",
	            duration: 400,
	            from: {
	                position: {
	                    my: "top",
	                    at: "bottom"
	                }
	            },
	            to: {
	                position: {
	                    my: "center",
	                    at: "center"
	                }
	            }
	        },
	        hide: {
	            type: "slide",
	            duration: 400,
	            from: {
	                opacity: 1,
	                position: {
	                    my: "center",
	                    at: "center"
	                }
	            },
	            to: {
	                opacity: 1,
	                position: {
	                    my: "top",
	                    at: "bottom"
	                }
	            }
	        }
	    },
	    _androidAnimation: function() {
	        var fullScreenConfig = {
	                show: {
	                    type: "slide",
	                    duration: 300,
	                    from: {
	                        top: "30%",
	                        opacity: 0
	                    },
	                    to: {
	                        top: 0,
	                        opacity: 1
	                    }
	                },
	                hide: {
	                    type: "slide",
	                    duration: 300,
	                    from: {
	                        top: 0,
	                        opacity: 1
	                    },
	                    to: {
	                        top: "30%",
	                        opacity: 0
	                    }
	                }
	            },
	            defaultConfig = {
	                show: {
	                    type: "fade",
	                    duration: 400,
	                    from: 0,
	                    to: 1
	                },
	                hide: {
	                    type: "fade",
	                    duration: 400,
	                    from: 1,
	                    to: 0
	                }
	            };
	        return this.option("fullScreen") ? fullScreenConfig : defaultConfig
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(POPUP_CLASS);
	        this._wrapper().addClass(POPUP_WRAPPER_CLASS);
	        this._$popupContent = this._$content.wrapInner($("<div>").addClass(POPUP_CONTENT_CLASS)).children().eq(0)
	    },
	    _render: function() {
	        var isFullscreen = this.option("fullScreen");
	        this._toggleFullScreenClass(isFullscreen);
	        this.callBase()
	    },
	    _toggleFullScreenClass: function(value) {
	        this._$content.toggleClass(POPUP_FULL_SCREEN_CLASS, value).toggleClass(POPUP_NORMAL_CLASS, !value)
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.title = new EmptyTemplate(this);
	        this._defaultTemplates.bottom = new EmptyTemplate(this)
	    },
	    _renderContentImpl: function() {
	        this.callBase();
	        this._renderTitle();
	        this._renderBottom()
	    },
	    _renderTitle: function() {
	        var items = this._getToolbarItems("top"),
	            titleText = this.option("title"),
	            showTitle = this.option("showTitle");
	        if (showTitle && !!titleText) {
	            items.unshift({
	                location: devices.current().ios ? "center" : "before",
	                text: titleText
	            })
	        }
	        if (showTitle || items.length > 0) {
	            this._$title && this._$title.remove();
	            var $title = $("<div>").addClass(POPUP_TITLE_CLASS).insertBefore(this.content());
	            this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass(POPUP_TITLE_CLASS);
	            this._renderDrag();
	            this._executeTitleRenderAction(this._$title)
	        } else {
	            if (this._$title) {
	                this._$title.detach()
	            }
	        }
	    },
	    _renderTemplateByType: function(optionName, data, $container) {
	        var template = this._getTemplateByOption(optionName),
	            toolbarTemplate = template instanceof EmptyTemplate;
	        if (toolbarTemplate) {
	            this._getTemplate("dx-polymorph-widget").render({
	                container: $container,
	                model: {
	                    widget: "dxToolbarBase",
	                    options: {
	                        items: data
	                    }
	                }
	            });
	            var $toolbar = $container.children("div");
	            $container.replaceWith($toolbar);
	            return $toolbar
	        } else {
	            var $result = template.render({
	                container: $container
	            });
	            if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
	                $container.replaceWith($result);
	                $container = $result
	            }
	            return $container
	        }
	    },
	    _executeTitleRenderAction: function(titleElement) {
	        this._getTitleRenderAction()({
	            titleElement: titleElement
	        })
	    },
	    _getTitleRenderAction: function() {
	        return this._titleRenderAction || this._createTitleRenderAction()
	    },
	    _createTitleRenderAction: function() {
	        return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
	            element: this.element(),
	            excludeValidators: ["designMode", "disabled", "readOnly"]
	        })
	    },
	    _getCloseButton: function() {
	        return {
	            toolbar: "top",
	            location: "after",
	            template: this._getCloseButtonRenderer()
	        }
	    },
	    _getCloseButtonRenderer: function() {
	        return $.proxy(function(_, __, $container) {
	            var $button = $("<div>").addClass(POPUP_TITLE_CLOSEBUTTON_CLASS);
	            this._createComponent($button, Button, {
	                icon: "close",
	                onClick: this._createToolbarItemAction(void 0),
	                integrationOptions: {}
	            });
	            $container.append($button)
	        }, this)
	    },
	    _getToolbarItems: function(toolbar) {
	        var toolbarItems = this.option("toolbarItems");
	        var toolbarsItems = [];
	        this._toolbarItemClasses = [];
	        var currentPlatform = devices.current().platform,
	            index = 0;
	        $.each(toolbarItems, $.proxy(function(_, data) {
	            var isShortcut = commonUtils.isDefined(data.shortcut),
	                item = isShortcut ? getButtonPlace(data.shortcut) : data;
	            if (isShortcut && "ios" === currentPlatform && index < 2) {
	                item.toolbar = "top";
	                index++
	            }
	            item.toolbar = data.toolbar || item.toolbar || "top";
	            if (item && item.toolbar === toolbar) {
	                if (isShortcut) {
	                    $.extend(item, {
	                        location: data.location
	                    }, this._getToolbarItemByAlias(data))
	                }
	                var isLTROrder = "win" === currentPlatform || "generic" === currentPlatform;
	                if ("done" === data.shortcut && isLTROrder || "cancel" === data.shortcut && !isLTROrder) {
	                    toolbarsItems.unshift(item)
	                } else {
	                    toolbarsItems.push(item)
	                }
	            }
	        }, this));
	        if ("top" === toolbar && this.option("showCloseButton") && this.option("showTitle")) {
	            toolbarsItems.push(this._getCloseButton())
	        }
	        return toolbarsItems
	    },
	    _getToolbarItemByAlias: function(data) {
	        var that = this,
	            itemType = data.shortcut;
	        if ($.inArray(itemType, ALLOWED_TOOLBAR_ITEM_ALIASES) < 0) {
	            return false
	        }
	        var itemConfig = $.extend({
	            text: messageLocalization.format(camelize(itemType, true)),
	            onClick: this._createToolbarItemAction(data.onClick),
	            integrationOptions: {}
	        }, data.options || {});
	        var itemClass = POPUP_CLASS + "-" + itemType;
	        this._toolbarItemClasses.push(itemClass);
	        return {
	            template: function(_, __, $container) {
	                var $toolbarItem = $("<div>").addClass(itemClass).appendTo($container);
	                that._createComponent($toolbarItem, Button, itemConfig)
	            }
	        }
	    },
	    _createToolbarItemAction: function(clickAction) {
	        return this._createAction(clickAction, {
	            afterExecute: function(e) {
	                e.component.hide()
	            }
	        })
	    },
	    _renderBottom: function() {
	        var items = this._getToolbarItems("bottom");
	        if (items.length) {
	            this._$bottom && this._$bottom.remove();
	            var $bottom = $("<div>").addClass(POPUP_BOTTOM_CLASS).insertAfter(this.content());
	            this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom).addClass(POPUP_BOTTOM_CLASS);
	            this._toggleClasses()
	        } else {
	            this._$bottom && this._$bottom.detach()
	        }
	    },
	    _toggleClasses: function() {
	        var aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
	        $.each(aliases, $.proxy(function(_, alias) {
	            var className = POPUP_CLASS + "-" + alias;
	            if ($.inArray(className, this._toolbarItemClasses) >= 0) {
	                this._wrapper().addClass(className + "-visible");
	                this._$bottom.addClass(className)
	            } else {
	                this._wrapper().removeClass(className + "-visible");
	                this._$bottom.removeClass(className)
	            }
	        }, this))
	    },
	    _getDragTarget: function() {
	        return this._$title
	    },
	    _renderGeometryImpl: function() {
	        this._resetContentHeight();
	        this.callBase.apply(this, arguments);
	        this._setContentHeight()
	    },
	    _resetContentHeight: function() {
	        this._$popupContent.css({
	            height: "auto"
	        })
	    },
	    _renderDrag: function() {
	        this.callBase();
	        this._$content.toggleClass(POPUP_DRAGGABLE_CLASS, this.option("dragEnabled"))
	    },
	    _renderResize: function() {
	        this.callBase();
	        this._$content.dxResizable("option", "onResize", $.proxy(function() {
	            this._setContentHeight();
	            this._actions.onResize(arguments)
	        }, this))
	    },
	    _setContentHeight: function() {
	        if (this._disallowUpdateContentHeight()) {
	            return
	        }
	        var contentPaddings = this._$content.outerHeight() - this._$content.height(),
	            contentHeight = this._$content.get(0).getBoundingClientRect().height - contentPaddings;
	        if (this._$title && this._$title.is(":visible")) {
	            contentHeight -= this._$title.get(0).getBoundingClientRect().height || 0
	        }
	        if (this._$bottom && this._$bottom.is(":visible")) {
	            contentHeight -= this._$bottom.get(0).getBoundingClientRect().height || 0
	        }
	        this._$popupContent.css({
	            height: contentHeight
	        })
	    },
	    _disallowUpdateContentHeight: function() {
	        var isHeightAuto = "auto" === this._$content.get(0).style.height,
	            maxHeightSpecified = "none" !== this._$content.css("maxHeight"),
	            minHeightSpecified = parseInt(this._$content.css("minHeight")) > 0;
	        return isHeightAuto && !(maxHeightSpecified || minHeightSpecified)
	    },
	    _renderDimensions: function() {
	        if (this.option("fullScreen")) {
	            this._$content.css({
	                width: "100%",
	                height: "100%"
	            })
	        } else {
	            this.callBase.apply(this, arguments)
	        }
	        this._renderFullscreenWidthClass()
	    },
	    _renderFullscreenWidthClass: function() {
	        this.overlayContent().toggleClass(POPUP_FULL_SCREEN_WIDTH_CLASS, this.overlayContent().outerWidth() === $(window).width())
	    },
	    _renderShadingDimensions: function() {
	        if (this.option("fullScreen")) {
	            this._wrapper().css({
	                width: "100%",
	                height: "100%"
	            })
	        } else {
	            this.callBase.apply(this, arguments)
	        }
	    },
	    _renderPosition: function() {
	        if (this.option("fullScreen")) {
	            translator.move(this._$content, {
	                top: 0,
	                left: 0
	            })
	        } else {
	            return this.callBase.apply(this, arguments)
	        }
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "showTitle":
	            case "title":
	            case "titleTemplate":
	                this._renderTitle();
	                this._renderGeometry();
	                break;
	            case "bottomTemplate":
	                this._renderBottom();
	                this._renderGeometry();
	                break;
	            case "onTitleRendered":
	                this._createTitleRenderAction(args.value);
	                break;
	            case "toolbarItems":
	                this._renderTitle();
	                this._renderBottom();
	                this._renderGeometry();
	                break;
	            case "dragEnabled":
	                this._renderDrag();
	                break;
	            case "fullScreen":
	                this._toggleFullScreenClass(args.value);
	                this._renderGeometry();
	                domUtils.triggerResizeEvent(this._$content);
	                break;
	            case "showCloseButton":
	                this._renderTitle();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    bottomToolbar: function() {
	        return this._$bottom
	    },
	    content: function() {
	        return this._$popupContent
	    },
	    overlayContent: function() {
	        return this._$content
	    }
	});
	registerComponent("dxPopup", Popup);
	module.exports = Popup;
	module.exports.default = module.exports;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/button.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    iconUtils = __webpack_require__(104),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    ValidationMixin = __webpack_require__(96),
	    ValidationEngine = __webpack_require__(106),
	    Widget = __webpack_require__(84),
	    inkRipple = __webpack_require__(115),
	    eventUtils = __webpack_require__(61),
	    themes = __webpack_require__(112),
	    clickEvent = __webpack_require__(65),
	    FunctionTemplate = __webpack_require__(87);
	var BUTTON_CLASS = "dx-button",
	    BUTTON_CONTENT_CLASS = "dx-button-content",
	    BUTTON_HAS_TEXT_CLASS = "dx-button-has-text",
	    BUTTON_HAS_ICON_CLASS = "dx-button-has-icon",
	    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
	    BUTTON_TEXT_CLASS = "dx-button-text",
	    ANONYMOUS_TEMPLATE_NAME = "content",
	    BUTTON_FEEDBACK_HIDE_TIMEOUT = 100;
	var Button = Widget.inherit({
	    _supportedKeys: function() {
	        var that = this,
	            click = function(e) {
	                e.preventDefault();
	                that._executeClickAction(e)
	            };
	        return $.extend(this.callBase(), {
	            space: click,
	            enter: click
	        })
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            iconSrc: {
	                since: "15.1",
	                alias: "icon"
	            }
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            hoverStateEnabled: true,
	            onClick: null,
	            type: "normal",
	            text: "",
	            icon: "",
	            validationGroup: void 0,
	            activeStateEnabled: true,
	            template: "content",
	            useSubmitBehavior: false,
	            useInkRipple: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                useInkRipple: true
	            }
	        }])
	    },
	    _getAnonymousTemplateName: function() {
	        return ANONYMOUS_TEMPLATE_NAME
	    },
	    _feedbackHideTimeout: BUTTON_FEEDBACK_HIDE_TIMEOUT,
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.content = new FunctionTemplate(function(options) {
	            var data = options.model,
	                $iconElement = iconUtils.getImageContainer(data && data.icon),
	                $textContainer = data && data.text ? $("<span>").text(data.text).addClass(BUTTON_TEXT_CLASS) : void 0;
	            options.container.append($iconElement).append($textContainer)
	        }, this)
	    },
	    _render: function() {
	        this.element().addClass(BUTTON_CLASS);
	        this._renderType();
	        this.option("useInkRipple") && this._renderInkRipple();
	        this._renderClick();
	        this.setAria("role", "button");
	        this._updateAriaLabel();
	        this.callBase()
	    },
	    _renderInkRipple: function() {
	        var isOnlyIconButton = !this.option("text") && this.option("icon") || "back" === this.option("type"),
	            config = {};
	        if (isOnlyIconButton) {
	            $.extend(config, {
	                waveSizeCoefficient: 1,
	                useHoldAnimation: false,
	                isCentered: true
	            })
	        }
	        this._inkRipple = inkRipple.render(config)
	    },
	    _toggleActiveState: function($element, value, e) {
	        this.callBase.apply(this, arguments);
	        if (!this._inkRipple) {
	            return
	        }
	        var config = {
	            element: this._$content,
	            jQueryEvent: e
	        };
	        if (value) {
	            this._inkRipple.showWave(config)
	        } else {
	            this._inkRipple.hideWave(config)
	        }
	    },
	    _renderContentImpl: function() {
	        var $element = this.element(),
	            data = this._getContentData();
	        if (this._$content) {
	            this._$content.empty()
	        } else {
	            this._$content = $("<div>").addClass(BUTTON_CONTENT_CLASS).appendTo($element)
	        }
	        $element.toggleClass(BUTTON_HAS_ICON_CLASS, !!data.icon).toggleClass(BUTTON_HAS_TEXT_CLASS, !!data.text);
	        var template = this._getTemplateByOption("template"),
	            $result = template.render({
	                model: data,
	                container: this._$content
	            });
	        if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
	            this._$content.replaceWith($result);
	            this._$content = $result;
	            this._$content.addClass(BUTTON_CONTENT_CLASS)
	        }
	        if (this.option("useSubmitBehavior")) {
	            this._renderSubmitInput()
	        }
	    },
	    _renderSubmitInput: function() {
	        this._$submitInput = $("<input>").attr("type", "submit").addClass("dx-button-submit-input").appendTo(this._$content).on("click", function(e) {
	            e.stopPropagation()
	        })
	    },
	    _getContentData: function() {
	        var icon = this.option("icon"),
	            text = this.option("text"),
	            back = "back" === this.option("type");
	        if (back && !icon) {
	            icon = "back"
	        }
	        return {
	            icon: icon,
	            text: text
	        }
	    },
	    _renderClick: function() {
	        var that = this,
	            eventName = eventUtils.addNamespace(clickEvent.name, this.NAME),
	            actionConfig = {};
	        if (this.option("useSubmitBehavior")) {
	            actionConfig.afterExecute = function(e) {
	                var validationResults = e.args[0].validationGroup.validate();
	                if (validationResults.isValid) {
	                    setTimeout(function() {
	                        e.component._$submitInput.get(0).click()
	                    })
	                }
	            }
	        }
	        this._clickAction = this._createActionByOption("onClick", actionConfig);
	        this.element().off(eventName).on(eventName, function(e) {
	            that._executeClickAction(e)
	        })
	    },
	    _executeClickAction: function(e) {
	        this._clickAction({
	            jQueryEvent: e,
	            validationGroup: ValidationEngine.getGroupConfig(this._findGroup())
	        })
	    },
	    _updateAriaLabel: function() {
	        var icon = this.option("icon"),
	            text = this.option("text");
	        if ("image" === iconUtils.getImageSourceType(icon)) {
	            if (icon.indexOf("base64") === -1) {
	                icon = icon.replace(/.+\/([^\.]+)\..+$/, "$1")
	            } else {
	                icon = "Base64"
	            }
	        }
	        var ariaLabel = text || icon;
	        this.setAria("label", $.trim(ariaLabel))
	    },
	    _renderType: function() {
	        var type = this.option("type");
	        if (type) {
	            this.element().addClass("dx-button-" + type)
	        }
	    },
	    _refreshType: function(prevType) {
	        var type = this.option("type");
	        prevType && this.element().removeClass("dx-button-" + prevType).addClass("dx-button-" + type);
	        if (!this.element().hasClass(BUTTON_HAS_ICON_CLASS) && "back" === type) {
	            this._renderContentImpl()
	        }
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "onClick":
	                this._renderClick();
	                break;
	            case "icon":
	            case "text":
	                this._renderContentImpl();
	                this._updateAriaLabel();
	                break;
	            case "type":
	                this._refreshType(args.previousValue);
	                this._renderContentImpl();
	                this._updateAriaLabel();
	                break;
	            case "template":
	                this._renderContentImpl();
	                break;
	            case "useInkRipple":
	                this._invalidate();
	                break;
	            case "useSubmitBehavior":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _clean: function() {
	        this.callBase();
	        delete this._$content
	    }
	}).include(ValidationMixin);
	registerComponent("dxButton", Button);
	module.exports = Button;
	module.exports.default = module.exports;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/utils.ink_ripple.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	var INKRIPPLE_CLASS = "dx-inkripple",
	    INKRIPPLE_WAVE_CLASS = "dx-inkripple-wave",
	    INKRIPPLE_SHOWING_CLASS = "dx-inkripple-showing",
	    INKRIPPLE_HIDING_CLASS = "dx-inkripple-hiding";
	var DEFAULT_WAVE_SIZE_COEFFICIENT = 2,
	    MAX_WAVE_SIZE = 4e3,
	    ANIMATION_DURATION = 300,
	    HOLD_ANIMATION_DURATION = 1e3,
	    DEFAULT_WAVE_INDEX = 0;
	var render = function(args) {
	    args = args || {};
	    if (void 0 === args.useHoldAnimation) {
	        args.useHoldAnimation = true
	    }
	    var config = {
	        waveSizeCoefficient: args.waveSizeCoefficient || DEFAULT_WAVE_SIZE_COEFFICIENT,
	        isCentered: args.isCentered || false,
	        wavesNumber: args.wavesNumber || 1,
	        durations: getDurations(args.useHoldAnimation)
	    };
	    return {
	        showWave: $.proxy(showWave, null, config),
	        hideWave: $.proxy(hideWave, null, config)
	    }
	};
	var getInkRipple = function(element) {
	    var result = element.children("." + INKRIPPLE_CLASS);
	    if (0 === result.length) {
	        result = $("<div>").addClass(INKRIPPLE_CLASS).appendTo(element)
	    }
	    return result
	};
	var getWaves = function(element, wavesNumber) {
	    var inkRipple = getInkRipple(element),
	        result = inkRipple.children("." + INKRIPPLE_WAVE_CLASS);
	    for (var i = result.length; i < wavesNumber; i++) {
	        var $currentWave = $("<div>").appendTo(inkRipple).addClass(INKRIPPLE_WAVE_CLASS);
	        result.push($currentWave[0])
	    }
	    return result
	};
	var getWaveStyleConfig = function(args, config) {
	    var left, top, element = config.element,
	        elementWidth = element.outerWidth(),
	        elementHeight = element.outerHeight(),
	        elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight)),
	        waveSize = Math.min(MAX_WAVE_SIZE, parseInt(elementDiagonal * args.waveSizeCoefficient));
	    if (args.isCentered) {
	        left = (elementWidth - waveSize) / 2;
	        top = (elementHeight - waveSize) / 2
	    } else {
	        var event = config.jQueryEvent,
	            position = config.element.offset(),
	            x = event.pageX - position.left,
	            y = event.pageY - position.top;
	        left = x - waveSize / 2;
	        top = y - waveSize / 2
	    }
	    return {
	        left: left,
	        top: top,
	        height: waveSize,
	        width: waveSize
	    }
	};
	var showWave = function(args, config) {
	    var $wave = getWaves(config.element, args.wavesNumber).eq(config.wave || DEFAULT_WAVE_INDEX);
	    args.hidingTimeout && clearTimeout(args.hidingTimeout);
	    hideSelectedWave($wave);
	    $wave.css(getWaveStyleConfig(args, config));
	    setTimeout($.proxy(showingWaveHandler, null, args, $wave), 0)
	};
	var showingWaveHandler = function(args, $wave) {
	    var durationCss = args.durations.showingScale + "ms";
	    $wave.addClass(INKRIPPLE_SHOWING_CLASS).css("transition-duration", durationCss)
	};
	var getDurations = function(useHoldAnimation) {
	    return {
	        showingScale: useHoldAnimation ? HOLD_ANIMATION_DURATION : ANIMATION_DURATION,
	        hidingScale: ANIMATION_DURATION,
	        hidingOpacity: ANIMATION_DURATION
	    }
	};
	var hideSelectedWave = function($wave) {
	    $wave.removeClass(INKRIPPLE_HIDING_CLASS).css("transition-duration", "")
	};
	var hideWave = function(args, config) {
	    var $wave = getWaves(config.element, config.wavesNumber).eq(config.wave || DEFAULT_WAVE_INDEX),
	        durations = args.durations,
	        durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
	    $wave.addClass(INKRIPPLE_HIDING_CLASS).removeClass(INKRIPPLE_SHOWING_CLASS).css("transition-duration", durationCss);
	    var animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
	    args.hidingTimeout = setTimeout($.proxy(hideSelectedWave, null, $wave), animationDuration)
	};
	module.exports = {
	    render: render
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    CollectionWidget = __webpack_require__(117),
	    BindableTemplate = __webpack_require__(134);
	var TOOLBAR_CLASS = "dx-toolbar",
	    TOOLBAR_BOTTOM_CLASS = "dx-toolbar-bottom",
	    TOOLBAR_MINI_CLASS = "dx-toolbar-mini",
	    TOOLBAR_ITEM_CLASS = "dx-toolbar-item",
	    TOOLBAR_LABEL_CLASS = "dx-toolbar-label",
	    TOOLBAR_BUTTON_CLASS = "dx-toolbar-button",
	    TOOLBAR_ITEMS_CONTAINER_CLASS = "dx-toolbar-items-container",
	    TOOLBAR_GROUP_CLASS = "dx-toolbar-group",
	    TOOLBAR_LABEL_SELECTOR = "." + TOOLBAR_LABEL_CLASS,
	    TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
	var ToolbarBase = CollectionWidget.inherit({
	    _initTemplates: function() {
	        this.callBase();
	        var template = new BindableTemplate(function($container, data, rawModel) {
	            if ($.isPlainObject(data)) {
	                if (data.text) {
	                    $container.text(data.text).wrapInner("<div>")
	                }
	                if (data.html) {
	                    $container.html(data.html)
	                }
	            } else {
	                $container.text(String(data))
	            }
	            this._getTemplate("dx-polymorph-widget").render({
	                container: $container,
	                model: rawModel
	            })
	        }.bind(this), ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
	        this._defaultTemplates.item = template;
	        this._defaultTemplates.menuItem = template
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            renderAs: "topToolbar"
	        })
	    },
	    _itemContainer: function() {
	        return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","))
	    },
	    _itemClass: function() {
	        return TOOLBAR_ITEM_CLASS
	    },
	    _itemDataKey: function() {
	        return TOOLBAR_ITEM_DATA_KEY
	    },
	    _buttonClass: function() {
	        return TOOLBAR_BUTTON_CLASS
	    },
	    _dimensionChanged: function() {
	        this._arrangeItems()
	    },
	    _render: function() {
	        this._renderToolbar();
	        this._renderSections();
	        this.setAria("role", "toolbar");
	        this.callBase();
	        this._arrangeItems()
	    },
	    _renderToolbar: function() {
	        this.element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_BOTTOM_CLASS, "bottomToolbar" === this.option("renderAs"));
	        this._$toolbarItemsContainer = $("<div>").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.element())
	    },
	    _renderSections: function() {
	        var $container = this._$toolbarItemsContainer,
	            that = this;
	        $.each(["before", "center", "after"], function() {
	            var sectionClass = "dx-toolbar-" + this,
	                $section = $container.find("." + sectionClass);
	            if (!$section.length) {
	                that["_$" + this + "Section"] = $section = $("<div>").addClass(sectionClass).appendTo($container)
	            }
	        })
	    },
	    _arrangeItems: function(elementWidth) {
	        elementWidth = elementWidth || this.element().width();
	        this._$centerSection.css({
	            margin: "0 auto",
	            "float": "none"
	        });
	        var beforeRect = this._$beforeSection.get(0).getBoundingClientRect(),
	            centerRect = this._$centerSection.get(0).getBoundingClientRect(),
	            afterRect = this._$afterSection.get(0).getBoundingClientRect();
	        if (beforeRect.right > centerRect.left || centerRect.right > afterRect.left) {
	            this._$centerSection.css({
	                marginLeft: beforeRect.width,
	                marginRight: afterRect.width,
	                "float": beforeRect.width > afterRect.width ? "none" : "right"
	            })
	        }
	        var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0),
	            $section = $label.parent();
	        if (!$label.length) {
	            return
	        }
	        var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left,
	            widthBeforeSection = $section.hasClass("dx-toolbar-before") ? 0 : labelOffset,
	            widthAfterSection = $section.hasClass("dx-toolbar-after") ? 0 : afterRect.width,
	            elemsAtSectionWidth = 0;
	        $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function() {
	            elemsAtSectionWidth += $(this).outerWidth()
	        });
	        var freeSpace = elementWidth - elemsAtSectionWidth,
	            labelPaddings = $label.outerWidth() - $label.width(),
	            labelMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection - labelPaddings, 0);
	        $label.css("max-width", labelMaxWidth)
	    },
	    _renderItem: function(index, item, itemContainer, $after) {
	        var location = item.location || "center",
	            container = itemContainer || this._$toolbarItemsContainer.find(".dx-toolbar-" + location),
	            itemHasText = Boolean(item.text),
	            itemElement = this.callBase(index, item, container, $after);
	        itemElement.toggleClass(this._buttonClass(), !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText);
	        return itemElement
	    },
	    _renderGroupedItems: function() {
	        var that = this;
	        $.each(this.option("items"), function(groupIndex, group) {
	            var groupItems = group.items,
	                $container = $("<div>", {
	                    "class": TOOLBAR_GROUP_CLASS
	                }),
	                location = group.location || "center";
	            if (!groupItems.length) {
	                return
	            }
	            $.each(groupItems, function(itemIndex, item) {
	                that._renderItem(itemIndex, item, $container, null)
	            });
	            that._$toolbarItemsContainer.find(".dx-toolbar-" + location).append($container)
	        })
	    },
	    _renderItems: function(items) {
	        var grouped = items.length && items[0].items;
	        grouped ? this._renderGroupedItems() : this.callBase(items)
	    },
	    _getToolbarItems: function() {
	        return this.option("items") || []
	    },
	    _renderContentImpl: function() {
	        var items = this._getToolbarItems();
	        this.element().toggleClass(TOOLBAR_MINI_CLASS, 0 === items.length);
	        if (this._renderedItemsCount) {
	            this._renderItems(items.slice(this._renderedItemsCount))
	        } else {
	            this._renderItems(items)
	        }
	    },
	    _renderEmptyMessage: $.noop,
	    _clean: function() {
	        this._$toolbarItemsContainer.children().empty();
	        this.element().empty()
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._arrangeItems()
	        }
	    },
	    _isVisible: function() {
	        return this.element().width() > 0 && this.element().height() > 0
	    },
	    _getIndexByItem: function(item) {
	        return $.inArray(item, this._getToolbarItems())
	    },
	    _itemOptionChanged: function(item, property, value) {
	        this.callBase.apply(this, [item, property, value]);
	        this._arrangeItems()
	    },
	    _optionChanged: function(args) {
	        var name = args.name;
	        switch (name) {
	            case "width":
	                this.callBase.apply(this, arguments);
	                this._dimensionChanged();
	                break;
	            case "renderAs":
	                this._invalidate();
	                break;
	            default:
	                this.callBase.apply(this, arguments)
	        }
	    }
	});
	registerComponent("dxToolbarBase", ToolbarBase);
	module.exports = ToolbarBase;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/collection/ui.collection_widget.edit.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    BaseCollectionWidget = __webpack_require__(118),
	    errors = __webpack_require__(15),
	    commonUtils = __webpack_require__(8),
	    PlainEditStrategy = __webpack_require__(135),
	    compileGetter = __webpack_require__(35).compileGetter,
	    DataSource = __webpack_require__(121).DataSource,
	    Selection = __webpack_require__(137),
	    when = __webpack_require__(10).when;
	var ITEM_DELETING_DATA_KEY = "dxItemDeleting";
	var CollectionWidget = BaseCollectionWidget.inherit({
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            selectedItem: true
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            selectionMode: "none",
	            selectAllMode: "page",
	            selectionRequired: false,
	            selectionByClick: true,
	            selectedItems: [],
	            selectedItemKeys: [],
	            keyExpr: null,
	            selectedIndex: -1,
	            selectedItem: null,
	            onSelectionChanged: null,
	            onItemReordered: null,
	            onItemDeleting: null,
	            onItemDeleted: null
	        })
	    },
	    _init: function() {
	        this._initEditStrategy();
	        this.callBase();
	        this._initKeyGetter();
	        this._initSelectionModule();
	        if ("multi" === this.option("selectionMode")) {
	            this._showDeprecatedSelectionMode()
	        }
	    },
	    _initKeyGetter: function() {
	        this._keyGetter = compileGetter(this.option("keyExpr"))
	    },
	    _getKeysByItems: function(selectedItems) {
	        return this._editStrategy.getKeysByItems(selectedItems)
	    },
	    _getItemsByKeys: function(selectedItemKeys, selectedItems) {
	        return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems)
	    },
	    _getKeyByIndex: function(index) {
	        return this._editStrategy.getKeyByIndex(index)
	    },
	    _getIndexByKey: function(key) {
	        return this._editStrategy.getIndexByKey(key)
	    },
	    _getIndexByItemData: function(itemData) {
	        return this._editStrategy.getIndexByItemData(itemData)
	    },
	    _initDataSource: function() {
	        this.callBase();
	        if ("allPages" === this.option("selectAllMode")) {
	            this._dataSource && this._dataSource.requireTotalCount(true)
	        }
	    },
	    _isKeySpecified: function() {
	        return !!(this._dataSource && this._dataSource.key())
	    },
	    keyGetter: function(item) {
	        if (this.option("keyExpr")) {
	            return this._keyGetter(item)
	        }
	        return this._dataSource && this._dataSource.store() && this._dataSource.store().keyOf(item) || item
	    },
	    _initSelectionModule: function() {
	        var that = this,
	            itemsGetter = that._editStrategy.itemsGetter;
	        this._selection = new Selection({
	            mode: this.option("selectionMode"),
	            equalByReference: !this._isKeySpecified(),
	            onSelectionChanged: function(args) {
	                if (args.addedItemKeys.length || args.removedItemKeys.length) {
	                    that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
	                    that._updateSelectedItems(args.addedItems, args.removedItems)
	                }
	            },
	            filter: function() {
	                return that._dataSource && that._dataSource.filter()
	            },
	            getItemData: function(item) {
	                return item
	            },
	            isItemSelected: function() {
	                return false
	            },
	            totalCount: function() {
	                var items = that.option("items");
	                var dataSource = that._dataSource;
	                return dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : items.length
	            },
	            key: function() {
	                if (that.option("keyExpr")) {
	                    return that.option("keyExpr")
	                }
	                return that._dataSource && that._dataSource.key()
	            },
	            keyOf: that.keyGetter.bind(that),
	            isSelectableItem: function() {
	                return true
	            },
	            load: function(options) {
	                if (that._dataSource) {
	                    options.userData = that._dataSource._userData
	                }
	                var store = that._dataSource && that._dataSource.store();
	                return store ? store.load(options) : $.Deferred().resolve([])
	            },
	            dataFields: function() {
	                return that._dataSource && that._dataSource.select()
	            },
	            plainItems: itemsGetter.bind(that._editStrategy)
	        })
	    },
	    _initEditStrategy: function() {
	        var Strategy = PlainEditStrategy;
	        this._editStrategy = new Strategy(this)
	    },
	    _forgetNextPageLoading: function() {
	        this.callBase()
	    },
	    _getSelectedItemIndices: function(keys) {
	        var that = this,
	            indices = [];
	        keys = keys || this._selection.getSelectedItemKeys();
	        $.each(keys, function(_, key) {
	            var selectedIndex = that._getIndexByKey(key);
	            if (selectedIndex !== -1) {
	                indices.push(selectedIndex)
	            }
	        });
	        return indices
	    },
	    _render: function() {
	        this._rendering = true;
	        this._syncSelectionOptions();
	        this._normalizeSelectedItems();
	        this.callBase();
	        var selectedItemIndices = this._getSelectedItemIndices();
	        this._renderSelection(selectedItemIndices, []);
	        this._rendering = false
	    },
	    _fireContentReadyAction: function() {
	        this._rendering = false;
	        this._rendered = true;
	        this.callBase.apply(this, arguments)
	    },
	    _syncSelectionOptions: function(byOption) {
	        byOption = byOption || this._chooseSelectOption();
	        var selectedItem, selectedItems, selectedIndex;
	        switch (byOption) {
	            case "selectedIndex":
	                selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
	                if (commonUtils.isDefined(selectedItem)) {
	                    this._setOptionSilent("selectedItems", [selectedItem]);
	                    this._setOptionSilent("selectedItem", selectedItem);
	                    this._setOptionSilent("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
	                } else {
	                    this._setOptionSilent("selectedItems", []);
	                    this._setOptionSilent("selectedItemKeys", []);
	                    this._setOptionSilent("selectedItem", null)
	                }
	                break;
	            case "selectedItems":
	                selectedItems = this.option("selectedItems") || [];
	                selectedIndex = this._editStrategy.getIndexByItemData(selectedItems[0]);
	                if (this.option("selectionRequired") && selectedIndex === -1) {
	                    this._syncSelectionOptions("selectedIndex");
	                    return
	                }
	                this._setOptionSilent("selectedItem", selectedItems[0]);
	                this._setOptionSilent("selectedIndex", selectedIndex);
	                this._setOptionSilent("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
	                break;
	            case "selectedItem":
	                selectedItem = this.option("selectedItem");
	                selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
	                if (this.option("selectionRequired") && selectedIndex === -1) {
	                    this._syncSelectionOptions("selectedIndex");
	                    return
	                }
	                if (commonUtils.isDefined(selectedItem)) {
	                    this._setOptionSilent("selectedItems", [selectedItem]);
	                    this._setOptionSilent("selectedIndex", selectedIndex);
	                    this._setOptionSilent("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
	                } else {
	                    this._setOptionSilent("selectedItems", []);
	                    this._setOptionSilent("selectedItemKeys", []);
	                    this._setOptionSilent("selectedIndex", -1)
	                }
	                break;
	            case "selectedItemKeys":
	                if (this.option("selectionRequired")) {
	                    var selectedItemKeys = this.option("selectedItemKeys");
	                    selectedIndex = this._getIndexByKey(selectedItemKeys[0]);
	                    if (selectedIndex === -1) {
	                        this._syncSelectionOptions("selectedIndex");
	                        return
	                    }
	                } else {
	                    this._selection.setSelection(this.option("selectedItemKeys"))
	                }
	        }
	    },
	    _chooseSelectOption: function() {
	        var optionName = "selectedIndex";
	        if (this.option("selectedItems").length) {
	            optionName = "selectedItems"
	        } else {
	            if (commonUtils.isDefined(this.option("selectedItem"))) {
	                optionName = "selectedItem"
	            } else {
	                if (this.option("selectedItemKeys").length) {
	                    optionName = "selectedItemKeys"
	                }
	            }
	        }
	        return optionName
	    },
	    _normalizeSelectedItems: function() {
	        if ("none" === this.option("selectionMode")) {
	            this._setOptionSilent("selectedItems", []);
	            this._syncSelectionOptions("selectedItems")
	        } else {
	            if ("single" === this.option("selectionMode")) {
	                var newSelection = this.option("selectedItems");
	                if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
	                    var currentSelection = this._selection.getSelectedItemKeys();
	                    var normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
	                    if (void 0 === normalizedSelection) {
	                        normalizedSelection = this._editStrategy.itemsGetter()[0]
	                    }
	                    if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
	                        normalizedSelection = normalizedSelection.items[0]
	                    }
	                    this._selection.setSelection([normalizedSelection]);
	                    this._setOptionSilent("selectedItems", this._getItemsByKeys([normalizedSelection]));
	                    this._syncSelectionOptions("selectedItems")
	                } else {
	                    this._selection.setSelection(this._getKeysByItems(newSelection))
	                }
	            } else {
	                this._selection.setSelection(this._getKeysByItems(this.option("selectedItems")))
	            }
	        }
	    },
	    _renderSelection: $.noop,
	    _itemClickHandler: function(e) {
	        this._createAction($.proxy(function(e) {
	            this._itemSelectHandler(e.jQueryEvent)
	        }, this), {
	            validatingTargetName: "itemElement"
	        })({
	            itemElement: $(e.currentTarget),
	            jQueryEvent: e
	        });
	        this.callBase.apply(this, arguments)
	    },
	    _itemSelectHandler: function(e) {
	        if (!this.option("selectionByClick")) {
	            return
	        }
	        var $itemElement = e.currentTarget;
	        if (this.isItemSelected($itemElement)) {
	            this.unselectItem(e.currentTarget)
	        } else {
	            this.selectItem(e.currentTarget)
	        }
	    },
	    _selectedItemElement: function(index) {
	        return this._itemElements().eq(index)
	    },
	    _postprocessRenderItem: function(args) {
	        if ("none" === this.option("selectionMode")) {
	            return
	        }
	        var $itemElement = $(args.itemElement);
	        if (this._isItemSelected(this._editStrategy.getNormalizedIndex($itemElement))) {
	            $itemElement.addClass(this._selectedItemClass());
	            this._setAriaSelected($itemElement, "true")
	        } else {
	            this._setAriaSelected($itemElement, "false")
	        }
	    },
	    _updateSelectedItems: function(addedItems, removedItems) {
	        var that = this;
	        if (that._rendered && (addedItems.length || removedItems.length)) {
	            var selectionChangePromise = that._selectionChangePromise;
	            if (!that._rendering) {
	                var addedSelection = [];
	                var removedSelection = [];
	                var i;
	                for (i = 0; i < addedItems.length; i++) {
	                    addedSelection.push(that._getIndexByItemData(addedItems[i]))
	                }
	                for (i = 0; i < removedItems.length; i++) {
	                    removedSelection.push(that._getIndexByItemData(removedItems[i]))
	                }
	                $.each(removedSelection, function(_, normalizedIndex) {
	                    that._removeSelection(normalizedIndex)
	                });
	                $.each(addedSelection, function(_, normalizedIndex) {
	                    that._addSelection(normalizedIndex)
	                });
	                that._updateSelection(addedSelection, removedSelection)
	            }
	            when(selectionChangePromise).done(function() {
	                that._fireSelectionChangeEvent(addedItems, removedItems)
	            })
	        }
	    },
	    _fireSelectionChangeEvent: function(addedItems, removedItems) {
	        this._createActionByOption("onSelectionChanged", {
	            excludeValidators: ["disabled", "readOnly"]
	        })({
	            addedItems: addedItems,
	            removedItems: removedItems
	        })
	    },
	    _updateSelection: function() {
	        this._renderSelection.apply(this, arguments)
	    },
	    _setAriaSelected: function($target, value) {
	        this.setAria("selected", value, $target)
	    },
	    _removeSelection: function(normalizedIndex) {
	        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
	        if (normalizedIndex !== -1) {
	            $itemElement.removeClass(this._selectedItemClass());
	            this._setAriaSelected($itemElement, "false");
	            $itemElement.triggerHandler("stateChanged")
	        }
	    },
	    _showDeprecatedSelectionMode: function() {
	        errors.log("W0001", this.NAME, "selectionMode: 'multi'", "16.1", "Use selectionMode: 'multiple' instead");
	        this.option("selectionMode", "multiple")
	    },
	    _addSelection: function(normalizedIndex) {
	        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
	        if (normalizedIndex !== -1) {
	            $itemElement.addClass(this._selectedItemClass());
	            this._setAriaSelected($itemElement, "true");
	            $itemElement.triggerHandler("stateChanged")
	        }
	    },
	    _isItemSelected: function(index) {
	        var key = this._getKeyByIndex(index);
	        return this._selection.isItemSelected(key)
	    },
	    _optionChanged: function(args) {
	        if (this._cancelOptionChange === args.name) {
	            return
	        }
	        switch (args.name) {
	            case "selectAllMode":
	                this._refreshDataSource();
	                break;
	            case "selectionMode":
	                if ("multi" === args.value) {
	                    this._showDeprecatedSelectionMode()
	                } else {
	                    this._invalidate()
	                }
	                break;
	            case "selectedIndex":
	            case "selectedItem":
	            case "selectedItems":
	            case "selectedItemKeys":
	                this._syncSelectionOptions(args.name);
	                this._normalizeSelectedItems();
	                break;
	            case "keyExpr":
	                this._initKeyGetter();
	                break;
	            case "selectionRequired":
	                this._normalizeSelectedItems();
	                break;
	            case "selectionByClick":
	            case "onSelectionChanged":
	            case "onItemDeleting":
	            case "onItemDeleted":
	            case "onItemReordered":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _clearSelectedItems: function() {
	        this._setOptionSilent("selectedItems", []);
	        this._syncSelectionOptions("selectedItems")
	    },
	    _setOptionSilent: function(name, value) {
	        this._cancelOptionChange = name;
	        this.option(name, value);
	        this._cancelOptionChange = false
	    },
	    _waitDeletingPrepare: function($itemElement) {
	        if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
	            return $.Deferred().resolve().promise()
	        }
	        $itemElement.data(ITEM_DELETING_DATA_KEY, true);
	        var deferred = $.Deferred(),
	            deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", {}, {
	                excludeValidators: ["disabled", "readOnly"]
	            });
	        when(deletePromise).always($.proxy(function(value) {
	            var deletePromiseExists = !deletePromise,
	                deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state(),
	                argumentsSpecified = !!arguments.length,
	                shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
	            $itemElement.data(ITEM_DELETING_DATA_KEY, false);
	            shouldDelete ? deferred.resolve() : deferred.reject()
	        }, this));
	        return deferred.promise()
	    },
	    _deleteItemFromDS: function($item) {
	        if (!this._dataSource) {
	            return $.Deferred().resolve().promise()
	        }
	        var deferred = $.Deferred(),
	            disabledState = this.option("disabled"),
	            dataStore = this._dataSource.store();
	        this.option("disabled", true);
	        if (!dataStore.remove) {
	            throw errors.Error("E1011")
	        }
	        dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
	            if (void 0 !== key) {
	                deferred.resolve()
	            } else {
	                deferred.reject()
	            }
	        }).fail(function() {
	            deferred.reject()
	        });
	        deferred.always($.proxy(function() {
	            this.option("disabled", disabledState)
	        }, this));
	        return deferred
	    },
	    _tryRefreshLastPage: function() {
	        var deferred = $.Deferred();
	        if (this._isLastPage() || this.option("grouped")) {
	            deferred.resolve()
	        } else {
	            this._refreshLastPage().done(function() {
	                deferred.resolve()
	            })
	        }
	        return deferred.promise()
	    },
	    _refreshLastPage: function() {
	        this._expectLastItemLoading();
	        return this._dataSource.load()
	    },
	    _updateSelectionAfterDelete: function(index) {
	        var key = this._getKeyByIndex(index);
	        this._selection.deselect([key])
	    },
	    _simulateOptionChange: function(optionName) {
	        var optionValue = this.option(optionName);
	        if (optionValue instanceof DataSource) {
	            return
	        }
	        this._optionChangedAction({
	            name: optionName,
	            fullName: optionName,
	            value: optionValue
	        })
	    },
	    isItemSelected: function(itemElement) {
	        return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement))
	    },
	    selectItem: function(itemElement) {
	        if ("none" === this.option("selectionMode")) {
	            return
	        }
	        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
	        if (itemIndex === -1) {
	            return
	        }
	        var key = this._getKeyByIndex(itemIndex);
	        if (this._selection.isItemSelected(key)) {
	            return
	        }
	        if ("single" === this.option("selectionMode")) {
	            this._selection.setSelection([key])
	        } else {
	            var selectedItemKeys = this.option("selectedItemKeys");
	            selectedItemKeys.push(key);
	            this._selection.setSelection(selectedItemKeys)
	        }
	    },
	    unselectItem: function(itemElement) {
	        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
	        if (itemIndex === -1) {
	            return
	        }
	        var selectedItemKeys = this._selection.getSelectedItemKeys();
	        if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
	            return
	        }
	        var key = this._getKeyByIndex(itemIndex);
	        this._selection.deselect([key])
	    },
	    deleteItem: function(itemElement) {
	        var that = this,
	            deferred = $.Deferred(),
	            $item = this._editStrategy.getItemElement(itemElement),
	            index = this._editStrategy.getNormalizedIndex(itemElement),
	            changingOption = this._dataSource ? "dataSource" : "items",
	            itemResponseWaitClass = this._itemResponseWaitClass();
	        if (index > -1) {
	            this._waitDeletingPrepare($item).done(function() {
	                $item.addClass(itemResponseWaitClass);
	                var deletedActionArgs = that._extendActionArgs($item);
	                that._deleteItemFromDS($item).done(function() {
	                    that._updateSelectionAfterDelete(index);
	                    that._editStrategy.deleteItemAtIndex(index);
	                    that._simulateOptionChange(changingOption);
	                    that._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
	                        beforeExecute: function() {
	                            $item.detach()
	                        },
	                        excludeValidators: ["disabled", "readOnly"]
	                    });
	                    that._renderEmptyMessage();
	                    that._tryRefreshLastPage().done(function() {
	                        deferred.resolveWith(that)
	                    })
	                }).fail(function() {
	                    $item.removeClass(itemResponseWaitClass);
	                    deferred.rejectWith(that)
	                })
	            }).fail(function() {
	                deferred.rejectWith(that)
	            })
	        } else {
	            deferred.rejectWith(that)
	        }
	        return deferred.promise()
	    },
	    reorderItem: function(itemElement, toItemElement) {
	        var deferred = $.Deferred(),
	            that = this,
	            strategy = this._editStrategy,
	            $movingItem = strategy.getItemElement(itemElement),
	            $destinationItem = strategy.getItemElement(toItemElement),
	            movingIndex = strategy.getNormalizedIndex(itemElement),
	            destinationIndex = strategy.getNormalizedIndex(toItemElement),
	            changingOption = this._dataSource ? "dataSource" : "items";
	        var canMoveItems = movingIndex > -1 && destinationIndex > -1 && movingIndex !== destinationIndex;
	        if (canMoveItems) {
	            deferred.resolveWith(this)
	        } else {
	            deferred.rejectWith(this)
	        }
	        return deferred.promise().done(function() {
	            $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
	            strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
	            that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys()));
	            if ("items" === changingOption) {
	                that._simulateOptionChange(changingOption)
	            }
	            that._itemEventHandler($movingItem, "onItemReordered", {
	                fromIndex: strategy.getIndex(movingIndex),
	                toIndex: strategy.getIndex(destinationIndex)
	            }, {
	                excludeValidators: ["disabled", "readOnly"]
	            })
	        })
	    }
	});
	module.exports = CollectionWidget;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/collection/ui.collection_widget.base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    when = __webpack_require__(10).when,
	    Action = __webpack_require__(34),
	    Guid = __webpack_require__(119),
	    domUtils = __webpack_require__(43),
	    Widget = __webpack_require__(84),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    DataHelperMixin = __webpack_require__(120),
	    CollectionWidgetItem = __webpack_require__(131),
	    selectors = __webpack_require__(91),
	    messageLocalization = __webpack_require__(79),
	    holdEvent = __webpack_require__(132),
	    clickEvent = __webpack_require__(65),
	    contextMenuEvent = __webpack_require__(133),
	    BindableTemplate = __webpack_require__(134);
	var COLLECTION_CLASS = "dx-collection",
	    ITEM_CLASS = "dx-item",
	    CONTENT_CLASS_POSTFIX = "-content",
	    ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder",
	    ITEM_DATA_KEY = "dxItemData",
	    ITEM_INDEX_KEY = "dxItemIndex",
	    ITEM_TEMPLATE_ID_PREFIX = "tmpl-",
	    ITEMS_SELECTOR = "[data-options*='dxItem']",
	    SELECTED_ITEM_CLASS = "dx-item-selected",
	    ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait",
	    EMPTY_COLLECTION = "dx-empty-collection",
	    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
	    ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+(\w+)$/;
	var FOCUS_UP = "up",
	    FOCUS_DOWN = "down",
	    FOCUS_LEFT = "left",
	    FOCUS_RIGHT = "right",
	    FOCUS_PAGE_UP = "pageup",
	    FOCUS_PAGE_DOWN = "pagedown",
	    FOCUS_LAST = "last",
	    FOCUS_FIRST = "first";
	var CollectionWidget = Widget.inherit({
	    _activeStateUnit: "." + ITEM_CLASS,
	    _supportedKeys: function() {
	        var click = function(e) {
	                var $itemElement = this.option("focusedElement");
	                if (!$itemElement) {
	                    return
	                }
	                e.target = $itemElement;
	                e.currentTarget = $itemElement;
	                this._itemClickHandler(e)
	            },
	            move = function(location, e) {
	                e.preventDefault();
	                e.stopPropagation();
	                this._moveFocus(location, e)
	            };
	        return $.extend(this.callBase(), {
	            space: click,
	            enter: click,
	            leftArrow: $.proxy(move, this, FOCUS_LEFT),
	            rightArrow: $.proxy(move, this, FOCUS_RIGHT),
	            upArrow: $.proxy(move, this, FOCUS_UP),
	            downArrow: $.proxy(move, this, FOCUS_DOWN),
	            pageUp: $.proxy(move, this, FOCUS_UP),
	            pageDown: $.proxy(move, this, FOCUS_DOWN),
	            home: $.proxy(move, this, FOCUS_FIRST),
	            end: $.proxy(move, this, FOCUS_LAST)
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            selectOnFocus: false,
	            loopItemFocus: true,
	            items: [],
	            itemTemplate: "item",
	            onItemRendered: null,
	            onItemClick: null,
	            onItemHold: null,
	            itemHoldTimeout: 750,
	            onItemContextMenu: null,
	            onFocusedItemChanged: null,
	            noDataText: messageLocalization.format("dxCollectionWidget-noDataText"),
	            dataSource: null,
	            _itemAttributes: {},
	            itemTemplateProperty: "template",
	            focusOnSelectedItem: true,
	            focusedElement: null,
	            disabledExpr: function(data) {
	                return data ? data.disabled : void 0
	            },
	            visibleExpr: function(data) {
	                return data ? data.visible : void 0
	            }
	        })
	    },
	    _getAnonymousTemplateName: function() {
	        return "item"
	    },
	    _init: function() {
	        this.callBase();
	        this._cleanRenderedItems();
	        this._refreshDataSource()
	    },
	    _initTemplates: function() {
	        this._initItemsFromMarkup();
	        this.callBase();
	        this._defaultTemplates.item = new BindableTemplate(function($container, data) {
	            if ($.isPlainObject(data)) {
	                if (data.text) {
	                    $container.text(data.text)
	                }
	                if (data.html) {
	                    $container.html(data.html)
	                }
	            } else {
	                $container.text(String(data))
	            }
	        }, ["text", "html"], this.option("integrationOptions.watchMethod"))
	    },
	    _initItemsFromMarkup: function() {
	        var $items = this.element().contents().filter(ITEMS_SELECTOR);
	        if (!$items.length || this.option("items").length) {
	            return
	        }
	        var items = $.map($items, $.proxy(function(item) {
	            var $item = $(item);
	            var result = domUtils.getElementOptions(item).dxItem;
	            var isTemplateRequired = $.trim($item.html()) && !result.template;
	            if (isTemplateRequired) {
	                result.template = this._prepareItemTemplate($item)
	            } else {
	                $item.remove()
	            }
	            return result
	        }, this));
	        this.option("items", items)
	    },
	    _prepareItemTemplate: function($item) {
	        var templateId = ITEM_TEMPLATE_ID_PREFIX + new Guid;
	        var templateOptions = 'dxTemplate: { name: "' + templateId + '" }';
	        $item.detach().clone().attr("data-options", templateOptions).data("options", templateOptions).appendTo(this.element());
	        return templateId
	    },
	    _dataSourceOptions: function() {
	        return {
	            paginate: false
	        }
	    },
	    _cleanRenderedItems: function() {
	        this._renderedItemsCount = 0
	    },
	    _focusTarget: function() {
	        return this.element()
	    },
	    _focusInHandler: function(e) {
	        this.callBase.apply(this, arguments);
	        if ($.inArray(e.target, this._focusTarget()) === -1) {
	            return
	        }
	        var $focusedElement = this.option("focusedElement");
	        if ($focusedElement && $focusedElement.length) {
	            this._setFocusedItem($focusedElement)
	        } else {
	            var $activeItem = this._getActiveItem();
	            if ($activeItem.length) {
	                this.option("focusedElement", $activeItem)
	            }
	        }
	    },
	    _focusOutHandler: function() {
	        this.callBase.apply(this, arguments);
	        var $target = this.option("focusedElement");
	        if ($target) {
	            this._toggleFocusClass(false, $target)
	        }
	    },
	    _getActiveItem: function(last) {
	        var $focusedElement = this.option("focusedElement");
	        if ($focusedElement && $focusedElement.length) {
	            return $focusedElement
	        }
	        var index = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0,
	            activeElements = this._getActiveElement(),
	            lastIndex = activeElements.length - 1;
	        if (index < 0) {
	            index = last ? lastIndex : 0
	        }
	        return activeElements.eq(index)
	    },
	    _renderFocusTarget: function() {
	        this.callBase.apply(this, arguments);
	        this._refreshActiveDescendant()
	    },
	    _moveFocus: function(location) {
	        var $newTarget, $items = this._getAvailableItems();
	        switch (location) {
	            case FOCUS_PAGE_UP:
	            case FOCUS_UP:
	                $newTarget = this._prevItem($items);
	                break;
	            case FOCUS_PAGE_DOWN:
	            case FOCUS_DOWN:
	                $newTarget = this._nextItem($items);
	                break;
	            case FOCUS_RIGHT:
	                $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
	                break;
	            case FOCUS_LEFT:
	                $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
	                break;
	            case FOCUS_FIRST:
	                $newTarget = $items.first();
	                break;
	            case FOCUS_LAST:
	                $newTarget = $items.last();
	                break;
	            default:
	                return false
	        }
	        if (0 !== $newTarget.length) {
	            this.option("focusedElement", $newTarget)
	        }
	    },
	    _getAvailableItems: function($itemElements) {
	        $itemElements = $itemElements || this._itemElements();
	        return $itemElements.filter(":visible").not(".dx-state-disabled")
	    },
	    _prevItem: function($items) {
	        var $target = this._getActiveItem(),
	            targetIndex = $items.index($target),
	            $last = $items.last(),
	            $item = $($items[targetIndex - 1]),
	            loop = this.option("loopItemFocus");
	        if (0 === $item.length && loop) {
	            $item = $last
	        }
	        return $item
	    },
	    _nextItem: function($items) {
	        var $target = this._getActiveItem(true),
	            targetIndex = $items.index($target),
	            $first = $items.first(),
	            $item = $($items[targetIndex + 1]),
	            loop = this.option("loopItemFocus");
	        if (0 === $item.length && loop) {
	            $item = $first
	        }
	        return $item
	    },
	    _selectFocusedItem: function($target) {
	        this.selectItem($target)
	    },
	    _removeFocusedItem: function($target) {
	        if ($target && $target.length) {
	            this._toggleFocusClass(false, $target);
	            $target.removeAttr("id")
	        }
	    },
	    _refreshActiveDescendant: function() {
	        this.setAria("activedescendant", "");
	        this.setAria("activedescendant", this.getFocusedItemId())
	    },
	    _setFocusedItem: function($target) {
	        if (!$target || !$target.length) {
	            return
	        }
	        $target.attr("id", this.getFocusedItemId());
	        this._toggleFocusClass(true, $target);
	        this.onFocusedItemChanged(this.getFocusedItemId());
	        this._refreshActiveDescendant();
	        if (this.option("selectOnFocus")) {
	            this._selectFocusedItem($target)
	        }
	    },
	    _findItemElementByItem: function(item) {
	        var result = $(),
	            that = this;
	        this.itemElements().each(function() {
	            var $item = $(this);
	            if ($item.data(that._itemDataKey()) === item) {
	                result = $item;
	                return false
	            }
	        });
	        return result
	    },
	    _getIndexByItem: function(item) {
	        return this.option("items").indexOf(item)
	    },
	    _itemOptionChanged: function(item, property, value) {
	        var $item = this._findItemElementByItem(item);
	        if (!$item.length) {
	            return
	        }
	        if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value)) {
	            var itemData = this._getItemData($item),
	                index = $item.data(this._itemIndexKey());
	            this._renderItem(index, itemData, null, $item)
	        }
	    },
	    _optionChanged: function(args) {
	        if ("items" === args.name) {
	            var matches = args.fullName.match(ITEM_PATH_REGEX);
	            if (matches && matches.length) {
	                var property = matches[matches.length - 1],
	                    itemPath = args.fullName.replace("." + property, ""),
	                    item = this.option(itemPath);
	                this._itemOptionChanged(item, property, args.value);
	                return
	            }
	        }
	        switch (args.name) {
	            case "items":
	            case "_itemAttributes":
	            case "itemTemplateProperty":
	                this._cleanRenderedItems();
	                this._invalidate();
	                break;
	            case "dataSource":
	                this.option("items", []);
	                this._refreshDataSource();
	                this._renderEmptyMessage();
	                break;
	            case "noDataText":
	                this._renderEmptyMessage();
	                break;
	            case "itemTemplate":
	                this._invalidate();
	                break;
	            case "onItemRendered":
	                this._createItemRenderAction();
	                break;
	            case "onItemClick":
	                break;
	            case "onItemHold":
	            case "itemHoldTimeout":
	                this._attachHoldEvent();
	                break;
	            case "onItemContextMenu":
	                this._attachContextMenuEvent();
	                break;
	            case "onFocusedItemChanged":
	                this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
	                break;
	            case "selectOnFocus":
	            case "loopItemFocus":
	            case "focusOnSelectedItem":
	                break;
	            case "focusedElement":
	                this._removeFocusedItem(args.previousValue);
	                this._setFocusedItem(args.value);
	                break;
	            case "visibleExpr":
	            case "disabledExpr":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _loadNextPage: function() {
	        var dataSource = this._dataSource;
	        this._expectNextPageLoading();
	        dataSource.pageIndex(1 + dataSource.pageIndex());
	        return dataSource.load()
	    },
	    _expectNextPageLoading: function() {
	        this._startIndexForAppendedItems = 0
	    },
	    _expectLastItemLoading: function() {
	        this._startIndexForAppendedItems = -1
	    },
	    _forgetNextPageLoading: function() {
	        this._startIndexForAppendedItems = null
	    },
	    _dataSourceChangedHandler: function(newItems) {
	        var items = this.option("items");
	        if (this._initialized && items && this._shouldAppendItems()) {
	            this._renderedItemsCount = items.length;
	            if (!this._isLastPage() || this._startIndexForAppendedItems !== -1) {
	                this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems))
	            }
	            this._forgetNextPageLoading();
	            this._renderContent();
	            this._renderFocusTarget()
	        } else {
	            this.option("items", newItems)
	        }
	    },
	    _dataSourceLoadErrorHandler: function() {
	        this._forgetNextPageLoading();
	        this.option("items", this.option("items"))
	    },
	    _shouldAppendItems: function() {
	        return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend()
	    },
	    _allowDynamicItemsAppend: function() {
	        return false
	    },
	    _clean: function() {
	        this._cleanFocusState();
	        this._cleanItemContainer()
	    },
	    _cleanItemContainer: function() {
	        this._itemContainer().empty()
	    },
	    _dispose: function() {
	        this.callBase();
	        clearTimeout(this._itemFocusTimeout)
	    },
	    _refresh: function() {
	        this._cleanRenderedItems();
	        this.callBase.apply(this, arguments)
	    },
	    _itemContainer: function() {
	        return this.element()
	    },
	    _itemClass: function() {
	        return ITEM_CLASS
	    },
	    _itemContentClass: function() {
	        return this._itemClass() + CONTENT_CLASS_POSTFIX
	    },
	    _selectedItemClass: function() {
	        return SELECTED_ITEM_CLASS
	    },
	    _itemResponseWaitClass: function() {
	        return ITEM_RESPONSE_WAIT_CLASS
	    },
	    _itemSelector: function() {
	        return "." + this._itemClass()
	    },
	    _itemDataKey: function() {
	        return ITEM_DATA_KEY
	    },
	    _itemIndexKey: function() {
	        return ITEM_INDEX_KEY
	    },
	    _itemElements: function() {
	        return this._itemContainer().find(this._itemSelector())
	    },
	    _render: function() {
	        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
	        this.callBase();
	        this.element().addClass(COLLECTION_CLASS);
	        this._attachClickEvent();
	        this._attachHoldEvent();
	        this._attachContextMenuEvent()
	    },
	    _attachClickEvent: function() {
	        var itemSelector = this._itemSelector(),
	            clickEventNamespace = eventUtils.addNamespace(clickEvent.name, this.NAME),
	            pointerDownEventNamespace = eventUtils.addNamespace(pointerEvents.down, this.NAME),
	            that = this;
	        var pointerDownAction = new Action(function(args) {
	            var event = args.event;
	            that._itemPointerDownHandler(event)
	        });
	        this._itemContainer().off(clickEventNamespace, itemSelector).off(pointerDownEventNamespace, itemSelector).on(clickEventNamespace, itemSelector, $.proxy(function(e) {
	            this._itemClickHandler(e)
	        }, this)).on(pointerDownEventNamespace, itemSelector, function(e) {
	            pointerDownAction.execute({
	                element: $(e.target),
	                event: e
	            })
	        })
	    },
	    _itemClickHandler: function(e, args, config) {
	        this._itemJQueryEventHandler(e, "onItemClick", args, config)
	    },
	    _itemPointerDownHandler: function(e) {
	        if (!this.option("focusStateEnabled")) {
	            return
	        }
	        this._itemFocusHandler = function() {
	            clearTimeout(this._itemFocusTimeout);
	            this._itemFocusHandler = null;
	            if (e.isDefaultPrevented()) {
	                return
	            }
	            var $target = $(e.target),
	                $closestItem = $target.closest(this._itemElements()),
	                $closestFocusable = $target.closest(selectors.focusable);
	            if ($closestItem.length && $.inArray($closestFocusable.get(0), this._focusTarget()) !== -1) {
	                this.option("focusedElement", $closestItem)
	            }
	        }.bind(this);
	        this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this))
	    },
	    _forcePointerDownFocus: function() {
	        this._itemFocusHandler && this._itemFocusHandler()
	    },
	    _updateFocusState: function() {
	        this.callBase.apply(this, arguments);
	        this._forcePointerDownFocus()
	    },
	    _attachHoldEvent: function() {
	        var $itemContainer = this._itemContainer(),
	            itemSelector = this._itemSelector(),
	            eventName = eventUtils.addNamespace(holdEvent.name, this.NAME);
	        $itemContainer.off(eventName, itemSelector);
	        if (this._shouldAttachHoldEvent()) {
	            $itemContainer.on(eventName, itemSelector, {
	                timeout: this._getHoldTimeout()
	            }, $.proxy(this._itemHoldHandler, this))
	        }
	    },
	    _getHoldTimeout: function() {
	        return this.option("itemHoldTimeout")
	    },
	    _shouldAttachHoldEvent: function() {
	        return this.option("onItemHold")
	    },
	    _itemHoldHandler: function(e) {
	        this._itemJQueryEventHandler(e, "onItemHold")
	    },
	    _attachContextMenuEvent: function() {
	        var $itemContainer = this._itemContainer(),
	            itemSelector = this._itemSelector(),
	            eventName = eventUtils.addNamespace(contextMenuEvent.name, this.NAME);
	        $itemContainer.off(eventName, itemSelector);
	        if (this._shouldAttachContextMenuEvent()) {
	            $itemContainer.on(eventName, itemSelector, $.proxy(this._itemContextMenuHandler, this))
	        }
	    },
	    _shouldAttachContextMenuEvent: function() {
	        return this.option("onItemContextMenu")
	    },
	    _itemContextMenuHandler: function(e) {
	        this._itemJQueryEventHandler(e, "onItemContextMenu")
	    },
	    _renderContentImpl: function() {
	        var items = this.option("items") || [];
	        if (this._renderedItemsCount) {
	            this._renderItems(items.slice(this._renderedItemsCount))
	        } else {
	            this._renderItems(items)
	        }
	    },
	    _renderItems: function(items) {
	        if (items.length) {
	            $.each(items, $.proxy(this._renderItem, this))
	        }
	        this._renderEmptyMessage()
	    },
	    _renderItem: function(index, itemData, $container, $itemToReplace) {
	        $container = $container || this._itemContainer();
	        var $itemFrame = this._renderItemFrame(index, itemData, $container, $itemToReplace);
	        this._setElementData($itemFrame, itemData, index);
	        $itemFrame.attr(this.option("_itemAttributes"));
	        this._attachItemClickEvent(itemData, $itemFrame);
	        var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
	        $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
	        var renderContentPromise = this._renderItemContent({
	            index: index,
	            itemData: itemData,
	            container: $itemContent,
	            contentClass: this._itemContentClass(),
	            defaultTemplateName: this.option("itemTemplate")
	        });
	        var that = this;
	        when(renderContentPromise).done(function($itemContent) {
	            that._postprocessRenderItem({
	                itemElement: $itemFrame,
	                itemContent: $itemContent,
	                itemData: itemData,
	                itemIndex: index
	            });
	            that._executeItemRenderAction(index, itemData, $itemFrame)
	        });
	        return $itemFrame
	    },
	    _attachItemClickEvent: function(itemData, $itemElement) {
	        if (!itemData || !itemData.onClick) {
	            return
	        }
	        $itemElement.on(clickEvent.name, $.proxy(function(e) {
	            this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
	                jQueryEvent: e
	            })
	        }, this))
	    },
	    _renderItemContent: function(args) {
	        var itemTemplateName = this._getItemTemplateName(args);
	        var itemTemplate = this._getTemplate(itemTemplateName);
	        this._addItemContentClasses(args);
	        var $templateResult = this._createItemByTemplate(itemTemplate, args);
	        if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS)) {
	            return args.container
	        }
	        return this._renderItemContentByNode(args, $templateResult)
	    },
	    _renderItemContentByNode: function(args, $node) {
	        args.container.replaceWith($node);
	        args.container = $node;
	        this._addItemContentClasses(args);
	        return $node
	    },
	    _addItemContentClasses: function(args) {
	        var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
	        args.container.addClass(classes.join(" "))
	    },
	    _renderItemFrame: function(index, itemData, $container, $itemToReplace) {
	        var $itemFrame = $("<div>");
	        new this.constructor.ItemClass($itemFrame, this, itemData || {});
	        if ($itemToReplace && $itemToReplace.length) {
	            $itemToReplace.replaceWith($itemFrame)
	        } else {
	            $itemFrame.appendTo($container)
	        }
	        return $itemFrame
	    },
	    _postprocessRenderItem: $.noop,
	    _executeItemRenderAction: function(index, itemData, itemElement) {
	        this._getItemRenderAction()({
	            itemElement: itemElement,
	            itemIndex: index,
	            itemData: itemData
	        })
	    },
	    _setElementData: function(element, data, index) {
	        element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data).data(this._itemIndexKey(), index)
	    },
	    _createItemRenderAction: function() {
	        return this._itemRenderAction = this._createActionByOption("onItemRendered", {
	            element: this.element(),
	            excludeValidators: ["designMode", "disabled", "readOnly"],
	            category: "rendering"
	        })
	    },
	    _getItemRenderAction: function() {
	        return this._itemRenderAction || this._createItemRenderAction()
	    },
	    _getItemTemplateName: function(args) {
	        var data = args.itemData,
	            templateProperty = args.templateProperty || this.option("itemTemplateProperty"),
	            template = data && data[templateProperty];
	        return template || args.defaultTemplateName
	    },
	    _createItemByTemplate: function(itemTemplate, renderArgs) {
	        return itemTemplate.render({
	            model: renderArgs.itemData,
	            container: renderArgs.container,
	            index: renderArgs.index
	        })
	    },
	    _emptyMessageContainer: function() {
	        return this._itemContainer()
	    },
	    _renderEmptyMessage: function() {
	        var noDataText = this.option("noDataText"),
	            items = this.option("items"),
	            hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
	        if (hideNoData && this._$noData) {
	            this._$noData.remove();
	            this._$noData = null;
	            this.setAria("label", void 0)
	        }
	        if (!hideNoData) {
	            this._$noData = this._$noData || $("<div>").addClass("dx-empty-message");
	            this._$noData.appendTo(this._emptyMessageContainer()).html(noDataText);
	            this.setAria("label", noDataText)
	        }
	        this.element().toggleClass(EMPTY_COLLECTION, !hideNoData)
	    },
	    _itemJQueryEventHandler: function(jQueryEvent, handlerOptionName, actionArgs, actionConfig) {
	        this._itemEventHandler(jQueryEvent.target, handlerOptionName, $.extend(actionArgs, {
	            jQueryEvent: jQueryEvent
	        }), actionConfig)
	    },
	    _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
	        var action = this._createActionByOption(handlerOptionName, $.extend({
	            validatingTargetName: "itemElement"
	        }, actionConfig));
	        return this._itemEventHandlerImpl(initiator, action, actionArgs)
	    },
	    _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
	        var action = this._createAction(handler, $.extend({
	            validatingTargetName: "itemElement"
	        }, actionConfig));
	        return this._itemEventHandlerImpl(initiator, action, actionArgs)
	    },
	    _itemEventHandlerImpl: function(initiator, action, actionArgs) {
	        var $itemElement = this._closestItemElement($(initiator));
	        return action($.extend(this._extendActionArgs($itemElement), actionArgs))
	    },
	    _extendActionArgs: function($itemElement) {
	        return {
	            itemElement: $itemElement,
	            itemIndex: this._itemElements().index($itemElement),
	            itemData: this._getItemData($itemElement)
	        }
	    },
	    _closestItemElement: function($element) {
	        return $($element).closest(this._itemSelector())
	    },
	    _getItemData: function(itemElement) {
	        return $(itemElement).data(this._itemDataKey())
	    },
	    getFocusedItemId: function() {
	        if (!this._focusedItemId) {
	            this._focusedItemId = new Guid
	        }
	        return this._focusedItemId
	    },
	    itemElements: function() {
	        return this._itemElements()
	    },
	    itemsContainer: function() {
	        return this._itemContainer()
	    }
	}).include(DataHelperMixin);
	CollectionWidget.ItemClass = CollectionWidgetItem;
	module.exports = CollectionWidget;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (core/guid.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var Class = __webpack_require__(18);
	var Guid = Class.inherit({
	    ctor: function(value) {
	        if (value) {
	            value = String(value)
	        }
	        this._value = this._normalize(value || this._generate())
	    },
	    _normalize: function(value) {
	        value = value.replace(/[^a-f0-9]/gi, "").toLowerCase();
	        while (value.length < 32) {
	            value += "0"
	        }
	        return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join("-")
	    },
	    _generate: function() {
	        var value = "";
	        for (var i = 0; i < 32; i++) {
	            value += Math.round(15 * Math.random()).toString(16)
	        }
	        return value
	    },
	    toString: function() {
	        return this._value
	    },
	    valueOf: function() {
	        return this._value
	    },
	    toJSON: function() {
	        return this._value
	    }
	});
	module.exports = Guid;
	module.exports.default = module.exports;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data_helper.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    DataSource = __webpack_require__(121).DataSource,
	    normalizeDataSourceOptions = __webpack_require__(121).normalizeDataSourceOptions;
	var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions",
	    DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler",
	    DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler",
	    DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler",
	    SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
	var DataHelperMixin = {
	    postCtor: function() {
	        this.on("disposing", function() {
	            this._disposeDataSource()
	        })
	    },
	    _refreshDataSource: function() {
	        this._initDataSource();
	        this._loadDataSource()
	    },
	    _initDataSource: function() {
	        var widgetDataSourceOptions, dataSourceType, dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
	        this._disposeDataSource();
	        if (dataSourceOptions) {
	            if (dataSourceOptions instanceof DataSource) {
	                this._isSharedDataSource = true;
	                this._dataSource = dataSourceOptions
	            } else {
	                widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
	                dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
	                this._dataSource = new dataSourceType($.extend(true, {}, widgetDataSourceOptions, normalizeDataSourceOptions(dataSourceOptions)))
	            }
	            this._addDataSourceHandlers()
	        }
	    },
	    _addDataSourceHandlers: function() {
	        if (DATA_SOURCE_CHANGED_METHOD in this) {
	            this._addDataSourceChangeHandler()
	        }
	        if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
	            this._addDataSourceLoadErrorHandler()
	        }
	        if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
	            this._addDataSourceLoadingChangedHandler()
	        }
	        this._addReadyWatcher()
	    },
	    _addReadyWatcher: function() {
	        this._dataSource.on("loadingChanged", $.proxy(function(isLoading) {
	            this._ready && this._ready(!isLoading)
	        }, this))
	    },
	    _addDataSourceChangeHandler: function() {
	        var dataSource = this._dataSource;
	        this._proxiedDataSourceChangedHandler = $.proxy(function() {
	            this[DATA_SOURCE_CHANGED_METHOD](dataSource.items())
	        }, this);
	        dataSource.on("changed", this._proxiedDataSourceChangedHandler)
	    },
	    _addDataSourceLoadErrorHandler: function() {
	        this._proxiedDataSourceLoadErrorHandler = $.proxy(this[DATA_SOURCE_LOAD_ERROR_METHOD], this);
	        this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler)
	    },
	    _addDataSourceLoadingChangedHandler: function() {
	        this._proxiedDataSourceLoadingChangedHandler = $.proxy(this[DATA_SOURCE_LOADING_CHANGED_METHOD], this);
	        this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
	    },
	    _loadDataSource: function() {
	        if (this._dataSource) {
	            var dataSource = this._dataSource;
	            if (dataSource.isLoaded()) {
	                this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler()
	            } else {
	                dataSource.load()
	            }
	        }
	    },
	    _loadSingle: function(key, value) {
	        key = "this" === key ? this._dataSource.key() || "this" : key;
	        return this._dataSource.loadSingle(key, value)
	    },
	    _isLastPage: function() {
	        return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize
	    },
	    _isDataSourceLoading: function() {
	        return this._dataSource && this._dataSource.isLoading()
	    },
	    _disposeDataSource: function() {
	        if (this._dataSource) {
	            if (this._isSharedDataSource) {
	                delete this._isSharedDataSource;
	                this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
	                this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
	                this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
	            } else {
	                this._dataSource.dispose()
	            }
	            delete this._dataSource;
	            delete this._proxiedDataSourceChangedHandler;
	            delete this._proxiedDataSourceLoadErrorHandler;
	            delete this._proxiedDataSourceLoadingChangedHandler
	        }
	    },
	    getDataSource: function() {
	        return this._dataSource || null
	    }
	};
	module.exports = DataHelperMixin;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/data_source/data_source.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    dataUtils = __webpack_require__(122),
	    Store = __webpack_require__(123),
	    ArrayStore = __webpack_require__(129),
	    CustomStore = __webpack_require__(130),
	    EventsMixin = __webpack_require__(38),
	    errors = __webpack_require__(124).errors,
	    array = __webpack_require__(99),
	    queue = __webpack_require__(50),
	    when = __webpack_require__(10).when,
	    __isString = commonUtils.isString,
	    __isNumber = commonUtils.isNumber,
	    __isBoolean = commonUtils.isBoolean,
	    __isDefined = commonUtils.isDefined;
	var CANCELED_TOKEN = "canceled";

	function OperationManager() {
	    this._counter = -1;
	    this._deferreds = {}
	}
	OperationManager.prototype.constructor = OperationManager;
	OperationManager.prototype.add = function(deferred) {
	    this._counter += 1;
	    this._deferreds[this._counter] = deferred;
	    return this._counter
	};
	OperationManager.prototype.remove = function(operationId) {
	    return delete this._deferreds[operationId]
	};
	OperationManager.prototype.cancel = function(operationId) {
	    if (operationId in this._deferreds) {
	        this._deferreds[operationId].reject(CANCELED_TOKEN);
	        return true
	    }
	    return false
	};
	var operationManager = new OperationManager;

	function isPending(deferred) {
	    return "pending" === deferred.state()
	}

	function normalizeDataSourceOptions(options) {
	    var store;

	    function createCustomStoreFromLoadFunc() {
	        var storeConfig = {};
	        $.each(["useDefaultSearch", "key", "load", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
	            storeConfig[this] = options[this];
	            delete options[this]
	        });
	        return new CustomStore(storeConfig)
	    }

	    function createStoreFromConfig(storeConfig) {
	        var alias = storeConfig.type;
	        delete storeConfig.type;
	        return Store.create(alias, storeConfig)
	    }

	    function createCustomStoreFromUrl(url) {
	        return new CustomStore({
	            load: function() {
	                return $.getJSON(url)
	            }
	        })
	    }
	    if ("string" === typeof options) {
	        options = {
	            paginate: false,
	            store: createCustomStoreFromUrl(options)
	        }
	    }
	    if (void 0 === options) {
	        options = []
	    }
	    if ($.isArray(options) || options instanceof Store) {
	        options = {
	            store: options
	        }
	    } else {
	        options = $.extend({}, options)
	    }
	    if (void 0 === options.store) {
	        options.store = []
	    }
	    store = options.store;
	    if ("load" in options) {
	        store = createCustomStoreFromLoadFunc()
	    } else {
	        if ($.isArray(store)) {
	            store = new ArrayStore(store)
	        } else {
	            if ($.isPlainObject(store)) {
	                store = createStoreFromConfig($.extend({}, store))
	            }
	        }
	    }
	    options.store = store;
	    return options
	}

	function normalizeStoreLoadOptionAccessorArguments(originalArguments) {
	    switch (originalArguments.length) {
	        case 0:
	            return;
	        case 1:
	            return originalArguments[0]
	    }
	    return $.makeArray(originalArguments)
	}

	function generateStoreLoadOptionAccessor(optionName) {
	    return function() {
	        var args = normalizeStoreLoadOptionAccessorArguments(arguments);
	        if (void 0 === args) {
	            return this._storeLoadOptions[optionName]
	        }
	        this._storeLoadOptions[optionName] = args
	    }
	}

	function mapDataRespectingGrouping(items, mapper, groupInfo) {
	    function mapRecursive(items, level) {
	        if (!commonUtils.isArray(items)) {
	            return items
	        }
	        return level ? mapGroup(items, level) : $.map(items, mapper)
	    }

	    function mapGroup(group, level) {
	        return $.map(group, function(item) {
	            var result = {
	                key: item.key,
	                items: mapRecursive(item.items, level - 1)
	            };
	            if ("aggregates" in item) {
	                result.aggregates = item.aggregates
	            }
	            return result
	        })
	    }
	    return mapRecursive(items, groupInfo ? dataUtils.normalizeSortingInfo(groupInfo).length : 0)
	}
	var DataSource = Class.inherit({
	    ctor: function(options) {
	        var that = this;
	        options = normalizeDataSourceOptions(options);
	        this._store = options.store;
	        this._storeLoadOptions = this._extractLoadOptions(options);
	        this._mapFunc = options.map;
	        this._postProcessFunc = options.postProcess;
	        this._pageIndex = void 0 !== options.pageIndex ? options.pageIndex : 0;
	        this._pageSize = void 0 !== options.pageSize ? options.pageSize : 20;
	        this._loadingCount = 0;
	        this._loadQueue = this._createLoadQueue();
	        this._searchValue = "searchValue" in options ? options.searchValue : null;
	        this._searchOperation = options.searchOperation || "contains";
	        this._searchExpr = options.searchExpr;
	        this._paginate = options.paginate;
	        $.each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], function(_, optionName) {
	            if (optionName in options) {
	                that.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName])
	            }
	        });
	        this._init()
	    },
	    _init: function() {
	        this._items = [];
	        this._userData = {};
	        this._totalCount = -1;
	        this._isLoaded = false;
	        if (!__isDefined(this._paginate)) {
	            this._paginate = !this.group()
	        }
	        this._isLastPage = !this._paginate
	    },
	    dispose: function() {
	        this._disposeEvents();
	        delete this._store;
	        if (this._delayedLoadTask) {
	            this._delayedLoadTask.abort()
	        }
	        this._disposed = true
	    },
	    _extractLoadOptions: function(options) {
	        var result = {},
	            names = ["sort", "filter", "select", "group", "requireTotalCount"],
	            customNames = this._store._customLoadOptions();
	        if (customNames) {
	            names = names.concat(customNames)
	        }
	        $.each(names, function() {
	            result[this] = options[this]
	        });
	        return result
	    },
	    loadOptions: function() {
	        return this._storeLoadOptions
	    },
	    items: function() {
	        return this._items
	    },
	    pageIndex: function(newIndex) {
	        if (!__isNumber(newIndex)) {
	            return this._pageIndex
	        }
	        this._pageIndex = newIndex;
	        this._isLastPage = !this._paginate
	    },
	    paginate: function(value) {
	        if (!__isBoolean(value)) {
	            return this._paginate
	        }
	        if (this._paginate !== value) {
	            this._paginate = value;
	            this.pageIndex(0)
	        }
	    },
	    pageSize: function(value) {
	        if (!__isNumber(value)) {
	            return this._pageSize
	        }
	        this._pageSize = value
	    },
	    isLastPage: function() {
	        return this._isLastPage
	    },
	    sort: generateStoreLoadOptionAccessor("sort"),
	    filter: function() {
	        var newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
	        if (void 0 === newFilter) {
	            return this._storeLoadOptions.filter
	        }
	        this._storeLoadOptions.filter = newFilter;
	        this.pageIndex(0)
	    },
	    group: generateStoreLoadOptionAccessor("group"),
	    select: generateStoreLoadOptionAccessor("select"),
	    requireTotalCount: function(value) {
	        if (!__isBoolean(value)) {
	            return this._storeLoadOptions.requireTotalCount
	        }
	        this._storeLoadOptions.requireTotalCount = value
	    },
	    searchValue: function(value) {
	        if (arguments.length < 1) {
	            return this._searchValue
	        }
	        this._searchValue = value;
	        this.pageIndex(0)
	    },
	    searchOperation: function(op) {
	        if (!__isString(op)) {
	            return this._searchOperation
	        }
	        this._searchOperation = op;
	        this.pageIndex(0)
	    },
	    searchExpr: function(expr) {
	        var argc = arguments.length;
	        if (0 === argc) {
	            return this._searchExpr
	        }
	        if (argc > 1) {
	            expr = $.makeArray(arguments)
	        }
	        this._searchExpr = expr;
	        this.pageIndex(0)
	    },
	    store: function() {
	        return this._store
	    },
	    key: function() {
	        return this._store && this._store.key()
	    },
	    totalCount: function() {
	        return this._totalCount
	    },
	    isLoaded: function() {
	        return this._isLoaded
	    },
	    isLoading: function() {
	        return this._loadingCount > 0
	    },
	    _createLoadQueue: function() {
	        return queue.create()
	    },
	    _changeLoadingCount: function(increment) {
	        var newLoading, oldLoading = this.isLoading();
	        this._loadingCount += increment;
	        newLoading = this.isLoading();
	        if (oldLoading ^ newLoading) {
	            this.fireEvent("loadingChanged", [newLoading])
	        }
	    },
	    _scheduleLoadCallbacks: function(deferred) {
	        var that = this;
	        that._changeLoadingCount(1);
	        deferred.always(function() {
	            that._changeLoadingCount(-1)
	        })
	    },
	    _scheduleFailCallbacks: function(deferred) {
	        var that = this;
	        deferred.fail(function() {
	            if (arguments[0] === CANCELED_TOKEN) {
	                return
	            }
	            that.fireEvent("loadError", arguments)
	        })
	    },
	    _scheduleChangedCallbacks: function(deferred) {
	        var that = this;
	        deferred.done(function() {
	            that.fireEvent("changed")
	        })
	    },
	    loadSingle: function(propName, propValue) {
	        var that = this;
	        var d = $.Deferred(),
	            key = this.key(),
	            store = this._store,
	            options = this._createStoreLoadOptions(),
	            handleDone = function(data) {
	                if (!__isDefined(data) || array.isEmpty(data)) {
	                    d.reject(new errors.Error("E4009"))
	                } else {
	                    d.resolve(that._applyMapFunction($.makeArray(data))[0])
	                }
	            };
	        this._scheduleFailCallbacks(d);
	        if (arguments.length < 2) {
	            propValue = propName;
	            propName = key
	        }
	        delete options.skip;
	        delete options.group;
	        delete options.refresh;
	        delete options.pageIndex;
	        delete options.searchString;
	        (function() {
	            if (propName === key || store instanceof CustomStore) {
	                return store.byKey(propValue, options)
	            }
	            options.take = 1;
	            options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
	            return store.load(options)
	        })().fail(d.reject).done(handleDone);
	        return d.promise()
	    },
	    load: function() {
	        var loadOperation, that = this,
	            d = $.Deferred();

	        function loadTask() {
	            if (that._disposed) {
	                return
	            }
	            if (!isPending(d)) {
	                return
	            }
	            return that._loadFromStore(loadOperation, d)
	        }
	        this._scheduleLoadCallbacks(d);
	        this._scheduleFailCallbacks(d);
	        this._scheduleChangedCallbacks(d);
	        loadOperation = this._createLoadOperation(d);
	        this.fireEvent("customizeStoreLoadOptions", [loadOperation]);
	        this._loadQueue.add(function() {
	            if ("number" === typeof loadOperation.delay) {
	                that._delayedLoadTask = commonUtils.executeAsync(loadTask, loadOperation.delay)
	            } else {
	                loadTask()
	            }
	            return d.promise()
	        });
	        return d.promise({
	            operationId: loadOperation.operationId
	        })
	    },
	    _createLoadOperation: function(deferred) {
	        var id = operationManager.add(deferred),
	            options = this._createStoreLoadOptions();
	        deferred.always(function() {
	            operationManager.remove(id)
	        });
	        return {
	            operationId: id,
	            storeLoadOptions: options
	        }
	    },
	    reload: function() {
	        this._init();
	        return this.load()
	    },
	    cancel: function(operationId) {
	        return operationManager.cancel(operationId)
	    },
	    _addSearchOptions: function(storeLoadOptions) {
	        if (this._disposed) {
	            return
	        }
	        if (this.store()._useDefaultSearch) {
	            this._addSearchFilter(storeLoadOptions)
	        } else {
	            storeLoadOptions.searchOperation = this._searchOperation;
	            storeLoadOptions.searchValue = this._searchValue;
	            storeLoadOptions.searchExpr = this._searchExpr
	        }
	    },
	    _createStoreLoadOptions: function() {
	        var result = $.extend({}, this._storeLoadOptions);
	        this._addSearchOptions(result);
	        if (this._paginate) {
	            if (this._pageSize) {
	                result.skip = this._pageIndex * this._pageSize;
	                result.take = this._pageSize
	            }
	        }
	        result.userData = this._userData;
	        return result
	    },
	    _addSearchFilter: function(storeLoadOptions) {
	        var value = this._searchValue,
	            op = this._searchOperation,
	            selector = this._searchExpr,
	            searchFilter = [];
	        if (!value) {
	            return
	        }
	        if (!selector) {
	            selector = "this"
	        }
	        if (!$.isArray(selector)) {
	            selector = [selector]
	        }
	        $.each(selector, function(i, item) {
	            if (searchFilter.length) {
	                searchFilter.push("or")
	            }
	            searchFilter.push([item, op, value])
	        });
	        if (storeLoadOptions.filter) {
	            storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter]
	        } else {
	            storeLoadOptions.filter = searchFilter
	        }
	    },
	    _loadFromStore: function(loadOptions, pendingDeferred) {
	        var that = this;

	        function handleSuccess(data, extra) {
	            function processResult() {
	                var loadResult;
	                if (data && !$.isArray(data) && data.data) {
	                    extra = data;
	                    data = data.data
	                }
	                loadResult = $.extend({
	                    data: data,
	                    extra: extra
	                }, loadOptions);
	                that.fireEvent("customizeLoadResult", [loadResult]);
	                when(loadResult.data).done(function(data) {
	                    loadResult.data = data;
	                    that._processStoreLoadResult(loadResult, pendingDeferred)
	                }).fail(pendingDeferred.reject)
	            }
	            if (that._disposed) {
	                return
	            }
	            if (!isPending(pendingDeferred)) {
	                return
	            }
	            processResult()
	        }
	        if (loadOptions.data) {
	            return $.Deferred().resolve(loadOptions.data).done(handleSuccess)
	        }
	        return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject)
	    },
	    _processStoreLoadResult: function(loadResult, pendingDeferred) {
	        var that = this;
	        var data = $.makeArray(loadResult.data),
	            extra = loadResult.extra,
	            storeLoadOptions = loadResult.storeLoadOptions;

	        function resolvePendingDeferred() {
	            that._isLoaded = true;
	            that._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
	            return pendingDeferred.resolve(data, extra)
	        }

	        function proceedLoadingTotalCount() {
	            that.store().totalCount(storeLoadOptions).done(function(count) {
	                extra.totalCount = count;
	                resolvePendingDeferred()
	            }).fail(pendingDeferred.reject)
	        }
	        if (that._disposed) {
	            return
	        }
	        data = that._applyPostProcessFunction(that._applyMapFunction(data));
	        if (!$.isPlainObject(extra)) {
	            extra = {}
	        }
	        that._items = data;
	        if (!data.length || !that._paginate || that._pageSize && data.length < that._pageSize) {
	            that._isLastPage = true
	        }
	        if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
	            proceedLoadingTotalCount()
	        } else {
	            resolvePendingDeferred()
	        }
	    },
	    _applyMapFunction: function(data) {
	        if (this._mapFunc) {
	            return mapDataRespectingGrouping(data, this._mapFunc, this.group())
	        }
	        return data
	    },
	    _applyPostProcessFunction: function(data) {
	        if (this._postProcessFunc) {
	            return this._postProcessFunc(data)
	        }
	        return data
	    }
	}).include(EventsMixin);
	exports.DataSource = DataSource;
	exports.normalizeDataSourceOptions = normalizeDataSourceOptions;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/utils.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    toComparable = __webpack_require__(35).toComparable;
	var normalizeBinaryCriterion = function(crit) {
	    return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
	};
	var normalizeSortingInfo = function(info) {
	    if (!$.isArray(info)) {
	        info = [info]
	    }
	    return $.map(info, function(i) {
	        return {
	            selector: $.isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
	            desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
	        }
	    })
	};
	var errorMessageFromXhr = function() {
	    var textStatusMessages = {
	        timeout: "Network connection timeout",
	        error: "Unspecified network error",
	        parsererror: "Unexpected server response"
	    };
	    var explainTextStatus = function(textStatus) {
	        var result = textStatusMessages[textStatus];
	        if (!result) {
	            return textStatus
	        }
	        return result
	    };
	    return function(xhr, textStatus) {
	        if (xhr.status < 400) {
	            return explainTextStatus(textStatus)
	        }
	        return xhr.statusText
	    }
	}();
	var aggregators = {
	    count: {
	        seed: 0,
	        step: function(count) {
	            return 1 + count
	        }
	    },
	    sum: {
	        seed: 0,
	        step: function(sum, item) {
	            return sum + item
	        }
	    },
	    min: {
	        step: function(min, item) {
	            return item < min ? item : min
	        }
	    },
	    max: {
	        step: function(max, item) {
	            return item > max ? item : max
	        }
	    },
	    avg: {
	        seed: [0, 0],
	        step: function(pair, value) {
	            return [pair[0] + value, pair[1] + 1]
	        },
	        finalize: function(pair) {
	            return pair[1] ? pair[0] / pair[1] : NaN
	        }
	    }
	};
	var processRequestResultLock = function() {
	    var lockDeferred, lockCount = 0;
	    var obtain = function() {
	        if (0 === lockCount) {
	            lockDeferred = $.Deferred()
	        }
	        lockCount++
	    };
	    var release = function() {
	        lockCount--;
	        if (lockCount < 1) {
	            lockDeferred.resolve()
	        }
	    };
	    var promise = function() {
	        var deferred = 0 === lockCount ? $.Deferred().resolve() : lockDeferred;
	        return deferred.promise()
	    };
	    var reset = function() {
	        lockCount = 0;
	        if (lockDeferred) {
	            lockDeferred.resolve()
	        }
	    };
	    return {
	        obtain: obtain,
	        release: release,
	        promise: promise,
	        reset: reset
	    }
	}();

	function isDisjunctiveOperator(condition) {
	    return /^(or|\|\||\|)$/i.test(condition)
	}

	function isConjunctiveOperator(condition) {
	    return /^(and|\&\&|\&)$/i.test(condition)
	}
	var keysEqual = function(keyExpr, key1, key2) {
	    if ($.isArray(keyExpr)) {
	        var name, names = $.map(key1, function(v, k) {
	            return k
	        });
	        for (var i = 0; i < names.length; i++) {
	            name = names[i];
	            if (toComparable(key1[name], true) != toComparable(key2[name], true)) {
	                return false
	            }
	        }
	        return true
	    }
	    return toComparable(key1, true) == toComparable(key2, true)
	};
	var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	var base64_encode = function(input) {
	    if (!$.isArray(input)) {
	        input = stringToByteArray(String(input))
	    }
	    var result = "";

	    function getBase64Char(index) {
	        return BASE64_CHARS.charAt(index)
	    }
	    for (var i = 0; i < input.length; i += 3) {
	        var octet1 = input[i],
	            octet2 = input[i + 1],
	            octet3 = input[i + 2];
	        result += $.map([octet1 >> 2, (3 & octet1) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (15 & octet2) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : 63 & octet3], getBase64Char).join("")
	    }
	    return result
	};
	var stringToByteArray = function(str) {
	    var code, i, bytes = [];
	    for (i = 0; i < str.length; i++) {
	        code = str.charCodeAt(i);
	        if (code < 128) {
	            bytes.push(code)
	        } else {
	            if (code < 2048) {
	                bytes.push(192 + (code >> 6), 128 + (63 & code))
	            } else {
	                if (code < 65536) {
	                    bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (63 & code))
	                } else {
	                    if (code < 2097152) {
	                        bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (63 & code))
	                    }
	                }
	            }
	        }
	    }
	    return bytes
	};
	var isUnaryOperation = function(crit) {
	    return "!" === crit[0] && $.isArray(crit[1])
	};
	var utils = {
	    normalizeBinaryCriterion: normalizeBinaryCriterion,
	    normalizeSortingInfo: normalizeSortingInfo,
	    errorMessageFromXhr: errorMessageFromXhr,
	    aggregators: aggregators,
	    keysEqual: keysEqual,
	    isDisjunctiveOperator: isDisjunctiveOperator,
	    isConjunctiveOperator: isConjunctiveOperator,
	    processRequestResultLock: processRequestResultLock,
	    isUnaryOperation: isUnaryOperation,
	    base64_encode: base64_encode
	};
	module.exports = utils;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/abstract_store.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    abstract = Class.abstract,
	    EventsMixin = __webpack_require__(38),
	    errorsModule = __webpack_require__(124),
	    dataUtils = __webpack_require__(122),
	    normalizeSortingInfo = dataUtils.normalizeSortingInfo,
	    compileGetter = __webpack_require__(35).compileGetter,
	    Query = __webpack_require__(125),
	    storeImpl = {};

	function multiLevelGroup(query, groupInfo) {
	    query = query.groupBy(groupInfo[0].selector);
	    if (groupInfo.length > 1) {
	        query = query.select(function(g) {
	            return $.extend({}, g, {
	                items: multiLevelGroup(Query(g.items), groupInfo.slice(1)).toArray()
	            })
	        })
	    }
	    return query
	}

	function arrangeSortingInfo(groupInfo, sortInfo) {
	    var filteredGroup = [];
	    $.each(groupInfo, function(_, group) {
	        var collision = $.grep(sortInfo, function(sort) {
	            return group.selector === sort.selector
	        });
	        if (collision.length < 1) {
	            filteredGroup.push(group)
	        }
	    });
	    return filteredGroup.concat(sortInfo)
	}
	var Store = Class.inherit({
	    ctor: function(options) {
	        var that = this;
	        options = options || {};
	        $.each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_, optionName) {
	            if (optionName in options) {
	                that.on(optionName.slice(2).toLowerCase(), options[optionName])
	            }
	        });
	        this._key = options.key;
	        this._errorHandler = options.errorHandler;
	        this._useDefaultSearch = true
	    },
	    _customLoadOptions: function() {
	        return null
	    },
	    key: function() {
	        return this._key
	    },
	    keyOf: function(obj) {
	        if (!this._keyGetter) {
	            this._keyGetter = compileGetter(this.key())
	        }
	        return this._keyGetter(obj)
	    },
	    _requireKey: function() {
	        if (!this.key()) {
	            throw errorsModule.errors.Error("E4005")
	        }
	    },
	    load: function(options) {
	        var that = this;
	        options = options || {};
	        this.fireEvent("loading", [options]);
	        return this._withLock(this._loadImpl(options)).done(function(result) {
	            that.fireEvent("loaded", [result, options])
	        })
	    },
	    _loadImpl: function(options) {
	        var filter = options.filter,
	            sort = options.sort,
	            select = options.select,
	            group = options.group,
	            skip = options.skip,
	            take = options.take,
	            q = this.createQuery(options);
	        if (filter) {
	            q = q.filter(filter)
	        }
	        if (group) {
	            group = normalizeSortingInfo(group)
	        }
	        if (sort || group) {
	            sort = normalizeSortingInfo(sort || []);
	            if (group) {
	                sort = arrangeSortingInfo(group, sort)
	            }
	            $.each(sort, function(index) {
	                q = q[index ? "thenBy" : "sortBy"](this.selector, this.desc)
	            })
	        }
	        if (select) {
	            q = q.select(select)
	        }
	        if (group) {
	            q = multiLevelGroup(q, group)
	        }
	        if (take || skip) {
	            q = q.slice(skip || 0, take)
	        }
	        return q.enumerate()
	    },
	    _withLock: function(task) {
	        var result = $.Deferred();
	        task.done(function() {
	            var that = this,
	                args = arguments;
	            dataUtils.processRequestResultLock.promise().done(function() {
	                result.resolveWith(that, args)
	            })
	        }).fail(function() {
	            result.rejectWith(this, arguments)
	        });
	        return result
	    },
	    createQuery: abstract,
	    totalCount: function(options) {
	        return this._totalCountImpl(options)
	    },
	    _totalCountImpl: function(options) {
	        options = options || {};
	        var q = this.createQuery(options),
	            group = options.group,
	            filter = options.filter;
	        if (filter) {
	            q = q.filter(filter)
	        }
	        if (group) {
	            group = normalizeSortingInfo(group);
	            q = multiLevelGroup(q, group)
	        }
	        return q.count()
	    },
	    byKey: function(key, extraOptions) {
	        return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)))
	    },
	    _byKeyImpl: abstract,
	    insert: function(values) {
	        var that = this;
	        that.fireEvent("modifying");
	        that.fireEvent("inserting", [values]);
	        return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
	            that.fireEvent("inserted", [callbackValues, callbackKey]);
	            that.fireEvent("modified")
	        }))
	    },
	    _insertImpl: abstract,
	    update: function(key, values) {
	        var that = this;
	        that.fireEvent("modifying");
	        that.fireEvent("updating", [key, values]);
	        return that._addFailHandlers(that._updateImpl(key, values).done(function(callbackKey, callbackValues) {
	            that.fireEvent("updated", [callbackKey, callbackValues]);
	            that.fireEvent("modified")
	        }))
	    },
	    _updateImpl: abstract,
	    remove: function(key) {
	        var that = this;
	        that.fireEvent("modifying");
	        that.fireEvent("removing", [key]);
	        return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
	            that.fireEvent("removed", [callbackKey]);
	            that.fireEvent("modified")
	        }))
	    },
	    _removeImpl: abstract,
	    _addFailHandlers: function(deferred) {
	        return deferred.fail(this._errorHandler, errorsModule._errorHandler)
	    }
	}).include(EventsMixin);
	Store.create = function(alias, options) {
	    if (!(alias in storeImpl)) {
	        throw errorsModule.errors.Error("E4020", alias)
	    }
	    return new storeImpl[alias](options)
	};
	Store.inherit = function(inheritor) {
	    return function(members, alias) {
	        var type = inheritor.apply(this, [members]);
	        if (alias) {
	            storeImpl[alias] = type
	        }
	        return type
	    }
	}(Store.inherit);
	module.exports = Store;
	module.exports.multiLevelGroup = multiLevelGroup;
	module.exports.arrangeSortingInfo = arrangeSortingInfo;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/errors.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var errorUtils = __webpack_require__(4),
	    coreErrors = __webpack_require__(3),
	    handlers = {};
	var errors = errorUtils(coreErrors.ERROR_MESSAGES, {
	    E4000: "[DevExpress.data]: {0}",
	    E4001: "Unknown aggregating function is detected: '{0}'",
	    E4002: "Unsupported OData protocol version is used",
	    E4003: "Unknown filter operation is used: {0}",
	    E4004: "The thenby() method is called before the sortby() method",
	    E4005: "Store requires a key expression for this operation",
	    E4006: "ArrayStore 'data' option must be an array",
	    E4007: "Compound keys cannot be auto-generated",
	    E4008: "Attempt to insert an item with the a duplicated key",
	    E4009: "Data item cannot be found",
	    E4010: "CustomStore does not support creating queries",
	    E4011: "Custom Store method is not implemented or is not a function: {0}",
	    E4012: "Custom Store method returns an invalid value: {0}",
	    E4013: "Local Store requires the 'name' configuration option is specified",
	    E4014: "Unknown key type is detected: {0}",
	    E4015: "Unknown entity name or alias is used: {0}",
	    E4017: "Keys cannot be modified",
	    E4018: "The server has returned a non-numeric value in a response to an item count request",
	    E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
	    E4020: "Unknown store type is detected: {0}",
	    E4021: "The server hasn't returned value in a response to an total count request"
	});

	function handleError(error) {
	    var id = "E4000";
	    if (error && "__id" in error) {
	        id = error.__id
	    }
	    errors.log(id, error)
	}
	var errorHandler = null;
	var _errorHandler = function(error) {
	    if (handlers.errorHandler) {
	        handlers.errorHandler(error)
	    }
	};
	handlers = {
	    errors: errors,
	    errorHandler: errorHandler,
	    _errorHandler: _errorHandler
	};
	module.exports = handlers;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/query.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    arrayQueryImpl = __webpack_require__(126),
	    remoteQueryImpl = __webpack_require__(127);
	var queryImpl = {
	    array: arrayQueryImpl,
	    remote: remoteQueryImpl
	};
	var query = function() {
	    var impl = $.isArray(arguments[0]) ? "array" : "remote";
	    return queryImpl[impl].apply(this, arguments)
	};
	module.exports = query;
	module.exports.queryImpl = queryImpl;
	module.exports.default = module.exports;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/array_query.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    compileGetter = __webpack_require__(35).compileGetter,
	    toComparable = __webpack_require__(35).toComparable,
	    errorsModule = __webpack_require__(124),
	    dataUtils = __webpack_require__(122);
	var Iterator = Class.inherit({
	    toArray: function() {
	        var result = [];
	        this.reset();
	        while (this.next()) {
	            result.push(this.current())
	        }
	        return result
	    },
	    countable: function() {
	        return false
	    }
	});
	var ArrayIterator = Iterator.inherit({
	    ctor: function(array) {
	        this.array = array;
	        this.index = -1
	    },
	    next: function() {
	        if (this.index + 1 < this.array.length) {
	            this.index++;
	            return true
	        }
	        return false
	    },
	    current: function() {
	        return this.array[this.index]
	    },
	    reset: function() {
	        this.index = -1
	    },
	    toArray: function() {
	        return this.array.slice(0)
	    },
	    countable: function() {
	        return true
	    },
	    count: function() {
	        return this.array.length
	    }
	});
	var WrappedIterator = Iterator.inherit({
	    ctor: function(iter) {
	        this.iter = iter
	    },
	    next: function() {
	        return this.iter.next()
	    },
	    current: function() {
	        return this.iter.current()
	    },
	    reset: function() {
	        return this.iter.reset()
	    }
	});
	var MapIterator = WrappedIterator.inherit({
	    ctor: function(iter, mapper) {
	        this.callBase(iter);
	        this.index = -1;
	        this.mapper = mapper
	    },
	    current: function() {
	        return this.mapper(this.callBase(), this.index)
	    },
	    next: function() {
	        var hasNext = this.callBase();
	        if (hasNext) {
	            this.index++
	        }
	        return hasNext
	    }
	});
	var SortIterator = Iterator.inherit({
	    ctor: function(iter, getter, desc) {
	        if (!(iter instanceof MapIterator)) {
	            iter = new MapIterator(iter, this._wrap)
	        }
	        this.iter = iter;
	        this.rules = [{
	            getter: getter,
	            desc: desc
	        }]
	    },
	    thenBy: function(getter, desc) {
	        var result = new SortIterator(this.sortedIter || this.iter, getter, desc);
	        if (!this.sortedIter) {
	            result.rules = this.rules.concat(result.rules)
	        }
	        return result
	    },
	    next: function() {
	        this._ensureSorted();
	        return this.sortedIter.next()
	    },
	    current: function() {
	        this._ensureSorted();
	        return this.sortedIter.current()
	    },
	    reset: function() {
	        delete this.sortedIter
	    },
	    countable: function() {
	        return this.sortedIter || this.iter.countable()
	    },
	    count: function() {
	        if (this.sortedIter) {
	            return this.sortedIter.count()
	        }
	        return this.iter.count()
	    },
	    _ensureSorted: function() {
	        var that = this;
	        if (that.sortedIter) {
	            return
	        }
	        $.each(that.rules, function() {
	            this.getter = compileGetter(this.getter)
	        });
	        that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
	            return that._compare(x, y)
	        })), that._unwrap)
	    },
	    _wrap: function(record, index) {
	        return {
	            index: index,
	            value: record
	        }
	    },
	    _unwrap: function(wrappedItem) {
	        return wrappedItem.value
	    },
	    _compare: function(x, y) {
	        var xIndex = x.index,
	            yIndex = y.index;
	        x = x.value;
	        y = y.value;
	        if (x === y) {
	            return xIndex - yIndex
	        }
	        for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
	            var rule = this.rules[i],
	                xValue = toComparable(rule.getter(x)),
	                yValue = toComparable(rule.getter(y)),
	                factor = rule.desc ? -1 : 1;
	            if (null === xValue && null !== yValue) {
	                return -factor
	            }
	            if (null !== xValue && null === yValue) {
	                return factor
	            }
	            if (void 0 === xValue && void 0 !== yValue) {
	                return factor
	            }
	            if (void 0 !== xValue && void 0 === yValue) {
	                return -factor
	            }
	            if (xValue < yValue) {
	                return -factor
	            }
	            if (xValue > yValue) {
	                return factor
	            }
	        }
	        return xIndex - yIndex
	    }
	});
	var compileCriteria = function() {
	    var compileGroup = function(crit) {
	        var groupOperator, nextGroupOperator, idx = 0,
	            bag = [],
	            ops = [];
	        $.each(crit, function() {
	            if ($.isArray(this) || $.isFunction(this)) {
	                if (bag.length > 1 && groupOperator !== nextGroupOperator) {
	                    throw new errorsModule.errors.Error("E4019")
	                }
	                ops.push(compileCriteria(this));
	                bag.push("op[" + idx + "](d)");
	                idx++;
	                groupOperator = nextGroupOperator;
	                nextGroupOperator = "&&"
	            } else {
	                nextGroupOperator = dataUtils.isConjunctiveOperator(this) ? "&&" : "||"
	            }
	        });
	        return new Function("op", "return function(d) { return " + bag.join(" " + groupOperator + " ") + " }")(ops)
	    };
	    var toString = function(value) {
	        return commonUtils.isDefined(value) ? value.toString() : ""
	    };
	    var compileBinary = function(crit) {
	        crit = dataUtils.normalizeBinaryCriterion(crit);
	        var getter = compileGetter(crit[0]),
	            op = crit[1],
	            value = crit[2];
	        value = toComparable(value);
	        switch (op.toLowerCase()) {
	            case "=":
	                return compileEquals(getter, value);
	            case "<>":
	                return compileEquals(getter, value, true);
	            case ">":
	                return function(obj) {
	                    return toComparable(getter(obj)) > value
	                };
	            case "<":
	                return function(obj) {
	                    return toComparable(getter(obj)) < value
	                };
	            case ">=":
	                return function(obj) {
	                    return toComparable(getter(obj)) >= value
	                };
	            case "<=":
	                return function(obj) {
	                    return toComparable(getter(obj)) <= value
	                };
	            case "startswith":
	                return function(obj) {
	                    return 0 === toComparable(toString(getter(obj))).indexOf(value)
	                };
	            case "endswith":
	                return function(obj) {
	                    var getterValue = toComparable(toString(getter(obj))),
	                        searchValue = toString(value);
	                    if (getterValue.length < searchValue.length) {
	                        return false
	                    }
	                    return getterValue.lastIndexOf(value) === getterValue.length - value.length
	                };
	            case "contains":
	                return function(obj) {
	                    return toComparable(toString(getter(obj))).indexOf(value) > -1
	                };
	            case "notcontains":
	                return function(obj) {
	                    return toComparable(toString(getter(obj))).indexOf(value) === -1
	                }
	        }
	        throw errorsModule.errors.Error("E4003", op)
	    };

	    function compileEquals(getter, value, negate) {
	        return function(obj) {
	            obj = toComparable(getter(obj));
	            var result = useStrictComparison(value) ? obj === value : obj == value;
	            if (negate) {
	                result = !result
	            }
	            return result
	        }
	    }

	    function useStrictComparison(value) {
	        return "" === value || 0 === value || false === value
	    }

	    function compileUnary(crit) {
	        var op = crit[0],
	            criteria = compileCriteria(crit[1]);
	        if ("!" === op) {
	            return function(obj) {
	                return !criteria(obj)
	            }
	        }
	        throw errorsModule.errors.Error("E4003", op)
	    }
	    return function(crit) {
	        if ($.isFunction(crit)) {
	            return crit
	        }
	        if ($.isArray(crit[0])) {
	            return compileGroup(crit)
	        }
	        if (dataUtils.isUnaryOperation(crit)) {
	            return compileUnary(crit)
	        }
	        return compileBinary(crit)
	    }
	}();
	var FilterIterator = WrappedIterator.inherit({
	    ctor: function(iter, criteria) {
	        this.callBase(iter);
	        this.criteria = compileCriteria(criteria)
	    },
	    next: function() {
	        while (this.iter.next()) {
	            if (this.criteria(this.current())) {
	                return true
	            }
	        }
	        return false
	    }
	});
	var GroupIterator = Iterator.inherit({
	    ctor: function(iter, getter) {
	        this.iter = iter;
	        this.getter = getter
	    },
	    next: function() {
	        this._ensureGrouped();
	        return this.groupedIter.next()
	    },
	    current: function() {
	        this._ensureGrouped();
	        return this.groupedIter.current()
	    },
	    reset: function() {
	        delete this.groupedIter
	    },
	    countable: function() {
	        return !!this.groupedIter
	    },
	    count: function() {
	        return this.groupedIter.count()
	    },
	    _ensureGrouped: function() {
	        if (this.groupedIter) {
	            return
	        }
	        var hash = {},
	            keys = [],
	            iter = this.iter,
	            getter = compileGetter(this.getter);
	        iter.reset();
	        while (iter.next()) {
	            var current = iter.current(),
	                key = getter(current);
	            if (key in hash) {
	                hash[key].push(current)
	            } else {
	                hash[key] = [current];
	                keys.push(key)
	            }
	        }
	        this.groupedIter = new ArrayIterator($.map(keys, function(key) {
	            return {
	                key: key,
	                items: hash[key]
	            }
	        }))
	    }
	});
	var SelectIterator = WrappedIterator.inherit({
	    ctor: function(iter, getter) {
	        this.callBase(iter);
	        this.getter = compileGetter(getter)
	    },
	    current: function() {
	        return this.getter(this.callBase())
	    },
	    countable: function() {
	        return this.iter.countable()
	    },
	    count: function() {
	        return this.iter.count()
	    }
	});
	var SliceIterator = WrappedIterator.inherit({
	    ctor: function(iter, skip, take) {
	        this.callBase(iter);
	        this.skip = Math.max(0, skip);
	        this.take = Math.max(0, take);
	        this.pos = 0
	    },
	    next: function() {
	        if (this.pos >= this.skip + this.take) {
	            return false
	        }
	        while (this.pos < this.skip && this.iter.next()) {
	            this.pos++
	        }
	        this.pos++;
	        return this.iter.next()
	    },
	    reset: function() {
	        this.callBase();
	        this.pos = 0
	    },
	    countable: function() {
	        return this.iter.countable()
	    },
	    count: function() {
	        return Math.min(this.iter.count() - this.skip, this.take)
	    }
	});
	var arrayQueryImpl = function(iter, queryOptions) {
	    queryOptions = queryOptions || {};
	    if (!(iter instanceof Iterator)) {
	        iter = new ArrayIterator(iter)
	    }
	    var handleError = function(error) {
	        var handler = queryOptions.errorHandler;
	        if (handler) {
	            handler(error)
	        }
	        errorsModule._errorHandler(error)
	    };
	    var aggregateCore = function(aggregator) {
	        var seed, d = $.Deferred().fail(handleError),
	            step = aggregator.step,
	            finalize = aggregator.finalize;
	        try {
	            iter.reset();
	            if ("seed" in aggregator) {
	                seed = aggregator.seed
	            } else {
	                seed = iter.next() ? iter.current() : NaN
	            }
	            var accumulator = seed;
	            while (iter.next()) {
	                accumulator = step(accumulator, iter.current())
	            }
	            d.resolve(finalize ? finalize(accumulator) : accumulator)
	        } catch (x) {
	            d.reject(x)
	        }
	        return d.promise()
	    };
	    var aggregate = function(seed, step, finalize) {
	        if (arguments.length < 2) {
	            return aggregateCore({
	                step: arguments[0]
	            })
	        }
	        return aggregateCore({
	            seed: seed,
	            step: step,
	            finalize: finalize
	        })
	    };
	    var standardAggregate = function(name) {
	        return aggregateCore(dataUtils.aggregators[name])
	    };
	    var select = function(getter) {
	        if (!$.isFunction(getter) && !$.isArray(getter)) {
	            getter = $.makeArray(arguments)
	        }
	        return chainQuery(new SelectIterator(iter, getter))
	    };
	    var selectProp = function(name) {
	        return select(compileGetter(name))
	    };
	    var chainQuery = function(iter) {
	        return arrayQueryImpl(iter, queryOptions)
	    };
	    return {
	        toArray: function() {
	            return iter.toArray()
	        },
	        enumerate: function() {
	            var d = $.Deferred().fail(handleError);
	            try {
	                d.resolve(iter.toArray())
	            } catch (x) {
	                d.reject(x)
	            }
	            return d.promise()
	        },
	        sortBy: function(getter, desc) {
	            return chainQuery(new SortIterator(iter, getter, desc))
	        },
	        thenBy: function(getter, desc) {
	            if (iter instanceof SortIterator) {
	                return chainQuery(iter.thenBy(getter, desc))
	            }
	            throw errorsModule.errors.Error("E4004")
	        },
	        filter: function(criteria) {
	            if (!$.isArray(criteria)) {
	                criteria = $.makeArray(arguments)
	            }
	            return chainQuery(new FilterIterator(iter, criteria))
	        },
	        slice: function(skip, take) {
	            if (void 0 === take) {
	                take = Number.MAX_VALUE
	            }
	            return chainQuery(new SliceIterator(iter, skip, take))
	        },
	        select: select,
	        groupBy: function(getter) {
	            return chainQuery(new GroupIterator(iter, getter))
	        },
	        aggregate: aggregate,
	        count: function() {
	            if (iter.countable()) {
	                var d = $.Deferred().fail(handleError);
	                try {
	                    d.resolve(iter.count())
	                } catch (x) {
	                    d.reject(x)
	                }
	                return d.promise()
	            }
	            return standardAggregate("count")
	        },
	        sum: function(getter) {
	            if (getter) {
	                return selectProp(getter).sum()
	            }
	            return standardAggregate("sum")
	        },
	        min: function(getter) {
	            if (getter) {
	                return selectProp(getter).min()
	            }
	            return standardAggregate("min")
	        },
	        max: function(getter) {
	            if (getter) {
	                return selectProp(getter).max()
	            }
	            return standardAggregate("max")
	        },
	        avg: function(getter) {
	            if (getter) {
	                return selectProp(getter).avg()
	            }
	            return standardAggregate("avg")
	        }
	    }
	};
	module.exports = arrayQueryImpl;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/remote_query.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    queryAdapters = __webpack_require__(128),
	    errorsModule = __webpack_require__(124),
	    arrayQueryImpl = __webpack_require__(126);
	var remoteQueryImpl = function(url, queryOptions, tasks) {
	    tasks = tasks || [];
	    queryOptions = queryOptions || {};
	    var createTask = function(name, args) {
	        return {
	            name: name,
	            args: args
	        }
	    };
	    var exec = function(executorTask) {
	        var _adapterFactory, _adapter, _taskQueue, _currentTask, _mergedSortArgs, d = $.Deferred();
	        var rejectWithNotify = function(error) {
	            var handler = queryOptions.errorHandler;
	            if (handler) {
	                handler(error)
	            }
	            errorsModule._errorHandler(error);
	            d.reject(error)
	        };

	        function mergeSortTask(task) {
	            switch (task.name) {
	                case "sortBy":
	                    _mergedSortArgs = [task.args];
	                    return true;
	                case "thenBy":
	                    if (!_mergedSortArgs) {
	                        throw errorsModule.errors.Error("E4004")
	                    }
	                    _mergedSortArgs.push(task.args);
	                    return true
	            }
	            return false
	        }

	        function unmergeSortTasks() {
	            var head = _taskQueue[0],
	                unmergedTasks = [];
	            if (head && "multiSort" === head.name) {
	                _taskQueue.shift();
	                $.each(head.args[0], function() {
	                    unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this))
	                })
	            }
	            _taskQueue = unmergedTasks.concat(_taskQueue)
	        }
	        try {
	            _adapterFactory = queryOptions.adapter;
	            if (!$.isFunction(_adapterFactory)) {
	                _adapterFactory = queryAdapters[_adapterFactory]
	            }
	            _adapter = _adapterFactory(queryOptions);
	            _taskQueue = [].concat(tasks).concat(executorTask);
	            while (_taskQueue.length) {
	                _currentTask = _taskQueue[0];
	                if (!mergeSortTask(_currentTask)) {
	                    if (_mergedSortArgs) {
	                        _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
	                        _mergedSortArgs = null;
	                        continue
	                    }
	                    if ("enumerate" !== String(_currentTask.name)) {
	                        if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
	                            break
	                        }
	                    }
	                }
	                _taskQueue.shift()
	            }
	            unmergeSortTasks();
	            _adapter.exec(url).done(function(result, extra) {
	                if (!_taskQueue.length) {
	                    d.resolve(result, extra)
	                } else {
	                    var clientChain = arrayQueryImpl(result, {
	                        errorHandler: queryOptions.errorHandler
	                    });
	                    $.each(_taskQueue, function() {
	                        clientChain = clientChain[this.name].apply(clientChain, this.args)
	                    });
	                    clientChain.done(d.resolve).fail(d.reject)
	                }
	            }).fail(rejectWithNotify)
	        } catch (x) {
	            rejectWithNotify(x)
	        }
	        return d.promise()
	    };
	    var query = {};
	    $.each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
	        var name = String(this);
	        query[name] = function() {
	            return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)))
	        }
	    });
	    $.each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
	        var name = String(this);
	        query[name] = function() {
	            return exec.call(this, createTask(name, arguments))
	        }
	    });
	    return query
	};
	module.exports = remoteQueryImpl;


/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (data/query_adapters.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = {};


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/array_store.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    objectUtils = __webpack_require__(36),
	    keysEqual = __webpack_require__(122).keysEqual,
	    Query = __webpack_require__(125),
	    errors = __webpack_require__(124).errors,
	    Store = __webpack_require__(123);
	var hasKey = function(target, keyOrKeys) {
	    var key, keys = $.makeArray(keyOrKeys);
	    while (keys.length) {
	        key = keys.shift();
	        if (key in target) {
	            return true
	        }
	    }
	    return false
	};
	var trivialPromise = function() {
	    var d = $.Deferred();
	    return d.resolve.apply(d, arguments).promise()
	};
	var rejectedPromise = function() {
	    var d = $.Deferred();
	    return d.reject.apply(d, arguments).promise()
	};
	var ArrayStore = Store.inherit({
	    ctor: function(options) {
	        if ($.isArray(options)) {
	            options = {
	                data: options
	            }
	        } else {
	            options = options || {}
	        }
	        this.callBase(options);
	        var initialArray = options.data;
	        if (initialArray && !$.isArray(initialArray)) {
	            throw errors.Error("E4006")
	        }
	        this._array = initialArray || []
	    },
	    createQuery: function() {
	        return Query(this._array, {
	            errorHandler: this._errorHandler
	        })
	    },
	    _byKeyImpl: function(key) {
	        var index = this._indexByKey(key);
	        if (index === -1) {
	            return rejectedPromise(errors.Error("E4009"))
	        }
	        return trivialPromise(this._array[index])
	    },
	    _insertImpl: function(values) {
	        var keyValue, obj, keyExpr = this.key();
	        if ($.isPlainObject(values)) {
	            obj = $.extend({}, values)
	        } else {
	            obj = values
	        }
	        if (keyExpr) {
	            keyValue = this.keyOf(obj);
	            if (void 0 === keyValue || "object" === typeof keyValue && $.isEmptyObject(keyValue)) {
	                if ($.isArray(keyExpr)) {
	                    throw errors.Error("E4007")
	                }
	                keyValue = obj[keyExpr] = String(new Guid)
	            } else {
	                if (void 0 !== this._array[this._indexByKey(keyValue)]) {
	                    return rejectedPromise(errors.Error("E4008"))
	                }
	            }
	        } else {
	            keyValue = obj
	        }
	        this._array.push(obj);
	        return trivialPromise(values, keyValue)
	    },
	    _updateImpl: function(key, values) {
	        var index, target, keyExpr = this.key();
	        if (keyExpr) {
	            if (hasKey(values, keyExpr) && !keysEqual(keyExpr, key, this.keyOf(values))) {
	                return rejectedPromise(errors.Error("E4017"))
	            }
	            index = this._indexByKey(key);
	            if (index < 0) {
	                return rejectedPromise(errors.Error("E4009"))
	            }
	            target = this._array[index]
	        } else {
	            target = key
	        }
	        objectUtils.deepExtendArraySafe(target, values);
	        return trivialPromise(key, values)
	    },
	    _removeImpl: function(key) {
	        var index = this._indexByKey(key);
	        if (index > -1) {
	            this._array.splice(index, 1)
	        }
	        return trivialPromise(key)
	    },
	    _indexByKey: function(key) {
	        for (var i = 0, arrayLength = this._array.length; i < arrayLength; i++) {
	            if (keysEqual(this.key(), this.keyOf(this._array[i]), key)) {
	                return i
	            }
	        }
	        return -1
	    },
	    clear: function() {
	        this.fireEvent("modifying");
	        this._array = [];
	        this.fireEvent("modified")
	    }
	}, "array");
	module.exports = ArrayStore;
	module.exports.default = module.exports;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (data/custom_store.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    deferredUtils = __webpack_require__(10),
	    dataUtils = __webpack_require__(122),
	    errors = __webpack_require__(124).errors,
	    Store = __webpack_require__(123);
	var TOTAL_COUNT = "totalCount",
	    LOAD = "load",
	    BY_KEY = "byKey",
	    INSERT = "insert",
	    UPDATE = "update",
	    REMOVE = "remove";

	function isPromise(obj) {
	    return obj && $.isFunction(obj.then)
	}

	function trivialPromise(value) {
	    return $.Deferred().resolve(value).promise()
	}

	function ensureRequiredFuncOption(name, obj) {
	    if (!$.isFunction(obj)) {
	        throw errors.Error("E4011", name)
	    }
	}

	function throwInvalidUserFuncResult(name) {
	    throw errors.Error("E4012", name)
	}

	function createUserFuncFailureHandler(pendingDeferred) {
	    function errorMessageFromXhr(promiseArguments) {
	        var xhr = promiseArguments[0],
	            textStatus = promiseArguments[1];
	        if (!xhr || !xhr.getResponseHeader) {
	            return null
	        }
	        return dataUtils.errorMessageFromXhr(xhr, textStatus)
	    }
	    return function(arg) {
	        var error;
	        if (arg instanceof Error) {
	            error = arg
	        } else {
	            error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || "Unknown error")
	        }
	        pendingDeferred.reject(error)
	    }
	}
	var CustomStore = Store.inherit({
	    ctor: function(options) {
	        options = options || {};
	        this.callBase(options);
	        this._useDefaultSearch = !!options.useDefaultSearch;
	        this._loadFunc = options[LOAD];
	        this._totalCountFunc = options[TOTAL_COUNT];
	        this._byKeyFunc = options[BY_KEY];
	        this._insertFunc = options[INSERT];
	        this._updateFunc = options[UPDATE];
	        this._removeFunc = options[REMOVE]
	    },
	    createQuery: function() {
	        throw errors.Error("E4010")
	    },
	    _totalCountImpl: function(options) {
	        var userResult, userFunc = this._totalCountFunc,
	            d = $.Deferred();
	        if (!$.isFunction(userFunc)) {
	            throw errors.Error("E4021")
	        }
	        userResult = userFunc.apply(this, [options]);
	        if (!isPromise(userResult)) {
	            userResult = Number(userResult);
	            if (!isFinite(userResult)) {
	                throwInvalidUserFuncResult(TOTAL_COUNT)
	            }
	            userResult = trivialPromise(userResult)
	        }
	        deferredUtils.fromPromise(userResult).done(function(count) {
	            d.resolve(Number(count))
	        }).fail(createUserFuncFailureHandler(d));
	        return this._addFailHandlers(d.promise())
	    },
	    _loadImpl: function(options) {
	        var userResult, userFunc = this._loadFunc,
	            d = $.Deferred();
	        ensureRequiredFuncOption(LOAD, userFunc);
	        userResult = userFunc.apply(this, [options]);
	        if ($.isArray(userResult)) {
	            userResult = trivialPromise(userResult)
	        } else {
	            if (null === userResult || void 0 === userResult) {
	                userResult = trivialPromise([])
	            } else {
	                if (!isPromise(userResult)) {
	                    throwInvalidUserFuncResult(LOAD)
	                }
	            }
	        }
	        deferredUtils.fromPromise(userResult).done(function(data, extra) {
	            d.resolve(data, extra)
	        }).fail(createUserFuncFailureHandler(d));
	        return this._addFailHandlers(d.promise())
	    },
	    _byKeyImpl: function(key, extraOptions) {
	        var userResult, userFunc = this._byKeyFunc,
	            d = $.Deferred();
	        ensureRequiredFuncOption(BY_KEY, userFunc);
	        userResult = userFunc.apply(this, [key, extraOptions]);
	        if (!isPromise(userResult)) {
	            userResult = trivialPromise(userResult)
	        }
	        deferredUtils.fromPromise(userResult).done(function(obj) {
	            d.resolve(obj)
	        }).fail(createUserFuncFailureHandler(d));
	        return d.promise()
	    },
	    _insertImpl: function(values) {
	        var userResult, userFunc = this._insertFunc,
	            d = $.Deferred();
	        ensureRequiredFuncOption(INSERT, userFunc);
	        userResult = userFunc.apply(this, [values]);
	        if (!isPromise(userResult)) {
	            userResult = trivialPromise(userResult)
	        }
	        deferredUtils.fromPromise(userResult).done(function(newKey) {
	            d.resolve(values, newKey)
	        }).fail(createUserFuncFailureHandler(d));
	        return d.promise()
	    },
	    _updateImpl: function(key, values) {
	        var userResult, userFunc = this._updateFunc,
	            d = $.Deferred();
	        ensureRequiredFuncOption(UPDATE, userFunc);
	        userResult = userFunc.apply(this, [key, values]);
	        if (!isPromise(userResult)) {
	            userResult = trivialPromise()
	        }
	        deferredUtils.fromPromise(userResult).done(function() {
	            d.resolve(key, values)
	        }).fail(createUserFuncFailureHandler(d));
	        return d.promise()
	    },
	    _removeImpl: function(key) {
	        var userResult, userFunc = this._removeFunc,
	            d = $.Deferred();
	        ensureRequiredFuncOption(REMOVE, userFunc);
	        userResult = userFunc.apply(this, [key]);
	        if (!isPromise(userResult)) {
	            userResult = trivialPromise()
	        }
	        deferredUtils.fromPromise(userResult).done(function() {
	            d.resolve(key)
	        }).fail(createUserFuncFailureHandler(d));
	        return d.promise()
	    }
	});
	module.exports = CustomStore;
	module.exports.default = module.exports;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/collection/item.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    publicComponentUtils = __webpack_require__(30),
	    dataUtils = __webpack_require__(35);
	var INVISIBLE_STATE_CLASS = "dx-state-invisible",
	    DISABLED_STATE_CLASS = "dx-state-disabled",
	    ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
	var forcibleWatcher = function(watchMethod, fn, callback) {
	    var filteredCallback = function() {
	        var oldValue;
	        return function(value) {
	            if (oldValue !== value) {
	                callback(value);
	                oldValue = value
	            }
	        }
	    }();
	    return {
	        dispose: watchMethod(fn, filteredCallback),
	        force: function() {
	            filteredCallback(fn())
	        }
	    }
	};
	var CollectionItem = Class.inherit({
	    ctor: function($element, collection, rawData) {
	        this._$element = $element;
	        this._collection = collection;
	        this._rawData = rawData;
	        publicComponentUtils.attachInstanceToElement($element, this, this._dispose);
	        this._render()
	    },
	    _render: function() {
	        var $placeholder = $("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
	        this._$element.append($placeholder);
	        this._watchers = [];
	        this._renderWatchers()
	    },
	    _renderWatchers: function() {
	        this._startWatcher("disabled", this._renderDisabled.bind(this));
	        this._startWatcher("visible", this._renderVisible.bind(this))
	    },
	    _startWatcher: function(field, render) {
	        var rawData = this._rawData,
	            expr = this._collection.option(field + "Expr"),
	            exprGetter = dataUtils.compileGetter(expr);
	        var watcher = forcibleWatcher(this._collection.option("integrationOptions.watchMethod"), function() {
	            return exprGetter(rawData)
	        }, function(value) {
	            this._dirty = true;
	            render(value)
	        }.bind(this));
	        this._watchers.push(watcher)
	    },
	    setDataField: function() {
	        this._dirty = false;
	        $.each(this._watchers, function(_, watcher) {
	            watcher.force()
	        });
	        if (this._dirty) {
	            return true
	        }
	    },
	    _renderDisabled: function(disabled) {
	        this._$element.toggleClass(DISABLED_STATE_CLASS, !!disabled)
	    },
	    _renderVisible: function(visible) {
	        this._$element.toggleClass(INVISIBLE_STATE_CLASS, void 0 !== visible && !visible)
	    },
	    _dispose: function() {
	        $.each(this._watchers, function(_, watcher) {
	            watcher.dispose()
	        })
	    }
	});
	CollectionItem.getInstance = function($element) {
	    return publicComponentUtils.getInstanceByElement($element, this)
	};
	module.exports = CollectionItem;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/hold.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    eventUtils = __webpack_require__(61),
	    Emitter = __webpack_require__(73),
	    registerEmitter = __webpack_require__(74),
	    abs = Math.abs;
	var HOLD_EVENT_NAME = "dxhold",
	    HOLD_TIMEOUT = 750,
	    TOUCH_BOUNDARY = 5;
	var HoldEmitter = Emitter.inherit({
	    start: function(e) {
	        this._startEventData = eventUtils.eventData(e);
	        this._startTimer(e)
	    },
	    _startTimer: function(e) {
	        var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
	        this._holdTimer = setTimeout($.proxy(function() {
	            this._requestAccept(e);
	            this._fireEvent(HOLD_EVENT_NAME, e, {
	                target: e.target
	            });
	            this._forgetAccept()
	        }, this), holdTimeout)
	    },
	    move: function(e) {
	        if (this._touchWasMoved(e)) {
	            this._cancel(e)
	        }
	    },
	    _touchWasMoved: function(e) {
	        var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
	        return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY
	    },
	    end: function() {
	        this._stopTimer()
	    },
	    _stopTimer: function() {
	        clearTimeout(this._holdTimer)
	    },
	    cancel: function() {
	        this._stopTimer()
	    }
	});
	registerEmitter({
	    emitter: HoldEmitter,
	    bubble: true,
	    events: [HOLD_EVENT_NAME]
	});
	module.exports = {
	    name: HOLD_EVENT_NAME
	};


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/contextmenu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    support = __webpack_require__(48),
	    devices = __webpack_require__(40),
	    Class = __webpack_require__(18),
	    registerEvent = __webpack_require__(63),
	    eventUtils = __webpack_require__(61),
	    holdEvent = __webpack_require__(132);
	var CONTEXTMENU_NAMESPACE = "dxContexMenu",
	    CONTEXTMENU_NAMESPACED_EVENT_NAME = eventUtils.addNamespace("contextmenu", CONTEXTMENU_NAMESPACE),
	    HOLD_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(holdEvent.name, CONTEXTMENU_NAMESPACE),
	    CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
	var ContextMenu = Class.inherit({
	    setup: function(element) {
	        var $element = $(element);
	        $element.on(CONTEXTMENU_NAMESPACED_EVENT_NAME, $.proxy(this._contextMenuHandler, this));
	        if (support.touch || devices.isSimulator()) {
	            $element.on(HOLD_NAMESPACED_EVENT_NAME, $.proxy(this._holdHandler, this))
	        }
	    },
	    _holdHandler: function(e) {
	        if (eventUtils.isMouseEvent(e) && !devices.isSimulator()) {
	            return
	        }
	        this._fireContextMenu(e)
	    },
	    _contextMenuHandler: function(e) {
	        this._fireContextMenu(e)
	    },
	    _fireContextMenu: function(e) {
	        return eventUtils.fireEvent({
	            type: CONTEXTMENU_EVENT_NAME,
	            originalEvent: e
	        })
	    },
	    teardown: function(element) {
	        $(element).off("." + CONTEXTMENU_NAMESPACE)
	    }
	});
	registerEvent(CONTEXTMENU_EVENT_NAME, new ContextMenu);
	exports.name = CONTEXTMENU_EVENT_NAME;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/widget/bindable_template.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    TemplateBase = __webpack_require__(86),
	    removeEvent = __webpack_require__(32),
	    commonUtils = __webpack_require__(8);
	var watchChanges = function() {
	    var start = function(rawData, watchMethod, fields, fieldsMap, callback) {
	        var globalDispose, fieldsDispose;
	        globalDispose = globalWatch(rawData, watchMethod, function(dataWithRawFields) {
	            fieldsDispose && fieldsDispose();
	            if (commonUtils.isPrimitive(dataWithRawFields)) {
	                callback(dataWithRawFields);
	                return
	            }
	            fieldsDispose = fieldsWatch(dataWithRawFields, watchMethod, fields, fieldsMap, function(data) {
	                callback(data)
	            })
	        });
	        return function() {
	            fieldsDispose && fieldsDispose();
	            globalDispose && globalDispose()
	        }
	    };
	    var globalWatch = function(data, watchMethod, callback) {
	        return watchMethod(function() {
	            return data
	        }, callback)
	    };
	    var fieldsWatch = function(data, watchMethod, fields, fieldsMap, callback) {
	        var resolvedData = {},
	            missedFields = fields.slice();
	        var watchHandlers = $.map(fields, function(name) {
	            var fieldGetter = fieldsMap[name];
	            return watchMethod(fieldGetter ? function() {
	                return fieldGetter(data)
	            } : function() {
	                return data[name]
	            }, function(value) {
	                resolvedData[name] = value;
	                if (missedFields.length) {
	                    var index = missedFields.indexOf(name);
	                    if (index >= 0) {
	                        missedFields.splice(index, 1)
	                    }
	                }
	                if (!missedFields.length) {
	                    callback(resolvedData)
	                }
	            })
	        });
	        return function() {
	            $.each(watchHandlers, function(_, dispose) {
	                dispose()
	            })
	        }
	    };
	    return start
	}();
	module.exports = TemplateBase.inherit({
	    ctor: function(render, fields, watchMethod, fieldsMap) {
	        this._render = render;
	        this._fields = fields;
	        this._fieldsMap = fieldsMap || {};
	        this._watchMethod = watchMethod
	    },
	    _renderCore: function(options) {
	        var $container = options.container;
	        var dispose = watchChanges(options.model, this._watchMethod, this._fields, this._fieldsMap, function(data) {
	            $container.empty();
	            this._render($container, data, options.model)
	        }.bind(this));
	        $container.on(removeEvent, dispose);
	        return $container.contents()
	    }
	});


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/collection/ui.collection_widget.edit.strategy.plain.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    EditStrategy = __webpack_require__(136);
	var PlainEditStrategy = EditStrategy.inherit({
	    _getPlainItems: function() {
	        return this._collectionWidget.option("items") || []
	    },
	    getIndexByItemData: function(itemData) {
	        return $.inArray(itemData, this._getPlainItems())
	    },
	    getItemDataByIndex: function(index) {
	        return this._getPlainItems()[index]
	    },
	    deleteItemAtIndex: function(index) {
	        this._getPlainItems().splice(index, 1)
	    },
	    itemsGetter: function() {
	        return this._getPlainItems()
	    },
	    getKeysByItems: function(items) {
	        var keyOf = this._collectionWidget.keyGetter.bind(this._collectionWidget);
	        var result = items;
	        if (keyOf) {
	            result = [];
	            for (var i = 0; i < items.length; i++) {
	                result.push(keyOf(items[i]))
	            }
	        }
	        return result
	    },
	    getIndexByKey: function(key) {
	        var keys = this.getKeysByItems(this._getPlainItems());
	        for (var i = 0, length = keys.length; i < length; i++) {
	            if (this._equalKeys(key, keys[i])) {
	                return i
	            }
	        }
	        return -1
	    },
	    getItemsByKeys: function(keys, items) {
	        return items || keys
	    },
	    moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
	        var items = this._getPlainItems(),
	            movedItemData = items[movingIndex];
	        items.splice(movingIndex, 1);
	        items.splice(destinationIndex, 0, movedItemData)
	    },
	    _isItemIndex: function(index) {
	        return "number" === typeof index && Math.round(index) === index
	    },
	    _getNormalizedItemIndex: function(itemElement) {
	        return this._collectionWidget._itemElements().index(itemElement)
	    },
	    _normalizeItemIndex: function(index) {
	        return index
	    },
	    _denormalizeItemIndex: function(index) {
	        return index
	    },
	    _getItemByNormalizedIndex: function(index) {
	        return index > -1 ? this._collectionWidget._itemElements().eq(index) : null
	    },
	    _itemsFromSameParent: function() {
	        return true
	    }
	});
	module.exports = PlainEditStrategy;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/collection/ui.collection_widget.edit.strategy.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    abstract = Class.abstract;
	var EditStrategy = Class.inherit({
	    ctor: function(collectionWidget) {
	        this._collectionWidget = collectionWidget
	    },
	    getIndexByItemData: abstract,
	    getItemDataByIndex: abstract,
	    getKeysByItems: abstract,
	    getItemsByKeys: abstract,
	    itemsGetter: abstract,
	    getKeyByIndex: function(index) {
	        var resultIndex = this._denormalizeItemIndex(index);
	        return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0]
	    },
	    _equalKeys: function(key1, key2) {
	        if (this._collectionWidget._isKeySpecified()) {
	            return commonUtils.equalByValue(key1, key2)
	        } else {
	            return key1 === key2
	        }
	    },
	    getIndexByKey: abstract,
	    getNormalizedIndex: function(value) {
	        if (this._isNormalizedItemIndex(value)) {
	            return value
	        }
	        if (this._isItemIndex(value)) {
	            return this._normalizeItemIndex(value)
	        }
	        if (this._isDOMNode(value)) {
	            return this._getNormalizedItemIndex(value)
	        }
	        return this._normalizeItemIndex(this.getIndexByItemData(value))
	    },
	    getIndex: function(value) {
	        if (this._isNormalizedItemIndex(value)) {
	            return this._denormalizeItemIndex(value)
	        }
	        if (this._isItemIndex(value)) {
	            return value
	        }
	        if (this._isDOMNode(value)) {
	            return this._denormalizeItemIndex(this._getNormalizedItemIndex(value))
	        }
	        return this.getIndexByItemData(value)
	    },
	    getItemElement: function(value) {
	        if (this._isNormalizedItemIndex(value)) {
	            return this._getItemByNormalizedIndex(value)
	        }
	        if (this._isItemIndex(value)) {
	            return this._getItemByNormalizedIndex(this._normalizeItemIndex(value))
	        }
	        if (this._isDOMNode(value)) {
	            return $(value)
	        }
	        return this._getItemByNormalizedIndex(this.getIndexByItemData(value))
	    },
	    deleteItemAtIndex: abstract,
	    itemPlacementFunc: function(movingIndex, destinationIndex) {
	        return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before"
	    },
	    moveItemAtIndexToIndex: abstract,
	    _isNormalizedItemIndex: function(index) {
	        return "number" === typeof index && Math.round(index) === index
	    },
	    _isDOMNode: function(value) {
	        var $value;
	        try {
	            $value = $(value)
	        } catch (error) {
	            return false
	        }
	        return $value && $value.length && $value.get(0).nodeType
	    },
	    _isItemIndex: abstract,
	    _getNormalizedItemIndex: abstract,
	    _normalizeItemIndex: abstract,
	    _denormalizeItemIndex: abstract,
	    _getItemByNormalizedIndex: abstract,
	    _itemsFromSameParent: abstract
	});
	module.exports = EditStrategy;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/selection/selection.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    deferredStrategy = __webpack_require__(138),
	    standardStrategy = __webpack_require__(140),
	    commonUtils = __webpack_require__(8);
	module.exports = Class.inherit({
	    ctor: function(options) {
	        options = options || {};
	        this._selectionStrategy = options.deferred ? new deferredStrategy(this) : new standardStrategy(this);
	        this._selectionMode = options.mode;
	        this._filter = options.filter;
	        this._getItemData = options.getItemData;
	        this._isItemSelected = options.isItemSelected;
	        this._totalCount = options.totalCount;
	        this._key = options.key;
	        this._keyOf = options.keyOf;
	        this._isSelectableItem = options.isSelectableItem;
	        this._load = options.load;
	        this._dataFields = options.dataFields;
	        this._plainItems = options.plainItems;
	        this._focusedItemIndex = -1;
	        this._selectedItemKeys = options.selectedKeys || [];
	        this._selectionFilter = void 0 === options.selectionFilter ? [] : options.selectionFilter;
	        this._selectedItems = [];
	        this._selectionChangeHandler = options.onSelectionChanged || $.noop;
	        this._maxFilterLengthInRequest = options.maxFilterLengthInRequest || 0;
	        this._equalByReference = options.equalByReference;
	        if (!this._equalByReference) {
	            this._selectionStrategy.updateSelectedItemKeyHash(this._selectedItemKeys)
	        }
	    },
	    validate: function() {
	        this._selectionStrategy.validate()
	    },
	    getSelectedItemKeys: function() {
	        return this._selectionStrategy.getSelectedItemKeys()
	    },
	    getSelectedItems: function() {
	        return this._selectionStrategy.getSelectedItems()
	    },
	    selectionFilter: function(value) {
	        if (void 0 === value) {
	            return this._selectionFilter
	        }
	        var filterIsChanged = this._selectionFilter !== value && JSON.stringify(this._selectionFilter) !== JSON.stringify(value);
	        this._selectionFilter = value;
	        filterIsChanged && this.onSelectionChanged()
	    },
	    setSelection: function(keys) {
	        return this.selectedItemKeys(keys)
	    },
	    select: function(keys) {
	        return this.selectedItemKeys(keys, true)
	    },
	    deselect: function(keys) {
	        return this.selectedItemKeys(keys, true, true)
	    },
	    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
	        var that = this;
	        keys = keys || [];
	        keys = $.isArray(keys) ? keys : [keys];
	        that.validate();
	        return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll)
	    },
	    clearSelection: function() {
	        return this.selectedItemKeys([])
	    },
	    _addSelectedItem: function(itemData, key) {
	        this._selectionStrategy.addSelectedItem(key, itemData)
	    },
	    _removeSelectedItem: function(key) {
	        this._selectionStrategy.removeSelectedItem(key)
	    },
	    _setSelectedItems: function(keys, items) {
	        this._selectionStrategy.setSelectedItems(keys, items)
	    },
	    onSelectionChanged: function() {
	        this._selectionStrategy.onSelectionChanged()
	    },
	    changeItemSelection: function(itemIndex, keys) {
	        var isSelectedItemsChanged, items = this._plainItems(),
	            item = items[itemIndex];
	        if (!this.isSelectable() || !this.isDataItem(item)) {
	            return false
	        }
	        var itemData = this._getItemData(item),
	            itemKey = this._keyOf(itemData);
	        keys = keys || {};
	        if (keys.shift && "multiple" === this._selectionMode && this._focusedItemIndex >= 0) {
	            isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items)
	        } else {
	            if (keys.control) {
	                this._resetItemSelectionWhenShiftKeyPressed();
	                var isSelected = this._selectionStrategy.isItemDataSelected(itemData);
	                if ("single" === this._selectionMode) {
	                    this.clearSelectedItems()
	                }
	                if (isSelected) {
	                    this._removeSelectedItem(itemKey)
	                } else {
	                    this._addSelectedItem(itemData, itemKey)
	                }
	                isSelectedItemsChanged = true
	            } else {
	                this._resetItemSelectionWhenShiftKeyPressed();
	                var isKeysEqual = this._selectionStrategy.equalKeys(this._selectedItemKeys[0], itemKey);
	                if (1 !== this._selectedItemKeys.length || !isKeysEqual) {
	                    this._setSelectedItems([itemKey], [itemData]);
	                    isSelectedItemsChanged = true
	                }
	            }
	        }
	        if (isSelectedItemsChanged) {
	            this._focusedItemIndex = itemIndex;
	            this.onSelectionChanged();
	            return true
	        }
	    },
	    isDataItem: function(item) {
	        return this._isSelectableItem(item)
	    },
	    isSelectable: function() {
	        return "single" === this._selectionMode || "multiple" === this._selectionMode
	    },
	    isItemSelected: function(arg) {
	        return this._selectionStrategy.isItemKeySelected(arg)
	    },
	    _resetItemSelectionWhenShiftKeyPressed: function() {
	        delete this._shiftFocusedItemIndex
	    },
	    changeItemSelectionWhenShiftKeyPressed: function(itemIndex, items) {
	        var itemIndexStep, index, isSelectedItemsChanged = false,
	            keyOf = this._keyOf,
	            key = keyOf(items[this._focusedItemIndex].data),
	            isFocusedItemSelected = items[this._focusedItemIndex] && this.isItemSelected(key);
	        if (!commonUtils.isDefined(this._shiftFocusedItemIndex)) {
	            this._shiftFocusedItemIndex = this._focusedItemIndex
	        }
	        var data, itemKey;
	        if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
	            itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
	            for (index = this._focusedItemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
	                if (this.isDataItem(items[index])) {
	                    itemKey = keyOf(this._getItemData(items[index]));
	                    this._removeSelectedItem(itemKey);
	                    isSelectedItemsChanged = true
	                }
	            }
	        }
	        if (itemIndex !== this._shiftFocusedItemIndex) {
	            itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
	            for (index = itemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
	                if (this.isDataItem(items[index])) {
	                    data = this._getItemData(items[index]);
	                    itemKey = keyOf(data);
	                    this._addSelectedItem(data, itemKey);
	                    isSelectedItemsChanged = true
	                }
	            }
	        }
	        if (this.isDataItem(items[this._focusedItemIndex]) && !isFocusedItemSelected) {
	            data = this._getItemData(items[index]);
	            itemKey = keyOf(data);
	            this._addSelectedItem(data, itemKey);
	            isSelectedItemsChanged = true
	        }
	        return isSelectedItemsChanged
	    },
	    clearSelectedItems: function() {
	        this._setSelectedItems([], [])
	    },
	    selectAll: function(isOnePage) {
	        if (isOnePage) {
	            return this._onePageSelectAll(false)
	        } else {
	            return this.selectedItemKeys([], true, false, true)
	        }
	    },
	    deselectAll: function(isOnePage) {
	        if (isOnePage) {
	            return this._onePageSelectAll(true)
	        } else {
	            return this.selectedItemKeys([], true, true, true)
	        }
	    },
	    _onePageSelectAll: function(isDeselect) {
	        var items = this._plainItems();
	        for (var i = 0; i < items.length; i++) {
	            var item = items[i],
	                itemData = this._getItemData(item),
	                itemKey = this._keyOf(itemData),
	                isSelected = this.isItemSelected(itemKey);
	            if (!isSelected && !isDeselect) {
	                this._addSelectedItem(itemData, itemKey)
	            }
	            if (isSelected && isDeselect) {
	                this._removeSelectedItem(itemKey)
	            }
	        }
	        this.onSelectionChanged();
	        return $.Deferred().resolve()
	    },
	    getSelectAllState: function(visibleOnly) {
	        return this._selectionStrategy.getSelectAllState(visibleOnly)
	    }
	});


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/selection/selection.strategy.deferred.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    SelectionStrategy = __webpack_require__(139),
	    errors = __webpack_require__(15),
	    dataQuery = __webpack_require__(125);
	module.exports = SelectionStrategy.inherit({
	    getSelectedItems: function() {
	        return this._loadFilteredData(this._getSelectionOption("_selectionFilter"))
	    },
	    getSelectedItemKeys: function() {
	        var d = $.Deferred(),
	            that = this,
	            key = this._getSelectionOption("_key")(),
	            select = commonUtils.isString(key) ? [key] : key;
	        this._loadFilteredData(this._getSelectionOption("_selectionFilter"), null, select).done(function(items) {
	            var keys = items.map(function(item) {
	                return that._getSelectionOption("_keyOf")(item)
	            });
	            d.resolve(keys)
	        }).fail(d.reject);
	        return d.promise()
	    },
	    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
	        if (isSelectAll) {
	            var filter = this._getSelectionOption("_filter")();
	            if (!filter) {
	                this._setSelectionOption("_selectionFilter", isDeselect ? [] : null)
	            } else {
	                this._addSelectionFilter(isDeselect, filter, false)
	            }
	        } else {
	            if (!preserve) {
	                this._setSelectionOption("_selectionFilter", [])
	            }
	            for (var i = 0; i < keys.length; i++) {
	                if (isDeselect) {
	                    this.removeSelectedItem(keys[i])
	                } else {
	                    this.addSelectedItem(keys[i])
	                }
	            }
	        }
	        this.onSelectionChanged();
	        return $.Deferred().resolve()
	    },
	    setSelectedItems: function(keys) {
	        this._setSelectionOption("_selectionFilter", null);
	        for (var i = 0; i < keys.length; i++) {
	            this.addSelectedItem(keys[i])
	        }
	    },
	    isItemDataSelected: function(itemData) {
	        return this.isItemKeySelected(itemData)
	    },
	    isItemKeySelected: function(itemData) {
	        var selectionFilter = this._getSelectionOption("_selectionFilter");
	        if (!selectionFilter) {
	            return true
	        }
	        return !!dataQuery([itemData]).filter(selectionFilter).toArray().length
	    },
	    _processSelectedItem: function(key) {
	        var keyField = this._getSelectionOption("_key")(),
	            filter = [keyField, "=", key];
	        if ($.isArray(keyField)) {
	            filter = [];
	            for (var i = 0; i < keyField.length; i++) {
	                filter.push([keyField[i], "=", key[keyField[i]]]);
	                if (i !== keyField.length - 1) {
	                    filter.push("and")
	                }
	            }
	        }
	        return filter
	    },
	    addSelectedItem: function(key) {
	        var filter = this._processSelectedItem(key);
	        this._addSelectionFilter(false, filter, true)
	    },
	    removeSelectedItem: function(key) {
	        var filter = this._processSelectedItem(key);
	        this._addSelectionFilter(true, filter, true)
	    },
	    validate: function() {
	        var key = this._getSelectionOption("_key");
	        if (key && void 0 === key()) {
	            throw errors.Error("E1042")
	        }
	    },
	    _hasSameFilter: function(selectionFilter, currentFilter) {
	        return this._findSubFilter(selectionFilter, currentFilter) >= 0
	    },
	    _findSubFilter: function(selectionFilter, filter) {
	        if (!selectionFilter) {
	            return -1
	        }
	        var filterString = JSON.stringify(filter);
	        for (var index = 0; index < selectionFilter.length; index++) {
	            var subFilter = selectionFilter[index];
	            if (subFilter && JSON.stringify(subFilter) === filterString) {
	                return index
	            }
	        }
	        return -1
	    },
	    _isLastSubFilter: function(selectionFilter, filter) {
	        if (selectionFilter && filter) {
	            return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1
	        }
	        return false
	    },
	    _addFilterOperator: function(selectionFilter, filterOperator) {
	        if (selectionFilter.length > 1 && commonUtils.isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
	            selectionFilter = [selectionFilter]
	        }
	        if (selectionFilter.length) {
	            selectionFilter.push(filterOperator)
	        }
	        return selectionFilter
	    },
	    _denormalizeFilter: function(filter) {
	        if (filter && commonUtils.isString(filter[0])) {
	            filter = [filter]
	        }
	        return filter
	    },
	    _addSelectionFilter: function(isDeselect, filter, isUnique) {
	        var that = this,
	            needAddFilter = true,
	            currentFilter = isDeselect ? ["!", filter] : filter,
	            selectionFilter = that._getSelectionOption("_selectionFilter") || [];
	        selectionFilter = that._denormalizeFilter(selectionFilter);
	        if (selectionFilter && selectionFilter.length) {
	            if (that._hasSameFilter(selectionFilter, currentFilter)) {
	                return
	            }
	            if (that._removeInvertedFilter(selectionFilter, isDeselect, filter)) {
	                needAddFilter = !isUnique
	            }
	            if (needAddFilter) {
	                selectionFilter = that._addFilterOperator(selectionFilter, isDeselect ? "and" : "or")
	            }
	        }
	        if (needAddFilter) {
	            selectionFilter.push(currentFilter)
	        }
	        selectionFilter = that._normalizeFilter(selectionFilter);
	        that._setSelectionOption("_selectionFilter", selectionFilter)
	    },
	    _normalizeFilter: function(filter) {
	        if (filter && 1 === filter.length) {
	            filter = filter[0]
	        }
	        return filter
	    },
	    _removeInvertedFilter: function(selectionFilter, isDeselect, filter) {
	        filter = isDeselect ? filter : ["!", filter];
	        var filterIndex = this._findSubFilter(selectionFilter, filter);
	        if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
	            selectionFilter.splice(0, selectionFilter.length);
	            return true
	        }
	        if (filterIndex >= 0) {
	            if (filterIndex > 0) {
	                selectionFilter.splice(filterIndex - 1, 2)
	            } else {
	                selectionFilter.splice(filterIndex, 2)
	            }
	            return true
	        }
	        return false
	    },
	    getSelectAllState: function() {
	        var filter = this._getSelectionOption("_filter")(),
	            selectionFilter = this._getSelectionOption("_selectionFilter");
	        if (!selectionFilter) {
	            return true
	        }
	        if (!selectionFilter.length) {
	            return false
	        }
	        if (!filter || !filter.length) {
	            return
	        }
	        selectionFilter = this._denormalizeFilter(selectionFilter);
	        if (this._isLastSubFilter(selectionFilter, filter)) {
	            return true
	        }
	        if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
	            return false
	        }
	        return
	    }
	});


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/selection/selection.strategy.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    dataQuery = __webpack_require__(125),
	    commonUtils = __webpack_require__(8),
	    getKeyHash = commonUtils.getKeyHash,
	    Class = __webpack_require__(18);
	module.exports = Class.inherit({
	    ctor: function(Selection) {
	        this._selection = Selection;
	        this._clearItemKeys()
	    },
	    _clearItemKeys: function() {
	        this._setSelectionOption("_addedItemKeys", []);
	        this._setSelectionOption("_removedItemKeys", []);
	        this._setSelectionOption("_removedItems", []);
	        this._setSelectionOption("_addedItems", [])
	    },
	    validate: $.noop,
	    _getSelectionOption: function(name) {
	        return this._selection[name]
	    },
	    _setSelectionOption: function(name, value) {
	        this._selection[name] = value
	    },
	    onSelectionChanged: function() {
	        var addedItemKeys = this._getSelectionOption("_addedItemKeys"),
	            removedItemKeys = this._getSelectionOption("_removedItemKeys"),
	            addedItems = this._getSelectionOption("_addedItems"),
	            removedItems = this._getSelectionOption("_removedItems"),
	            selectedItems = this._getSelectionOption("_selectedItems"),
	            selectedItemKeys = this._getSelectionOption("_selectedItemKeys");
	        this._clearItemKeys();
	        this._getSelectionOption("_selectionChangeHandler")({
	            selectedItems: selectedItems,
	            selectedItemKeys: selectedItemKeys,
	            addedItemKeys: addedItemKeys,
	            removedItemKeys: removedItemKeys,
	            addedItems: addedItems,
	            removedItems: removedItems
	        })
	    },
	    equalKeys: function(key1, key2) {
	        if (this._getSelectionOption("_equalByReference")) {
	            if (commonUtils.isObject(key1) && commonUtils.isObject(key2)) {
	                return key1 === key2
	            }
	        }
	        return commonUtils.equalByValue(key1, key2)
	    },
	    _clearSelection: function(keys, preserve, isDeselect, isSelectAll) {
	        keys = keys || [];
	        keys = $.isArray(keys) ? keys : [keys];
	        this.validate();
	        return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll)
	    },
	    _loadFilteredData: function(filterExpr, filterFunction, select) {
	        var filterLength = encodeURI(JSON.stringify(filterExpr)).length,
	            needLoadAllData = this._getSelectionOption("_maxFilterLengthInRequest") && filterLength > this._getSelectionOption("_maxFilterLengthInRequest"),
	            deferred = $.Deferred(),
	            loadOptions = {
	                filter: needLoadAllData ? void 0 : filterExpr,
	                select: needLoadAllData ? this._getSelectionOption("_dataFields")() : select || this._getSelectionOption("_dataFields")()
	            };
	        if (filterExpr && 0 === filterExpr.length) {
	            deferred.resolve([])
	        } else {
	            this._getSelectionOption("_load")(loadOptions).done(function(items) {
	                var filteredItems = items;
	                if (needLoadAllData) {
	                    filteredItems = dataQuery(filteredItems).filter(filterExpr).toArray()
	                }
	                if (filterFunction) {
	                    filteredItems = dataQuery(filteredItems).filter(filterFunction).toArray()
	                }
	                deferred.resolve(filteredItems)
	            }).fail($.proxy(deferred.reject, deferred))
	        }
	        return deferred
	    },
	    updateSelectedItemKeyHash: function(keys) {
	        for (var i = 0; i < keys.length; i++) {
	            var keyHash = getKeyHash(keys[i]);
	            if (!commonUtils.isObject(keyHash)) {
	                this._getSelectionOption("_keyHashIndices")[keyHash] = this._getSelectionOption("_keyHashIndices")[keyHash] || [];
	                var keyIndices = this._getSelectionOption("_keyHashIndices")[keyHash];
	                keyIndices.push(i)
	            }
	        }
	    },
	    _isAnyItemSelected: function(items) {
	        for (var i = 0; i < items.length; i++) {
	            if (this._getSelectionOption("_isItemSelected")(items[i])) {
	                return
	            }
	        }
	        return false
	    },
	    _getFullSelectAllState: function() {
	        var items = this._getSelectionOption("_plainItems")(),
	            dataFilter = this._getSelectionOption("_filter")(),
	            selectedItems = this._getSelectionOption("_selectedItems");
	        if (dataFilter) {
	            selectedItems = dataQuery(selectedItems).filter(dataFilter).toArray()
	        }
	        var selectedItemsLength = selectedItems.length;
	        if (!selectedItemsLength) {
	            return this._isAnyItemSelected(items)
	        }
	        if (selectedItemsLength >= this._getSelectionOption("_totalCount")()) {
	            return true
	        }
	        return
	    },
	    _getVisibleSelectAllState: function() {
	        var items = this._getSelectionOption("_plainItems")(),
	            hasSelectedItems = false,
	            hasUnselectedItems = false;
	        for (var i = 0; i < items.length; i++) {
	            var item = items[i],
	                itemData = this._getSelectionOption("_getItemData")(item),
	                key = this._getSelectionOption("_keyOf")(itemData);
	            if (this._getSelectionOption("_isSelectableItem")(item)) {
	                if (this.isItemKeySelected(key)) {
	                    hasSelectedItems = true
	                } else {
	                    hasUnselectedItems = true
	                }
	            }
	        }
	        if (hasSelectedItems) {
	            return !hasUnselectedItems ? true : void 0
	        } else {
	            return false
	        }
	    }
	});


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/selection/selection.strategy.standard.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    getKeyHash = commonUtils.getKeyHash,
	    dataQuery = __webpack_require__(125),
	    when = __webpack_require__(10).when,
	    errors = __webpack_require__(15),
	    SelectionStrategy = __webpack_require__(139);

	function SelectionFilterCreator(keyExpr, selectedItemKeys, isSelectAll, equalKeys) {
	    this.getFilter = function() {
	        return this._filter || this.getExpr() || this.getFunction()
	    };
	    this.getFunction = function() {
	        if (!isFunction()) {
	            return
	        }
	        return functionFilter
	    };
	    this.getExpr = function() {
	        if (isFunction()) {
	            return
	        }
	        var filterExpr;
	        for (var i = 0, length = selectedItemKeys.length; i < length; i++) {
	            filterExpr = filterExpr || [];
	            var filterExprPart, itemKeyValue = selectedItemKeys[i];
	            if (i > 0) {
	                filterExpr.push(isSelectAll ? "and" : "or")
	            }
	            if (commonUtils.isString(keyExpr)) {
	                filterExprPart = getFilterForPlainKey(itemKeyValue)
	            } else {
	                filterExprPart = getFilterForCompositeKey(itemKeyValue)
	            }
	            filterExpr.push(filterExprPart)
	        }
	        this._filter = filterExpr;
	        return filterExpr
	    };
	    this.getCombinedFilter = function(dataSourceFilter) {
	        var filterExpr = this.getExpr(),
	            combinedFilter = filterExpr;
	        if (isSelectAll && dataSourceFilter) {
	            if (filterExpr) {
	                combinedFilter = [];
	                combinedFilter.push(filterExpr);
	                combinedFilter.push(dataSourceFilter)
	            } else {
	                combinedFilter = dataSourceFilter
	            }
	        }
	        return combinedFilter
	    };
	    var isFunction = function() {
	        return !keyExpr
	    };
	    var functionFilter = function(item) {
	        for (var i = 0; i < selectedItemKeys.length; i++) {
	            if (equalKeys(selectedItemKeys[i], item)) {
	                return !isSelectAll
	            }
	        }
	        return isSelectAll
	    };
	    var getFilterForPlainKey = function(keyValue, key) {
	        return [key || keyExpr, isSelectAll ? "<>" : "=", keyValue]
	    };
	    var getFilterForCompositeKey = function(itemKeyValue) {
	        var filterExpr = [];
	        for (var i = 0, length = keyExpr.length; i < length; i++) {
	            if (i > 0) {
	                filterExpr.push(isSelectAll ? "or" : "and")
	            }
	            var currentKeyExpr = keyExpr[i],
	                currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr],
	                filterExprPart = getFilterForPlainKey(currentKeyValue, currentKeyExpr);
	            filterExpr.push(filterExprPart)
	        }
	        return filterExpr
	    }
	}
	module.exports = SelectionStrategy.inherit({
	    ctor: function(Selection) {
	        this.callBase(Selection);
	        this._initSelectedItemKeyHash()
	    },
	    _initSelectedItemKeyHash: function() {
	        this._setSelectionOption("_keyHashIndices", this._getSelectionOption("_equalByReference") ? null : {})
	    },
	    getSelectedItemKeys: function() {
	        return this._getSelectionOption("_selectedItemKeys").slice(0)
	    },
	    getSelectedItems: function() {
	        return this._getSelectionOption("_selectedItems").slice(0)
	    },
	    _preserveSelectionUpdate: function(items, isDeselect) {
	        var keyOf = this._getSelectionOption("_keyOf");
	        if (!keyOf) {
	            return
	        }
	        for (var i = 0; i < items.length; i++) {
	            var item = items[i],
	                key = keyOf(item);
	            if (isDeselect) {
	                this.removeSelectedItem(key)
	            } else {
	                this.addSelectedItem(key, item)
	            }
	        }
	    },
	    _loadSelectedItemsCore: function(keys, isDeselect, isSelectAll) {
	        var deferred = $.Deferred(),
	            key = this._getSelectionOption("_key");
	        if (!keys.length && !isSelectAll) {
	            deferred.resolve([]);
	            return deferred
	        }
	        if (isSelectAll && isDeselect && !this._getSelectionOption("_filter")) {
	            return this._clearSelection()
	        }
	        var selectionFilterCreator = new SelectionFilterCreator(key(), keys, isSelectAll, this.equalKeys.bind(this)),
	            combinedFilter = selectionFilterCreator.getCombinedFilter(this._getSelectionOption("_filter")());
	        var deselectedItems = [];
	        if (isDeselect) {
	            deselectedItems = combinedFilter ? dataQuery(this._getSelectionOption("_selectedItems")).filter(combinedFilter).toArray() : this._getSelectionOption("_selectedItems").slice(0)
	        }
	        var filteredItems = deselectedItems.length ? deselectedItems : this._getSelectionOption("_plainItems")().filter(this._getSelectionOption("_isSelectableItem")).map(this._getSelectionOption("_getItemData"));
	        var filter = selectionFilterCreator.getFilter();
	        if (filter) {
	            filteredItems = dataQuery(filteredItems).filter(filter).toArray()
	        }
	        if (!isSelectAll && (deselectedItems.length || filteredItems.length === keys.length)) {
	            deferred.resolve(filteredItems)
	        } else {
	            deferred = this._loadFilteredData(combinedFilter, selectionFilterCreator.getFunction())
	        }
	        return deferred
	    },
	    _replaceSelectionUpdate: function(items) {
	        var internalKeys = [],
	            keyOf = this._getSelectionOption("_keyOf");
	        if (!keyOf) {
	            return
	        }
	        for (var i = 0; i < items.length; i++) {
	            var item = items[i],
	                key = keyOf(item);
	            internalKeys.push(key)
	        }
	        this.setSelectedItems(internalKeys, items)
	    },
	    _warnOnIncorrectKeys: function(keys) {
	        for (var i = 0; i < keys.length; i++) {
	            if (!this.isItemKeySelected(keys[i])) {
	                errors.log("W1002", keys[i])
	            }
	        }
	    },
	    _loadSelectedItems: function(keys, isDeselect, isSelectAll) {
	        var that = this,
	            deferred = $.Deferred();
	        when(that._lastLoadDeferred).always(function() {
	            that._loadSelectedItemsCore(keys, isDeselect, isSelectAll).done(deferred.resolve).fail(deferred.reject)
	        });
	        that._lastLoadDeferred = deferred;
	        return deferred
	    },
	    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
	        var that = this,
	            deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll);
	        deferred.done(function(items) {
	            if (preserve) {
	                that._preserveSelectionUpdate(items, isDeselect)
	            } else {
	                that._replaceSelectionUpdate(items)
	            }
	            if (!isSelectAll && !isDeselect) {
	                that._warnOnIncorrectKeys(keys)
	            }
	            that.onSelectionChanged()
	        });
	        return deferred
	    },
	    addSelectedItem: function(key, itemData) {
	        var keyHash = this._getKeyHash(key);
	        if (this._indexOfSelectedItemKey(keyHash) === -1) {
	            if (!commonUtils.isObject(keyHash) && this._getSelectionOption("_keyHashIndices")) {
	                this._getSelectionOption("_keyHashIndices")[keyHash] = [this._getSelectionOption("_selectedItemKeys").length]
	            }
	            this._getSelectionOption("_selectedItemKeys").push(key);
	            this._getSelectionOption("_addedItemKeys").push(key);
	            this._getSelectionOption("_addedItems").push(itemData);
	            this._getSelectionOption("_selectedItems").push(itemData)
	        }
	    },
	    _getSelectedIndexByKey: function(key) {
	        var selectedItemKeys = this._getSelectionOption("_selectedItemKeys");
	        for (var index = 0; index < selectedItemKeys.length; index++) {
	            if (this.equalKeys(selectedItemKeys[index], key)) {
	                return index
	            }
	        }
	        return -1
	    },
	    _getSelectedIndexByHash: function(key) {
	        var indices = this._getSelectionOption("_keyHashIndices")[key];
	        return indices && indices[0] >= 0 ? indices[0] : -1
	    },
	    _indexOfSelectedItemKey: function(key) {
	        var selectedIndex;
	        if (this._getSelectionOption("_equalByReference")) {
	            selectedIndex = this._getSelectionOption("_selectedItemKeys").indexOf(key)
	        } else {
	            if (commonUtils.isObject(key)) {
	                selectedIndex = this._getSelectedIndexByKey(key)
	            } else {
	                selectedIndex = this._getSelectedIndexByHash(key)
	            }
	        }
	        return selectedIndex
	    },
	    _shiftSelectedKeyIndices: function(keyIndex) {
	        for (var currentKeyIndex = keyIndex; currentKeyIndex < this._getSelectionOption("_selectedItemKeys").length; currentKeyIndex++) {
	            var currentKey = this._getSelectionOption("_selectedItemKeys")[currentKeyIndex],
	                currentKeyHash = getKeyHash(currentKey),
	                currentKeyIndices = this._getSelectionOption("_keyHashIndices")[currentKeyHash];
	            if (!currentKeyIndices) {
	                continue
	            }
	            for (var i = 0; i < currentKeyIndices.length; i++) {
	                if (currentKeyIndices[i] > keyIndex) {
	                    currentKeyIndices[i]--
	                }
	            }
	        }
	    },
	    removeSelectedItem: function(key) {
	        var keyHash = this._getKeyHash(key),
	            keyIndex = this._indexOfSelectedItemKey(keyHash);
	        if (keyIndex < 0) {
	            return
	        }
	        this._getSelectionOption("_selectedItemKeys").splice(keyIndex, 1);
	        this._getSelectionOption("_removedItemKeys").push(key);
	        this._getSelectionOption("_removedItems").push(this._getSelectionOption("_selectedItems")[keyIndex]);
	        this._getSelectionOption("_selectedItems").splice(keyIndex, 1);
	        if (commonUtils.isObject(keyHash) || !this._getSelectionOption("_keyHashIndices")) {
	            return
	        }
	        var keyIndices = this._getSelectionOption("_keyHashIndices")[keyHash];
	        if (!keyIndices) {
	            return
	        }
	        keyIndices.shift();
	        if (!keyIndices.length) {
	            delete this._getSelectionOption("_keyHashIndices")[keyHash]
	        }
	        this._shiftSelectedKeyIndices(keyIndex)
	    },
	    _needRemoveItemKey: function(keys, key) {
	        var hashIndices = this._getSelectionOption("_keyHashIndices");
	        if (!hashIndices) {
	            return keys.indexOf(key) < 0
	        }
	        var hash = this._getKeyHash(key);
	        for (var i = 0; i < keys.length; i++) {
	            var keyHash = this._getKeyHash(keys[i]);
	            if (this.equalKeys(hash, keyHash)) {
	                return false
	            }
	        }
	        return true
	    },
	    _updateAddedItemKeys: function(keys, items) {
	        for (var i = 0; i < keys.length; i++) {
	            if (this._indexOfSelectedItemKey(keys[i]) < 0) {
	                this._getSelectionOption("_addedItemKeys").push(keys[i]);
	                this._getSelectionOption("_addedItems").push(items[i])
	            }
	        }
	    },
	    _updateRemovedItemKeys: function(keys) {
	        var oldSelectedKeys = this._getSelectionOption("_selectedItemKeys"),
	            oldSelectedItems = this._getSelectionOption("_selectedItems");
	        for (var i = 0; i < oldSelectedKeys.length; i++) {
	            if (this._needRemoveItemKey(keys, oldSelectedKeys[i])) {
	                this._getSelectionOption("_removedItemKeys").push(oldSelectedKeys[i]);
	                this._getSelectionOption("_removedItems").push(oldSelectedItems[i])
	            }
	        }
	    },
	    _getKeyHash: function(key) {
	        return this._getSelectionOption("_equalByReference") ? key : getKeyHash(key)
	    },
	    setSelectedItems: function(keys, items) {
	        this._updateRemovedItemKeys(keys, items);
	        this._updateAddedItemKeys(keys, items);
	        if (!this._getSelectionOption("_equalByReference")) {
	            this._initSelectedItemKeyHash();
	            this.updateSelectedItemKeyHash(keys)
	        }
	        this._setSelectionOption("_selectedItemKeys", keys);
	        this._setSelectionOption("_selectedItems", items)
	    },
	    isItemDataSelected: function(itemData) {
	        var key = this._getSelectionOption("_keyOf")(itemData);
	        return this.isItemKeySelected(key)
	    },
	    isItemKeySelected: function(key) {
	        var keyHash = this._getKeyHash(key);
	        var index = this._indexOfSelectedItemKey(keyHash);
	        return index !== -1
	    },
	    getSelectAllState: function(visibleOnly) {
	        if (visibleOnly) {
	            return this._getVisibleSelectAllState()
	        } else {
	            return this._getFullSelectAllState()
	        }
	    }
	});


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(142);
	module.exports.default = module.exports;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var DataGrid = __webpack_require__(143);
	module.exports = DataGrid;
	__webpack_require__(211);
	__webpack_require__(213);
	__webpack_require__(214);
	__webpack_require__(217);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(268);
	__webpack_require__(272);
	__webpack_require__(274);
	__webpack_require__(278);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    logger = __webpack_require__(6).logger,
	    browser = __webpack_require__(16),
	    Widget = __webpack_require__(84),
	    gridCore = __webpack_require__(144),
	    callModuleItemsMethod = gridCore.callModuleItemsMethod;
	var DATAGRID_ROW_SELECTOR = ".dx-row",
	    DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the name of a jQuery selector is now deprecated. Instead, use the jQuery object that references this selector.";
	__webpack_require__(146);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(154);
	__webpack_require__(156);
	__webpack_require__(163);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(173);
	gridCore.registerModulesOrder(["stateStoring", "columns", "selection", "editorFactory", "columnChooser", "editing", "grouping", "masterDetail", "validating", "adaptivity", "data", "virtualScrolling", "columnHeaders", "filterRow", "headerPanel", "headerFilter", "sorting", "search", "rows", "pager", "columnsResizingReordering", "contextMenu", "keyboardNavigation", "errorHandling", "summary", "fixedColumns", "export", "gridView"]);
	var DataGrid = Widget.inherit({
	    _activeStateUnit: DATAGRID_ROW_SELECTOR,
	    _getDefaultOptions: function() {
	        var that = this,
	            result = that.callBase();
	        $.each(gridCore.modules, function() {
	            if ($.isFunction(this.defaultOptions)) {
	                $.extend(true, result, this.defaultOptions())
	            }
	        });
	        return result
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            "editing.editMode": {
	                since: "15.2",
	                alias: "editing.mode"
	            },
	            "editing.editEnabled": {
	                since: "15.2",
	                alias: "editing.allowUpdating"
	            },
	            "editing.insertEnabled": {
	                since: "15.2",
	                alias: "editing.allowAdding"
	            },
	            "editing.removeEnabled": {
	                since: "15.2",
	                alias: "editing.allowDeleting"
	            },
	            "grouping.groupContinuedMessage": {
	                since: "16.1",
	                alias: "grouping.texts.groupContinuedMessage"
	            },
	            "grouping.groupContinuesMessage": {
	                since: "16.1",
	                alias: "grouping.texts.groupContinuesMessage"
	            },
	            "export.texts.excelFormat": {
	                since: "16.1",
	                alias: "export.texts.exportAll"
	            },
	            "export.texts.exportToExcel": {
	                since: "16.1",
	                alias: "export.texts.exportAll"
	            },
	            "export.texts.selectedRows": {
	                since: "16.1",
	                alias: "export.texts.exportSelectedRows"
	            },
	            "filterRow.operationDescriptions.>": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.greaterThan"
	            },
	            "filterRow.operationDescriptions.<": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.lessThan"
	            },
	            "filterRow.operationDescriptions.=": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.equal"
	            },
	            "filterRow.operationDescriptions.<>": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.notEqual"
	            },
	            "filterRow.operationDescriptions.<=": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.lessThanOrEqual"
	            },
	            "filterRow.operationDescriptions.>=": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.greaterThanOrEqual"
	            },
	            "filterRow.operationDescriptions.startswith": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.startsWith"
	            },
	            "filterRow.operationDescriptions.notcontains": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.notContains"
	            },
	            "filterRow.operationDescriptions.endswith": {
	                since: "16.2",
	                alias: "filterRow.operationDescriptions.endsWith"
	            }
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: {
	                platform: "ios"
	            },
	            options: {
	                showRowLines: true
	            }
	        }, {
	            device: function() {
	                return browser.webkit
	            },
	            options: {
	                loadingTimeout: 30,
	                loadPanel: {
	                    animation: {
	                        show: {
	                            easing: "cubic-bezier(1, 0, 1, 0)",
	                            duration: 500,
	                            from: {
	                                opacity: 0
	                            },
	                            to: {
	                                opacity: 1
	                            }
	                        }
	                    }
	                }
	            }
	        }, {
	            device: function(device) {
	                return "desktop" !== device.deviceType
	            },
	            options: {
	                grouping: {
	                    expandMode: "rowClick"
	                }
	            }
	        }])
	    },
	    _init: function() {
	        var that = this;
	        that.callBase();
	        gridCore.processModules(that, gridCore);
	        callModuleItemsMethod(that, "init")
	    },
	    _clean: $.noop,
	    _optionChanged: function(args) {
	        var that = this;
	        callModuleItemsMethod(that, "optionChanged", [args]);
	        if (!args.handled) {
	            that.callBase(args)
	        }
	    },
	    _dimensionChanged: function() {
	        this.updateDimensions(true)
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this.updateDimensions()
	        }
	    },
	    _renderContentImpl: function() {
	        this.getView("gridView").render(this.element())
	    },
	    _renderContent: function() {
	        var that = this;
	        commonUtils.deferRender(function() {
	            that._renderContentImpl()
	        })
	    },
	    _getTemplate: function(templateName) {
	        var template = templateName;
	        if (commonUtils.isString(template) && "#" === template[0]) {
	            template = $(templateName);
	            logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING)
	        }
	        return this.callBase(template)
	    },
	    _dispose: function() {
	        var that = this;
	        that.callBase();
	        callModuleItemsMethod(that, "dispose")
	    },
	    isReady: function() {
	        return this.getController("data").isReady()
	    },
	    beginUpdate: function() {
	        var that = this;
	        that.callBase();
	        callModuleItemsMethod(that, "beginUpdate")
	    },
	    endUpdate: function() {
	        var that = this;
	        callModuleItemsMethod(that, "endUpdate");
	        that.callBase()
	    },
	    getController: function(name) {
	        return this._controllers[name]
	    },
	    getView: function(name) {
	        return this._views[name]
	    },
	    focus: function(element) {
	        this.callBase();
	        if (commonUtils.isDefined(element)) {
	            this.getController("keyboardNavigation").focus(element)
	        }
	    }
	});
	DataGrid.registerModule = gridCore.registerModule.bind(gridCore);
	registerComponent("dxDataGrid", DataGrid);
	module.exports = DataGrid;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.core.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    toComparable = __webpack_require__(35).toComparable,
	    stringUtils = __webpack_require__(7),
	    modules = __webpack_require__(145),
	    dataUtils = __webpack_require__(122),
	    formatHelper = __webpack_require__(54);
	var DATE_INTERVAL_SELECTORS = {
	        year: function(value) {
	            return value && value.getFullYear()
	        },
	        month: function(value) {
	            return value && value.getMonth() + 1
	        },
	        day: function(value) {
	            return value && value.getDate()
	        },
	        quarter: function(value) {
	            return value && Math.floor(value.getMonth() / 3) + 1
	        },
	        hour: function(value) {
	            return value && value.getHours()
	        },
	        minute: function(value) {
	            return value && value.getMinutes()
	        },
	        second: function(value) {
	            return value && value.getSeconds()
	        }
	    },
	    DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
	$.extend(exports, modules, function() {
	    var getIntervalSelector = function() {
	        var groupInterval, nameIntervalSelector, data = arguments[1],
	            value = this.calculateCellValue(data);
	        if (!commonUtils.isDefined(value)) {
	            return null
	        } else {
	            if ("date" === this.dataType) {
	                nameIntervalSelector = arguments[0];
	                return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value)
	            } else {
	                if ("number" === this.dataType) {
	                    groupInterval = arguments[0];
	                    return Math.floor(Number(value) / groupInterval) * groupInterval
	                }
	            }
	        }
	    };
	    var getDateValues = function(dateValue) {
	        if (commonUtils.isDate(dateValue)) {
	            return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()]
	        }
	        return $.map(("" + dateValue).split("/"), function(value, index) {
	            return 1 === index ? Number(value) - 1 : Number(value)
	        })
	    };
	    var getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
	        var dateStart, dateEnd, column = this,
	            selector = getFilterSelector(column, target),
	            values = getDateValues(filterValue),
	            dateInterval = exports.getGroupInterval(column)[values.length - 1];
	        switch (dateInterval) {
	            case "year":
	                dateStart = new Date(values[0], 0, 1);
	                dateEnd = new Date(values[0] + 1, 0, 1);
	                break;
	            case "month":
	                dateStart = new Date(values[0], values[1], 1);
	                dateEnd = new Date(values[0], values[1] + 1, 1);
	                break;
	            case "quarter":
	                dateStart = new Date(values[0], 3 * values[1], 1);
	                dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
	                break;
	            case "hour":
	                dateStart = new Date(values[0], values[1], values[2], values[3]);
	                dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
	                break;
	            case "minute":
	                dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
	                dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
	                break;
	            case "second":
	                dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
	                dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
	                break;
	            default:
	                dateStart = new Date(values[0], values[1], values[2]);
	                dateEnd = new Date(values[0], values[1], values[2] + 1)
	        }
	        switch (selectedFilterOperation) {
	            case "<":
	                return [selector, "<", dateStart];
	            case "<=":
	                return [selector, "<", dateEnd];
	            case ">":
	                return [selector, ">=", dateEnd];
	            case ">=":
	                return [selector, ">=", dateStart];
	            case "<>":
	                return [
	                    [selector, "<", dateStart], "or", [selector, ">=", dateEnd]
	                ];
	            default:
	                return [
	                    [selector, ">=", dateStart], "and", [selector, "<", dateEnd]
	                ]
	        }
	    };
	    var getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
	        var interval, startFilterValue, endFilterValue, column = this,
	            selector = getFilterSelector(column, target),
	            values = ("" + filterValue).split("/"),
	            value = Number(values[values.length - 1]),
	            isExclude = "exclude" === column.filterType,
	            groupInterval = exports.getGroupInterval(column);
	        if ("headerFilter" === target && groupInterval && commonUtils.isDefined(filterValue)) {
	            interval = groupInterval[values.length - 1];
	            startFilterValue = [selector, isExclude ? "<" : ">=", value];
	            endFilterValue = [selector, isExclude ? ">=" : "<", value + interval];
	            return [startFilterValue, isExclude ? "or" : "and", endFilterValue]
	        }
	        return [selector, selectedFilterOperation || "=", filterValue]
	    };
	    var getFilterSelector = function(column, target) {
	        var selector = column.dataField || column.selector;
	        if ("search" === target) {
	            selector = column.displayField || column.calculateDisplayValue || selector
	        }
	        return selector
	    };
	    var getFilterExpressionByRange = function(filterValue) {
	        var column = this,
	            dataField = column.dataField;
	        if (commonUtils.isArray(filterValue) && commonUtils.isDefined(filterValue[0]) && commonUtils.isDefined(filterValue[1])) {
	            return [
	                [dataField, ">=", filterValue[0]], "and", [dataField, "<=", filterValue[1]]
	            ]
	        }
	    };
	    var equalSelectors = function(selector1, selector2) {
	        if (commonUtils.isFunction(selector1) && commonUtils.isFunction(selector2)) {
	            if (selector1.originalCallback && selector2.originalCallback) {
	                return selector1.originalCallback === selector2.originalCallback
	            }
	        }
	        return selector1 === selector2
	    };
	    return {
	        formatValue: function(value, options) {
	            var valueText = formatHelper.format(value, options.format, options.precision) || value && value.toString() || "",
	                formatObject = {
	                    value: value,
	                    valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
	                    target: options.target || "row",
	                    groupInterval: options.groupInterval
	                };
	            return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
	        },
	        getFormatOptionsByColumn: function(column, target) {
	            return {
	                format: column.format,
	                precision: column.precision,
	                getDisplayFormat: column.getDisplayFormat,
	                customizeText: column.customizeText,
	                target: target
	            }
	        },
	        getDisplayValue: function(column, value, data, rowType) {
	            if (column.displayValueMap && void 0 !== column.displayValueMap[value]) {
	                return column.displayValueMap[value]
	            } else {
	                if (column.calculateDisplayValue && data && "group" !== rowType) {
	                    return column.calculateDisplayValue(data)
	                } else {
	                    if (column.lookup && !("group" === rowType && column.calculateGroupValue)) {
	                        return column.lookup.calculateCellValue(value)
	                    }
	                }
	            }
	            return value
	        },
	        getGroupRowSummaryText: function(summaryItems, summaryTexts) {
	            var i, summaryItem, result = "(";
	            for (i = 0; i < summaryItems.length; i++) {
	                summaryItem = summaryItems[i];
	                result += (i > 0 ? ", " : "") + exports.getSummaryText(summaryItem, summaryTexts)
	            }
	            return result += ")"
	        },
	        getSummaryText: function(summaryItem, summaryTexts) {
	            var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
	            return this.formatValue(summaryItem.value, {
	                format: summaryItem.valueFormat,
	                precision: summaryItem.precision,
	                getDisplayFormat: function(valueText) {
	                    return displayFormat ? stringUtils.format(displayFormat, valueText, summaryItem.columnCaption) : valueText
	                },
	                customizeText: summaryItem.customizeText
	            })
	        },
	        normalizeSortingInfo: function(sort) {
	            sort = sort || [];
	            var result, i;
	            result = dataUtils.normalizeSortingInfo(sort);
	            for (i = 0; i < sort.length; i++) {
	                if (sort && sort[i] && void 0 !== sort[i].isExpanded) {
	                    result[i].isExpanded = sort[i].isExpanded
	                }
	                if (sort && sort[i] && void 0 !== sort[i].groupInterval) {
	                    result[i].groupInterval = sort[i].groupInterval
	                }
	            }
	            return result
	        },
	        getFormatByDataType: function(dataType) {
	            switch (dataType) {
	                case "date":
	                    return "shortDate"
	            }
	        },
	        defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
	            var column = this,
	                selector = getFilterSelector(column, target),
	                isSearchByDisplayValue = column.calculateDisplayValue && "search" === target,
	                dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType,
	                filter = null;
	            if ("headerFilter" === target && null === filterValue) {
	                filter = [selector, selectedFilterOperation || "=", null];
	                if ("string" === dataType) {
	                    filter = [filter, "=" === selectedFilterOperation ? "or" : "and", [selector, selectedFilterOperation || "=", ""]]
	                }
	            } else {
	                if ("string" === dataType && (!column.lookup || isSearchByDisplayValue)) {
	                    filter = [selector, selectedFilterOperation || "contains", filterValue]
	                } else {
	                    if ("between" === selectedFilterOperation) {
	                        return getFilterExpressionByRange.apply(column, arguments)
	                    } else {
	                        if ("date" === dataType && commonUtils.isDefined(filterValue)) {
	                            return getFilterExpressionForDate.apply(column, arguments)
	                        } else {
	                            if ("number" === dataType) {
	                                return getFilterExpressionForNumber.apply(column, arguments)
	                            } else {
	                                if ("object" !== dataType) {
	                                    filter = [selector, selectedFilterOperation || "=", filterValue]
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return filter
	        },
	        getHeaderFilterGroupParameters: function(column, remoteGrouping) {
	            var result = [],
	                dataField = column.dataField || column.name,
	                groupInterval = this.getGroupInterval(column);
	            if (column.calculateGroupValue) {
	                return remoteGrouping ? [{
	                    selector: column.calculateGroupValue,
	                    isExpanded: false
	                }] : $.proxy(column.calculateGroupValue, column)
	            }
	            if (groupInterval) {
	                $.each(groupInterval, function(index, interval) {
	                    result.push(remoteGrouping ? {
	                        selector: dataField,
	                        groupInterval: interval,
	                        isExpanded: false
	                    } : $.proxy(getIntervalSelector, column, interval))
	                });
	                return result
	            }
	            return remoteGrouping ? [{
	                selector: dataField,
	                isExpanded: false
	            }] : function(data) {
	                var result = column.calculateCellValue(data);
	                if (void 0 === result || "" === result) {
	                    result = null
	                }
	                return result
	            }
	        },
	        getGroupInterval: function(column) {
	            var index, result = [],
	                dateIntervals = ["year", "month", "day", "hour", "minute", "second"],
	                groupInterval = column.headerFilter && column.headerFilter.groupInterval,
	                interval = "quarter" === groupInterval ? "month" : groupInterval;
	            if ("date" === column.dataType) {
	                result = DEFAULT_DATE_INTERVAL;
	                index = $.inArray(interval, dateIntervals);
	                if (index >= 0) {
	                    result = dateIntervals.slice(0, index);
	                    result.push(groupInterval);
	                    return result
	                }
	                return result
	            } else {
	                if (commonUtils.isDefined(groupInterval)) {
	                    return commonUtils.isArray(groupInterval) ? groupInterval : [groupInterval]
	                }
	            }
	        },
	        checkChanges: function(changes, changeNames) {
	            var i, changesWithChangeNamesCount = 0;
	            for (i = 0; i < changeNames.length; i++) {
	                if (changes[changeNames[i]]) {
	                    changesWithChangeNamesCount++
	                }
	            }
	            return changes.length && changes.length === changesWithChangeNamesCount
	        },
	        equalSortParameters: function(sortParameters1, sortParameters2, ignoreIsExpanded) {
	            var i;
	            sortParameters1 = exports.normalizeSortingInfo(sortParameters1);
	            sortParameters2 = exports.normalizeSortingInfo(sortParameters2);
	            if ($.isArray(sortParameters1) && $.isArray(sortParameters2)) {
	                if (sortParameters1.length !== sortParameters2.length) {
	                    return false
	                } else {
	                    for (i = 0; i < sortParameters1.length; i++) {
	                        if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
	                            return false
	                        }
	                    }
	                }
	                return true
	            } else {
	                return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length)
	            }
	        },
	        equalFilterParameters: function(filter1, filter2) {
	            var i;
	            if ($.isArray(filter1) && $.isArray(filter2)) {
	                if (filter1.length !== filter2.length) {
	                    return false
	                } else {
	                    for (i = 0; i < filter1.length; i++) {
	                        if (!exports.equalFilterParameters(filter1[i], filter2[i])) {
	                            return false
	                        }
	                    }
	                }
	                return true
	            } else {
	                if ($.isFunction(filter1) && filter1.columnIndex >= 0 && $.isFunction(filter2) && filter2.columnIndex >= 0) {
	                    return filter1.columnIndex === filter2.columnIndex
	                } else {
	                    return toComparable(filter1) == toComparable(filter2)
	                }
	            }
	        },
	        proxyMethod: function(instance, methodName, defaultResult) {
	            if (!instance[methodName]) {
	                instance[methodName] = function() {
	                    var dataSource = this._dataSource;
	                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
	                }
	            }
	        },
	        combineFilters: function(filters, operation) {
	            var i, resultFilter = [];
	            operation = operation || "and";
	            for (i = 0; i < filters.length; i++) {
	                if (!filters[i]) {
	                    continue
	                }
	                if (resultFilter.length) {
	                    resultFilter.push(operation)
	                }
	                resultFilter.push(filters[i])
	            }
	            if (1 === resultFilter.length) {
	                resultFilter = resultFilter[0]
	            }
	            if (resultFilter.length) {
	                return resultFilter
	            }
	        },
	        getPointsByColumns: function(items, pointCreated, isVertical, startColumnIndex) {
	            var point, i, item, offset, prevItemOffset, rtlEnabled, cellsLength = items.length,
	                notCreatePoint = false,
	                columnIndex = startColumnIndex || 0,
	                result = [];
	            for (i = 0; i <= cellsLength; i++) {
	                if (i < cellsLength) {
	                    item = items.eq(i);
	                    offset = item.offset();
	                    rtlEnabled = "rtl" === item.css("direction")
	                }
	                point = {
	                    index: columnIndex,
	                    x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? item.outerWidth() : 0) : 0,
	                    y: offset ? offset.top + (isVertical && i === cellsLength ? item.outerHeight() : 0) : 0,
	                    columnIndex: columnIndex
	                };
	                if (!isVertical && i > 0) {
	                    prevItemOffset = items.eq(i - 1).offset();
	                    if (prevItemOffset.top < point.y) {
	                        point.y = prevItemOffset.top
	                    }
	                }
	                if (pointCreated) {
	                    notCreatePoint = pointCreated(point)
	                }
	                if (!notCreatePoint) {
	                    result.push(point)
	                }
	                columnIndex++
	            }
	            return result
	        }
	    }
	}());


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/grid_core/ui.grid_core.modules.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    errors = __webpack_require__(15),
	    messageLocalization = __webpack_require__(79);
	var CallBacks = function(options) {
	    options = options || {};
	    var firing, firingIndex, list = [],
	        fireCore = function(context, args) {
	            firing = true;
	            for (firingIndex = 0; firingIndex < list.length; firingIndex++) {
	                if (list[firingIndex] && false === list[firingIndex].apply(context, args) && options.stopOnFalse) {
	                    break
	                }
	            }
	            firing = false
	        },
	        that = {
	            add: function(fn) {
	                if ("function" === typeof fn && !that.has(fn)) {
	                    list.push(fn)
	                }
	                return this
	            },
	            has: function(fn) {
	                return fn ? $.inArray(fn, list) > -1 : !!list.length
	            },
	            remove: function(fn) {
	                var index = $.inArray(fn, list);
	                if (index > -1) {
	                    list.splice(index, 1);
	                    if (firing && index <= firingIndex) {
	                        firingIndex--
	                    }
	                }
	                return this
	            },
	            fireWith: function(context, args) {
	                args = args || [];
	                fireCore(context, args.slice ? args.slice() : args)
	            },
	            fire: function() {
	                that.fireWith(this, arguments);
	                return this
	            },
	            empty: function() {
	                list = [];
	                return this
	            }
	        };
	    return that
	};
	var ModuleItem = Class.inherit({
	    _endUpdateCore: function() {},
	    ctor: function(component) {
	        var that = this;
	        that._updateLockCount = 0;
	        that.component = component;
	        that._actions = {};
	        that._actionConfigs = {};
	        $.each(this.callbackNames() || [], function(index, name) {
	            var flags = that.callbackFlags(name);
	            that[this] = CallBacks(flags)
	        })
	    },
	    init: function() {},
	    callbackNames: function() {},
	    callbackFlags: function() {},
	    publicMethods: function() {},
	    beginUpdate: function() {
	        this._updateLockCount++
	    },
	    endUpdate: function() {
	        if (this._updateLockCount > 0) {
	            this._updateLockCount--;
	            if (!this._updateLockCount) {
	                this._endUpdateCore()
	            }
	        }
	    },
	    option: function(name) {
	        var component = this.component,
	            optionCache = component._optionCache;
	        if (1 === arguments.length && optionCache) {
	            if (!(name in optionCache)) {
	                optionCache[name] = component.option(name)
	            }
	            return optionCache[name]
	        }
	        return component.option.apply(component, arguments)
	    },
	    localize: function(name) {
	        var optionCache = this.component._optionCache;
	        if (optionCache) {
	            if (!(name in optionCache)) {
	                optionCache[name] = messageLocalization.format(name)
	            }
	            return optionCache[name]
	        }
	        return messageLocalization.format(name)
	    },
	    on: function() {
	        return this.component.on.apply(this.component, arguments)
	    },
	    off: function() {
	        return this.component.off.apply(this.component, arguments)
	    },
	    optionChanged: function(args) {
	        if (args.name in this._actions) {
	            this.createAction(args.name, this._actionConfigs[args.name]);
	            args.handled = true
	        }
	    },
	    getAction: function(actionName) {
	        return this._actions[actionName]
	    },
	    setAria: function(name, value, $target) {
	        var target = $target.get(0),
	            prefix = "role" !== name && "id" !== name ? "aria-" : "";
	        if (target.setAttribute) {
	            target.setAttribute(prefix + name, value)
	        } else {
	            $target.attr(prefix + name, value)
	        }
	    },
	    _createComponent: function() {
	        return this.component._createComponent.apply(this.component, arguments)
	    },
	    getController: function(name) {
	        return this.component._controllers[name]
	    },
	    createAction: function(actionName, config) {
	        var action;
	        if (commonUtils.isFunction(actionName)) {
	            action = this.component._createAction($.proxy(actionName, this), config);
	            return function(e) {
	                action({
	                    jQueryEvent: e
	                })
	            }
	        } else {
	            this._actions[actionName] = this.component._createActionByOption(actionName, config);
	            this._actionConfigs[actionName] = config
	        }
	    },
	    executeAction: function(actionName, options) {
	        var action = this._actions[actionName];
	        return action && action(options)
	    },
	    dispose: function() {
	        var that = this;
	        $.each(that.callbackNames() || [], function() {
	            that[this].empty()
	        })
	    }
	});
	var Controller = ModuleItem;
	var ViewController = Controller.inherit({
	    getView: function(name) {
	        return this.component._views[name]
	    },
	    getViews: function() {
	        return this.component._views
	    }
	});
	var View = ModuleItem.inherit({
	    _isReady: function() {
	        return this.component.isReady()
	    },
	    _endUpdateCore: function() {
	        this.callBase();
	        if (!this._isReady() && this._requireReady) {
	            this._requireRender = false;
	            this.component._requireResize = false
	        }
	        if (this._requireRender) {
	            this._requireRender = false;
	            this.render(this._$parent)
	        }
	    },
	    _invalidate: function(requireResize, requireReady) {
	        this._requireRender = true;
	        this.component._requireResize = this.component._requireResize || requireResize;
	        this._requireReady = this._requireReady || requireReady
	    },
	    _renderCore: function() {},
	    _resizeCore: function() {},
	    _afterRender: function() {},
	    _parentElement: function() {
	        return this._$parent
	    },
	    ctor: function(component) {
	        this.callBase(component);
	        this.renderCompleted = $.Callbacks();
	        this.resizeCompleted = $.Callbacks()
	    },
	    element: function() {
	        return this._$element
	    },
	    isVisible: function() {
	        return true
	    },
	    getTemplate: function(name) {
	        return this.component._getTemplate(name)
	    },
	    render: function($parent, options) {
	        var $element = this._$element,
	            isVisible = this.isVisible();
	        this._requireReady = false;
	        if (!$element) {
	            $element = this._$element = $("<div />").appendTo($parent);
	            this._$parent = $parent
	        }
	        $element.toggleClass("dx-hidden", !isVisible);
	        if (isVisible) {
	            this.component._optionCache = {};
	            this._renderCore(options);
	            this.component._optionCache = void 0;
	            this._afterRender($parent);
	            this.renderCompleted.fire()
	        }
	    },
	    resize: function() {
	        this.isResizing = true;
	        this._resizeCore();
	        this.resizeCompleted.fire();
	        this.isResizing = false
	    },
	    focus: function() {
	        this.element().focus()
	    }
	});
	var MODULES_ORDER_MAX_INDEX = 1e6;
	var processModules = function(that, componentClass) {
	    var modules = componentClass.modules,
	        modulesOrder = componentClass.modulesOrder,
	        controllerTypes = componentClass.controllerTypes || {},
	        viewTypes = componentClass.viewTypes || {};
	    if (!componentClass.controllerTypes) {
	        if (modulesOrder) {
	            modules.sort(function(module1, module2) {
	                var orderIndex1 = $.inArray(module1.name, modulesOrder);
	                var orderIndex2 = $.inArray(module2.name, modulesOrder);
	                if (orderIndex1 < 0) {
	                    orderIndex1 = MODULES_ORDER_MAX_INDEX
	                }
	                if (orderIndex2 < 0) {
	                    orderIndex2 = MODULES_ORDER_MAX_INDEX
	                }
	                return orderIndex1 - orderIndex2
	            })
	        }
	        $.each(modules, function() {
	            var controllers = this.controllers,
	                moduleName = this.name,
	                views = this.views;
	            controllers && $.each(controllers, function(name, type) {
	                if (controllerTypes[name]) {
	                    throw errors.Error("E1001", moduleName, name)
	                } else {
	                    if (!(type && type.subclassOf && type.subclassOf(Controller))) {
	                        type.subclassOf(Controller);
	                        throw errors.Error("E1002", moduleName, name)
	                    }
	                }
	                controllerTypes[name] = type
	            });
	            views && $.each(views, function(name, type) {
	                if (viewTypes[name]) {
	                    throw errors.Error("E1003", moduleName, name)
	                } else {
	                    if (!(type && type.subclassOf && type.subclassOf(View))) {
	                        throw errors.Error("E1004", moduleName, name)
	                    }
	                }
	                viewTypes[name] = type
	            })
	        });
	        $.each(modules, function() {
	            var extenders = this.extenders;
	            if (extenders) {
	                extenders.controllers && $.each(extenders.controllers, function(name, extender) {
	                    if (controllerTypes[name]) {
	                        controllerTypes[name] = controllerTypes[name].inherit(extender)
	                    }
	                });
	                extenders.views && $.each(extenders.views, function(name, extender) {
	                    if (viewTypes[name]) {
	                        viewTypes[name] = viewTypes[name].inherit(extender)
	                    }
	                })
	            }
	        });
	        componentClass.controllerTypes = controllerTypes;
	        componentClass.viewTypes = viewTypes
	    }
	    var registerPublicMethods = function(that, name, moduleItem) {
	        var publicMethods = moduleItem.publicMethods();
	        if (publicMethods) {
	            $.each(publicMethods, function(index, methodName) {
	                if (moduleItem[methodName]) {
	                    if (!that[methodName]) {
	                        that[methodName] = function() {
	                            return moduleItem[methodName].apply(moduleItem, arguments)
	                        }
	                    } else {
	                        throw errors.Error("E1005", methodName)
	                    }
	                } else {
	                    throw errors.Error("E1006", name, methodName)
	                }
	            })
	        }
	    };
	    var createModuleItems = function(moduleTypes) {
	        var moduleItems = {};
	        $.each(moduleTypes, function(name, moduleType) {
	            var moduleItem = new moduleType(that);
	            moduleItem.name = name;
	            registerPublicMethods(that, name, moduleItem);
	            moduleItems[name] = moduleItem
	        });
	        return moduleItems
	    };
	    that._controllers = createModuleItems(controllerTypes);
	    that._views = createModuleItems(viewTypes)
	};
	var callModuleItemsMethod = function(that, methodName, args) {
	    args = args || [];
	    if (that._controllers) {
	        $.each(that._controllers, function() {
	            this[methodName] && this[methodName].apply(this, args)
	        })
	    }
	    if (that._views) {
	        $.each(that._views, function() {
	            this[methodName] && this[methodName].apply(this, args)
	        })
	    }
	};
	$.extend(exports, function() {
	    return {
	        modules: [],
	        View: View,
	        ViewController: ViewController,
	        Controller: Controller,
	        registerModule: function(name, module) {
	            var i, modules = this.modules;
	            for (i = 0; i < modules.length; i++) {
	                if (modules[i].name === name) {
	                    return
	                }
	            }
	            module.name = name;
	            modules.push(module);
	            delete this.controllerTypes;
	            delete this.viewTypes
	        },
	        registerModulesOrder: function(moduleNames) {
	            this.modulesOrder = moduleNames
	        },
	        unregisterModule: function(name) {
	            this.modules = $.grep(this.modules, function(module) {
	                return module.name !== name
	            });
	            delete this.controllerTypes;
	            delete this.viewTypes
	        },
	        processModules: processModules,
	        callModuleItemsMethod: callModuleItemsMethod
	    }
	}());


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.column_headers_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    columnsView = __webpack_require__(147),
	    commonUtils = __webpack_require__(8),
	    messageLocalization = __webpack_require__(79);
	var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
	    DATAGRID_HEADERS_CLASS = "dx-datagrid-headers",
	    DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
	    DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
	    DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
	    DATAGRID_CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc",
	    DATAGRID_CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc",
	    DATAGRID_CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none",
	    DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
	    DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators";
	var createCellContent = function($cell) {
	    return $("<div />").addClass(DATAGRID_CELL_CONTENT_CLASS).appendTo($cell)
	};
	exports.ColumnHeadersView = columnsView.ColumnsView.inherit({
	    _createTable: function() {
	        var $table = this.callBase.apply(this, arguments);
	        $table.on("mousedown selectstart", this.createAction(function(e) {
	            var event = e.jQueryEvent;
	            if (event.shiftKey) {
	                event.preventDefault()
	            }
	        }));
	        return $table
	    },
	    _getDefaultTemplate: function(column) {
	        var template;
	        if (column.command) {
	            template = function($container, options) {
	                var column = options.column;
	                $container.html("&nbsp;");
	                $container.addClass(column.cssClass)
	            }
	        } else {
	            template = function($container) {
	                var $content = createCellContent($container);
	                $content.text(column.caption)
	            }
	        }
	        return template
	    },
	    _getHeaderTemplate: function(column) {
	        return !column.command && column.headerCellTemplate || {
	            allowRenderToDetachedContainer: true,
	            render: this._getDefaultTemplate(column)
	        }
	    },
	    _processTemplate: function(template, options) {
	        var resultTemplate, column = options.column,
	            renderingTemplate = this.callBase(template);
	        if (renderingTemplate && column.headerCellTemplate) {
	            resultTemplate = {
	                render: function(options) {
	                    var $content = createCellContent(options.container);
	                    renderingTemplate.render($.extend({}, options, {
	                        container: $content
	                    }))
	                }
	            }
	        } else {
	            resultTemplate = renderingTemplate
	        }
	        return resultTemplate
	    },
	    _handleDataChanged: function() {
	        if (this._isGroupingChanged || this._requireReady) {
	            this._isGroupingChanged = false;
	            this.render()
	        }
	    },
	    _renderCell: function($row, options) {
	        var $cell = this.callBase($row, options);
	        if ("header" === options.row.rowType) {
	            $cell.addClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS);
	            if (!commonUtils.isDefined(options.column.command)) {
	                this.setAria("role", "columnheader", $cell);
	                this.setAria("label", options.column.caption + " " + messageLocalization.format("dxDataGrid-ariaColumn"), $cell)
	            }
	        }
	        return $cell
	    },
	    _createRow: function(row) {
	        var $row = this.callBase(row).toggleClass(DATAGRID_COLUMN_LINES_CLASS, this.option("showColumnLines"));
	        if ("header" === row.rowType) {
	            $row.addClass(DATAGRID_HEADER_ROW_CLASS)
	        }
	        return $row
	    },
	    _renderCore: function() {
	        var that = this,
	            $container = that.element();
	        if (that._tableElement && !that._dataController.isLoaded() && !that._hasRowElements) {
	            return
	        }
	        $container.addClass(DATAGRID_HEADERS_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled")).empty();
	        that._updateContent(that._renderTable());
	        that.callBase.apply(that, arguments)
	    },
	    _renderRows: function() {
	        var that = this;
	        if (that._dataController.isLoaded() || that._hasRowElements) {
	            that.callBase.apply(that, arguments);
	            that._hasRowElements = true
	        }
	    },
	    _getRowVisibleColumns: function(rowIndex) {
	        return this._columnsController.getVisibleColumns(rowIndex)
	    },
	    _renderRow: function($table, options) {
	        options.columns = this._getRowVisibleColumns(options.row.rowIndex);
	        this.callBase($table, options)
	    },
	    _createCell: function(options) {
	        var column = options.column,
	            $cellElement = this.callBase.apply(this, arguments);
	        column.rowspan > 1 && $cellElement.attr("rowspan", column.rowspan);
	        return $cellElement
	    },
	    _getRows: function() {
	        var i, result = [],
	            rowCount = this.getRowCount();
	        if (this.option("showColumnHeaders")) {
	            for (i = 0; i < rowCount; i++) {
	                result.push({
	                    rowType: "header",
	                    rowIndex: i
	                })
	            }
	        }
	        return result
	    },
	    _getCellTemplate: function(options) {
	        if ("header" === options.rowType) {
	            return this._getHeaderTemplate(options.column)
	        }
	    },
	    _columnOptionChanged: function(e) {
	        var changeTypes = e.changeTypes,
	            optionNames = e.optionNames,
	            showColumnLines = this.option("showColumnLines");
	        if (changeTypes.grouping) {
	            this._isGroupingChanged = true;
	            return
	        }
	        this.callBase(e);
	        if (optionNames.width || optionNames.visibleWidth) {
	            !showColumnLines && this._updateColumnTextWidths();
	            this.resizeCompleted.fire()
	        }
	    },
	    _updateColumnTextWidths: function() {
	        var indicatorWidth, $indicatorContainer, that = this,
	            widths = [],
	            columns = that.getColumns(),
	            $cells = that.getColumnElements();
	        if (!$cells) {
	            return
	        }
	        $.each(columns, function(index, column) {
	            indicatorWidth = 0;
	            $indicatorContainer = that._getIndicatorContainer($($cells[index]));
	            if ($indicatorContainer.length) {
	                indicatorWidth = $indicatorContainer.outerWidth()
	            }
	            widths[index] = $($cells[index]).width() - ("center" === column.alignment ? 2 * indicatorWidth : indicatorWidth)
	        });
	        $.each($cells, function(index, cell) {
	            if (widths.length && widths[index] > 0) {
	                $(cell).find("." + DATAGRID_CELL_CONTENT_CLASS).css("max-width", widths[index])
	            }
	        })
	    },
	    _isElementVisible: function(elementOptions) {
	        return elementOptions && elementOptions.visible
	    },
	    getHeadersRowHeight: function() {
	        var $tableElement = this._getTableElement(),
	            $headerRows = $tableElement && $tableElement.find("." + DATAGRID_HEADER_ROW_CLASS);
	        if ($headerRows && $headerRows.length) {
	            return $headerRows.first().height() * $headerRows.length
	        }
	        return 0
	    },
	    getHeaderElement: function(index) {
	        var columnElements = this.getColumnElements();
	        return columnElements && columnElements.eq(index)
	    },
	    getColumnElements: function(index, bandColumnIndex) {
	        var rowIndex, result, $cellElement, visibleColumns, that = this,
	            columnsController = that._columnsController,
	            rowCount = that.getRowCount();
	        if (that.option("showColumnHeaders")) {
	            if (rowCount > 1 && (!commonUtils.isDefined(index) || commonUtils.isDefined(bandColumnIndex))) {
	                result = $();
	                visibleColumns = commonUtils.isDefined(bandColumnIndex) ? columnsController.getChildrenByBandColumn(bandColumnIndex, index) : columnsController.getVisibleColumns();
	                $.each(visibleColumns, function(_, column) {
	                    rowIndex = commonUtils.isDefined(index) ? index : columnsController.getRowIndex(column.index);
	                    $cellElement = that.getCellElement(rowIndex, columnsController.getVisibleIndex(column.index, rowIndex));
	                    $cellElement && result.push($cellElement.get(0))
	                });
	                return result
	            } else {
	                if (!index || index < rowCount) {
	                    return that.getCellElements(index || 0)
	                }
	            }
	        }
	    },
	    getColumnWidths: function() {
	        var indicatorWidth, $indicatorElements, that = this,
	            resultWidths = [],
	            columns = that.getColumns(),
	            $columnElements = that.getColumnElements();
	        if ($columnElements && $columnElements.length) {
	            resultWidths = that._getWidths($columnElements);
	            if (that.option("showColumnLines")) {
	                $.each($columnElements, function(index, columnElement) {
	                    $indicatorElements = $(columnElement).find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
	                    if ($indicatorElements.length) {
	                        $.each($indicatorElements.children(), function(_, indicator) {
	                            if ("none" !== $(indicator).css("display")) {
	                                indicatorWidth = $indicatorElements.outerWidth(true);
	                                resultWidths[index] += "center" === columns[index].alignment ? 2 * indicatorWidth : indicatorWidth;
	                                return false
	                            }
	                        })
	                    }
	                })
	            }
	            return resultWidths
	        }
	        return this.callBase.apply(that, arguments)
	    },
	    allowDragging: function(column, sourceLocation, draggingPanels) {
	        var i, draggingPanel, rowIndex = column && this._columnsController.getRowIndex(column.index),
	            columns = this.getColumns(0 === rowIndex ? 0 : null),
	            draggableColumnCount = 0,
	            allowDrag = function(column) {
	                return column.allowReordering || column.allowGrouping || column.allowHiding
	            };
	        for (i = 0; i < columns.length; i++) {
	            if (allowDrag(columns[i])) {
	                draggableColumnCount++
	            }
	        }
	        if (draggableColumnCount <= 1) {
	            return false
	        } else {
	            if (!draggingPanels) {
	                return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering
	            }
	        }
	        for (i = 0; i < draggingPanels.length; i++) {
	            draggingPanel = draggingPanels[i];
	            if (draggingPanel && draggingPanel.allowDragging(column, sourceLocation)) {
	                return true
	            }
	        }
	        return false
	    },
	    getBoundingRect: function() {
	        var offset, that = this,
	            $columnElements = that.getColumnElements();
	        if ($columnElements && $columnElements.length) {
	            offset = that._getTableElement().offset();
	            return {
	                top: offset.top
	            }
	        }
	        return null
	    },
	    getName: function() {
	        return "headers"
	    },
	    getColumnCount: function() {
	        var $columnElements = this.getColumnElements();
	        return $columnElements ? $columnElements.length : 0
	    },
	    isVisible: function() {
	        return this.option("showColumnHeaders")
	    },
	    optionChanged: function(args) {
	        var that = this;
	        switch (args.name) {
	            case "showColumnHeaders":
	            case "wordWrapEnabled":
	            case "showColumnLines":
	                that._invalidate(true, true);
	                args.handled = true;
	                break;
	            default:
	                that.callBase(args)
	        }
	    },
	    getHeight: function() {
	        var $element = this.element();
	        return $element ? $element.outerHeight(true) : 0
	    },
	    getContextMenuItems: function(options) {
	        var onItemClick, sortingOptions, that = this,
	            column = options.column;
	        if (options.row && "header" === options.row.rowType) {
	            sortingOptions = that.option("sorting");
	            if (sortingOptions && "none" !== sortingOptions.mode && column && column.allowSorting) {
	                onItemClick = function(params) {
	                    setTimeout(function() {
	                        that._columnsController.changeSortOrder(column.index, params.itemData.value)
	                    })
	                };
	                return [{
	                    text: sortingOptions.ascendingText,
	                    value: "asc",
	                    disabled: "asc" === column.sortOrder,
	                    icon: DATAGRID_CONTEXT_MENU_SORT_ASC_ICON,
	                    onItemClick: onItemClick
	                }, {
	                    text: sortingOptions.descendingText,
	                    value: "desc",
	                    disabled: "desc" === column.sortOrder,
	                    icon: DATAGRID_CONTEXT_MENU_SORT_DESC_ICON,
	                    onItemClick: onItemClick
	                }, {
	                    text: sortingOptions.clearText,
	                    value: "none",
	                    disabled: !column.sortOrder,
	                    icon: DATAGRID_CONTEXT_MENU_SORT_NONE_ICON,
	                    onItemClick: onItemClick
	                }]
	            }
	        }
	    },
	    getRowCount: function() {
	        return this._columnsController && this._columnsController.getRowCount()
	    },
	    setRowsOpacity: function(columnIndex, value, rowIndex) {
	        var i, columnElements, that = this,
	            rowCount = that.getRowCount(),
	            columns = that._columnsController.getColumns(),
	            column = columns && columns[columnIndex],
	            columnID = column && column.isBand && column.index,
	            setColumnOpacity = function(index, column) {
	                if (column.ownerBand === columnID) {
	                    columnElements.eq(index).css({
	                        opacity: value
	                    });
	                    if (column.isBand) {
	                        that.setRowsOpacity(column.index, value, i + 1)
	                    }
	                }
	            };
	        if (commonUtils.isDefined(columnID)) {
	            rowIndex = rowIndex || 0;
	            for (i = rowIndex; i < rowCount; i++) {
	                columnElements = that.getCellElements(i);
	                $.each(that.getColumns(i), setColumnOpacity)
	            }
	        }
	    }
	});
	gridCore.registerModule("columnHeaders", {
	    defaultOptions: function() {
	        return {
	            showColumnHeaders: true,
	            cellHintEnabled: true
	        }
	    },
	    views: {
	        columnHeadersView: exports.ColumnHeadersView
	    }
	});


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.columns_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    clickEvent = __webpack_require__(65),
	    browser = __webpack_require__(16),
	    commonUtils = __webpack_require__(8),
	    devices = __webpack_require__(40),
	    gridCore = __webpack_require__(144),
	    gridCoreUtils = __webpack_require__(148);
	var DATAGRID_SCROLL_CONTAINER_CLASS = "dx-datagrid-scroll-container",
	    DATAGRID_ROW_CLASS = "dx-row",
	    DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
	    DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
	    DATAGRID_DETAIL_ROW_CLASS = "dx-master-detail-row",
	    DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
	    DATAGRID_TABLE_CLASS = "dx-datagrid-table",
	    DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
	    DATAGRID_CONTENT_FIXED_CLASS = "dx-datagrid-content-fixed",
	    DATAGRID_HIDDEN_COLUMNS_WIDTH = "0.0001px",
	    DATAGRID_CELL_HINT_VISIBLE = "dxCellHintVisible";
	var appendElementTemplate = {
	    render: function(options) {
	        options.container.append(options.content)
	    }
	};
	exports.ColumnsView = gridCore.View.inherit(gridCoreUtils.columnStateMixin).inherit({
	    _createScrollableOptions: function() {
	        var that = this,
	            scrollingOptions = that.option("scrolling"),
	            useNativeScrolling = that.option("scrolling.useNative");
	        var options = $.extend({}, scrollingOptions, {
	            direction: "both",
	            bounceEnabled: false,
	            useKeyboard: false
	        });
	        if (void 0 === useNativeScrolling) {
	            useNativeScrolling = true
	        }
	        if ("auto" === useNativeScrolling) {
	            delete options.useNative;
	            delete options.useSimulatedScrollbar
	        } else {
	            options.useNative = !!useNativeScrolling;
	            options.useSimulatedScrollbar = !useNativeScrolling
	        }
	        return options
	    },
	    _updateCell: function($cell, parameters) {
	        if (parameters.rowType) {
	            this._cellPrepared($cell, parameters)
	        }
	    },
	    _createCell: function(options) {
	        var column = options.column,
	            alignment = column.alignment || commonUtils.getDefaultAlignment(this.option("rtlEnabled"));
	        var cell = window.document.createElement("td");
	        cell.style.textAlign = alignment;
	        var $cell = $(cell);
	        this.setAria("role", "gridcell", $cell);
	        if (!commonUtils.isDefined(column.groupIndex) && column.cssClass) {
	            $cell.addClass(column.cssClass)
	        }
	        if ("expand" === column.command) {
	            $cell.addClass(DATAGRID_GROUP_SPACE_CLASS)
	        }
	        column.colspan > 1 && $cell.attr("colspan", column.colspan);
	        return $cell
	    },
	    _createRow: function() {
	        return $("<tr />").addClass(DATAGRID_ROW_CLASS).attr("role", "row")
	    },
	    _createTable: function(columns) {
	        var that = this,
	            $table = $("<table />").addClass(DATAGRID_TABLE_CLASS).addClass(DATAGRID_TABLE_FIXED_CLASS).attr("role", "grid");
	        if (columns) {
	            $table.append(that._createColGroup(columns));
	            if (devices.real().ios) {
	                $table.append("<thead><tr></tr></thead>")
	            }
	        }
	        $table.append("<tbody />");
	        if (browser.mozilla) {
	            $table.on("mousedown", "td", function(e) {
	                if (e.ctrlKey) {
	                    e.preventDefault()
	                }
	            })
	        }
	        if (that.option("cellHintEnabled")) {
	            $table.on("mousemove", ".dx-row > td", this.createAction(function(args) {
	                var e = args.jQueryEvent,
	                    $element = $(e.target),
	                    $cell = $(e.currentTarget),
	                    $row = $cell.parent(),
	                    isDataRow = $row.hasClass("dx-data-row"),
	                    isHeaderRow = $row.hasClass("dx-header-row"),
	                    isGroupRow = $row.hasClass("dx-group-row"),
	                    visibleColumns = that._columnsController.getVisibleColumns(),
	                    rowOptions = $row.data("options"),
	                    columnIndex = $cell.index(),
	                    cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex],
	                    column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
	                if ((!isDataRow || isDataRow && column && !column.cellTemplate) && (!isHeaderRow || isHeaderRow && column && !column.headerCellTemplate) && (!isGroupRow || isGroupRow && column && (void 0 === column.groupIndex || !column.groupCellTemplate))) {
	                    if ($element.data(DATAGRID_CELL_HINT_VISIBLE)) {
	                        $element.removeAttr("title");
	                        $element.data(DATAGRID_CELL_HINT_VISIBLE, false)
	                    }
	                    if ($element[0].scrollWidth > $element[0].clientWidth && !commonUtils.isDefined($element.attr("title"))) {
	                        $element.attr("title", $element.text());
	                        $element.data(DATAGRID_CELL_HINT_VISIBLE, true)
	                    }
	                }
	            }))
	        }
	        var getOptions = function(event) {
	            var cellElement = $(event.currentTarget),
	                rowOptions = cellElement.parent().data("options"),
	                options = rowOptions && rowOptions.cells && rowOptions.cells[cellElement.index()];
	            return $.extend({}, options, {
	                cellElement: cellElement,
	                jQueryEvent: event,
	                eventType: event.type
	            })
	        };
	        $table.on("mouseover", ".dx-row > td", function(e) {
	            that.executeAction("onCellHoverChanged", getOptions(e))
	        });
	        $table.on("mouseout", ".dx-row > td", function(e) {
	            that.executeAction("onCellHoverChanged", getOptions(e))
	        });
	        $table.on(clickEvent.name, ".dx-row > td", function(e) {
	            that.executeAction("onCellClick", getOptions(e))
	        });
	        $table.on(clickEvent.name, ".dx-row", {
	            useNative: that._isNativeClick()
	        }, that.createAction(function(e) {
	            var jQueryEvent = e.jQueryEvent;
	            if (!$(jQueryEvent.target).closest("a").length) {
	                e.rowIndex = that.getRowIndex(jQueryEvent.currentTarget);
	                if (e.rowIndex >= 0) {
	                    e.rowElement = $(jQueryEvent.currentTarget);
	                    e.columns = that.getColumns();
	                    that._rowClick(e)
	                }
	            }
	        }));
	        return $table
	    },
	    _isNativeClick: $.noop,
	    _rowClick: $.noop,
	    _createColGroup: function(columns) {
	        var i, j, colspan, colgroupElement = $("<colgroup />");
	        for (i = 0; i < columns.length; i++) {
	            colspan = columns[i].colspan || 1;
	            for (j = 0; j < colspan; j++) {
	                colgroupElement.append(this._createCol(columns[i]))
	            }
	        }
	        return colgroupElement
	    },
	    _createCol: function(column) {
	        var width = column.visibleWidth || column.width;
	        if ("adaptiveHidden" === width) {
	            width = DATAGRID_HIDDEN_COLUMNS_WIDTH
	        }
	        return $("<col />").width(width)
	    },
	    renderDelayedTemplates: function() {
	        var templateParameters, delayedTemplates = this._delayedTemplates;
	        while (delayedTemplates.length) {
	            templateParameters = delayedTemplates.shift();
	            templateParameters.template.render(templateParameters.options);
	            if (templateParameters.options.model && templateParameters.options.model.column) {
	                this._updateCell(templateParameters.options.container, templateParameters.options.model)
	            }
	        }
	    },
	    _processTemplate: function(template) {
	        var templateID, renderingTemplate, that = this;
	        if (template && template.render) {
	            renderingTemplate = {
	                allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
	                render: function(options) {
	                    template.render(options.container, options.model)
	                }
	            }
	        } else {
	            if ($.isFunction(template)) {
	                renderingTemplate = {
	                    render: function(options) {
	                        template(options.container, options.model)
	                    }
	                }
	            } else {
	                templateID = commonUtils.isString(template) ? template : $(template).attr("id");
	                if (!templateID) {
	                    renderingTemplate = that.getTemplate(template)
	                } else {
	                    if (!that._templatesCache[templateID]) {
	                        that._templatesCache[templateID] = that.getTemplate(template)
	                    }
	                    renderingTemplate = that._templatesCache[templateID]
	                }
	            }
	        }
	        return renderingTemplate
	    },
	    renderTemplate: function(container, template, options, allowRenderToDetachedContainer) {
	        var that = this,
	            renderingTemplate = that._processTemplate(template, options);
	        if (renderingTemplate) {
	            options.component = that.component;
	            if (renderingTemplate.allowRenderToDetachedContainer || allowRenderToDetachedContainer) {
	                renderingTemplate.render({
	                    container: container,
	                    model: options
	                });
	                return true
	            } else {
	                that._delayedTemplates.push({
	                    template: renderingTemplate,
	                    options: {
	                        container: container,
	                        model: options
	                    }
	                })
	            }
	        }
	        return false
	    },
	    _appendRow: function($table, $row, appendTemplate) {
	        appendTemplate = appendTemplate || appendElementTemplate;
	        appendTemplate.render({
	            content: $row,
	            container: $table
	        })
	    },
	    _resizeCore: function() {
	        var that = this,
	            scrollLeft = that._scrollLeft;
	        that._scrollLeft = 0;
	        that.scrollTo({
	            left: scrollLeft
	        })
	    },
	    _renderCore: function() {
	        var $root = this.element().parent();
	        if (!$root || $root.parent().length) {
	            this.renderDelayedTemplates()
	        }
	    },
	    _renderTable: function(options) {
	        options = options || {};
	        var $table, that = this;
	        options.columns = that._columnsController.getVisibleColumns();
	        $table = that._createTable(options.columns);
	        that._renderRows($table, options);
	        return $table
	    },
	    _renderRows: function($table, options) {
	        var i, that = this,
	            rows = that._getRows(options.change);
	        for (i = 0; i < rows.length; i++) {
	            that._renderRow($table, $.extend({
	                row: rows[i]
	            }, options))
	        }
	    },
	    _renderRow: function($table, options) {
	        var $row, that = this;
	        options.row.cells = [];
	        $row = that._createRow(options.row);
	        that._renderCells($row, options);
	        that._appendRow($table, $row);
	        that._rowPrepared($row, $.extend({
	            columns: options.columns
	        }, options.row))
	    },
	    _renderCells: function($row, options) {
	        var i, that = this,
	            columnIndex = 0,
	            row = options.row,
	            columns = options.columns;
	        for (i = 0; i < columns.length; i++) {
	            that._renderCell($row, $.extend({
	                column: columns[i],
	                columnIndex: columnIndex,
	                value: row.values && row.values[columnIndex]
	            }, options));
	            if (columns[i].colspan > 1) {
	                columnIndex += columns[i].colspan
	            } else {
	                columnIndex++
	            }
	        }
	    },
	    _renderCell: function($row, options) {
	        var $cell, that = this,
	            cellOptions = that._getCellOptions(options),
	            column = options.column;
	        options.row.cells.push(cellOptions);
	        $cell = that._createCell(cellOptions);
	        if (!column.command) {
	            that.setAria("label", that.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + that.localize("dxDataGrid-ariaValue") + " " + cellOptions.text, $cell)
	        }
	        that._renderCellContent($cell, cellOptions);
	        $row.get(0).appendChild($cell.get(0));
	        return $cell
	    },
	    _renderCellContent: function($cell, options) {
	        var template = this._getCellTemplate(options);
	        if (!template || this.renderTemplate($cell, template, options)) {
	            this._updateCell($cell, options)
	        }
	    },
	    _getCellTemplate: function() {},
	    _getRows: function() {
	        return []
	    },
	    _getCellOptions: function(options) {
	        return {
	            column: options.column,
	            columnIndex: options.columnIndex,
	            rowType: options.row.rowType
	        }
	    },
	    _cellPrepared: function($cell, options) {
	        options.cellElement = $cell;
	        this.executeAction("onCellPrepared", options)
	    },
	    _rowPrepared: function($row, options) {
	        $.data($row.get(0), "options", options);
	        options.rowElement = $row;
	        this.executeAction("onRowPrepared", options)
	    },
	    _columnOptionChanged: function(e) {
	        var optionNames = e.optionNames;
	        if (gridCore.checkChanges(optionNames, ["width", "visibleWidth"])) {
	            var visibleColumns = this._columnsController.getVisibleColumns();
	            var widths = $.map(visibleColumns, function(column) {
	                return column.visibleWidth || column.width || "auto"
	            });
	            this.setColumnWidths(widths);
	            return
	        }
	        if (!this._requireReady) {
	            this.render()
	        }
	    },
	    getTableElements: function() {
	        return this._tableElement || $()
	    },
	    _getTableElement: function() {
	        return this._tableElement
	    },
	    _setTableElement: function(tableElement) {
	        this._tableElement = tableElement
	    },
	    optionChanged: function(args) {
	        this.callBase(args);
	        switch (args.name) {
	            case "cellHintEnabled":
	            case "onCellPrepared":
	            case "onRowPrepared":
	            case "onCellHoverChanged":
	                this._invalidate(true, true);
	                args.handled = true
	        }
	    },
	    init: function() {
	        var that = this;
	        that._scrollLeft = 0;
	        that._columnsController = that.getController("columns");
	        that._dataController = that.getController("data");
	        that._delayedTemplates = [];
	        that._templatesCache = {};
	        that.createAction("onCellClick");
	        that.createAction("onRowClick");
	        that.createAction("onCellHoverChanged", {
	            excludeValidators: ["disabled", "readOnly"]
	        });
	        that.createAction("onCellPrepared", {
	            excludeValidators: ["designMode", "disabled", "readOnly"],
	            category: "rendering"
	        });
	        that.createAction("onRowPrepared", {
	            excludeValidators: ["designMode", "disabled", "readOnly"],
	            category: "rendering",
	            afterExecute: function(e) {
	                that._afterRowPrepared(e)
	            }
	        });
	        that._columnsController.columnsChanged.add($.proxy(that._columnOptionChanged, that));
	        that._dataController && that._dataController.changed.add($.proxy(that._handleDataChanged, that))
	    },
	    _afterRowPrepared: $.noop,
	    _handleDataChanged: function() {},
	    callbackNames: function() {
	        return ["scrollChanged"]
	    },
	    scrollTo: function(pos) {
	        var that = this,
	            $element = that.element(),
	            $scrollContainer = $element && $element.children("." + DATAGRID_SCROLL_CONTAINER_CLASS).not("." + DATAGRID_CONTENT_FIXED_CLASS);
	        that._skipScrollChanged = false;
	        if (commonUtils.isDefined(pos) && commonUtils.isDefined(pos.left) && that._scrollLeft !== pos.left) {
	            that._scrollLeft = pos.left;
	            $scrollContainer && $scrollContainer.scrollLeft(Math.round(pos.left));
	            that._skipScrollChanged = true
	        }
	    },
	    _wrapTableInScrollContainer: function($table) {
	        var $scrollContainer, that = this;
	        $scrollContainer = $("<div/>").on("scroll", function() {
	            !that._skipScrollChanged && that.scrollChanged.fire({
	                left: $scrollContainer.scrollLeft()
	            }, that.name);
	            that._skipScrollChanged = false
	        }).addClass(DATAGRID_CONTENT_CLASS).addClass(DATAGRID_SCROLL_CONTAINER_CLASS).append($table).appendTo(that.element());
	        return $scrollContainer
	    },
	    _updateContent: function($newTableElement) {
	        this._setTableElement($newTableElement);
	        this._wrapTableInScrollContainer($newTableElement)
	    },
	    _findContentElement: $.noop,
	    _getWidths: function($cellElements) {
	        var width, clientRect, result = [];
	        if ($cellElements) {
	            $.each($cellElements, function(index, item) {
	                width = item.offsetWidth;
	                if (item.getBoundingClientRect) {
	                    clientRect = item.getBoundingClientRect();
	                    if (clientRect.width > width) {
	                        width = Math.ceil(clientRect.width)
	                    }
	                }
	                result.push(width)
	            })
	        }
	        return result
	    },
	    getColumnWidths: function($tableElement) {
	        var $cells, that = this,
	            result = [];
	        $tableElement = $tableElement || that._getTableElement();
	        if ($tableElement) {
	            $cells = $tableElement.children("tbody").children(":not(." + DATAGRID_GROUP_ROW_CLASS + ", ." + DATAGRID_DETAIL_ROW_CLASS + ")").first().children("td");
	            result = that._getWidths($cells)
	        }
	        return result
	    },
	    setColumnWidths: function(widths, $tableElement, columns) {
	        var $cols, i, width, columnIndex;
	        $tableElement = $tableElement || this._getTableElement();
	        if ($tableElement && $tableElement.length && widths) {
	            columnIndex = 0;
	            $cols = $tableElement.find("col");
	            columns = columns || this.getColumns(null, $tableElement);
	            for (i = 0; i < columns.length; i++) {
	                if (columns[i].colspan) {
	                    columnIndex += columns[i].colspan;
	                    continue
	                }
	                width = widths[columnIndex];
	                if ("adaptiveHidden" === width) {
	                    width = DATAGRID_HIDDEN_COLUMNS_WIDTH
	                }
	                $cols.eq(columnIndex).css("width", width || "auto");
	                columnIndex++
	            }
	        }
	    },
	    getCellElements: function(rowIndex) {
	        return this._getCellElementsCore(rowIndex)
	    },
	    _getCellElementsCore: function(rowIndex) {
	        var $row = this._getRowElements().eq(rowIndex);
	        return $row.children()
	    },
	    getCellElement: function(rowIndex, columnIdentifier) {
	        var $cell, that = this,
	            $cells = that.getCellElements(rowIndex),
	            columnVisibleIndex = that._getVisibleColumnIndex($cells, rowIndex, columnIdentifier);
	        if ($cells.length && columnVisibleIndex >= 0) {
	            $cell = $cells.eq(columnVisibleIndex)
	        }
	        if ($cell && $cell.length) {
	            return $cell
	        }
	    },
	    getRowElement: function(rowIndex) {
	        var that = this,
	            $rowElement = $(),
	            $tableElements = that.getTableElements();
	        $.each($tableElements, function(_, tableElement) {
	            $rowElement = $rowElement.add(that._getRowElements($(tableElement)).eq(rowIndex))
	        });
	        if ($rowElement.length) {
	            return $rowElement
	        }
	    },
	    _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
	        var columnIndex;
	        if (commonUtils.isString(columnIdentifier)) {
	            columnIndex = this._columnsController.columnOption(columnIdentifier, "index");
	            return this._columnsController.getVisibleIndex(columnIndex)
	        }
	        return columnIdentifier
	    },
	    getColumnElements: function() {},
	    getColumns: function(rowIndex) {
	        return this._columnsController.getVisibleColumns(rowIndex)
	    },
	    getCell: function(cellPosition, rows) {
	        var $cells, $rows = rows || this._getRowElements();
	        if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
	            cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
	            $cells = this.getCellElements(cellPosition.rowIndex);
	            if ($cells && $cells.length > 0) {
	                return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1)
	            }
	        }
	    },
	    getRowsCount: function() {
	        var tableElement = this._getTableElement();
	        if (tableElement && 1 === tableElement.length) {
	            return tableElement[0].rows.length
	        }
	        return 0
	    },
	    _getRowElements: function(tableElement) {
	        tableElement = tableElement || this._getTableElement();
	        return tableElement && tableElement.children("tbody").children("." + DATAGRID_ROW_CLASS) || $()
	    },
	    getRowIndex: function($row) {
	        return this._getRowElements().index($row)
	    },
	    getBoundingRect: function() {},
	    getName: function() {},
	    setScrollerSpacing: function(width) {
	        var that = this,
	            $element = that.element(),
	            rtlEnabled = that.option("rtlEnabled");
	        $element && $element.css(rtlEnabled ? {
	            paddingLeft: width
	        } : {
	            paddingRight: width
	        })
	    },
	    isScrollbarVisible: function(isHorizontal) {
	        var $element = this.element(),
	            $tableElement = this._tableElement;
	        if ($element && $tableElement) {
	            return isHorizontal ? $tableElement.outerWidth() - $element.width() > 0 : $tableElement.outerHeight() - $element.height() > 0
	        }
	        return false
	    }
	});


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/grid_core/ui.grid_core.utils.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    LoadPanel = __webpack_require__(149);
	var DATAGRID_NODATA_TEXT_CLASS = "dx-datagrid-nodata",
	    DATAGRID_INDICATOR_ALIGNMENT_CLASS = "dx-indicator-alignment-",
	    DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
	    DATAGRID_GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item";
	exports.renderNoDataText = function($element) {
	    var that = this;
	    $element = $element || this.element();
	    var noDataElement = $element.find("." + DATAGRID_NODATA_TEXT_CLASS),
	        isVisible = this._dataController.isEmpty(),
	        isLoading = this._dataController.isLoading(),
	        rtlEnabled = this.option("rtlEnabled");
	    if (!noDataElement.length) {
	        noDataElement = $("<span>").addClass(DATAGRID_NODATA_TEXT_CLASS).appendTo($element)
	    }
	    if (isVisible && !isLoading) {
	        noDataElement.removeClass("dx-hidden").text(that._getNoDataText());
	        commonUtils.deferUpdate(function() {
	            var noDataHeight = noDataElement.height(),
	                noDataWidth = noDataElement.width();
	            commonUtils.deferRender(function() {
	                noDataElement.css({
	                    marginTop: -Math.floor(noDataHeight / 2),
	                    marginRight: rtlEnabled ? -Math.floor(noDataWidth / 2) : 0,
	                    marginLeft: rtlEnabled ? 0 : -Math.floor(noDataWidth / 2)
	                })
	            })
	        })
	    } else {
	        noDataElement.addClass("dx-hidden")
	    }
	};
	exports.renderLoadPanel = function($element, $container, isLocalStore) {
	    var loadPanelOptions, that = this;
	    that._loadPanel && that._loadPanel.element().remove();
	    loadPanelOptions = that.option("loadPanel");
	    if (loadPanelOptions && ("auto" === loadPanelOptions.enabled ? !isLocalStore : loadPanelOptions.enabled)) {
	        loadPanelOptions = $.extend({
	            shading: false,
	            message: loadPanelOptions.text,
	            position: {
	                of: $element
	            },
	            container: $element
	        }, loadPanelOptions);
	        that._loadPanel = that._createComponent($("<div>").appendTo($container), LoadPanel, loadPanelOptions)
	    } else {
	        that._loadPanel = null
	    }
	};
	exports.columnStateMixin = {
	    _applyColumnState: function(options) {
	        var that = this,
	            rtlEnabled = this.option("rtlEnabled"),
	            columnAlignment = that._getColumnAlignment(options.column.alignment, rtlEnabled),
	            parameters = $.extend(true, {
	                columnAlignment: columnAlignment
	            }, options),
	            isGroupPanelItem = parameters.rootElement.hasClass(DATAGRID_GROUP_PANEL_ITEM_CLASS),
	            $indicatorsContainer = that._createIndicatorContainer(parameters, isGroupPanelItem),
	            $span = $("<span>").addClass(that._getIndicatorClassName(options.name)),
	            getIndicatorAlignment = function() {
	                if (rtlEnabled) {
	                    return "left" === columnAlignment ? "right" : "left"
	                }
	                return columnAlignment
	            };
	        parameters.container = $indicatorsContainer;
	        parameters.indicator = $span;
	        that._renderIndicator(parameters);
	        $indicatorsContainer[(isGroupPanelItem || !options.showColumnLines) && "left" === getIndicatorAlignment() ? "appendTo" : "prependTo"](options.rootElement).addClass(DATAGRID_INDICATOR_ALIGNMENT_CLASS + columnAlignment);
	        return $span
	    },
	    _getIndicatorClassName: $.noop,
	    _getColumnAlignment: function(alignment, rtlEnabled) {
	        rtlEnabled = rtlEnabled || this.option("rtlEnabled");
	        return "center" !== alignment ? alignment : commonUtils.getDefaultAlignment(rtlEnabled)
	    },
	    _createIndicatorContainer: function(options, ignoreIndicatorAlignment) {
	        var $indicatorsContainer = options.rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS),
	            indicatorAlignment = "left" === options.columnAlignment ? "right" : "left";
	        if (!$indicatorsContainer.length) {
	            $indicatorsContainer = $("<div>").addClass(DATAGRID_COLUMN_INDICATORS_CLASS)
	        }
	        return $indicatorsContainer.css("float", options.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null)
	    },
	    _getIndicatorContainer: function($cell) {
	        return $cell && $cell.find("." + DATAGRID_COLUMN_INDICATORS_CLASS)
	    },
	    _renderIndicator: function(options) {
	        var $container = options.container,
	            $indicator = options.indicator;
	        $container && $indicator && $container.append($indicator)
	    },
	    _updateIndicators: function(indicatorName) {
	        var rowOptions, $cell, i, that = this,
	            columns = that.getColumns(),
	            $cells = that.getColumnElements();
	        for (i = 0; i < columns.length; i++) {
	            $cell = $cells.eq(i);
	            that._updateIndicator($cell, columns[i], indicatorName);
	            rowOptions = $cell.parent().data("options");
	            if (rowOptions && rowOptions.cells) {
	                rowOptions.cells[$cell.index()].column = columns[i]
	            }
	        }
	    },
	    _updateIndicator: function($cell, column, indicatorName) {
	        if (!column.command) {
	            return this._applyColumnState({
	                name: indicatorName,
	                rootElement: $cell,
	                column: column,
	                showColumnLines: this.option("showColumnLines")
	            })
	        }
	    }
	};
	exports.getIndexByKey = function(key, items, keyName) {
	    var item, index = -1;
	    if (commonUtils.isArray(items)) {
	        keyName = arguments.length <= 2 ? "key" : keyName;
	        for (var i = 0; i < items.length; i++) {
	            item = commonUtils.isDefined(keyName) ? items[i][keyName] : items[i];
	            if (commonUtils.equalByValue(key, item)) {
	                index = i;
	                break
	            }
	        }
	    }
	    return index
	};
	exports.exportMixin = {
	    _getEmptyCell: function() {
	        return {
	            text: "",
	            value: void 0,
	            colspan: 1,
	            rowspan: 1
	        }
	    },
	    _defaultSetter: function(value) {
	        value = parseInt(value, 10);
	        return !value ? 1 : value
	    },
	    _makeRowOffset: function(resultItems) {
	        var offset = 0,
	            rowIndex = resultItems.length - 1,
	            row = resultItems[rowIndex],
	            cellIndex = row.length;
	        $.each(resultItems, function(rowIndex) {
	            if (this[cellIndex] && this[cellIndex].rowspan + rowIndex > resultItems.length - 1) {
	                offset = Math.max.apply(this, [this[cellIndex].colspan, offset])
	            }
	        });
	        for (var i = 0; i < offset; i++) {
	            row.push(this._cloneItem(resultItems[resultItems.length - 2][cellIndex && cellIndex - 1 || 0]))
	        }
	        if (offset > 0) {
	            this._makeRowOffset(resultItems)
	        }
	    },
	    _cloneItem: function(item) {
	        return $.extend({}, item, this._getEmptyCell())
	    },
	    _prepareItems: function(cols, items) {
	        var i, row, cellIndex, rowIndex, that = this,
	            resultItems = [];
	        for (rowIndex = 0; rowIndex < items.length; rowIndex++) {
	            row = [];
	            resultItems.push(row);
	            do {
	                that._makeRowOffset(resultItems);
	                cellIndex = row.length;
	                row.push(items[rowIndex].shift());
	                if (row[row.length - 1]) {
	                    row[row.length - 1].colspan = that._defaultSetter(row[row.length - 1].colspan);
	                    row[row.length - 1].rowspan = that._defaultSetter(row[row.length - 1].rowspan)
	                } else {
	                    row[row.length - 1] = $({}, that._getEmptyCell())
	                }
	                for (i = 1; i < row[cellIndex].colspan; i++) {
	                    row.push(that._cloneItem(row[row.length - 1]))
	                }
	            } while (items[rowIndex].length);
	            while (row.length < cols) {
	                row.push(that._cloneItem(row[row.length - 1]))
	            }
	        }
	        return resultItems
	    }
	};


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/load_panel.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    messageLocalization = __webpack_require__(79),
	    registerComponent = __webpack_require__(44),
	    LoadIndicator = __webpack_require__(150),
	    Overlay = __webpack_require__(97);
	var LOADPANEL_CLASS = "dx-loadpanel",
	    LOADPANEL_WRAPPER_CLASS = "dx-loadpanel-wrapper",
	    LOADPANEL_INDICATOR_CLASS = "dx-loadpanel-indicator",
	    LOADPANEL_MESSAGE_CLASS = "dx-loadpanel-message",
	    LOADPANEL_CONTENT_CLASS = "dx-loadpanel-content",
	    LOADPANEL_CONTENT_WRAPPER_CLASS = "dx-loadpanel-content-wrapper",
	    LOADPANEL_PANE_HIDDEN_CLASS = "dx-loadpanel-pane-hidden";
	var LoadPanel = Overlay.inherit({
	    _supportedKeys: function() {
	        return $.extend(this.callBase(), {
	            escape: $.noop
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            message: messageLocalization.format("Loading"),
	            width: 222,
	            height: 90,
	            animation: null,
	            showIndicator: true,
	            indicatorSrc: "",
	            showPane: true,
	            delay: 0,
	            closeOnBackButton: false,
	            resizeEnabled: false,
	            focusStateEnabled: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: {
	                platform: "generic"
	            },
	            options: {
	                shadingColor: "transparent"
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase.apply(this, arguments)
	    },
	    _initOptions: function() {
	        this.callBase.apply(this, arguments);
	        this.option("templatesRenderAsynchronously", false)
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(LOADPANEL_CLASS);
	        this._wrapper().addClass(LOADPANEL_WRAPPER_CLASS)
	    },
	    _renderContentImpl: function() {
	        this.callBase();
	        this.content().addClass(LOADPANEL_CONTENT_CLASS);
	        this._$contentWrapper = $("<div>").addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
	        this._$contentWrapper.appendTo(this._$content);
	        this._togglePaneVisible();
	        this._cleanPreviousContent();
	        this._renderLoadIndicator();
	        this._renderMessage()
	    },
	    _show: function() {
	        var delay = this.option("delay");
	        if (!delay) {
	            return this.callBase()
	        }
	        var deferred = $.Deferred();
	        var callBase = $.proxy(this.callBase, this);
	        this._clearShowTimeout();
	        this._showTimeout = setTimeout(function() {
	            callBase().done(function() {
	                deferred.resolve()
	            })
	        }, delay);
	        return deferred.promise()
	    },
	    _hide: function() {
	        this._clearShowTimeout();
	        return this.callBase()
	    },
	    _clearShowTimeout: function() {
	        clearTimeout(this._showTimeout)
	    },
	    _renderMessage: function() {
	        if (!this._$contentWrapper) {
	            return
	        }
	        var message = this.option("message");
	        if (!message) {
	            return
	        }
	        var $message = $("<div>").addClass(LOADPANEL_MESSAGE_CLASS).text(message);
	        this._$contentWrapper.append($message)
	    },
	    _renderLoadIndicator: function() {
	        if (!this._$contentWrapper || !this.option("showIndicator")) {
	            return
	        }
	        this._$indicator = $("<div>").addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$contentWrapper);
	        this._createComponent(this._$indicator, LoadIndicator, {
	            indicatorSrc: this.option("indicatorSrc")
	        })
	    },
	    _cleanPreviousContent: function() {
	        this.content().find("." + LOADPANEL_MESSAGE_CLASS).remove();
	        this.content().find("." + LOADPANEL_INDICATOR_CLASS).remove()
	    },
	    _togglePaneVisible: function() {
	        this.content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option("showPane"))
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "delay":
	                break;
	            case "message":
	            case "showIndicator":
	                this._cleanPreviousContent();
	                this._renderLoadIndicator();
	                this._renderMessage();
	                break;
	            case "showPane":
	                this._togglePaneVisible();
	                break;
	            case "indicatorSrc":
	                if (this._$indicator) {
	                    this._createComponent(this._$indicator, LoadIndicator, {
	                        indicatorSrc: this.option("indicatorSrc")
	                    })
	                }
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _dispose: function() {
	        this._clearShowTimeout();
	        this.callBase()
	    }
	});
	registerComponent("dxLoadPanel", LoadPanel);
	module.exports = LoadPanel;
	module.exports.default = module.exports;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/load_indicator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    support = __webpack_require__(48),
	    themes = __webpack_require__(112),
	    browser = __webpack_require__(16),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    Widget = __webpack_require__(84);
	var LOADINDICATOR_CLASS = "dx-loadindicator",
	    LOADINDICATOR_WRAPPER_CLASS = "dx-loadindicator-wrapper",
	    LOADINDICATOR_CONTENT_CLASS = "dx-loadindicator-content",
	    LOADINDICATOR_ICON_CLASS = "dx-loadindicator-icon",
	    LOADINDICATOR_SEGMENT_CLASS = "dx-loadindicator-segment",
	    LOADINDICATOR_SEGMENT_INNER_CLASS = "dx-loadindicator-segment-inner",
	    LOADINDICATOR_IMAGE_CLASS = "dx-loadindicator-image";
	var LoadIndicator = Widget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            indicatorSrc: "",
	            activeStateEnabled: false,
	            hoverStateEnabled: false,
	            _animatingSegmentCount: 1,
	            _animatingSegmentInner: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        var themeName = function() {
	            var currentTheme = themes.current();
	            return currentTheme && currentTheme.split(".")[0]
	        };
	        return this.callBase().concat([{
	            device: function() {
	                var realDevice = devices.real(),
	                    obsoleteAndroid = "android" === realDevice.platform && !/chrome/i.test(navigator.userAgent);
	                return browser.msie && browser.version < 10 || obsoleteAndroid
	            },
	            options: {
	                viaImage: true
	            }
	        }, {
	            device: function() {
	                return "win8" === themeName() || "win10" === themeName()
	            },
	            options: {
	                _animatingSegmentCount: 5
	            }
	        }, {
	            device: function() {
	                return "ios7" === themeName()
	            },
	            options: {
	                _animatingSegmentCount: 11
	            }
	        }, {
	            device: function() {
	                return "android5" === themeName()
	            },
	            options: {
	                _animatingSegmentCount: 2,
	                _animatingSegmentInner: true
	            }
	        }, {
	            device: function() {
	                return "generic" === themeName()
	            },
	            options: {
	                _animatingSegmentCount: 7
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(LOADINDICATOR_CLASS)
	    },
	    _render: function() {
	        this._renderWrapper();
	        this._renderIndicatorContent();
	        this._renderMarkup();
	        this.callBase()
	    },
	    _renderWrapper: function() {
	        this._$wrapper = $("<div>").addClass(LOADINDICATOR_WRAPPER_CLASS);
	        this.element().append(this._$wrapper)
	    },
	    _renderIndicatorContent: function() {
	        this._$content = $("<div>").addClass(LOADINDICATOR_CONTENT_CLASS);
	        this._$wrapper.append(this._$content)
	    },
	    _renderMarkup: function() {
	        if (support.animation && !this.option("viaImage") && !this.option("indicatorSrc")) {
	            this._renderMarkupForAnimation()
	        } else {
	            this._renderMarkupForImage()
	        }
	    },
	    _renderMarkupForAnimation: function() {
	        var animatingSegmentInner = this.option("_animatingSegmentInner");
	        this._$indicator = $("<div>").addClass(LOADINDICATOR_ICON_CLASS);
	        this._$content.append(this._$indicator);
	        for (var i = this.option("_animatingSegmentCount"); i >= 0; --i) {
	            var $segment = $("<div>").addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
	            if (animatingSegmentInner) {
	                $segment.append($("<div>").addClass(LOADINDICATOR_SEGMENT_INNER_CLASS))
	            }
	            this._$indicator.append($segment)
	        }
	    },
	    _renderMarkupForImage: function() {
	        var indicatorSrc = this.option("indicatorSrc");
	        this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
	        if (indicatorSrc) {
	            this._$wrapper.css("background-image", "url(" + indicatorSrc + ")")
	        }
	    },
	    _renderDimensions: function() {
	        this.callBase();
	        this._updateContentSizeForAnimation()
	    },
	    _updateContentSizeForAnimation: function() {
	        if (!this._$indicator) {
	            return
	        }
	        var width = this.option("width"),
	            height = this.option("height");
	        if (width || height) {
	            width = this.element().width();
	            height = this.element().height();
	            var minDimension = Math.min(height, width);
	            this._$wrapper.css({
	                height: minDimension,
	                width: minDimension,
	                "font-size": minDimension
	            })
	        }
	    },
	    _clean: function() {
	        this.callBase();
	        this._removeMarkupForAnimation();
	        this._removeMarkupForImage()
	    },
	    _removeMarkupForAnimation: function() {
	        if (!this._$indicator) {
	            return
	        }
	        this._$indicator.remove();
	        delete this._$indicator
	    },
	    _removeMarkupForImage: function() {
	        this._$wrapper.css("background-image", "none")
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "_animatingSegmentCount":
	            case "_animatingSegmentInner":
	            case "indicatorSrc":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxLoadIndicator", LoadIndicator);
	module.exports = LoadIndicator;
	module.exports.default = module.exports;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.columns_controller.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    isWrapped = __webpack_require__(37).isWrapped,
	    dataCoreUtils = __webpack_require__(35),
	    commonUtils = __webpack_require__(8),
	    isDefined = commonUtils.isDefined,
	    objectUtils = __webpack_require__(36),
	    errors = __webpack_require__(15),
	    gridCore = __webpack_require__(144),
	    normalizeSortingInfo = gridCore.normalizeSortingInfo,
	    equalSortParameters = gridCore.equalSortParameters,
	    normalizeIndexes = __webpack_require__(99).normalizeIndexes,
	    inflector = __webpack_require__(49),
	    dateUtils = __webpack_require__(51),
	    numberLocalization = __webpack_require__(20),
	    dateLocalization = __webpack_require__(55),
	    messageLocalization = __webpack_require__(79),
	    when = __webpack_require__(10).when,
	    DataSourceModule = __webpack_require__(121),
	    normalizeDataSourceOptions = DataSourceModule.normalizeDataSourceOptions;
	var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"],
	    USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "sortIndex", "groupIndex", "filterValue", "selectedFilterOperation", "added"].concat(USER_STATE_FIELD_NAMES_15_1),
	    DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand";
	var ColumnsController = gridCore.Controller.inherit(function() {
	    var DEFAULT_COLUMN_OPTIONS = {
	            visible: true,
	            showInColumnChooser: true
	        },
	        DATATYPE_OPERATIONS = {
	            number: ["=", "<>", "<", ">", "<=", ">=", "between"],
	            string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
	            date: ["=", "<>", "<", ">", "<=", ">=", "between"]
	        },
	        COLUMN_INDEX_OPTIONS = {
	            visibleIndex: true,
	            groupIndex: true,
	            grouped: true,
	            sortIndex: true,
	            sortOrder: true
	        },
	        GROUP_LOCATION = "group",
	        COLUMN_CHOOSER_LOCATION = "columnChooser";
	    var createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {
	        var calculatedColumnOptions, commonColumnOptions = {};
	        if (columnOptions) {
	            if (commonUtils.isString(columnOptions)) {
	                columnOptions = {
	                    dataField: columnOptions
	                }
	            }
	            if (columnOptions.command) {
	                return $.extend(true, {}, columnOptions)
	            } else {
	                commonColumnOptions = that.getCommonSettings();
	                if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {
	                    columnOptions = $.extend({}, columnOptions, {
	                        dataField: userStateColumnOptions.dataField
	                    })
	                }
	                calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);
	                return $.extend(true, {}, DEFAULT_COLUMN_OPTIONS, commonColumnOptions, calculatedColumnOptions, columnOptions, {
	                    selector: null
	                })
	            }
	        }
	    };
	    var createColumnsFromOptions = function(that, columnsOptions, bandColumn) {
	        var result = [];
	        if (columnsOptions) {
	            $.each(columnsOptions, function(index, columnOptions) {
	                var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index],
	                    column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);
	                if (column) {
	                    if (bandColumn) {
	                        column.ownerBand = bandColumn
	                    }
	                    result.push(column)
	                }
	                if (column.isBand) {
	                    result = result.concat(createColumnsFromOptions(that, column.columns, column));
	                    delete column.columns
	                }
	            })
	        }
	        return result
	    };
	    var getParentBandColumns = function(columnIndex, columns) {
	        var result = [],
	            columnID = columns[columnIndex].ownerBand;
	        if (isDefined(columnID)) {
	            $.each(columns, function(index, column) {
	                if (column.index === columnID) {
	                    result.unshift(column);
	                    if (isDefined(column.ownerBand)) {
	                        result = getParentBandColumns(index, columns).concat(result)
	                    } else {
	                        return false
	                    }
	                }
	            })
	        }
	        return result
	    };
	    var calculateColspan = function(that, columnID, columns) {
	        var colspan = 0;
	        columns = columns || that.getChildrenByBandColumn(columnID);
	        $.each(columns, function(_, column) {
	            if (column.visible && column.ownerBand === columnID) {
	                if (column.isBand) {
	                    colspan += calculateColspan(that, column.index, columns)
	                } else {
	                    colspan += 1
	                }
	            }
	        });
	        return colspan
	    };
	    var processBandColumns = function(that, columns) {
	        var i, column, rowspan, colspan, rowCount = that.getRowCount();
	        for (i = 0; i < columns.length; i++) {
	            column = columns[i];
	            if (column.visible || column.command) {
	                if (column.isBand) {
	                    colspan = calculateColspan(that, column.index);
	                    column.colspan = colspan
	                }
	                if (!column.isBand || !column.colspan) {
	                    rowspan = rowCount - (!column.command && !isDefined(column.groupIndex) ? getParentBandColumns(i, columns).length : 0);
	                    if (rowspan > 1) {
	                        column.rowspan = rowspan
	                    }
	                }
	            }
	        }
	    };
	    var getValueDataType = function(value) {
	        var dataType = $.type(value);
	        if ("string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType) {
	            dataType = void 0
	        }
	        return dataType
	    };
	    var getSerializationFormat = function(dataType, value) {
	        switch (dataType) {
	            case "date":
	                return dateUtils.getDateSerializationFormat(value);
	            case "number":
	                if (commonUtils.isString(value)) {
	                    return "string"
	                }
	        }
	    };
	    var updateSerializers = function(options, dataType) {
	        if (!options.deserializeValue) {
	            if ("date" === dataType) {
	                options.deserializeValue = function(value) {
	                    return dateUtils.deserializeDate(value, this.serializationFormat, $.proxy(dateLocalization.parse, dateLocalization))
	                };
	                options.serializeValue = function(value) {
	                    return dateUtils.serializeDate(value, this.serializationFormat, $.proxy(dateLocalization.format, dateLocalization))
	                }
	            }
	            if ("number" === dataType) {
	                options.deserializeValue = function(value) {
	                    return isDefined(value) ? Number(value) : value
	                };
	                options.serializeValue = function(value) {
	                    return isDefined(value) && "string" === this.serializationFormat ? value.toString() : value
	                }
	            }
	        }
	    };
	    var getAlignmentByDataType = function(dataType, isRTL) {
	        switch (dataType) {
	            case "number":
	                return "right";
	            case "boolean":
	                return "center";
	            default:
	                return commonUtils.getDefaultAlignment(isRTL)
	        }
	    };
	    var getCustomizeTextByDataType = function(dataType) {
	        if ("boolean" === dataType) {
	            return function(e) {
	                if (true === e.value) {
	                    return this.trueText || "true"
	                } else {
	                    if (false === e.value) {
	                        return this.falseText || "false"
	                    } else {
	                        return e.valueText || ""
	                    }
	                }
	            }
	        }
	    };
	    var createColumnsFromDataSource = function(that, dataSource) {
	        var fieldName, i, firstItems = getFirstItems(dataSource),
	            processedFields = {},
	            result = [];
	        for (i = 0; i < firstItems.length; i++) {
	            if (firstItems[i]) {
	                for (fieldName in firstItems[i]) {
	                    if (!commonUtils.isFunction(firstItems[i][fieldName]) || isWrapped(firstItems[i][fieldName])) {
	                        processedFields[fieldName] = true
	                    }
	                }
	            }
	        }
	        for (fieldName in processedFields) {
	            if (0 !== fieldName.indexOf("__")) {
	                var column = createColumn(that, fieldName);
	                result.push(column)
	            }
	        }
	        return result
	    };
	    var getFirstItems = function(dataSource) {
	        var groupsCount, items = [];
	        var getFirstItemsCore = function(items, groupsCount) {
	            var i, childItems;
	            if (!items || !groupsCount) {
	                return items
	            }
	            for (i = 0; i < items.length; i++) {
	                childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);
	                if (childItems && childItems.length) {
	                    return childItems
	                }
	            }
	        };
	        if (dataSource && dataSource.items().length > 0) {
	            groupsCount = normalizeSortingInfo(dataSource.group()).length;
	            items = getFirstItemsCore(dataSource.items(), groupsCount) || []
	        }
	        return items
	    };
	    var updateColumnIndexes = function(that) {
	        $.each(that._columns, function(index, column) {
	            column.index = index
	        });
	        $.each(that._columns, function(index, column) {
	            if (commonUtils.isObject(column.ownerBand)) {
	                column.ownerBand = column.ownerBand.index
	            }
	        });
	        $.each(that._commandColumns, function(index, column) {
	            column.index = -(index + 1)
	        })
	    };
	    var updateColumnGroupIndexes = function(that, currentColumn) {
	        normalizeIndexes(that._columns, "groupIndex", currentColumn, function(column) {
	            var grouped = column.grouped;
	            delete column.grouped;
	            return grouped
	        })
	    };
	    var updateColumnSortIndexes = function(that, currentColumn) {
	        $.each(that._columns, function(index, column) {
	            if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {
	                delete column.sortIndex
	            }
	        });
	        normalizeIndexes(that._columns, "sortIndex", currentColumn, function(column) {
	            return !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)
	        })
	    };
	    var updateColumnVisibleIndexes = function(that, currentColumn) {
	        var i, key, column, bandColumnIndex, parentBandColumns, bandColumns = {},
	            columns = [];
	        for (i = 0; i < that._columns.length; i++) {
	            column = that._columns[i];
	            parentBandColumns = getParentBandColumns(i, that._columns);
	            if (parentBandColumns.length) {
	                bandColumnIndex = parentBandColumns[parentBandColumns.length - 1].index;
	                bandColumns[bandColumnIndex] = bandColumns[bandColumnIndex] || [];
	                bandColumns[bandColumnIndex].push(column)
	            } else {
	                columns.push(column)
	            }
	        }
	        for (key in bandColumns) {
	            normalizeIndexes(bandColumns[key], "visibleIndex", currentColumn)
	        }
	        normalizeIndexes(columns, "visibleIndex", currentColumn)
	    };
	    var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
	        var column, rowIndex = commonUtils.isObject(visibleIndex) ? visibleIndex.rowIndex : null,
	            columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);
	        visibleIndex = commonUtils.isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;
	        column = columns[visibleIndex];
	        return column && isDefined(column.index) ? column.index : -1
	    };
	    var moveColumnToGroup = function(that, column, groupIndex) {
	        var i, groupColumns = that.getGroupColumns();
	        if (groupIndex >= 0) {
	            for (i = 0; i < groupColumns.length; i++) {
	                if (groupColumns[i].groupIndex >= groupIndex) {
	                    groupColumns[i].groupIndex++
	                }
	            }
	        } else {
	            groupIndex = 0;
	            for (i = 0; i < groupColumns.length; i++) {
	                groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)
	            }
	        }
	        column.groupIndex = groupIndex
	    };
	    var checkUserStateColumn = function(column, userStateColumn) {
	        return column && userStateColumn && userStateColumn.name === column.name && (userStateColumn.dataField === column.dataField || column.name)
	    };
	    var applyUserState = function(that) {
	        var column, columnUserState, userStateColumnIndex, i, columnsUserState = that._columnsUserState,
	            ignoreColumnOptionNames = that._ignoreColumnOptionNames || [],
	            columns = that._columns,
	            columnCountById = {},
	            resultColumns = [],
	            allColumnsHaveState = true,
	            userStateColumnIndexes = [];

	        function applyFieldsState(column, userStateColumn) {
	            var fieldName;
	            if (!userStateColumn) {
	                return
	            }
	            for (var index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {
	                fieldName = USER_STATE_FIELD_NAMES[index];
	                if ($.inArray(fieldName, ignoreColumnOptionNames) >= 0) {
	                    continue
	                }
	                if ("dataType" === fieldName) {
	                    column[fieldName] = column[fieldName] || userStateColumn[fieldName]
	                } else {
	                    if ($.inArray(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {
	                        if (fieldName in userStateColumn) {
	                            column[fieldName] = userStateColumn[fieldName]
	                        }
	                    } else {
	                        column[fieldName] = userStateColumn[fieldName]
	                    }
	                }
	            }
	        }

	        function findUserStateColumn(columnsUserState, column) {
	            var id = column.name || column.dataField,
	                count = columnCountById[id] || 0;
	            for (var j = 0; j < columnsUserState.length; j++) {
	                if (checkUserStateColumn(column, columnsUserState[j])) {
	                    if (count) {
	                        count--
	                    } else {
	                        columnCountById[id] = columnCountById[id] || 0;
	                        columnCountById[id]++;
	                        return j
	                    }
	                }
	            }
	            return -1
	        }
	        if (columnsUserState) {
	            for (i = 0; i < columns.length; i++) {
	                userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);
	                allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;
	                userStateColumnIndexes.push(userStateColumnIndex)
	            }
	            for (i = 0; i < columns.length; i++) {
	                column = columns[i];
	                userStateColumnIndex = userStateColumnIndexes[i];
	                if (that._hasUserState || allColumnsHaveState) {
	                    applyFieldsState(column, columnsUserState[userStateColumnIndex])
	                }
	                if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {
	                    resultColumns[userStateColumnIndex] = column
	                } else {
	                    resultColumns.push(column)
	                }
	            }
	            for (i = 0; i < columnsUserState.length; i++) {
	                columnUserState = columnsUserState[i];
	                if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {
	                    column = createColumn(that, columnUserState.added);
	                    applyFieldsState(column, columnUserState);
	                    resultColumns.push(column)
	                }
	            }
	            assignColumns(that, resultColumns)
	        }
	    };
	    var updateIndexes = function(that, column) {
	        updateColumnIndexes(that);
	        updateColumnGroupIndexes(that, column);
	        updateColumnSortIndexes(that, column);
	        updateColumnVisibleIndexes(that, column)
	    };
	    var assignColumns = function(that, columns) {
	        that._columns = columns;
	        that._visibleColumns = void 0;
	        that._fixedColumns = void 0;
	        that._rowCount = void 0;
	        that.updateColumnDataTypes()
	    };
	    var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
	        var columnChanges = that._columnChanges || {
	            optionNames: {
	                length: 0
	            },
	            changeTypes: {
	                length: 0
	            },
	            columnIndex: columnIndex
	        };
	        optionName = optionName || "all";
	        var changeTypes = columnChanges.changeTypes;
	        if (changeType && !changeTypes[changeType]) {
	            changeTypes[changeType] = true;
	            changeTypes.length++
	        }
	        var optionNames = columnChanges.optionNames;
	        if (optionName && !optionNames[optionName]) {
	            optionNames[optionName] = true;
	            optionNames.length++
	        }
	        if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {
	            delete columnChanges.columnIndex
	        }
	        that._columnChanges = columnChanges;
	        that._visibleColumns = void 0;
	        that._fixedColumns = void 0;
	        that._rowCount = void 0
	    };
	    var fireColumnsChanged = function(that) {
	        var onColumnsChanging = that.option("onColumnsChanging"),
	            columnChanges = that._columnChanges;
	        if (that.isInitialized() && !that._updateLockCount && columnChanges) {
	            if (onColumnsChanging) {
	                that._updateLockCount++;
	                onColumnsChanging($.extend({
	                    component: that.component
	                }, columnChanges));
	                that._updateLockCount--
	            }
	            that._columnChanges = void 0;
	            if (columnChanges.optionNames && (columnChanges.optionNames.dataField || columnChanges.optionNames.lookup)) {
	                that.reinit()
	            } else {
	                that.columnsChanged.fire(columnChanges)
	            }
	        }
	    };
	    var columnOptionCore = function(that, column, optionName, value, notFireEvent) {
	        var prevValue, optionSetter, columns, changeType, optionGetter = dataCoreUtils.compileGetter(optionName),
	            columnIndex = column.index;
	        if (3 === arguments.length) {
	            return optionGetter(column, {
	                functionsAsIs: true
	            })
	        }
	        prevValue = optionGetter(column, {
	            functionsAsIs: true
	        });
	        if (prevValue !== value) {
	            if ("groupIndex" === optionName) {
	                changeType = "grouping"
	            } else {
	                if ("sortIndex" === optionName || "sortOrder" === optionName) {
	                    changeType = "sorting"
	                } else {
	                    changeType = "columns"
	                }
	            }
	            optionSetter = dataCoreUtils.compileSetter(optionName);
	            optionSetter(column, value, {
	                functionsAsIs: true
	            });
	            if (!isDefined(prevValue) && !isDefined(value)) {
	                notFireEvent = true
	            }
	            if (!notFireEvent) {
	                if ($.inArray(optionName, USER_STATE_FIELD_NAMES) < 0 && "visibleWidth" !== optionName) {
	                    columns = that.option("columns");
	                    column = columns && columns[columnIndex];
	                    if (commonUtils.isString(column)) {
	                        column = columns[columnIndex] = {
	                            dataField: column
	                        }
	                    }
	                    if (column) {
	                        optionSetter(column, value, {
	                            functionsAsIs: true
	                        })
	                    }
	                }
	                updateColumnChanges(that, changeType, optionName, columnIndex)
	            }
	        }
	    };
	    var isSortOrderValid = function(sortOrder) {
	        return "asc" === sortOrder || "desc" === sortOrder
	    };
	    var addExpandColumn = function(that) {
	        that.addCommandColumn({
	            command: "expand",
	            width: "auto",
	            cssClass: DATAGRID_COMMAND_EXPAND_CLASS,
	            allowEditing: false,
	            allowGrouping: false,
	            allowSorting: false,
	            allowResizing: false,
	            allowReordering: false,
	            allowHiding: false
	        })
	    };
	    var defaultSetCellValue = function(data, value) {
	        var name, i, path = this.dataField.split("."),
	            dotCount = path.length - 1;
	        if (this.serializeValue) {
	            value = this.serializeValue(value)
	        }
	        for (i = 0; i < dotCount; i++) {
	            name = path[i];
	            data = data[name] = data[name] || {}
	        }
	        data[path[dotCount]] = value
	    };
	    var getDataColumns = function(columns, rowIndex, bandColumnID) {
	        var result = [];
	        rowIndex = rowIndex || 0;
	        columns[rowIndex] && $.each(columns[rowIndex], function(_, column) {
	            if (column.ownerBand === bandColumnID || isDefined(column.groupIndex)) {
	                if (!column.isBand || !column.colspan) {
	                    if (!column.command || rowIndex < 1) {
	                        result.push(column)
	                    }
	                } else {
	                    result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index))
	                }
	            }
	        });
	        return result
	    };
	    var isChildrenColumnVisibleInHeaders = function(that, columnID) {
	        var result;
	        $.each(that.getChildrenByBandColumn(columnID), function(_, column) {
	            if (column.visible) {
	                if (column.isBand) {
	                    result = isChildrenColumnVisibleInHeaders(that, column.index)
	                } else {
	                    if (column.ownerBand === columnID) {
	                        result = true
	                    }
	                }
	            }
	            return !result
	        });
	        return result
	    };
	    var getRowCount = function(that, level, bandColumnIndex) {
	        var rowCount, visibleInHeaders;
	        level = level || 1;
	        rowCount = level;
	        $.each(that._columns, function(_, column) {
	            if (column.isBand && column.visible && column.ownerBand === bandColumnIndex) {
	                visibleInHeaders = isChildrenColumnVisibleInHeaders(that, column.index);
	                if (visibleInHeaders) {
	                    rowCount = Math.max(rowCount, getRowCount(that, level + 1, column.index))
	                }
	            }
	        });
	        return rowCount
	    };
	    var getFixedPosition = function(column) {
	        return !column.fixedPosition ? "left" : column.fixedPosition
	    };
	    var processExpandColumns = function(columns, expandColumns, columnIndex) {
	        var rowspan = columns[columnIndex] && columns[columnIndex].rowspan,
	            expandColumnsByRow = expandColumns.slice(0);
	        if (rowspan > 1) {
	            expandColumnsByRow = $.map(expandColumnsByRow, function(expandColumn) {
	                return $.extend({}, expandColumn, {
	                    rowspan: rowspan
	                })
	            })
	        }
	        expandColumnsByRow.unshift(columnIndex, 0);
	        columns.splice.apply(columns, expandColumnsByRow);
	        return rowspan || 1
	    };
	    var digitsCount = function(number) {
	        var i;
	        for (i = 0; number > 1; i++) {
	            number /= 10
	        }
	        return i
	    };
	    var numberToString = function(number, digitsCount) {
	        var str = number ? number.toString() : "0";
	        while (str.length < digitsCount) {
	            str = "0" + str
	        }
	        return str
	    };
	    return {
	        _endUpdateCore: function() {
	            fireColumnsChanged(this)
	        },
	        init: function() {
	            var that = this,
	                columns = that.option("columns");
	            that._commandColumns = that._commandColumns || [];
	            that._columns = that._columns || [];
	            addExpandColumn(that);
	            that._isColumnsFromOptions = !!columns;
	            if (that._isColumnsFromOptions) {
	                assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);
	                applyUserState(that)
	            } else {
	                assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns)
	            }
	            if (that._dataSourceApplied) {
	                that.applyDataSource(that._dataSource, true)
	            } else {
	                updateIndexes(that)
	            }
	        },
	        callbackNames: function() {
	            return ["columnsChanged"]
	        },
	        optionChanged: function(args) {
	            switch (args.name) {
	                case "adaptColumnWidthByRatio":
	                    args.handled = true;
	                    break;
	                case "columns":
	                    args.handled = true;
	                    if (args.name === args.fullName) {
	                        this._columnsUserState = null;
	                        this._ignoreColumnOptionNames = null;
	                        this.init()
	                    } else {
	                        this.reinit()
	                    }
	                    break;
	                case "commonColumnSettings":
	                case "columnAutoWidth":
	                case "allowColumnResizing":
	                case "allowColumnReordering":
	                case "columnFixing":
	                case "grouping":
	                case "groupPanel":
	                case "regenerateColumnsByVisibleItems":
	                case "customizeColumns":
	                case "editing":
	                case "columnHidingEnabled":
	                    args.handled = true;
	                    this.reinit();
	                    break;
	                case "rtlEnabled":
	                    this.reinit();
	                    break;
	                default:
	                    this.callBase(args)
	            }
	        },
	        publicMethods: function() {
	            return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns"]
	        },
	        applyDataSource: function(dataSource, forceApplying) {
	            var that = this,
	                isDataSourceLoaded = dataSource && dataSource.isLoaded();
	            that._dataSource = dataSource;
	            if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option("regenerateColumnsByVisibleItems")) {
	                if (isDataSourceLoaded) {
	                    if (!that._isColumnsFromOptions) {
	                        assignColumns(that, createColumnsFromDataSource(that, dataSource));
	                        that._dataSourceColumnsCount = that._columns.length;
	                        applyUserState(that)
	                    }
	                    return that.updateColumns(dataSource, forceApplying)
	                } else {
	                    that._dataSourceApplied = false
	                }
	            } else {
	                if (isDataSourceLoaded && !that.isAllDataTypesDefined() && that.updateColumnDataTypes(dataSource)) {
	                    updateColumnChanges(that, "columns");
	                    fireColumnsChanged(that)
	                }
	            }
	        },
	        reset: function() {
	            this._dataSourceApplied = false;
	            this._dataSourceColumnsCount = void 0;
	            this.reinit()
	        },
	        reinit: function() {
	            this._columnsUserState = this.getUserState();
	            this._ignoreColumnOptionNames = null;
	            this.init()
	        },
	        isInitialized: function() {
	            return !!this._columns.length || !!this.option("columns")
	        },
	        isDataSourceApplied: function() {
	            return this._dataSourceApplied
	        },
	        getCommonSettings: function() {
	            var commonColumnSettings = this.option("commonColumnSettings") || {},
	                groupingOptions = this.option("grouping") || {},
	                groupPanelOptions = this.option("groupPanel") || {};
	            return $.extend({
	                allowFixing: this.option("columnFixing.enabled"),
	                allowResizing: this.option("allowColumnResizing"),
	                allowReordering: this.option("allowColumnReordering"),
	                autoExpandGroup: groupingOptions.autoExpandAll,
	                allowCollapsing: groupingOptions.allowCollapsing,
	                allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled
	            }, commonColumnSettings)
	        },
	        isColumnOptionUsed: function(optionName) {
	            for (var i = 0; i < this._columns.length; i++) {
	                if (this._columns[i][optionName]) {
	                    return true
	                }
	            }
	        },
	        isAllDataTypesDefined: function() {
	            var i, columns = this._columns;
	            if (!columns.length) {
	                return false
	            }
	            for (i = 0; i < columns.length; i++) {
	                if (!columns[i].dataType) {
	                    return false
	                }
	            }
	            return true
	        },
	        getColumns: function() {
	            return this._columns
	        },
	        getGroupColumns: function() {
	            var result = [];
	            $.each(this._columns, function() {
	                var column = this;
	                if (isDefined(column.groupIndex)) {
	                    result[column.groupIndex] = column
	                }
	            });
	            return result
	        },
	        getVisibleColumns: function(rowIndex) {
	            this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();
	            rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;
	            return this._visibleColumns[rowIndex] || []
	        },
	        getFixedColumns: function(rowIndex) {
	            this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();
	            rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;
	            return this._fixedColumns[rowIndex] || []
	        },
	        _getFixedColumnsCore: function() {
	            var i, j, column, prevColumn, notFixedColumnCount, transparentColumnIndex, lastFixedPosition, visibleColumns, that = this,
	                result = [],
	                rowCount = that.getRowCount(),
	                isColumnFixing = that._isColumnFixing(),
	                transparentColumn = {
	                    command: "transparent"
	                },
	                transparentColspan = 0;
	            if (isColumnFixing) {
	                for (i = 0; i <= rowCount; i++) {
	                    notFixedColumnCount = 0;
	                    lastFixedPosition = null;
	                    transparentColumnIndex = null;
	                    visibleColumns = that.getVisibleColumns(i);
	                    for (j = 0; j < visibleColumns.length; j++) {
	                        prevColumn = visibleColumns[j - 1];
	                        column = visibleColumns[j];
	                        if (!column.command) {
	                            if (!column.fixed) {
	                                if (0 === i) {
	                                    if (column.isBand && column.colspan) {
	                                        transparentColspan += column.colspan
	                                    } else {
	                                        transparentColspan++
	                                    }
	                                }
	                                notFixedColumnCount++;
	                                if (!isDefined(transparentColumnIndex)) {
	                                    transparentColumnIndex = j
	                                }
	                            } else {
	                                if (prevColumn && prevColumn.fixed && getFixedPosition(prevColumn) !== getFixedPosition(column)) {
	                                    if (!isDefined(transparentColumnIndex)) {
	                                        transparentColumnIndex = j
	                                    }
	                                } else {
	                                    lastFixedPosition = column.fixedPosition
	                                }
	                            }
	                        }
	                    }
	                    if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {
	                        return []
	                    }
	                    if (!isDefined(transparentColumnIndex)) {
	                        transparentColumnIndex = "right" === lastFixedPosition ? 0 : visibleColumns.length
	                    }
	                    result[i] = visibleColumns.slice(0);
	                    if (!transparentColumn.colspan) {
	                        transparentColumn.colspan = transparentColspan
	                    }
	                    result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn)
	                }
	            }
	            return result
	        },
	        _isColumnFixing: function() {
	            var isColumnFixing = this.option("columnFixing.enabled");
	            !isColumnFixing && $.each(this._columns, function(_, column) {
	                if (column.fixed) {
	                    isColumnFixing = true;
	                    return false
	                }
	            });
	            return isColumnFixing
	        },
	        _getExpandColumnsCore: function() {
	            return this.getGroupColumns()
	        },
	        getExpandColumns: function() {
	            var expandColumn, expandColumns = this._getExpandColumnsCore();
	            if (expandColumns.length) {
	                expandColumn = this.columnOption("command:expand")
	            }
	            expandColumns = $.map(expandColumns, function(column) {
	                return $.extend({}, column, {
	                    visibleWidth: "auto"
	                }, expandColumn, {
	                    index: column.index
	                })
	            });
	            return expandColumns
	        },
	        _getVisibleColumnsCore: function() {
	            var i, firstPositiveIndexColumn, isFixedToEnd, that = this,
	                result = [],
	                rowspanExpandColumns = 0,
	                expandColumns = that.getExpandColumns(),
	                rowCount = that.getRowCount(),
	                positiveIndexedColumns = [],
	                negativeIndexedColumns = [],
	                notGroupedColumnsCount = 0,
	                rtlEnabled = that.option("rtlEnabled"),
	                columns = $.extend(true, [], that._columns.length ? that._commandColumns.concat(that._columns) : []),
	                columnDigitsCount = digitsCount(columns.length);
	            processBandColumns(that, columns);
	            for (i = 0; i < rowCount; i++) {
	                result[i] = [];
	                negativeIndexedColumns[i] = [{}];
	                positiveIndexedColumns[i] = [{}, {}, {}]
	            }
	            $.each(columns, function(index) {
	                var rowIndex, indexedColumns, column = this,
	                    visibleIndex = column.visibleIndex,
	                    parentBandColumns = getParentBandColumns(index, columns),
	                    visible = column.visible && that.isParentColumnVisible(column.index);
	                if (visible && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
	                    rowIndex = parentBandColumns.length;
	                    if (visibleIndex < 0) {
	                        visibleIndex = -visibleIndex;
	                        indexedColumns = negativeIndexedColumns[rowIndex]
	                    } else {
	                        column.fixed = parentBandColumns.length ? parentBandColumns[0].fixed : column.fixed;
	                        column.fixedPosition = parentBandColumns.length ? parentBandColumns[0].fixedPosition : column.fixedPosition;
	                        if (column.fixed || column.command) {
	                            isFixedToEnd = "right" === column.fixedPosition;
	                            if (rtlEnabled) {
	                                isFixedToEnd = !isFixedToEnd
	                            }
	                            if (isFixedToEnd || column.command) {
	                                indexedColumns = positiveIndexedColumns[rowIndex][2]
	                            } else {
	                                indexedColumns = positiveIndexedColumns[rowIndex][0]
	                            }
	                        } else {
	                            indexedColumns = positiveIndexedColumns[rowIndex][1]
	                        }
	                    }
	                    if (parentBandColumns.length) {
	                        visibleIndex = numberToString(visibleIndex, columnDigitsCount);
	                        for (i = parentBandColumns.length - 1; i >= 0; i--) {
	                            visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex
	                        }
	                    }
	                    indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
	                    indexedColumns[visibleIndex].push(column);
	                    notGroupedColumnsCount++
	                }
	            });
	            $.each(result, function(rowIndex) {
	                objectUtils.orderEach(negativeIndexedColumns[rowIndex], function(_, columns) {
	                    result[rowIndex].unshift.apply(result[rowIndex], columns)
	                });
	                firstPositiveIndexColumn = result[rowIndex].length;
	                $.each(positiveIndexedColumns[rowIndex], function(index, columnsByFixing) {
	                    objectUtils.orderEach(columnsByFixing, function(_, columnsByVisibleIndex) {
	                        result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex)
	                    })
	                });
	                if (rowspanExpandColumns < rowIndex + 1) {
	                    rowspanExpandColumns += processExpandColumns(result[rowIndex], expandColumns, firstPositiveIndexColumn)
	                }
	            });
	            result.push(getDataColumns(result));
	            if (!notGroupedColumnsCount && that._columns.length) {
	                result[rowCount].push({
	                    command: "empty"
	                })
	            }
	            return result
	        },
	        getInvisibleColumns: function(columns, bandColumnIndex) {
	            var hiddenColumnsByBand, that = this,
	                result = [];
	            columns = columns || that._columns;
	            $.each(columns, function(_, column) {
	                if (column.ownerBand !== bandColumnIndex) {
	                    return
	                }
	                if (column.isBand) {
	                    if (!column.visible) {
	                        hiddenColumnsByBand = that.getChildrenByBandColumn(column.index)
	                    } else {
	                        hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index)
	                    }
	                    if (hiddenColumnsByBand.length) {
	                        result.push(column);
	                        result = result.concat(hiddenColumnsByBand)
	                    }
	                    return
	                }
	                if (!column.visible) {
	                    result.push(column)
	                }
	            });
	            return result
	        },
	        getChooserColumns: function(getAllColumns) {
	            var columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();
	            return $.grep(columns, function(column) {
	                return column.showInColumnChooser
	            })
	        },
	        allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
	            var that = this,
	                columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
	                sourceColumn = that._columns[columnIndex];
	            if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
	                if (sourceLocation === targetLocation) {
	                    if (sourceLocation === COLUMN_CHOOSER_LOCATION) {
	                        return false
	                    }
	                    fromVisibleIndex = commonUtils.isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;
	                    toVisibleIndex = commonUtils.isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
	                    return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex
	                } else {
	                    if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {
	                        return sourceColumn && sourceColumn.allowGrouping
	                    } else {
	                        if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {
	                            return sourceColumn && sourceColumn.allowHiding
	                        }
	                    }
	                }
	                return true
	            }
	            return false
	        },
	        moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
	            var targetGroupIndex, column, that = this,
	                fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
	                toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation),
	                isGroupMoving = sourceLocation === GROUP_LOCATION || targetLocation === GROUP_LOCATION;
	            if (fromIndex >= 0) {
	                column = that._columns[fromIndex];
	                toVisibleIndex = commonUtils.isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
	                targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
	                if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
	                    if (targetGroupIndex > column.groupIndex) {
	                        targetGroupIndex--
	                    }
	                    delete column.groupIndex;
	                    delete column.sortOrder;
	                    updateColumnGroupIndexes(that)
	                }
	                if (targetLocation === GROUP_LOCATION) {
	                    moveColumnToGroup(that, column, targetGroupIndex);
	                    updateColumnGroupIndexes(that)
	                } else {
	                    if (toVisibleIndex >= 0) {
	                        var targetColumn = that._columns[toIndex];
	                        if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {
	                            column.visibleIndex = void 0
	                        } else {
	                            if (column.fixed ^ targetColumn.fixed) {
	                                column.visibleIndex = void 0
	                            } else {
	                                column.visibleIndex = targetColumn.visibleIndex
	                            }
	                        }
	                        updateColumnVisibleIndexes(that, column)
	                    }
	                }
	                column.visible = targetLocation !== COLUMN_CHOOSER_LOCATION;
	                updateColumnChanges(that, isGroupMoving ? "grouping" : "columns");
	                fireColumnsChanged(that)
	            }
	        },
	        changeSortOrder: function(columnIndex, sortOrder) {
	            var that = this,
	                sortingOptions = that.option("sorting"),
	                sortingMode = sortingOptions && sortingOptions.mode,
	                needResetSorting = "single" === sortingMode || !sortOrder,
	                allowSorting = "single" === sortingMode || "multiple" === sortingMode,
	                column = that._columns[columnIndex],
	                nextSortOrder = function(column) {
	                    if ("ctrl" === sortOrder) {
	                        if (!("sortOrder" in column && "sortIndex" in column)) {
	                            return false
	                        }
	                        delete column.sortOrder;
	                        delete column.sortIndex
	                    } else {
	                        if (isDefined(column.groupIndex) || isDefined(column.sortIndex)) {
	                            column.sortOrder = "desc" === column.sortOrder ? "asc" : "desc"
	                        } else {
	                            column.sortOrder = "asc"
	                        }
	                    }
	                    return true
	                },
	                isSortingChanged = false;
	            if (allowSorting && column && column.allowSorting) {
	                if (needResetSorting && !isDefined(column.groupIndex)) {
	                    $.each(that._columns, function(index) {
	                        if (index !== columnIndex && this.sortOrder && !isDefined(this.groupIndex)) {
	                            delete this.sortOrder;
	                            delete this.sortIndex;
	                            isSortingChanged = true
	                        }
	                    })
	                }
	                if (isSortOrderValid(sortOrder)) {
	                    if (column.sortOrder !== sortOrder) {
	                        column.sortOrder = sortOrder;
	                        isSortingChanged = true
	                    }
	                } else {
	                    if ("none" === sortOrder) {
	                        if (column.sortOrder) {
	                            delete column.sortIndex;
	                            delete column.sortOrder;
	                            isSortingChanged = true
	                        }
	                    } else {
	                        isSortingChanged = nextSortOrder(column)
	                    }
	                }
	            }
	            if (isSortingChanged) {
	                updateColumnSortIndexes(that);
	                updateColumnChanges(that, "sorting");
	                fireColumnsChanged(that)
	            }
	        },
	        getSortDataSourceParameters: function(useLocalSelector) {
	            var that = this,
	                sortColumns = [],
	                sort = [];
	            $.each(that._columns, function() {
	                if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {
	                    sortColumns[this.sortIndex] = this
	                }
	            });
	            $.each(sortColumns, function() {
	                var sortOrder = this && this.sortOrder;
	                if (isSortOrderValid(sortOrder)) {
	                    sort.push({
	                        selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
	                        desc: "desc" === this.sortOrder
	                    })
	                }
	            });
	            return sort.length > 0 ? sort : null
	        },
	        getGroupDataSourceParameters: function(useLocalSelector) {
	            var group = [];
	            $.each(this.getGroupColumns(), function() {
	                var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
	                if (selector) {
	                    group.push({
	                        selector: selector,
	                        desc: "desc" === this.sortOrder,
	                        isExpanded: !!this.autoExpandGroup
	                    })
	                }
	            });
	            return group.length > 0 ? group : null
	        },
	        refresh: function(updateNewLookupsOnly) {
	            var deferreds = [];
	            $.each(this._columns, function() {
	                var lookup = this.lookup;
	                if (lookup && !this.calculateDisplayValue) {
	                    if (updateNewLookupsOnly && lookup.valueMap) {
	                        return
	                    }
	                    if (lookup.update) {
	                        deferreds.push(lookup.update())
	                    }
	                }
	            });
	            return when.apply($, deferreds)
	        },
	        _updateColumnOptions: function(column) {
	            column.selector = column.selector || function(data) {
	                return column.calculateCellValue(data)
	            };
	            $.each(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], function(_, calculateCallbackName) {
	                var calculateCallback = column[calculateCallbackName];
	                if (commonUtils.isFunction(calculateCallback) && !calculateCallback.originalCallback) {
	                    column[calculateCallbackName] = function(data) {
	                        return calculateCallback.call(column, data)
	                    };
	                    column[calculateCallbackName].originalCallback = calculateCallback
	                }
	            });
	            if (commonUtils.isString(column.calculateDisplayValue)) {
	                column.displayField = column.calculateDisplayValue;
	                column.calculateDisplayValue = dataCoreUtils.compileGetter(column.displayField)
	            }
	            if (column.calculateDisplayValue) {
	                column.displayValueMap = column.displayValueMap || {}
	            }
	            updateSerializers(column, column.dataType);
	            var lookup = column.lookup;
	            if (lookup) {
	                updateSerializers(lookup, lookup.dataType)
	            }
	            var dataType = lookup ? lookup.dataType : column.dataType;
	            if (dataType) {
	                column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option("rtlEnabled"));
	                column.format = column.format || gridCore.getFormatByDataType(dataType);
	                column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
	                if (!isDefined(column.filterOperations)) {
	                    column.filterOperations = !lookup && DATATYPE_OPERATIONS[dataType] || []
	                }
	                column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
	                column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : "boolean" === dataType && !column.cellTemplate
	            }
	        },
	        updateColumnDataTypes: function(dataSource) {
	            var that = this,
	                firstItems = getFirstItems(dataSource),
	                isColumnDataTypesUpdated = false;
	            $.each(that._columns, function(index, column) {
	                var i, value, dataType, lookupDataType, valueDataType, lookup = column.lookup;
	                if (column.calculateCellValue && firstItems.length) {
	                    if (!column.dataType || lookup && !lookup.dataType) {
	                        for (i = 0; i < firstItems.length; i++) {
	                            value = column.calculateCellValue(firstItems[i]);
	                            valueDataType = column.dataType || getValueDataType(value);
	                            dataType = dataType || valueDataType;
	                            if (dataType && valueDataType && dataType !== valueDataType) {
	                                dataType = "string"
	                            }
	                            if (lookup) {
	                                valueDataType = lookup.dataType || getValueDataType(gridCore.getDisplayValue(column, value, firstItems[i]));
	                                lookupDataType = lookupDataType || valueDataType;
	                                if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {
	                                    lookupDataType = "string"
	                                }
	                            }
	                        }
	                        column.dataType = dataType;
	                        if (lookup) {
	                            lookup.dataType = lookupDataType
	                        }
	                        if (dataType) {
	                            isColumnDataTypesUpdated = true
	                        }
	                    }
	                    if (!column.serializationFormat || lookup && !lookup.serializationFormat) {
	                        for (i = 0; i < firstItems.length; i++) {
	                            value = column.calculateCellValue(firstItems[i], true);
	                            column.serializationFormat = column.serializationFormat || getSerializationFormat(column.dataType, value);
	                            if (lookup) {
	                                lookup.serializationFormat = lookup.serializationFormat || getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))
	                            }
	                        }
	                    }
	                }
	                that._updateColumnOptions(column)
	            });
	            return isColumnDataTypesUpdated
	        },
	        _customizeColumns: function(columns) {
	            var that = this,
	                customizeColumns = that.option("customizeColumns");
	            if (customizeColumns) {
	                customizeColumns(columns);
	                assignColumns(that, createColumnsFromOptions(that, columns))
	            }
	        },
	        updateColumns: function(dataSource, forceApplying) {
	            var sortParameters, groupParameters, that = this;
	            if (!forceApplying) {
	                that.updateSortingGrouping(dataSource)
	            }
	            if (!dataSource || dataSource.isLoaded()) {
	                sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();
	                groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();
	                that._customizeColumns(that._columns);
	                updateIndexes(that);
	                return when(that.refresh(true)).always(function() {
	                    that._updateChanges(dataSource, {
	                        sorting: sortParameters,
	                        grouping: groupParameters
	                    });
	                    fireColumnsChanged(that)
	                })
	            }
	        },
	        _updateChanges: function(dataSource, parameters) {
	            var that = this;
	            if (dataSource) {
	                that.updateColumnDataTypes(dataSource);
	                that._dataSourceApplied = true
	            }
	            if (!equalSortParameters(parameters.sorting, that.getSortDataSourceParameters())) {
	                updateColumnChanges(that, "sorting")
	            }
	            if (!equalSortParameters(parameters.grouping, that.getGroupDataSourceParameters())) {
	                updateColumnChanges(that, "grouping")
	            }
	            updateColumnChanges(that, "columns")
	        },
	        updateSortingGrouping: function(dataSource, fromDataSource) {
	            var sortParameters, groupParameters, columnsGroupParameters, columnsSortParameters, isColumnsChanged, that = this,
	                updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {
	                    var i, selector, isExpanded;
	                    $.each(columns, function(index, column) {
	                        delete column[indexParameterName];
	                        if (sortParameters) {
	                            for (i = 0; i < sortParameters.length; i++) {
	                                selector = sortParameters[i].selector;
	                                isExpanded = sortParameters[i].isExpanded;
	                                if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue) {
	                                    column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
	                                    if (void 0 !== isExpanded) {
	                                        column.autoExpandGroup = isExpanded
	                                    }
	                                    column[indexParameterName] = i;
	                                    break
	                                }
	                            }
	                        }
	                    })
	                };
	            if (dataSource) {
	                sortParameters = normalizeSortingInfo(dataSource.sort());
	                groupParameters = normalizeSortingInfo(dataSource.group());
	                columnsGroupParameters = that.getGroupDataSourceParameters();
	                columnsSortParameters = that.getSortDataSourceParameters();
	                if (!that._columns.length) {
	                    $.each(groupParameters, function(index, group) {
	                        that._columns.push(group.selector)
	                    });
	                    $.each(sortParameters, function(index, sort) {
	                        that._columns.push(sort.selector)
	                    });
	                    assignColumns(that, createColumnsFromOptions(that, that._columns))
	                }
	                if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && !equalSortParameters(groupParameters, columnsGroupParameters)) {
	                    updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
	                    if (fromDataSource) {
	                        updateColumnChanges(that, "grouping");
	                        isColumnsChanged = true
	                    }
	                }
	                if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !equalSortParameters(sortParameters, columnsSortParameters)) {
	                    updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
	                    if (fromDataSource) {
	                        updateColumnChanges(that, "sorting");
	                        isColumnsChanged = true
	                    }
	                }
	                if (isColumnsChanged) {
	                    fireColumnsChanged(that)
	                }
	            }
	        },
	        updateFilter: function(filter, allowSelectorUpdate, columnIndex) {
	            var that = this;
	            if (!commonUtils.isArray(filter)) {
	                return filter
	            }
	            var column, i;
	            filter = $.extend([], filter);
	            columnIndex = filter.columnIndex || columnIndex;
	            if (allowSelectorUpdate && commonUtils.isString(filter[0])) {
	                column = that.columnOption(filter[0]);
	                if (column && column.selector) {
	                    filter[0] = column.selector;
	                    filter[0].columnIndex = column.index
	                }
	            } else {
	                if (commonUtils.isFunction(filter[0])) {
	                    filter[0].columnIndex = columnIndex
	                }
	            }
	            for (i = 0; i < filter.length; i++) {
	                filter[i] = that.updateFilter(filter[i], allowSelectorUpdate, columnIndex)
	            }
	            return filter
	        },
	        columnCount: function() {
	            return this._columns.length
	        },
	        columnOption: function(identifier, option, value, notFireEvent) {
	            var i, needUpdateIndexes, column, that = this,
	                identifierOptionName = commonUtils.isString(identifier) && identifier.substr(0, identifier.indexOf(":")),
	                columns = identifier < 0 || "command" === identifierOptionName ? that._commandColumns : that._columns;
	            if (void 0 === identifier) {
	                return
	            }
	            if (identifierOptionName) {
	                identifier = identifier.substr(identifierOptionName.length + 1)
	            }
	            for (i = 0; i < columns.length; i++) {
	                if (identifierOptionName) {
	                    if ("" + columns[i][identifierOptionName] === identifier) {
	                        column = columns[i];
	                        break
	                    }
	                } else {
	                    if (columns[i].index === identifier || columns[i].name === identifier || columns[i].dataField === identifier || columns[i].caption === identifier) {
	                        column = columns[i];
	                        break
	                    }
	                }
	            }
	            if (column) {
	                if (1 === arguments.length) {
	                    return $.extend({}, column)
	                }
	                if (commonUtils.isString(option)) {
	                    if (2 === arguments.length) {
	                        return columnOptionCore(that, column, option)
	                    } else {
	                        needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[option];
	                        columnOptionCore(that, column, option, value, notFireEvent)
	                    }
	                } else {
	                    if (commonUtils.isObject(option)) {
	                        $.each(option, function(optionName, value) {
	                            needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[optionName];
	                            columnOptionCore(that, column, optionName, value, notFireEvent)
	                        })
	                    }
	                }
	                if (needUpdateIndexes) {
	                    updateIndexes(that, column)
	                }
	                fireColumnsChanged(that)
	            }
	        },
	        clearSorting: function() {
	            var i, that = this,
	                columnCount = this.columnCount();
	            that.beginUpdate();
	            for (i = 0; i < columnCount; i++) {
	                that.columnOption(i, "sortOrder", void 0)
	            }
	            that.endUpdate()
	        },
	        clearGrouping: function() {
	            var i, that = this,
	                columnCount = this.columnCount();
	            that.beginUpdate();
	            for (i = 0; i < columnCount; i++) {
	                that.columnOption(i, "groupIndex", void 0)
	            }
	            that.endUpdate()
	        },
	        getVisibleIndex: function(index, rowIndex) {
	            var i, columns = this.getVisibleColumns(rowIndex);
	            for (i = columns.length - 1; i >= 0; i--) {
	                if (columns[i].index === index) {
	                    return i
	                }
	            }
	            return -1
	        },
	        addColumn: function(options) {
	            var that = this,
	                column = createColumn(that, options);
	            column.added = options;
	            that._columns.push(column);
	            updateIndexes(that, column);
	            that.updateColumns(that._dataSource)
	        },
	        deleteColumn: function(id) {
	            var that = this,
	                columnIndex = that.columnOption(id, "index");
	            if (columnIndex >= 0) {
	                that._columns.splice(columnIndex, 1);
	                updateIndexes(that);
	                that.updateColumns(that._dataSource)
	            }
	        },
	        addCommandColumn: function(options) {
	            var i, commandColumns = this._commandColumns;
	            for (i = 0; i < commandColumns.length; i++) {
	                if (commandColumns[i].command === options.command) {
	                    return
	                }
	            }
	            commandColumns.push(options)
	        },
	        getUserState: function() {
	            var i, columns = this._columns,
	                result = [];

	            function handleStateField(index, value) {
	                if (void 0 !== columns[i][value]) {
	                    result[i][value] = columns[i][value]
	                }
	            }
	            for (i = 0; i < columns.length; i++) {
	                result[i] = {};
	                $.each(USER_STATE_FIELD_NAMES, handleStateField)
	            }
	            return result
	        },
	        setUserState: function(state) {
	            var commonColumnSettings, that = this,
	                ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
	            if (!ignoreColumnOptionNames) {
	                ignoreColumnOptionNames = [];
	                commonColumnSettings = that.getCommonSettings();
	                if (!that.option("columnChooser.enabled")) {
	                    ignoreColumnOptionNames.push("visible")
	                }
	                if ("none" === that.option("sorting.mode")) {
	                    ignoreColumnOptionNames.push("sortIndex", "sortOrder")
	                }
	                if (!commonColumnSettings.allowGrouping) {
	                    ignoreColumnOptionNames.push("groupIndex")
	                }
	                if (!commonColumnSettings.allowFixing) {
	                    ignoreColumnOptionNames.push("fixed", "fixedPosition")
	                }
	                if (!commonColumnSettings.allowResizing) {
	                    ignoreColumnOptionNames.push("width", "visibleWidth")
	                }
	                if (!that.option("filterRow.visible")) {
	                    ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation")
	                }
	                if (!that.option("headerFilter.visible")) {
	                    ignoreColumnOptionNames.push("filterValues", "filterType")
	                }
	            }
	            that._columnsUserState = state;
	            that._ignoreColumnOptionNames = ignoreColumnOptionNames;
	            that._hasUserState = !!state;
	            that.init()
	        },
	        _createCalculatedColumnOptions: function(columnOptions, bandColumn) {
	            var getter, calculatedColumnOptions = {},
	                dataField = columnOptions.dataField;
	            if (commonUtils.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {
	                calculatedColumnOptions.isBand = true;
	                dataField = null
	            }
	            if (dataField) {
	                if (commonUtils.isString(dataField)) {
	                    getter = dataCoreUtils.compileGetter(dataField);
	                    calculatedColumnOptions = {
	                        caption: inflector.captionize(dataField),
	                        calculateCellValue: function(data, skipDeserialization) {
	                            var value = getter(data);
	                            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
	                        },
	                        setCellValue: defaultSetCellValue,
	                        parseValue: function(text) {
	                            var result, parsedValue, column = this;
	                            if ("number" === column.dataType) {
	                                if (commonUtils.isString(text)) {
	                                    parsedValue = numberLocalization.parse(text);
	                                    if (commonUtils.isNumber(parsedValue)) {
	                                        result = parsedValue
	                                    }
	                                } else {
	                                    if (isDefined(text)) {
	                                        result = Number(text)
	                                    }
	                                }
	                            } else {
	                                if ("boolean" === column.dataType) {
	                                    if (text === column.trueText) {
	                                        result = true
	                                    } else {
	                                        if (text === column.falseText) {
	                                            result = false
	                                        }
	                                    }
	                                } else {
	                                    if ("date" === column.dataType) {
	                                        parsedValue = dateLocalization.parse(text, column.format);
	                                        if (parsedValue) {
	                                            result = parsedValue
	                                        }
	                                    } else {
	                                        result = text
	                                    }
	                                }
	                            }
	                            return result
	                        }
	                    }
	                }
	                calculatedColumnOptions.allowFiltering = true
	            } else {
	                calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression
	            }
	            calculatedColumnOptions.calculateFilterExpression = function() {
	                return gridCore.defaultCalculateFilterExpression.apply(this, arguments)
	            };
	            calculatedColumnOptions.createFilterExpression = function() {
	                var result;
	                if (this.calculateFilterExpression) {
	                    result = this.calculateFilterExpression.apply(this, arguments)
	                }
	                if (result) {
	                    result.columnIndex = this.index
	                }
	                return result
	            };
	            if (!dataField || !commonUtils.isString(dataField)) {
	                $.extend(true, calculatedColumnOptions, {
	                    allowSorting: false,
	                    allowGrouping: false,
	                    calculateCellValue: function() {
	                        return null
	                    }
	                })
	            }
	            if (bandColumn) {
	                calculatedColumnOptions.allowFixing = false
	            }
	            if (columnOptions.dataType) {
	                calculatedColumnOptions.userDataType = columnOptions.dataType
	            }
	            if (columnOptions.selectedFilterOperation) {
	                calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation
	            }
	            if (columnOptions.lookup) {
	                calculatedColumnOptions.lookup = {
	                    calculateCellValue: function(value, skipDeserialization) {
	                        if (this.valueExpr) {
	                            value = this.valueMap && this.valueMap[value]
	                        }
	                        return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
	                    },
	                    updateValueMap: function() {
	                        var calculateValue, calculateDisplayValue, item, i;
	                        this.valueMap = {};
	                        if (this.items) {
	                            calculateValue = dataCoreUtils.compileGetter(this.valueExpr);
	                            calculateDisplayValue = dataCoreUtils.compileGetter(this.displayExpr);
	                            for (i = 0; i < this.items.length; i++) {
	                                item = this.items[i];
	                                this.valueMap[calculateValue(item)] = calculateDisplayValue(item)
	                            }
	                        }
	                    },
	                    update: function() {
	                        var dataSourceOptions, that = this,
	                            dataSource = that.dataSource;
	                        if (dataSource) {
	                            if (commonUtils.isFunction(dataSource) && !isWrapped(dataSource)) {
	                                dataSource = dataSource({})
	                            }
	                            if (commonUtils.isObject(dataSource) || commonUtils.isArray(dataSource)) {
	                                if (that.valueExpr) {
	                                    dataSourceOptions = normalizeDataSourceOptions(dataSource);
	                                    dataSourceOptions.paginate = false;
	                                    dataSource = new DataSourceModule.DataSource(dataSourceOptions);
	                                    return dataSource.load().done(function(data) {
	                                        that.items = data;
	                                        that.updateValueMap && that.updateValueMap()
	                                    })
	                                }
	                            } else {
	                                errors.log("E1016")
	                            }
	                        } else {
	                            that.updateValueMap && that.updateValueMap()
	                        }
	                    }
	                }
	            }
	            calculatedColumnOptions.resizedCallbacks = $.Callbacks();
	            if (columnOptions.resized) {
	                calculatedColumnOptions.resizedCallbacks.add($.proxy(columnOptions.resized, columnOptions))
	            }
	            $.each(calculatedColumnOptions, function(optionName) {
	                var defaultOptionName;
	                if (commonUtils.isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf("default")) {
	                    defaultOptionName = "default" + optionName.charAt(0).toUpperCase() + optionName.substr(1);
	                    calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName]
	                }
	            });
	            return calculatedColumnOptions
	        },
	        getRowCount: function() {
	            this._rowCount = this._rowCount || getRowCount(this);
	            return this._rowCount
	        },
	        getRowIndex: function(columnIndex, alwaysGetRowIndex) {
	            var column = this._columns[columnIndex];
	            return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, this._columns).length : 0
	        },
	        getChildrenByBandColumn: function(bandColumnIndex, rowIndex) {
	            var that = this,
	                result = [];
	            if (isDefined(rowIndex)) {
	                result = $.grep(that.getVisibleColumns(rowIndex), function(column) {
	                    return column.ownerBand === bandColumnIndex && !column.command
	                })
	            } else {
	                $.each(that._columns, function(_, column) {
	                    if ((!isDefined(column.groupIndex) || column.showWhenGrouped) && that.isParentBandColumn(column.index, bandColumnIndex)) {
	                        result.push(column)
	                    }
	                })
	            }
	            return result
	        },
	        isParentBandColumn: function(columnIndex, bandColumnIndex) {
	            var result = false,
	                column = this._columns[columnIndex],
	                parentBandColumns = column && getParentBandColumns(columnIndex, this._columns);
	            if (parentBandColumns) {
	                $.each(parentBandColumns, function(_, bandColumn) {
	                    if (bandColumn.index === bandColumnIndex) {
	                        result = true;
	                        return false
	                    }
	                })
	            }
	            return result
	        },
	        isParentColumnVisible: function(columnIndex) {
	            var result = true,
	                bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, this._columns);
	            bandColumns && $.each(bandColumns, function(_, bandColumn) {
	                result = result && bandColumn.visible;
	                return result
	            });
	            return result
	        }
	    }
	}());
	exports.ColumnsController = ColumnsController;
	gridCore.registerModule("columns", {
	    defaultOptions: function() {
	        return {
	            commonColumnSettings: {
	                allowFiltering: true,
	                allowHiding: true,
	                allowSorting: true,
	                allowEditing: true,
	                encodeHtml: true,
	                trueText: messageLocalization.format("dxDataGrid-trueText"),
	                falseText: messageLocalization.format("dxDataGrid-falseText")
	            },
	            allowColumnReordering: false,
	            allowColumnResizing: false,
	            adaptColumnWidthByRatio: true,
	            columns: void 0,
	            regenerateColumnsByVisibleItems: false,
	            customizeColumns: null
	        }
	    },
	    controllers: {
	        columns: ColumnsController
	    }
	});


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.data_controller.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    gridCoreUtils = __webpack_require__(148),
	    dataSourceAdapterProvider = __webpack_require__(153),
	    ArrayStore = __webpack_require__(129),
	    CustomStore = __webpack_require__(130),
	    errors = __webpack_require__(15),
	    commonUtils = __webpack_require__(8),
	    DataHelperMixin = __webpack_require__(120),
	    equalKeys = commonUtils.equalByValue,
	    when = __webpack_require__(10).when;
	exports.DataController = gridCore.Controller.inherit({}).include(DataHelperMixin).inherit(function() {
	    var members = {
	        init: function() {
	            var that = this;
	            that._items = [];
	            that._columnsController = that.getController("columns");
	            that._columnsChangedHandler = $.proxy(that._handleColumnsChanged, that);
	            that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
	            that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
	            that._loadErrorHandler = $.proxy(that._handleLoadError, that);
	            that._customizeStoreLoadOptionsHandler = $.proxy(that._handleCustomizeStoreLoadOptions, that);
	            that._columnsController.columnsChanged.add(that._columnsChangedHandler);
	            that._isLoading = false;
	            that._isCustomLoading = false;
	            that._changes = [];
	            that.createAction("onDataErrorOccurred");
	            that.dataErrorOccurred.add(function(error) {
	                return that.executeAction("onDataErrorOccurred", {
	                    error: error
	                })
	            });
	            that._refreshDataSource()
	        },
	        callbackNames: function() {
	            return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged"]
	        },
	        callbackFlags: function(name) {
	            if ("dataErrorOccurred" === name) {
	                return {
	                    stopOnFalse: true
	                }
	            }
	        },
	        publicMethods: function() {
	            return ["beginCustomLoading", "endCustomLoading", "refresh", "filter", "clearFilter", "getCombinedFilter", "keyOf", "byKey", "getDataByKeys", "pageIndex", "pageSize", "pageCount", "totalCount", "_disposeDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getDataSource", "getVisibleRows", "repaintRows"]
	        },
	        optionChanged: function(args) {
	            var that = this;

	            function handled() {
	                args.handled = true
	            }

	            function reload() {
	                that._columnsController.reset();
	                that._items = [];
	                that._refreshDataSource()
	            }
	            if ("dataSource" === args.name && args.name === args.fullName && args.value === args.previousValue) {
	                handled();
	                that.refresh();
	                return
	            }
	            switch (args.name) {
	                case "cacheEnabled":
	                case "loadingTimeout":
	                case "remoteOperations":
	                    handled();
	                    break;
	                case "dataSource":
	                case "scrolling":
	                case "paging":
	                    handled();
	                    reload();
	                    break;
	                case "rtlEnabled":
	                    reload();
	                    break;
	                default:
	                    that.callBase(args)
	            }
	        },
	        isReady: function() {
	            return !this._isLoading
	        },
	        getDataSource: function() {
	            return this._dataSource && this._dataSource._dataSource
	        },
	        getCombinedFilter: function(returnDataField) {
	            return this.combinedFilter(void 0, returnDataField)
	        },
	        combinedFilter: function(filter, returnDataField) {
	            var additionalFilter, that = this,
	                dataSource = that._dataSource,
	                columnsController = that._columnsController;
	            if (dataSource) {
	                if (void 0 === filter) {
	                    filter = dataSource.filter()
	                }
	                additionalFilter = that._calculateAdditionalFilter();
	                if (additionalFilter) {
	                    if (columnsController.isDataSourceApplied() || columnsController.isAllDataTypesDefined()) {
	                        filter = gridCore.combineFilters([additionalFilter, filter])
	                    }
	                }
	                filter = columnsController.updateFilter(filter, !returnDataField && !dataSource.remoteOperations().filtering)
	            }
	            return filter
	        },
	        _endUpdateCore: function() {
	            var changes = this._changes;
	            if (changes.length) {
	                this._changes = [];
	                this.updateItems(1 === changes.length ? changes[0] : {})
	            }
	        },
	        _handleCustomizeStoreLoadOptions: function(e) {
	            var columnsController = this._columnsController,
	                dataSource = this._dataSource,
	                storeLoadOptions = e.storeLoadOptions;
	            if (e.isCustomLoading && !storeLoadOptions.isLoadingAll) {
	                return
	            }
	            storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
	            if (!columnsController.isDataSourceApplied()) {
	                columnsController.updateColumnDataTypes(dataSource)
	            }
	            this._columnsUpdating = true;
	            columnsController.updateSortingGrouping(dataSource, !this._isFirstLoading);
	            this._columnsUpdating = false;
	            storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
	            storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
	            dataSource.sort(storeLoadOptions.sort);
	            dataSource.group(storeLoadOptions.group);
	            storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
	            e.group = columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().grouping);
	            this._isFirstLoading = false
	        },
	        _handleColumnsChanged: function(e) {
	            var filterValue, filterValues, that = this,
	                changeTypes = e.changeTypes,
	                optionNames = e.optionNames;
	            var updateItemsHandler = function() {
	                that._columnsController.columnsChanged.remove(updateItemsHandler);
	                that.updateItems()
	            };
	            if (changeTypes.sorting || changeTypes.grouping) {
	                if (that._dataSource && !that._columnsUpdating) {
	                    that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
	                    that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
	                    that.reload()
	                }
	                that.pageChanged.fire()
	            } else {
	                if (changeTypes.columns) {
	                    if (optionNames.filterValues || optionNames.filterValue || optionNames.selectedFilterOperation) {
	                        filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
	                        filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
	                        if (commonUtils.isArray(filterValues) || void 0 === e.columnIndex || commonUtils.isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue) {
	                            that._applyFilter()
	                        }
	                    }
	                    if (!that._needApplyFilter && !gridCore.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "selectedFilterOperation", "filterValues", "filterType"])) {
	                        that._columnsController.columnsChanged.add(updateItemsHandler)
	                    }
	                }
	            }
	        },
	        _handleDataChanged: function(e) {
	            var that = this,
	                dataSource = that._dataSource,
	                columnsController = that._columnsController,
	                isAllDataTypesDefined = columnsController.isAllDataTypesDefined(),
	                isAsyncDataSourceApplying = false;
	            if (dataSource && !that._isDataSourceApplying) {
	                that._isDataSourceApplying = true;
	                when(that._columnsController.applyDataSource(dataSource)).done(function() {
	                    if (that._isLoading) {
	                        that._handleLoadingChanged(false)
	                    }
	                    if (isAsyncDataSourceApplying && e && e.isDelayed) {
	                        e.isDelayed = false
	                    }
	                    that._isDataSourceApplying = false;
	                    var additionalFilter = that._calculateAdditionalFilter(),
	                        needApplyFilter = that._needApplyFilter;
	                    that._needApplyFilter = false;
	                    if (needApplyFilter && additionalFilter && additionalFilter.length && !isAllDataTypesDefined) {
	                        errors.log("W1005", that.component.NAME);
	                        that._applyFilter()
	                    } else {
	                        that.updateItems(e)
	                    }
	                });
	                if (that._isDataSourceApplying) {
	                    isAsyncDataSourceApplying = true;
	                    that._handleLoadingChanged(true)
	                }
	                that._needApplyFilter = !that._columnsController.isDataSourceApplied()
	            }
	        },
	        _handleLoadingChanged: function(isLoading) {
	            this._isLoading = isLoading;
	            this._fireLoadingChanged()
	        },
	        _handleLoadError: function(e) {
	            this.dataErrorOccurred.fire(e)
	        },
	        _initDataSource: function() {
	            var that = this,
	                dataSource = this.option("dataSource"),
	                pageIndex = this.option("paging.pageIndex"),
	                pageSize = this.option("paging.pageSize"),
	                scrollingMode = that.option("scrolling.mode"),
	                pagingEnabled = this.option("paging.enabled"),
	                appendMode = "infinite" === scrollingMode,
	                virtualMode = "virtual" === scrollingMode,
	                oldDataSource = this._dataSource;
	            that.callBase();
	            dataSource = that._dataSource;
	            that._isFirstLoading = true;
	            if (dataSource) {
	                dataSource.requireTotalCount(!appendMode);
	                if (void 0 !== pagingEnabled) {
	                    dataSource.paginate(pagingEnabled || virtualMode || appendMode)
	                }
	                if (void 0 !== pageSize) {
	                    dataSource.pageSize(pageSize)
	                }
	                if (void 0 !== pageIndex) {
	                    dataSource.pageIndex(pageIndex)
	                }
	                that.setDataSource(dataSource)
	            } else {
	                if (oldDataSource) {
	                    that.updateItems()
	                }
	            }
	        },
	        _loadDataSource: function() {
	            var dataSource = this._dataSource;
	            dataSource && dataSource.load()
	        },
	        _processItems: function(items) {
	            var that = this,
	                visibleColumns = that._columnsController.getVisibleColumns(),
	                options = {
	                    visibleColumns: visibleColumns,
	                    dataIndex: 0
	                },
	                result = [];
	            $.each(items, function(index, item) {
	                if (commonUtils.isDefined(item)) {
	                    item = that._processItem(item, options);
	                    result.push(item)
	                }
	            });
	            return result
	        },
	        _processItem: function(item, options) {
	            item = this._generateDataItem(item);
	            item = this._processDataItem(item, options);
	            item.dataIndex = options.dataIndex++;
	            return item
	        },
	        _generateDataItem: function(data) {
	            return {
	                rowType: "data",
	                data: data,
	                key: this.keyOf(data)
	            }
	        },
	        _processDataItem: function(dataItem, options) {
	            dataItem.values = this.generateDataValues(dataItem.data, options.visibleColumns);
	            return dataItem
	        },
	        generateDataValues: function(data, columns) {
	            var column, value, values = [];
	            for (var i = 0; i < columns.length; i++) {
	                column = columns[i];
	                value = null;
	                if (column.command) {
	                    value = null
	                } else {
	                    if (column.calculateCellValue) {
	                        value = column.calculateCellValue(data)
	                    } else {
	                        if (column.dataField) {
	                            value = data[column.dataField]
	                        }
	                    }
	                }
	                values.push(value)
	            }
	            return values
	        },
	        _updateItemsCore: function(change) {
	            var items, that = this,
	                dataSource = that._dataSource,
	                changeType = change.changeType || "refresh";
	            change.changeType = changeType;
	            if (dataSource) {
	                items = change.items || dataSource.items();
	                items = that._processItems(items.slice(0), changeType);
	                change.items = items;
	                switch (changeType) {
	                    case "prepend":
	                        that._items.unshift.apply(that._items, items);
	                        break;
	                    case "append":
	                        that._items.push.apply(that._items, items);
	                        break;
	                    case "update":
	                        var prevIndex = -1,
	                            rowIndices = change.rowIndices.slice(0),
	                            rowIndexCorrection = 0;
	                        rowIndices.sort(function(a, b) {
	                            return a - b
	                        });
	                        for (var i = 0; i < rowIndices.length; i++) {
	                            if (rowIndices[i] < 0) {
	                                rowIndices.splice(i, 1);
	                                i--
	                            }
	                        }
	                        change.items = [];
	                        change.rowIndices = [];
	                        change.changeTypes = [];
	                        var equalItems = function(item1, item2, strict) {
	                            return item1 && item2 && equalKeys(item1.key, item2.key) && (!strict || item1.rowType === item2.rowType)
	                        };
	                        $.each(rowIndices, function(index, rowIndex) {
	                            var oldItem, newItem, oldNextItem, newNextItem, strict;
	                            rowIndex += rowIndexCorrection;
	                            if (prevIndex === rowIndex) {
	                                return
	                            }
	                            change.rowIndices.push(rowIndex);
	                            prevIndex = rowIndex;
	                            oldItem = that._items[rowIndex];
	                            oldNextItem = that._items[rowIndex + 1];
	                            newItem = items[rowIndex];
	                            newNextItem = items[rowIndex + 1];
	                            strict = equalItems(oldItem, oldNextItem) || equalItems(newItem, newNextItem);
	                            if (newItem) {
	                                change.items.push(newItem)
	                            }
	                            if (oldItem && newItem && equalItems(oldItem, newItem, strict)) {
	                                changeType = "update";
	                                that._items[rowIndex] = newItem;
	                                if (oldItem.visible !== newItem.visible) {
	                                    change.items.splice(-1, 1, {
	                                        visible: newItem.visible
	                                    })
	                                }
	                            } else {
	                                if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, strict)) {
	                                    changeType = "insert";
	                                    that._items.splice(rowIndex, 0, newItem);
	                                    rowIndexCorrection++
	                                } else {
	                                    if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, strict)) {
	                                        changeType = "remove";
	                                        that._items.splice(rowIndex, 1);
	                                        rowIndexCorrection--;
	                                        prevIndex = -1
	                                    }
	                                }
	                            }
	                            change.changeTypes.push(changeType)
	                        });
	                        break;
	                    default:
	                        that._items = items.slice(0)
	                }
	                $.each(that._items, function(index, item) {
	                    item.rowIndex = index
	                })
	            } else {
	                that._items = []
	            }
	        },
	        updateItems: function(change) {
	            change = change || {};
	            var that = this;
	            if (that._updateLockCount) {
	                that._changes.push(change);
	                return
	            }
	            that._updateItemsCore(change);
	            commonUtils.deferRender(function() {
	                that.changed.fire(change)
	            })
	        },
	        isLoading: function() {
	            return this._isLoading || this._isCustomLoading
	        },
	        _fireLoadingChanged: function(messageText) {
	            this.loadingChanged.fire(this.isLoading(), messageText)
	        },
	        _calculateAdditionalFilter: function() {
	            return null
	        },
	        _applyFilter: function() {
	            var that = this,
	                dataSource = that._dataSource;
	            if (dataSource) {
	                dataSource.pageIndex(0);
	                return that.reload().done($.proxy(that.pageChanged, "fire"))
	            }
	        },
	        filter: function(filterExpr) {
	            var dataSource = this._dataSource,
	                filter = dataSource.filter();
	            if (0 === arguments.length) {
	                return dataSource ? dataSource.filter() : void 0
	            }
	            filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
	            if (gridCore.equalFilterParameters(filter, filterExpr)) {
	                return
	            }
	            if (dataSource) {
	                dataSource.filter(filterExpr)
	            }
	            this._applyFilter()
	        },
	        clearFilter: function(filterName) {
	            var that = this,
	                columnsController = that._columnsController,
	                clearColumnOption = function(optionName) {
	                    var index, columnCount = columnsController.columnCount();
	                    for (index = 0; index < columnCount; index++) {
	                        columnsController.columnOption(index, optionName, void 0)
	                    }
	                };
	            that.component.beginUpdate();
	            if (arguments.length > 0) {
	                switch (filterName) {
	                    case "dataSource":
	                        that.filter(null);
	                        break;
	                    case "search":
	                        that.searchByText("");
	                        break;
	                    case "header":
	                        clearColumnOption("filterValues");
	                        break;
	                    case "row":
	                        clearColumnOption("filterValue")
	                }
	            } else {
	                that.filter(null);
	                that.searchByText("");
	                clearColumnOption("filterValue");
	                clearColumnOption("filterValues")
	            }
	            that.component.endUpdate()
	        },
	        _fireDataSourceChanged: function() {
	            var that = this;
	            var changedHandler = function() {
	                that.changed.remove(changedHandler);
	                that.dataSourceChanged.fire()
	            };
	            that.changed.add(changedHandler)
	        },
	        _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
	            var dataSourceAdapter = dataSourceAdapterProvider.create(this.component);
	            dataSourceAdapter.init(dataSource, remoteOperations);
	            return dataSourceAdapter
	        },
	        isLocalStore: function(store) {
	            store = store || this.store();
	            return store instanceof ArrayStore
	        },
	        isCustomStore: function(store) {
	            store = store || this.store();
	            return store instanceof CustomStore
	        },
	        _createDataSourceAdapter: function(dataSource) {
	            var remoteOperations = this.option("remoteOperations"),
	                store = dataSource.store(),
	                enabledRemoteOperations = {
	                    filtering: true,
	                    sorting: true,
	                    paging: true,
	                    grouping: true,
	                    summary: true
	                };
	            if (remoteOperations && remoteOperations.groupPaging) {
	                remoteOperations = $.extend({}, enabledRemoteOperations, remoteOperations)
	            }
	            if ("auto" === remoteOperations) {
	                remoteOperations = this.isLocalStore(store) || this.isCustomStore(store) ? {} : {
	                    filtering: true,
	                    sorting: true,
	                    paging: true
	                }
	            }
	            if (true === remoteOperations) {
	                remoteOperations = enabledRemoteOperations
	            }
	            return this._createDataSourceAdapterCore(dataSource, remoteOperations)
	        },
	        setDataSource: function(dataSource) {
	            var that = this,
	                oldDataSource = that._dataSource;
	            if (!dataSource && oldDataSource) {
	                oldDataSource.changed.remove(that._dataChangedHandler);
	                oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
	                oldDataSource.loadError.remove(that._loadErrorHandler);
	                oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
	                oldDataSource.dispose(that._isSharedDataSource)
	            }
	            if (dataSource) {
	                dataSource = that._createDataSourceAdapter(dataSource)
	            }
	            that._dataSource = dataSource;
	            if (dataSource) {
	                that._fireDataSourceChanged();
	                that._isLoading = !dataSource.isLoaded();
	                that._needApplyFilter = true;
	                dataSource.changed.add(that._dataChangedHandler);
	                dataSource.loadingChanged.add(that._loadingChangedHandler);
	                dataSource.loadError.add(that._loadErrorHandler);
	                dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler)
	            }
	        },
	        items: function() {
	            return this._items
	        },
	        isEmpty: function() {
	            return !this.items().length
	        },
	        pageCount: function() {
	            return this._dataSource ? this._dataSource.pageCount() : 1
	        },
	        dataSource: function() {
	            return this._dataSource
	        },
	        store: function() {
	            var dataSource = this._dataSource;
	            return dataSource && dataSource.store()
	        },
	        loadAll: function(data) {
	            var that = this,
	                d = $.Deferred(),
	                dataSource = that._dataSource;
	            if (dataSource) {
	                if (data) {
	                    var options = {
	                        data: data,
	                        isCustomLoading: true,
	                        storeLoadOptions: {},
	                        loadOptions: {
	                            group: dataSource.group(),
	                            sort: dataSource.sort()
	                        }
	                    };
	                    dataSource._handleDataLoaded(options);
	                    when(options.data).done(function(data) {
	                        d.resolve(that._processItems(data, "loadingAll"), options.extra && options.extra.summary)
	                    }).fail(d.reject)
	                } else {
	                    if (!that.isLoading()) {
	                        var loadOptions = $.extend({}, dataSource.loadOptions(), {
	                            isLoadingAll: true,
	                            requireTotalCount: false
	                        });
	                        dataSource.load(loadOptions).done(function(items, extra) {
	                            items = that._processItems(items.slice(0), "loadingAll");
	                            d.resolve(items, extra && extra.summary)
	                        }).fail(d.reject)
	                    } else {
	                        d.reject()
	                    }
	                }
	            } else {
	                d.resolve([])
	            }
	            return d
	        },
	        getKeyByRowIndex: function(rowIndex) {
	            var item = this.items()[rowIndex];
	            if (item) {
	                return item.key
	            }
	        },
	        getRowIndexByKey: function(key) {
	            return gridCoreUtils.getIndexByKey(key, this.items())
	        },
	        keyOf: function(data) {
	            var store = this.store();
	            if (store) {
	                return store.keyOf(data)
	            }
	        },
	        byKey: function(key) {
	            var result, store = this.store(),
	                rowIndex = this.getRowIndexByKey(key);
	            if (!store) {
	                return
	            }
	            if (rowIndex >= 0) {
	                result = $.Deferred().resolve(this.items()[rowIndex].data)
	            }
	            return result || store.byKey(key)
	        },
	        getDataByKeys: function(rowKeys) {
	            var that = this,
	                result = $.Deferred(),
	                deferreds = [],
	                data = [];
	            $.each(rowKeys, function(index, key) {
	                deferreds.push(that.byKey(key).done(function(keyData) {
	                    data[index] = keyData
	                }))
	            });
	            when.apply($, deferreds).always(function() {
	                result.resolve(data)
	            });
	            return result
	        },
	        pageIndex: function(value) {
	            var that = this,
	                pagingOptions = that.option("paging"),
	                dataSource = that._dataSource;
	            if (dataSource) {
	                if (void 0 !== value) {
	                    if (dataSource.pageIndex() !== value) {
	                        dataSource.pageIndex(value);
	                        if (pagingOptions) {
	                            pagingOptions.pageIndex = value
	                        }
	                        return dataSource.load().done($.proxy(that.pageChanged, "fire"))
	                    }
	                }
	                return dataSource.pageIndex()
	            }
	            return 0
	        },
	        pageSize: function(value) {
	            var that = this,
	                pagingOptions = that.option("paging"),
	                dataSource = that._dataSource;
	            if (void 0 === value) {
	                return dataSource ? dataSource.pageSize() : 0
	            }
	            if (dataSource) {
	                if (dataSource.pageSize() !== value) {
	                    dataSource.pageIndex(0);
	                    dataSource.pageSize(value);
	                    if (pagingOptions) {
	                        pagingOptions.pageSize = value
	                    }
	                    return dataSource.reload().done($.proxy(that.pageChanged, "fire"))
	                }
	            }
	        },
	        beginCustomLoading: function(messageText) {
	            this._isCustomLoading = true;
	            this._fireLoadingChanged(messageText || "")
	        },
	        endCustomLoading: function() {
	            this._isCustomLoading = false;
	            this._fireLoadingChanged()
	        },
	        refresh: function() {
	            var that = this,
	                d = $.Deferred();
	            when(this._columnsController.refresh()).always(function() {
	                when(that.reload(true)).done(d.resolve).fail(d.reject)
	            });
	            return d
	        },
	        getVisibleRows: function() {
	            return this.items()
	        },
	        _disposeDataSource: function() {
	            this.setDataSource(null)
	        },
	        repaintRows: function(rowIndexes) {
	            rowIndexes = $.isArray(rowIndexes) ? rowIndexes : [rowIndexes];
	            if (rowIndexes.length > 1 || commonUtils.isDefined(rowIndexes[0])) {
	                this.updateItems({
	                    changeType: "update",
	                    rowIndices: rowIndexes
	                })
	            }
	        }
	    };
	    gridCore.proxyMethod(members, "load");
	    gridCore.proxyMethod(members, "reload");
	    gridCore.proxyMethod(members, "itemsCount", 0);
	    gridCore.proxyMethod(members, "totalItemsCount", 0);
	    gridCore.proxyMethod(members, "hasKnownLastPage", true);
	    gridCore.proxyMethod(members, "isLoaded", true);
	    gridCore.proxyMethod(members, "totalCount", 0);
	    return members
	}());
	gridCore.registerModule("data", {
	    defaultOptions: function() {
	        return {
	            loadingTimeout: 0,
	            dataSource: null,
	            cacheEnabled: true,
	            onDataErrorOccurred: null,
	            remoteOperations: "auto",
	            paging: {
	                enabled: true,
	                pageSize: void 0,
	                pageIndex: void 0
	            }
	        }
	    },
	    controllers: {
	        data: exports.DataController
	    }
	});


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.data_source_adapter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    commonUtils = __webpack_require__(8),
	    ArrayStore = __webpack_require__(129),
	    when = __webpack_require__(10).when;

	function cloneItems(items, groupCount) {
	    if (items) {
	        items = items.slice(0);
	        if (groupCount) {
	            for (var i = 0; i < items.length; i++) {
	                items[i] = $.extend({
	                    key: items[i].key
	                }, items[i]);
	                items[i].items = cloneItems(items[i].items, groupCount - 1)
	            }
	        }
	    }
	    return items
	}
	var DataSourceAdapter = gridCore.Controller.inherit(function() {
	    function calculateOperationTypes(loadOptions, lastLoadOptions) {
	        var operationTypes = {};
	        if (lastLoadOptions) {
	            operationTypes = {
	                sorting: !gridCore.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
	                grouping: !gridCore.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
	                filtering: !gridCore.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter),
	                skip: loadOptions.skip !== lastLoadOptions.skip,
	                take: loadOptions.take !== lastLoadOptions.take
	            };
	            operationTypes.reload = operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
	            operationTypes.paging = operationTypes.skip || operationTypes.take
	        }
	        return operationTypes
	    }

	    function executeTask(action, timeout) {
	        if (commonUtils.isDefined(timeout)) {
	            commonUtils.executeAsync(action, timeout)
	        } else {
	            action()
	        }
	    }
	    return {
	        init: function(dataSource, remoteOperations) {
	            var that = this;
	            that._dataSource = dataSource;
	            that._remoteOperations = remoteOperations || {};
	            that._isLastPage = !dataSource.isLastPage();
	            that._hasLastPage = false;
	            that._currentTotalCount = 0;
	            that.changed = $.Callbacks();
	            that.loadingChanged = $.Callbacks();
	            that.loadError = $.Callbacks();
	            that.customizeStoreLoadOptions = $.Callbacks();
	            that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
	            that._dataLoadingHandler = $.proxy(that._handleDataLoading, that);
	            that._dataLoadedHandler = $.proxy(that._handleDataLoaded, that);
	            that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
	            that._loadErrorHandler = $.proxy(that._handleLoadError, that);
	            dataSource.on("changed", that._dataChangedHandler);
	            dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
	            dataSource.on("customizeLoadResult", that._dataLoadedHandler);
	            dataSource.on("loadingChanged", that._loadingChangedHandler);
	            dataSource.on("loadError", that._loadErrorHandler);
	            $.each(dataSource, function(memberName, member) {
	                if (!that[memberName] && $.isFunction(member)) {
	                    that[memberName] = function() {
	                        return this._dataSource[memberName].apply(this._dataSource, arguments)
	                    }
	                }
	            })
	        },
	        remoteOperations: function() {
	            return this._remoteOperations
	        },
	        dispose: function(isSharedDataSource) {
	            var that = this,
	                dataSource = that._dataSource;
	            dataSource.off("changed", that._dataChangedHandler);
	            dataSource.off("customizeStoreLoadOptions", that._dataLoadingHandler);
	            dataSource.off("customizeLoadResult", that._dataLoadedHandler);
	            dataSource.off("loadingChanged", that._loadingChangedHandler);
	            dataSource.off("loadError", that._loadErrorHandler);
	            if (!isSharedDataSource) {
	                dataSource.dispose()
	            }
	        },
	        refresh: function(options, isReload, operationTypes) {
	            var that = this,
	                dataSource = that._dataSource;
	            if (isReload || operationTypes.reload) {
	                that._currentTotalCount = 0;
	                that._isLastPage = !dataSource.paginate();
	                that._hasLastPage = that._isLastPage
	            }
	        },
	        _customizeRemoteOperations: function() {},
	        _handleDataLoading: function(options) {
	            var loadOptions, operationTypes, that = this,
	                dataSource = that._dataSource,
	                lastLoadOptions = that._lastLoadOptions;
	            that.customizeStoreLoadOptions.fire(options);
	            options.delay = this.option("loadingTimeout");
	            options.originalStoreLoadOptions = options.storeLoadOptions;
	            options.remoteOperations = $.extend({}, this.remoteOperations());
	            var isReload = !that.isLoaded() && !that._isRefreshing;
	            loadOptions = $.extend({}, options.storeLoadOptions);
	            operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions);
	            that._customizeRemoteOperations(options, isReload, operationTypes);
	            if (options.isCustomLoading) {
	                return
	            } else {
	                that._lastLoadOptions = loadOptions
	            }
	            that._isRefreshing = true;
	            when(that.refresh(options, isReload, operationTypes)).always(function() {
	                if (that._lastOperationId === options.operationId) {
	                    that.load()
	                }
	                that._isRefreshing = false
	            });
	            dataSource.cancel(that._lastOperationId);
	            that._lastOperationId = options.operationId;
	            if (that._isRefreshing) {
	                dataSource.cancel(that._lastOperationId)
	            }
	        },
	        _handleDataLoaded: function(options) {
	            options.storeLoadOptions = options.originalStoreLoadOptions
	        },
	        _handleLoadingChanged: function(isLoading) {
	            this.loadingChanged.fire(isLoading)
	        },
	        _handleLoadError: function(error) {
	            this.changed.fire({
	                changeType: "loadError",
	                error: error
	            });
	            this.loadError.fire(error)
	        },
	        _handleDataChanged: function(args) {
	            var currentTotalCount, that = this,
	                dataSource = that._dataSource,
	                isLoading = false,
	                itemsCount = that.itemsCount();
	            that._isLastPage = !itemsCount || !that.pageSize() || itemsCount < that.pageSize();
	            if (that._isLastPage) {
	                that._hasLastPage = true
	            }
	            if (dataSource.totalCount() >= 0) {
	                if (dataSource.pageIndex() >= that.pageCount()) {
	                    dataSource.pageIndex(that.pageCount() - 1);
	                    dataSource.load();
	                    isLoading = true
	                }
	            } else {
	                currentTotalCount = dataSource.pageIndex() * that.pageSize() + itemsCount;
	                that._currentTotalCount = Math.max(that._currentTotalCount, currentTotalCount);
	                if (0 === itemsCount && dataSource.pageIndex() >= that.pageCount()) {
	                    dataSource.pageIndex(that.pageCount() - 1);
	                    dataSource.load();
	                    isLoading = true
	                }
	            }
	            if (!isLoading) {
	                this.component._optionCache = {};
	                this.changed.fire(args);
	                this.component._optionCache = void 0
	            }
	        },
	        isLastPage: function() {
	            return this._isLastPage
	        },
	        totalCount: function() {
	            return parseInt(this._currentTotalCount || this._dataSource.totalCount())
	        },
	        itemsCount: function() {
	            return this._dataSource.items().length
	        },
	        totalItemsCount: function() {
	            return this.totalCount()
	        },
	        pageSize: function() {
	            var dataSource = this._dataSource;
	            if (!arguments.length && !dataSource.paginate()) {
	                return 0
	            }
	            return dataSource.pageSize.apply(dataSource, arguments)
	        },
	        pageCount: function() {
	            var that = this,
	                count = that.totalItemsCount(),
	                pageSize = that.pageSize();
	            if (pageSize && count > 0) {
	                return Math.max(1, Math.ceil(count / pageSize))
	            }
	            return 1
	        },
	        hasKnownLastPage: function() {
	            return this._hasLastPage || this._dataSource.totalCount() >= 0
	        },
	        load: function(options) {
	            var store, loadResult, dataSourceLoadOptions, that = this,
	                dataSource = that._dataSource,
	                d = $.Deferred();
	            if (options) {
	                store = dataSource.store();
	                dataSourceLoadOptions = dataSource.loadOptions();
	                loadResult = {
	                    storeLoadOptions: options,
	                    isCustomLoading: true
	                };
	                $.each(store._customLoadOptions() || [], function(_, optionName) {
	                    if (!(optionName in loadResult.storeLoadOptions)) {
	                        loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName]
	                    }
	                });
	                dataSource._scheduleLoadCallbacks(d);
	                that._handleDataLoading(loadResult);
	                executeTask(function() {
	                    when(loadResult.data || store.load(loadResult.storeLoadOptions)).done(function(data, extra) {
	                        loadResult.data = data;
	                        loadResult.extra = extra || {};
	                        that._handleDataLoaded(loadResult);
	                        if (options.requireTotalCount && void 0 === loadResult.extra.totalCount) {
	                            loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions)
	                        }
	                        when(loadResult.data, loadResult.extra.totalCount).done(function(data, totalCount) {
	                            loadResult.extra.totalCount = totalCount;
	                            d.resolve(data, loadResult.extra)
	                        }).fail(d.reject)
	                    }).fail(d.reject)
	                }, that.option("loadingTimeout"));
	                return d.fail(function() {
	                    that.fireEvent("loadError", arguments)
	                }).promise()
	            } else {
	                return dataSource.load()
	            }
	        }
	    }
	}());
	DataSourceAdapter = DataSourceAdapter.inherit({
	    reload: function(full) {
	        return full ? this._dataSource.reload() : this._dataSource.load()
	    },
	    _customizeRemoteOperations: function(options, isReload, operationTypes) {
	        var that = this,
	            cachedStoreData = that._cachedStoreData,
	            cachedPagingData = that._cachedPagingData;
	        that.callBase.apply(that, arguments);
	        if (isReload) {
	            cachedStoreData = void 0;
	            cachedPagingData = void 0
	        } else {
	            if (operationTypes.reload) {
	                cachedPagingData = void 0
	            }
	            $.each(operationTypes, function(operationType, value) {
	                if (value && options.remoteOperations[operationType]) {
	                    cachedStoreData = void 0;
	                    cachedPagingData = void 0
	                }
	            })
	        }
	        if (cachedPagingData) {
	            options.remoteOperations.paging = false
	        }
	        options.cachedStoreData = cachedStoreData;
	        options.cachedPagingData = cachedPagingData;
	        if (!options.isCustomLoading) {
	            that._cachedStoreData = cachedStoreData;
	            that._cachedPagingData = cachedPagingData
	        }
	    },
	    _handleDataLoading: function(options) {
	        this.callBase(options);
	        this._handleDataLoadingCore(options)
	    },
	    _handleDataLoadingCore: function(options) {
	        var remoteOperations = options.remoteOperations;
	        options.loadOptions = {};
	        var localLoadOptionNames = {
	            filter: !remoteOperations.filtering,
	            sort: !remoteOperations.sorting,
	            group: !remoteOperations.grouping,
	            summary: !remoteOperations.summary,
	            skip: !remoteOperations.paging,
	            take: !remoteOperations.paging,
	            requireTotalCount: !remoteOperations.paging
	        };
	        $.each(options.storeLoadOptions, function(optionName, optionValue) {
	            if (localLoadOptionNames[optionName]) {
	                options.loadOptions[optionName] = optionValue;
	                delete options.storeLoadOptions[optionName]
	            }
	        });
	        options.data = options.cachedStoreData
	    },
	    _handleDataLoaded: function(options) {
	        var callBase = this.callBase,
	            loadOptions = options.loadOptions,
	            localPaging = options.remoteOperations && !options.remoteOperations.paging,
	            isCaching = false !== this.option("cacheEnabled") && localPaging && options.storeLoadOptions,
	            needStoreCache = isCaching && !options.isCustomLoading;
	        if (!loadOptions) {
	            this._dataSource.cancel(options.operationId);
	            return
	        }
	        if (localPaging) {
	            options.skip = loadOptions.skip;
	            options.take = loadOptions.take;
	            delete loadOptions.skip;
	            delete loadOptions.take
	        }
	        if (loadOptions.group) {
	            loadOptions.group = options.group || loadOptions.group
	        }
	        var groupCount = gridCore.normalizeSortingInfo(options.storeLoadOptions.group || loadOptions.group).length;
	        if (isCaching && options.cachedPagingData) {
	            options.data = cloneItems(options.cachedPagingData, groupCount)
	        } else {
	            if (needStoreCache && !this._cachedStoreData) {
	                this._cachedStoreData = cloneItems(options.data, gridCore.normalizeSortingInfo(options.storeLoadOptions.group).length)
	            }
	            new ArrayStore(options.data).load(loadOptions).done(function(data) {
	                options.data = data
	            });
	            if (needStoreCache) {
	                this._cachedPagingData = cloneItems(options.data, groupCount)
	            }
	        }
	        if (loadOptions.requireTotalCount && localPaging) {
	            options.extra = $.isPlainObject(options.extra) ? options.extra : {};
	            options.extra.totalCount = options.data.length
	        }
	        this._handleDataLoadedCore(options);
	        callBase.apply(this, arguments)
	    },
	    _handleDataLoadedCore: function(options) {
	        if (options.remoteOperations && !options.remoteOperations.paging) {
	            if (void 0 !== options.skip) {
	                options.data = options.data.slice(options.skip)
	            }
	            if (void 0 !== options.take) {
	                options.data = options.data.slice(0, options.take)
	            }
	        }
	    }
	});
	module.exports = {
	    extend: function(extender) {
	        DataSourceAdapter = DataSourceAdapter.inherit(extender)
	    },
	    create: function(component) {
	        return new DataSourceAdapter(component)
	    }
	};


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.sorting_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    clickEvent = __webpack_require__(65),
	    gridCore = __webpack_require__(144),
	    commonUtils = __webpack_require__(8),
	    sortingMixin = __webpack_require__(155).sortingMixin,
	    messageLocalization = __webpack_require__(79),
	    eventUtils = __webpack_require__(61);
	var COLUMN_HEADERS_VIEW_NAMESPACE = "dxDataGridColumnHeadersView";
	var ColumnHeadersViewSortingExtender = $.extend({}, sortingMixin, {
	    _createRow: function(row) {
	        var that = this,
	            $row = that.callBase(row);
	        if ("header" === row.rowType) {
	            $row.on(eventUtils.addNamespace(clickEvent.name, COLUMN_HEADERS_VIEW_NAMESPACE), "> td", that.createAction(function(e) {
	                var keyName = null,
	                    event = e.jQueryEvent,
	                    $cellElementFromEvent = $(event.currentTarget),
	                    rowIndex = $cellElementFromEvent.parent().index(),
	                    columnIndex = $.map(that.getCellElements(rowIndex), function($cellElement, index) {
	                        if ($cellElement === $cellElementFromEvent.get(0)) {
	                            return index
	                        }
	                    })[0],
	                    visibleColumns = that._columnsController.getVisibleColumns(rowIndex),
	                    column = visibleColumns[columnIndex],
	                    editingController = that.getController("editing"),
	                    editingMode = that.option("editing.mode"),
	                    isCellEditing = editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
	                if (isCellEditing) {
	                    return
	                }
	                if (column && !commonUtils.isDefined(column.groupIndex) && !column.command) {
	                    if (event.shiftKey) {
	                        keyName = "shift"
	                    } else {
	                        if (event.ctrlKey) {
	                            keyName = "ctrl"
	                        }
	                    }
	                    setTimeout(function() {
	                        that._columnsController.changeSortOrder(column.index, keyName)
	                    })
	                }
	            }))
	        }
	        return $row
	    },
	    _renderCellContent: function($cell, options) {
	        var that = this,
	            column = options.column;
	        that.callBase($cell, options);
	        if (!column.command && "header" === options.rowType) {
	            that._applyColumnState({
	                name: "sort",
	                rootElement: $cell,
	                column: column,
	                showColumnLines: that.option("showColumnLines")
	            })
	        }
	    },
	    _columnOptionChanged: function(e) {
	        var changeTypes = e.changeTypes;
	        if (1 === changeTypes.length && changeTypes.sorting) {
	            this._updateIndicators("sort");
	            return
	        }
	        this.callBase(e)
	    },
	    optionChanged: function(args) {
	        var that = this;
	        switch (args.name) {
	            case "sorting":
	                that._invalidate();
	                args.handled = true;
	                break;
	            default:
	                that.callBase(args)
	        }
	    }
	});
	var HeaderPanelSortingExtender = $.extend({}, sortingMixin, {
	    _createGroupPanelItem: function($rootElement, groupColumn) {
	        var that = this,
	            $item = that.callBase.apply(that, arguments);
	        $item.on(eventUtils.addNamespace(clickEvent.name, "dxDataGridHeaderPanel"), that.createAction(function() {
	            setTimeout(function() {
	                that.getController("columns").changeSortOrder(groupColumn.index)
	            })
	        }));
	        that._applyColumnState({
	            name: "sort",
	            rootElement: $item,
	            column: {
	                alignment: that.option("rtlEnabled") ? "right" : "left",
	                allowSorting: groupColumn.allowSorting,
	                sortOrder: "desc" === groupColumn.sortOrder ? "desc" : "asc"
	            },
	            showColumnLines: true
	        });
	        return $item
	    },
	    optionChanged: function(args) {
	        var that = this;
	        switch (args.name) {
	            case "sorting":
	                that._invalidate();
	                args.handled = true;
	                break;
	            default:
	                that.callBase(args)
	        }
	    }
	});
	gridCore.registerModule("sorting", {
	    defaultOptions: function() {
	        return {
	            sorting: {
	                mode: "single",
	                ascendingText: messageLocalization.format("dxDataGrid-sortingAscendingText"),
	                descendingText: messageLocalization.format("dxDataGrid-sortingDescendingText"),
	                clearText: messageLocalization.format("dxDataGrid-sortingClearText")
	            }
	        }
	    },
	    extenders: {
	        views: {
	            columnHeadersView: ColumnHeadersViewSortingExtender,
	            headerPanel: HeaderPanelSortingExtender
	        }
	    }
	});


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/grid_core/ui.grid_core.sorting.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var commonUtils = __webpack_require__(8);
	var DATAGRID_SORT_CLASS = "dx-sort",
	    DATAGRID_SORT_NONE_CLASS = "dx-sort-none",
	    DATAGRID_SORTUP_CLASS = "dx-sort-up",
	    DATAGRID_SORTDOWN_CLASS = "dx-sort-down",
	    DATAGRID_HEADERS_ACTION_CLASS = "dx-datagrid-action",
	    DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
	    DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content";
	exports.sortingMixin = {
	    _applyColumnState: function(options) {
	        var side, ariaSortState, $sortIndicator, that = this,
	            sortingMode = that.option("sorting.mode"),
	            rootElement = options.rootElement,
	            column = options.column,
	            $indicatorsContainer = rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
	        if ("sort" === options.name) {
	            side = that.option("rtlEnabled") ? "right" : "left";
	            rootElement.find("." + DATAGRID_SORT_CLASS).remove();
	            !$indicatorsContainer.children().length && $indicatorsContainer.remove();
	            rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, "");
	            if (("single" === sortingMode || "multiple" === sortingMode) && column.allowSorting || commonUtils.isDefined(column.sortOrder)) {
	                ariaSortState = "asc" === column.sortOrder ? "ascending" : "descending";
	                $sortIndicator = that.callBase(options).toggleClass(DATAGRID_SORTUP_CLASS, "asc" === column.sortOrder).toggleClass(DATAGRID_SORTDOWN_CLASS, "desc" === column.sortOrder);
	                options.rootElement.addClass(DATAGRID_HEADERS_ACTION_CLASS);
	                if ("center" === column.alignment && !$sortIndicator.hasClass(DATAGRID_SORT_NONE_CLASS)) {
	                    rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, $sortIndicator.outerWidth(true))
	                }
	            }
	            if (!commonUtils.isDefined(column.sortOrder)) {
	                that.setAria("sort", "none", rootElement)
	            } else {
	                that.setAria("sort", ariaSortState, rootElement)
	            }
	            return $sortIndicator
	        } else {
	            return that.callBase(options)
	        }
	    },
	    _getIndicatorClassName: function(name) {
	        if ("sort" === name) {
	            return DATAGRID_SORT_CLASS
	        }
	        return this.callBase(name)
	    },
	    _renderIndicator: function(options) {
	        var rtlEnabled, column = options.column,
	            $container = options.container,
	            $indicator = options.indicator;
	        if ("sort" === options.name) {
	            rtlEnabled = this.option("rtlEnabled");
	            if (!commonUtils.isDefined(column.sortOrder)) {
	                $indicator && $indicator.addClass(DATAGRID_SORT_NONE_CLASS)
	            }
	            if ($container.children().length && (!rtlEnabled && "left" === options.columnAlignment || rtlEnabled && "right" === options.columnAlignment)) {
	                $container.prepend($indicator);
	                return
	            }
	        }
	        this.callBase(options)
	    },
	    _updateIndicator: function($cell, column, indicatorName) {
	        if ("sort" === indicatorName && commonUtils.isDefined(column.groupIndex)) {
	            return
	        }
	        this.callBase.apply(this, arguments)
	    }
	};


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.rows_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    stringUtils = __webpack_require__(7),
	    compileGetter = __webpack_require__(35).compileGetter,
	    gridCore = __webpack_require__(144),
	    columnsView = __webpack_require__(147),
	    gridCoreUtils = __webpack_require__(148),
	    Scrollable = __webpack_require__(157).default,
	    removeEvent = __webpack_require__(32),
	    messageLocalization = __webpack_require__(79),
	    isDefined = commonUtils.isDefined;
	var DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
	    DATAGRID_GROUP_CELL_CLASS = "dx-group-cell",
	    DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
	    DATAGRID_DATA_ROW_CLASS = "dx-data-row",
	    DATAGRID_FREE_SPACE_CLASS = "dx-freespace-row",
	    DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
	    DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
	    DATAGRID_ROW_LINES_CLASS = "dx-row-lines",
	    DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
	    DATAGRID_ROW_ALTERNATION_CLASS = "dx-row-alt",
	    DATAGRID_LAST_ROW_BORDER = "dx-last-row-border",
	    DATAGRID_LOADPANEL_HIDE_TIMEOUT = 200,
	    appendFreeSpaceRowTemplate = {
	        render: function(options) {
	            var $tbody = options.container.find("tbody");
	            if ($tbody.length) {
	                $tbody.last().append(options.content)
	            } else {
	                options.container.append(options.content)
	            }
	        }
	    };
	exports.RowsView = columnsView.ColumnsView.inherit({
	    _getDefaultTemplate: function(column) {
	        switch (column.command) {
	            case "empty":
	                return function(container) {
	                    container.html("&nbsp;")
	                };
	            default:
	                return function($container, options) {
	                    var isDataTextEmpty = stringUtils.isEmpty(options.text) && "data" === options.rowType,
	                        text = isDataTextEmpty ? "&nbsp;" : options.text,
	                        container = $container.get(0);
	                    if (column.encodeHtml && !isDataTextEmpty) {
	                        container.textContent = text
	                    } else {
	                        container.innerHTML = text
	                    }
	                }
	        }
	    },
	    _getDefaultGroupTemplate: function() {
	        var that = this,
	            summaryTexts = that.option("summary.texts");
	        return function(container, options) {
	            var data = options.data,
	                text = options.column.caption + ": " + options.text;
	            if (options.summaryItems && options.summaryItems.length) {
	                text += " " + gridCore.getGroupRowSummaryText(options.summaryItems, summaryTexts)
	            }
	            if (data) {
	                if (options.groupContinuedMessage && options.groupContinuesMessage) {
	                    text += " (" + options.groupContinuedMessage + ". " + options.groupContinuesMessage + ")"
	                } else {
	                    if (options.groupContinuesMessage) {
	                        text += " (" + options.groupContinuesMessage + ")"
	                    } else {
	                        if (options.groupContinuedMessage) {
	                            text += " (" + options.groupContinuedMessage + ")"
	                        }
	                    }
	                }
	            }
	            container.addClass(DATAGRID_GROUP_CELL_CLASS);
	            container.text(text)
	        }
	    },
	    _update: function() {},
	    _getCellTemplate: function(options) {
	        var template, that = this,
	            column = options.column;
	        if ("group" === options.rowType && isDefined(column.groupIndex) && !column.showWhenGrouped) {
	            template = column.groupCellTemplate || {
	                allowRenderToDetachedContainer: true,
	                render: that._getDefaultGroupTemplate()
	            }
	        } else {
	            template = column.cellTemplate || {
	                allowRenderToDetachedContainer: true,
	                render: that._getDefaultTemplate(column)
	            }
	        }
	        return template
	    },
	    _createRow: function(row) {
	        var isGroup, isDataRow, isRowExpanded, $row = this.callBase(row);
	        if (row) {
	            isGroup = "group" === row.rowType;
	            isDataRow = "data" === row.rowType;
	            isDataRow && $row.addClass(DATAGRID_DATA_ROW_CLASS);
	            isDataRow && row.dataIndex % 2 === 1 && this.option("rowAlternationEnabled") && $row.addClass(DATAGRID_ROW_ALTERNATION_CLASS);
	            isDataRow && this.option("showRowLines") && $row.addClass(DATAGRID_ROW_LINES_CLASS);
	            this.option("showColumnLines") && $row.addClass(DATAGRID_COLUMN_LINES_CLASS);
	            if (isGroup) {
	                $row.addClass(DATAGRID_GROUP_ROW_CLASS);
	                isRowExpanded = row.isExpanded;
	                this.setAria("role", "rowgroup", $row);
	                this.setAria("expanded", isDefined(isRowExpanded) && isRowExpanded.toString(), $row)
	            }
	        }
	        return $row
	    },
	    _afterRowPrepared: function(e) {
	        var arg = e.args[0],
	            dataController = this._dataController,
	            watch = this.option("integrationOptions.watchMethod");
	        if (!arg.data || "data" !== arg.rowType || arg.inserted || !this.option("twoWayBindingEnabled") || !watch) {
	            return
	        }
	        var dispose = watch(function() {
	            return dataController.generateDataValues(arg.data, arg.columns)
	        }, function() {
	            dataController.updateItems({
	                changeType: "update",
	                rowIndices: [arg.rowIndex]
	            })
	        }, {
	            deep: true,
	            skipImmediate: true
	        });
	        arg.rowElement.on(removeEvent, dispose)
	    },
	    _renderScrollable: function(force) {
	        var that = this,
	            $element = that.element();
	        if (!$element.children().length) {
	            $element.append("<div />")
	        }
	        if (force || !that._loadPanel) {
	            that._renderLoadPanel($element, $element.parent(), that._dataController.isLocalStore())
	        }
	        if ((force || !that.getScrollable()) && that._dataController.isLoaded()) {
	            var columns = that.getColumns(),
	                allColumnsHasWidth = true;
	            for (var i = 0; i < columns.length; i++) {
	                if (!columns[i].width) {
	                    allColumnsHasWidth = false;
	                    break
	                }
	            }
	            if (that.option("columnAutoWidth") || that._hasHeight || allColumnsHasWidth || that._columnsController._isColumnFixing()) {
	                that._renderScrollableCore($element)
	            }
	        }
	    },
	    _handleScroll: function(e) {
	        var that = this;
	        that._scrollTop = e.scrollOffset.top;
	        that._scrollLeft = e.scrollOffset.left;
	        that.scrollChanged.fire(e.scrollOffset, that.name)
	    },
	    _renderScrollableCore: function($element) {
	        var that = this,
	            scrollingMode = that.option("scrolling.mode"),
	            dxScrollableOptions = that._createScrollableOptions(),
	            scrollHandler = $.proxy(that._handleScroll, that);
	        dxScrollableOptions.onScroll = scrollHandler;
	        dxScrollableOptions.onStop = scrollHandler;
	        dxScrollableOptions.useKeyboard = !that.option("paging.enabled") || "virtual" === scrollingMode || "infinite" === scrollingMode;
	        that._scrollable = that._createComponent($element, Scrollable, dxScrollableOptions);
	        that._scrollableContainer = that._scrollable && that._scrollable._$container
	    },
	    _renderLoadPanel: gridCoreUtils.renderLoadPanel,
	    _renderContent: function(contentElement, tableElement) {
	        contentElement.replaceWith($("<div>").addClass(DATAGRID_CONTENT_CLASS).append(tableElement));
	        return this._findContentElement()
	    },
	    _updateContent: function(newTableElement, change) {
	        var that = this,
	            tableElement = that._getTableElement(),
	            contentElement = that._findContentElement(),
	            changeType = change && change.changeType,
	            executors = [];
	        switch (changeType) {
	            case "update":
	                $.each(change.rowIndices, function(index, rowIndex) {
	                    var $newRowElement = that._getRowElements(newTableElement).eq(index),
	                        changeType = change.changeTypes[index],
	                        item = change.items && change.items[index];
	                    executors.push(function() {
	                        var $rowsElement = that._getRowElements(),
	                            $rowElement = $rowsElement.eq(rowIndex);
	                        switch (changeType) {
	                            case "update":
	                                if (item) {
	                                    if (isDefined(item.visible) && item.visible !== $rowElement.is(":visible")) {
	                                        $rowElement.toggle(item.visible)
	                                    } else {
	                                        $rowElement.replaceWith($newRowElement)
	                                    }
	                                }
	                                break;
	                            case "insert":
	                                if (!$rowsElement.length) {
	                                    $newRowElement.prependTo(tableElement)
	                                } else {
	                                    if ($rowElement.length) {
	                                        $newRowElement.insertBefore($rowElement)
	                                    } else {
	                                        $newRowElement.insertAfter($rowsElement.last())
	                                    }
	                                }
	                                break;
	                            case "remove":
	                                $rowElement.remove()
	                        }
	                    })
	                });
	                $.each(executors, function() {
	                    this()
	                });
	                newTableElement.remove();
	                break;
	            default:
	                that._setTableElement(newTableElement);
	                contentElement.addClass(DATAGRID_CONTENT_CLASS);
	                that._renderContent(contentElement, newTableElement)
	        }
	    },
	    _renderFreeSpaceRow: function(tableElement) {
	        var i, that = this,
	            freeSpaceRowElement = that._createRow(),
	            columns = this.getColumns();
	        freeSpaceRowElement.addClass(DATAGRID_FREE_SPACE_CLASS).toggleClass(DATAGRID_COLUMN_LINES_CLASS, that.option("showColumnLines"));
	        for (i = 0; i < columns.length; i++) {
	            freeSpaceRowElement.append(that._createCell({
	                column: columns[i],
	                rowType: "freeSpace"
	            }))
	        }
	        that._appendRow(tableElement, freeSpaceRowElement, appendFreeSpaceRowTemplate)
	    },
	    _needUpdateRowHeight: function(itemsCount) {
	        return itemsCount > 0 && !this._rowHeight
	    },
	    _updateRowHeight: function() {
	        var tableHeight, freeSpaceRowHeight, $freeSpaceRowElement, that = this,
	            tableElement = that._getTableElement(),
	            itemsCount = that._dataController.items().length;
	        if (tableElement && that._needUpdateRowHeight(itemsCount)) {
	            tableHeight = tableElement.outerHeight();
	            $freeSpaceRowElement = that._getFreeSpaceRowElements().first();
	            if ($freeSpaceRowElement && $freeSpaceRowElement.is(":visible")) {
	                freeSpaceRowHeight = parseFloat($freeSpaceRowElement[0].style.height) || 0;
	                tableHeight -= freeSpaceRowHeight
	            }
	            that._rowHeight = tableHeight / itemsCount
	        }
	    },
	    _findContentElement: function() {
	        var $content = this.element(),
	            scrollable = this.getScrollable();
	        if ($content) {
	            if (scrollable) {
	                $content = scrollable.content()
	            }
	            return $content.children().first()
	        }
	    },
	    _getRowElements: function(tableElement) {
	        var $rows = this.callBase(tableElement);
	        return $rows && $rows.not("." + DATAGRID_FREE_SPACE_CLASS)
	    },
	    _getFreeSpaceRowElements: function($table) {
	        var tableElements = $table || this.getTableElements();
	        return tableElements && tableElements.children("tbody").children("." + DATAGRID_FREE_SPACE_CLASS)
	    },
	    _getNoDataText: function() {
	        return this.option("noDataText")
	    },
	    _renderNoDataText: gridCoreUtils.renderNoDataText,
	    _rowClick: function(e) {
	        var item = this._dataController.items()[e.rowIndex] || {};
	        this.executeAction("onRowClick", $.extend({
	            evaluate: function(expr) {
	                var getter = compileGetter(expr);
	                return getter(item.data)
	            }
	        }, e, item))
	    },
	    _getGroupCellOptions: function(options) {
	        var columnIndex = (options.row.groupIndex || 0) + options.columnsCountBeforeGroups;
	        return {
	            columnIndex: columnIndex,
	            colspan: options.columns.length - columnIndex - 1
	        }
	    },
	    _renderCells: function($row, options) {
	        if ("group" === options.row.rowType) {
	            this._renderGroupedCells($row, options)
	        } else {
	            if (options.row.values) {
	                this.callBase($row, options)
	            }
	        }
	    },
	    _renderGroupedCells: function($row, options) {
	        var i, isExpanded, groupColumn, groupColumnAlignment, row = options.row,
	            columns = options.columns,
	            rowIndex = row.rowIndex,
	            groupCellOptions = this._getGroupCellOptions(options);
	        for (i = 0; i <= groupCellOptions.columnIndex; i++) {
	            if (i === groupCellOptions.columnIndex && columns[i].allowCollapsing && "infinite" !== options.scrollingMode) {
	                isExpanded = !!row.isExpanded
	            } else {
	                isExpanded = null
	            }
	            this._renderCell($row, {
	                value: isExpanded,
	                row: row,
	                rowIndex: rowIndex,
	                column: {
	                    command: "expand",
	                    cssClass: columns[i].cssClass
	                },
	                columnIndex: i
	            })
	        }
	        groupColumnAlignment = commonUtils.getDefaultAlignment(this.option("rtlEnabled"));
	        groupColumn = $.extend({}, columns[groupCellOptions.columnIndex], {
	            command: null,
	            cssClass: null,
	            showWhenGrouped: false,
	            alignment: groupColumnAlignment
	        });
	        if (groupCellOptions.colspan > 1) {
	            groupColumn.colspan = groupCellOptions.colspan
	        }
	        this._renderCell($row, {
	            value: row.values[row.groupIndex],
	            row: row,
	            rowIndex: rowIndex,
	            column: groupColumn,
	            columnIndex: groupCellOptions.columnIndex
	        })
	    },
	    _renderRows: function($table, options) {
	        var i, that = this,
	            columns = options.columns,
	            columnsCountBeforeGroups = 0,
	            scrollingMode = that.option("scrolling.mode");
	        for (i = 0; i < columns.length; i++) {
	            if ("expand" === columns[i].command) {
	                columnsCountBeforeGroups = i;
	                break
	            }
	        }
	        that.callBase($table, $.extend({
	            scrollingMode: scrollingMode,
	            columnsCountBeforeGroups: columnsCountBeforeGroups
	        }, options));
	        that._renderFreeSpaceRow($table);
	        if (!that._hasHeight) {
	            that.updateFreeSpaceRowHeight($table)
	        }
	    },
	    _renderRow: function($table, options) {
	        var that = this,
	            row = options.row,
	            rowTemplate = that.option("rowTemplate");
	        if (("data" === row.rowType || "group" === row.rowType) && !isDefined(row.groupIndex) && rowTemplate) {
	            that.renderTemplate($table, rowTemplate, $.extend({
	                columns: options.columns
	            }, row), true)
	        } else {
	            that.callBase($table, options)
	        }
	    },
	    _renderTable: function(options) {
	        var that = this,
	            $table = that.callBase(options),
	            triggerShownEvent = function() {
	                if (that.element().closest(document).length) {
	                    that.resizeCompleted.remove(triggerShownEvent);
	                    that.element().triggerHandler("dxshown")
	                }
	            };
	        if (!isDefined(that._getTableElement())) {
	            that._setTableElement($table);
	            that._renderScrollable(true);
	            that.resizeCompleted.add(triggerShownEvent)
	        } else {
	            that._renderScrollable()
	        }
	        return $table
	    },
	    _renderCore: function(change) {
	        var $table, that = this,
	            $element = that.element();
	        $element.addClass(DATAGRID_ROWS_VIEW_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled"));
	        $table = that._renderTable({
	            change: change
	        });
	        that._updateContent($table, change);
	        that.callBase(change);
	        that._lastColumnWidths = null
	    },
	    _getRows: function(change) {
	        return change && change.items || this._dataController.items()
	    },
	    _getCellOptions: function(options) {
	        var parameters, groupingTextsOptions, scrollingMode, that = this,
	            column = options.column,
	            row = options.row,
	            data = row.data,
	            summaryCells = row && row.summaryCells,
	            value = options.value,
	            displayValue = gridCore.getDisplayValue(column, value, data, row.rowType);
	        parameters = this.callBase(options);
	        parameters.value = value;
	        parameters.displayValue = displayValue;
	        parameters.row = row;
	        parameters.key = row.key;
	        parameters.data = data;
	        parameters.rowType = row.rowType;
	        parameters.values = row.values;
	        parameters.text = !column.command ? gridCore.formatValue(displayValue, column) : "";
	        parameters.rowIndex = row.rowIndex;
	        parameters.summaryItems = summaryCells && summaryCells[options.columnIndex];
	        parameters.resized = column.resizedCallbacks;
	        if (isDefined(column.groupIndex)) {
	            groupingTextsOptions = that.option("grouping.texts");
	            scrollingMode = that.option("scrolling.mode");
	            if ("virtual" !== scrollingMode && "infinite" !== scrollingMode) {
	                parameters.groupContinuesMessage = data && data.isContinuationOnNextPage && groupingTextsOptions && groupingTextsOptions.groupContinuesMessage;
	                parameters.groupContinuedMessage = data && data.isContinuation && groupingTextsOptions && groupingTextsOptions.groupContinuedMessage
	            }
	        }
	        return parameters
	    },
	    getCellOptions: function(rowIndex, columnIdentifier) {
	        var cellOptions, column, rowOptions = this._dataController.items()[rowIndex];
	        if (rowOptions) {
	            column = this._columnsController.columnOption(columnIdentifier);
	            if (column) {
	                cellOptions = this._getCellOptions({
	                    value: column.calculateCellValue(rowOptions.data),
	                    rowIndex: rowOptions.rowIndex,
	                    row: rowOptions,
	                    column: column
	                })
	            }
	        }
	        return cellOptions
	    },
	    getRow: function(index) {
	        var rows = this._getRowElements();
	        if (rows.length > index) {
	            return $(rows[index])
	        }
	    },
	    getCellIndex: function($cell) {
	        var cellIndex = $cell.length ? $cell[0].cellIndex : -1;
	        return cellIndex
	    },
	    updateFreeSpaceRowHeight: function($table) {
	        var elementHeight, freeSpaceRowCount, scrollingMode, resultHeight, that = this,
	            contentElement = that._findContentElement(),
	            freeSpaceRowElements = that._getFreeSpaceRowElements($table),
	            contentHeight = 0;
	        if (freeSpaceRowElements && contentElement) {
	            var isFreeSpaceRowVisible = false;
	            if (that._dataController.items().length > 0) {
	                if (!that._hasHeight) {
	                    freeSpaceRowCount = that._dataController.pageSize() - that._dataController.items().length;
	                    scrollingMode = that.option("scrolling.mode");
	                    if (freeSpaceRowCount > 0 && that._dataController.pageCount() > 1 && "virtual" !== scrollingMode && "infinite" !== scrollingMode) {
	                        freeSpaceRowElements.height(freeSpaceRowCount * that._rowHeight);
	                        isFreeSpaceRowVisible = true
	                    }
	                    if (!isFreeSpaceRowVisible && $table) {
	                        freeSpaceRowElements.height(0)
	                    } else {
	                        freeSpaceRowElements.css("display", isFreeSpaceRowVisible ? "" : "none")
	                    }
	                    that._updateLastRowBorder(isFreeSpaceRowVisible)
	                } else {
	                    freeSpaceRowElements.css("display", "none");
	                    commonUtils.deferUpdate(function() {
	                        elementHeight = that.element().height();
	                        contentHeight = contentElement.outerHeight();
	                        resultHeight = elementHeight - contentHeight - that.getScrollbarWidth(true);
	                        if (resultHeight > 0) {
	                            commonUtils.deferRender(function() {
	                                freeSpaceRowElements.height(resultHeight);
	                                isFreeSpaceRowVisible = true;
	                                freeSpaceRowElements.css("display", "")
	                            })
	                        }
	                        commonUtils.deferRender(function() {
	                            that._updateLastRowBorder(isFreeSpaceRowVisible)
	                        })
	                    })
	                }
	            } else {
	                freeSpaceRowElements.height(0);
	                freeSpaceRowElements.css("display", "");
	                that._updateLastRowBorder(true)
	            }
	        }
	    },
	    _columnOptionChanged: function(e) {
	        var optionNames = e.optionNames;
	        if (e.changeTypes.grouping) {
	            return
	        }
	        if (optionNames.width || optionNames.visibleWidth) {
	            this.callBase(e);
	            this._fireColumnResizedCallbacks()
	        }
	    },
	    getScrollable: function() {
	        return this._scrollable
	    },
	    init: function() {
	        var that = this,
	            dataController = that.getController("data");
	        that.callBase();
	        that._editorFactoryController = that.getController("editorFactory");
	        that._rowHeight = 0;
	        that._scrollTop = 0;
	        that._scrollLeft = 0;
	        that._hasHeight = false;
	        dataController.loadingChanged.add(function(isLoading, messageText) {
	            that.setLoading(isLoading, messageText)
	        });
	        dataController.dataSourceChanged.add(function() {
	            that._handleScroll({
	                scrollOffset: {
	                    top: that._scrollTop,
	                    left: that._scrollLeft
	                }
	            })
	        })
	    },
	    _handleDataChanged: function(change) {
	        var that = this;
	        switch (change.changeType) {
	            case "refresh":
	            case "prepend":
	            case "append":
	            case "update":
	                that.render(null, change);
	                break;
	            default:
	                that._update(change)
	        }
	    },
	    publicMethods: function() {
	        return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"]
	    },
	    contentWidth: function() {
	        return this.element().width() - this.getScrollbarWidth()
	    },
	    getScrollbarWidth: function(isHorizontal) {
	        var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0),
	            scrollbarWidth = 0;
	        if (scrollableContainer) {
	            if (!isHorizontal) {
	                scrollbarWidth = scrollableContainer.clientWidth ? scrollableContainer.offsetWidth - scrollableContainer.clientWidth : 0
	            } else {
	                scrollbarWidth = scrollableContainer.clientHeight ? scrollableContainer.offsetHeight - scrollableContainer.clientHeight : 0
	            }
	        }
	        return scrollbarWidth > 0 ? scrollbarWidth : 0
	    },
	    _fireColumnResizedCallbacks: function() {
	        var i, that = this,
	            lastColumnWidths = that._lastColumnWidths || [],
	            columnWidths = [],
	            columns = that.getColumns();
	        for (i = 0; i < columns.length; i++) {
	            columnWidths[i] = columns[i].visibleWidth;
	            if (columns[i].resizedCallbacks && !isDefined(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i]) {
	                columns[i].resizedCallbacks.fire(columnWidths[i])
	            }
	        }
	        that._lastColumnWidths = columnWidths
	    },
	    _updateLastRowBorder: function(isFreeSpaceRowVisible) {
	        if (this.option("showBorders") && this.option("showRowLines") && !isFreeSpaceRowVisible) {
	            this.element().addClass(DATAGRID_LAST_ROW_BORDER)
	        } else {
	            this.element().removeClass(DATAGRID_LAST_ROW_BORDER)
	        }
	    },
	    _updateScrollable: function() {
	        var dxScrollable = Scrollable.getInstance(this.element());
	        if (dxScrollable) {
	            dxScrollable.update();
	            this._updateHorizontalScrollPosition()
	        }
	    },
	    _updateHorizontalScrollPosition: function() {
	        var scrollable = this.getScrollable(),
	            scrollLeft = scrollable && scrollable.scrollOffset().left;
	        if (0 === scrollLeft && scrollLeft !== this._scrollLeft) {
	            scrollable.scrollTo({
	                x: this._scrollLeft
	            })
	        }
	    },
	    _resizeCore: function() {
	        var that = this;
	        that._fireColumnResizedCallbacks();
	        that._updateRowHeight();
	        commonUtils.deferRender(function() {
	            that._renderScrollable();
	            that._renderNoDataText();
	            that.updateFreeSpaceRowHeight()
	        });
	        that._updateScrollable();
	        that.setLoading(that._dataController.isLoading())
	    },
	    scrollTo: function(location) {
	        var $element = this.element(),
	            dxScrollable = $element && Scrollable.getInstance($element);
	        if (dxScrollable) {
	            dxScrollable.scrollTo(location)
	        }
	    },
	    height: function(height, hasHeight) {
	        var that = this,
	            $element = this.element();
	        if (isDefined(height)) {
	            that._hasHeight = void 0 === hasHeight ? "auto" !== height : hasHeight;
	            if ($element) {
	                $element.css("height", height)
	            }
	        } else {
	            return $element ? $element.outerHeight(true) : 0
	        }
	    },
	    setLoading: function(isLoading, messageText) {
	        var visibilityOptions, that = this,
	            loadPanel = that._loadPanel,
	            dataController = that._dataController,
	            loadPanelOptions = that.option("loadPanel") || {},
	            animation = dataController.isLoaded() ? loadPanelOptions.animation : null,
	            $element = that.element();
	        if (!loadPanel && void 0 !== messageText && dataController.isLocalStore() && "auto" === loadPanelOptions.enabled && $element) {
	            that._renderLoadPanel($element, $element.parent());
	            loadPanel = that._loadPanel
	        }
	        if (loadPanel) {
	            visibilityOptions = {
	                message: messageText || loadPanelOptions.text,
	                animation: animation,
	                visible: isLoading
	            };
	            clearTimeout(that._hideLoadingTimeoutID);
	            if (loadPanel.option("visible") && !isLoading) {
	                that._hideLoadingTimeoutID = setTimeout(function() {
	                    loadPanel.option(visibilityOptions)
	                }, DATAGRID_LOADPANEL_HIDE_TIMEOUT)
	            } else {
	                loadPanel.option(visibilityOptions)
	            }
	        }
	    },
	    setRowsOpacity: function(columnIndex, value) {
	        var i, that = this,
	            columnsController = that._columnsController,
	            visibleColumns = that.getColumns(),
	            columns = columnsController.getColumns(),
	            column = columns && columns[columnIndex],
	            columnID = column && column.isBand && column.index,
	            $rows = that._getRowElements().not("." + DATAGRID_GROUP_ROW_CLASS) || [];
	        $.each($rows, function(rowIndex, row) {
	            if (!$(row).hasClass(DATAGRID_GROUP_ROW_CLASS)) {
	                for (i = 0; i < visibleColumns.length; i++) {
	                    if (commonUtils.isNumber(columnID) && columnsController.isParentBandColumn(visibleColumns[i].index, columnID) || visibleColumns[i].index === columnIndex) {
	                        that.getCellElements(rowIndex).eq(i).css({
	                            opacity: value
	                        });
	                        if (!commonUtils.isNumber(columnID)) {
	                            break
	                        }
	                    }
	                }
	            }
	        })
	    },
	    _getCellElementsCore: function(rowIndex) {
	        var groupCellIndex, $cells = this.callBase(rowIndex);
	        if ($cells) {
	            groupCellIndex = $cells.filter("." + DATAGRID_GROUP_CELL_CLASS).index();
	            if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1) {
	                $cells.length = groupCellIndex + 1
	            }
	        }
	        return $cells
	    },
	    getTopVisibleItemIndex: function() {
	        var rowElements, rowElement, that = this,
	            itemIndex = 0,
	            prevOffsetTop = 0,
	            offsetTop = 0,
	            scrollPosition = that._scrollTop,
	            contentElementOffsetTop = that._findContentElement().offset().top,
	            items = that._dataController.items(),
	            tableElement = that._getTableElement();
	        if (items.length && tableElement) {
	            rowElements = tableElement.children("tbody").children(".dx-row:visible, .dx-error-row").not("." + DATAGRID_FREE_SPACE_CLASS);
	            for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
	                prevOffsetTop = offsetTop;
	                rowElement = rowElements.eq(itemIndex);
	                if (rowElement.length) {
	                    offsetTop = rowElement.offset().top - contentElementOffsetTop;
	                    if (offsetTop > scrollPosition) {
	                        if (2 * scrollPosition < offsetTop + prevOffsetTop && itemIndex) {
	                            itemIndex--
	                        }
	                        break
	                    }
	                }
	            }
	            if (itemIndex && itemIndex === items.length) {
	                itemIndex--
	            }
	        }
	        return itemIndex
	    },
	    getTopVisibleRowData: function() {
	        var itemIndex = this.getTopVisibleItemIndex(),
	            items = this._dataController.items();
	        if (items[itemIndex]) {
	            return items[itemIndex].data
	        }
	    },
	    optionChanged: function(args) {
	        var that = this;
	        that.callBase(args);
	        switch (args.name) {
	            case "wordWrapEnabled":
	            case "showColumnLines":
	            case "showRowLines":
	            case "rowAlternationEnabled":
	            case "rowTemplate":
	            case "twoWayBindingEnabled":
	                that._invalidate(true, true);
	                args.handled = true;
	                break;
	            case "scrolling":
	                that._rowHeight = null;
	                that._tableElement = null;
	                args.handled = true;
	                break;
	            case "rtlEnabled":
	                that._rowHeight = null;
	                that._tableElement = null;
	                break;
	            case "loadPanel":
	                that._tableElement = null;
	                that._invalidate(true, true);
	                args.handled = true;
	                break;
	            case "noDataText":
	                that._renderNoDataText();
	                args.handled = true
	        }
	    },
	    dispose: function() {
	        clearTimeout(this._hideLoadingTimeoutID)
	    },
	    setScrollerSpacing: function() {}
	});
	gridCore.registerModule("rows", {
	    defaultOptions: function() {
	        return {
	            hoverStateEnabled: false,
	            loadPanel: {
	                enabled: "auto",
	                text: messageLocalization.format("Loading"),
	                width: 200,
	                height: 90,
	                showIndicator: true,
	                indicatorSrc: "",
	                showPane: true
	            },
	            rowTemplate: null,
	            columnAutoWidth: false,
	            noDataText: messageLocalization.format("dxDataGrid-noDataText"),
	            wordWrapEnabled: false,
	            showColumnLines: true,
	            showRowLines: false,
	            rowAlternationEnabled: false,
	            activeStateEnabled: false,
	            twoWayBindingEnabled: true
	        }
	    },
	    views: {
	        rowsView: exports.RowsView
	    }
	});


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scrollable.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    support = __webpack_require__(48),
	    browser = __webpack_require__(16),
	    commonUtils = __webpack_require__(8),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    DOMComponent = __webpack_require__(28),
	    selectors = __webpack_require__(91),
	    eventUtils = __webpack_require__(61),
	    scrollEvents = __webpack_require__(158),
	    simulatedStrategy = __webpack_require__(159),
	    NativeStrategy = __webpack_require__(162),
	    when = __webpack_require__(10).when;
	var SCROLLABLE = "dxScrollable",
	    SCROLLABLE_STRATEGY = "dxScrollableStrategy",
	    SCROLLABLE_CLASS = "dx-scrollable",
	    SCROLLABLE_DISABLED_CLASS = "dx-scrollable-disabled",
	    SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container",
	    SCROLLABLE_WRAPPER_CLASS = "dx-scrollable-wrapper",
	    SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content",
	    VERTICAL = "vertical",
	    HORIZONTAL = "horizontal",
	    BOTH = "both";
	var beforeActivateExists = void 0 !== document.onbeforeactivate;
	var deviceDependentOptions = function() {
	    return [{
	        device: function() {
	            return !support.nativeScrolling
	        },
	        options: {
	            useNative: false
	        }
	    }, {
	        device: function(device) {
	            return !support.nativeScrolling && !devices.isSimulator() && "generic" === devices.real().platform && "generic" === device.platform
	        },
	        options: {
	            bounceEnabled: false,
	            scrollByThumb: true,
	            scrollByContent: support.touch,
	            showScrollbar: "onHover"
	        }
	    }]
	};
	var Scrollable = DOMComponent.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            disabled: false,
	            onScroll: null,
	            direction: VERTICAL,
	            showScrollbar: "onScroll",
	            useNative: true,
	            bounceEnabled: true,
	            scrollByContent: true,
	            scrollByThumb: false,
	            onUpdated: null,
	            onStart: null,
	            onEnd: null,
	            onBounce: null,
	            onStop: null,
	            useSimulatedScrollbar: false,
	            useKeyboard: true,
	            inertiaEnabled: true,
	            pushBackValue: 0,
	            updateManually: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat(deviceDependentOptions(), [{
	            device: function() {
	                return support.nativeScrolling && "android" === devices.real().platform
	            },
	            options: {
	                useSimulatedScrollbar: true
	            }
	        }, {
	            device: function() {
	                return "ios" === devices.real().platform
	            },
	            options: {
	                pushBackValue: 1
	            }
	        }])
	    },
	    _initOptions: function(options) {
	        this.callBase(options);
	        if (!("useSimulatedScrollbar" in options)) {
	            this._setUseSimulatedScrollbar()
	        }
	    },
	    _setUseSimulatedScrollbar: function() {
	        if (!this.initialOption("useSimulatedScrollbar")) {
	            this.option("useSimulatedScrollbar", !this.option("useNative"))
	        }
	    },
	    _init: function() {
	        this.callBase();
	        this._initMarkup();
	        this._attachNativeScrollbarsCustomizationCss();
	        this._locked = false
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this.update();
	            this._toggleRTLDirection(this.option("rtlEnabled"));
	            this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
	            delete this._savedScrollOffset
	        } else {
	            this._savedScrollOffset = this.scrollOffset()
	        }
	    },
	    _initMarkup: function() {
	        var $element = this.element().addClass(SCROLLABLE_CLASS),
	            $container = this._$container = $("<div>").addClass(SCROLLABLE_CONTAINER_CLASS),
	            $wrapper = this._$wrapper = $("<div>").addClass(SCROLLABLE_WRAPPER_CLASS),
	            $content = this._$content = $("<div>").addClass(SCROLLABLE_CONTENT_CLASS);
	        if (beforeActivateExists) {
	            $element.on(eventUtils.addNamespace("beforeactivate", SCROLLABLE), function(e) {
	                if (!$(e.target).is(selectors.focusable)) {
	                    e.preventDefault()
	                }
	            })
	        }
	        $content.append($element.contents()).appendTo($container);
	        $container.appendTo($wrapper);
	        $wrapper.appendTo($element)
	    },
	    _dimensionChanged: function() {
	        this.update()
	    },
	    _attachNativeScrollbarsCustomizationCss: function() {
	        if (!(navigator.platform.indexOf("Mac") > -1 && browser.webkit)) {
	            this.element().addClass("dx-scrollable-customizable-scrollbars")
	        }
	    },
	    _render: function() {
	        this._renderDirection();
	        this._renderStrategy();
	        this._attachEventHandlers();
	        this._renderDisabledState();
	        this._createActions();
	        this.update();
	        this.callBase()
	    },
	    _toggleRTLDirection: function(rtl) {
	        var that = this;
	        this.callBase(rtl);
	        if (rtl && this.option("direction") !== VERTICAL) {
	            commonUtils.deferUpdate(function() {
	                var left = that.scrollWidth() - that.clientWidth();
	                commonUtils.deferRender(function() {
	                    that.scrollTo({
	                        left: left
	                    })
	                })
	            })
	        }
	    },
	    _attachEventHandlers: function() {
	        var strategy = this._strategy;
	        var initEventData = {
	            getDirection: $.proxy(strategy.getDirection, strategy),
	            validate: $.proxy(this._validate, this),
	            isNative: this.option("useNative"),
	            scrollTarget: this._$container
	        };
	        this._$wrapper.off("." + SCROLLABLE).on(eventUtils.addNamespace(scrollEvents.init, SCROLLABLE), initEventData, $.proxy(this._initHandler, this)).on(eventUtils.addNamespace(scrollEvents.start, SCROLLABLE), $.proxy(strategy.handleStart, strategy)).on(eventUtils.addNamespace(scrollEvents.move, SCROLLABLE), $.proxy(strategy.handleMove, strategy)).on(eventUtils.addNamespace(scrollEvents.end, SCROLLABLE), $.proxy(strategy.handleEnd, strategy)).on(eventUtils.addNamespace(scrollEvents.cancel, SCROLLABLE), $.proxy(strategy.handleCancel, strategy)).on(eventUtils.addNamespace(scrollEvents.stop, SCROLLABLE), $.proxy(strategy.handleStop, strategy));
	        this._$container.off("." + SCROLLABLE).on(eventUtils.addNamespace("scroll", SCROLLABLE), $.proxy(strategy.handleScroll, strategy))
	    },
	    _validate: function(e) {
	        if (this._isLocked()) {
	            return false
	        }
	        this._updateIfNeed();
	        return this._strategy.validate(e)
	    },
	    _initHandler: function() {
	        var strategy = this._strategy;
	        strategy.handleInit.apply(strategy, arguments)
	    },
	    _renderDisabledState: function() {
	        this.element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option("disabled"));
	        if (this.option("disabled")) {
	            this._lock()
	        } else {
	            this._unlock()
	        }
	    },
	    _renderDirection: function() {
	        this.element().removeClass("dx-scrollable-" + HORIZONTAL).removeClass("dx-scrollable-" + VERTICAL).removeClass("dx-scrollable-" + BOTH).addClass("dx-scrollable-" + this.option("direction"))
	    },
	    _renderStrategy: function() {
	        this._createStrategy();
	        this._strategy.render();
	        this.element().data(SCROLLABLE_STRATEGY, this._strategy)
	    },
	    _createStrategy: function() {
	        this._strategy = this.option("useNative") ? new NativeStrategy(this) : new simulatedStrategy.SimulatedStrategy(this)
	    },
	    _createActions: function() {
	        this._strategy.createActions()
	    },
	    _clean: function() {
	        this._strategy.dispose()
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "onStart":
	            case "onEnd":
	            case "onStop":
	            case "onUpdated":
	            case "onScroll":
	            case "onBounce":
	                this._createActions();
	                break;
	            case "direction":
	                this._resetInactiveDirection();
	                this._invalidate();
	                break;
	            case "useNative":
	                this._setUseSimulatedScrollbar();
	                this._invalidate();
	                break;
	            case "inertiaEnabled":
	            case "scrollByContent":
	            case "scrollByThumb":
	            case "bounceEnabled":
	            case "useKeyboard":
	            case "showScrollbar":
	            case "useSimulatedScrollbar":
	            case "pushBackValue":
	                this._invalidate();
	                break;
	            case "disabled":
	                this._renderDisabledState();
	                break;
	            case "updateManually":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _resetInactiveDirection: function() {
	        var inactiveProp = this._getInactiveProp();
	        if (!inactiveProp) {
	            return
	        }
	        var scrollOffset = this.scrollOffset();
	        scrollOffset[inactiveProp] = 0;
	        this.scrollTo(scrollOffset)
	    },
	    _getInactiveProp: function() {
	        var direction = this.option("direction");
	        if (direction === VERTICAL) {
	            return "left"
	        }
	        if (direction === HORIZONTAL) {
	            return "top"
	        }
	    },
	    _location: function() {
	        return this._strategy.location()
	    },
	    _normalizeLocation: function(location) {
	        if ($.isPlainObject(location)) {
	            var left = commonUtils.ensureDefined(location.left, location.x);
	            var top = commonUtils.ensureDefined(location.top, location.y);
	            return {
	                left: commonUtils.isDefined(left) ? -left : void 0,
	                top: commonUtils.isDefined(top) ? -top : void 0
	            }
	        } else {
	            var direction = this.option("direction");
	            return {
	                left: direction !== VERTICAL ? -location : void 0,
	                top: direction !== HORIZONTAL ? -location : void 0
	            }
	        }
	    },
	    _isLocked: function() {
	        return this._locked
	    },
	    _lock: function() {
	        this._locked = true
	    },
	    _unlock: function() {
	        if (!this.option("disabled")) {
	            this._locked = false
	        }
	    },
	    _isDirection: function(direction) {
	        var current = this.option("direction");
	        if (direction === VERTICAL) {
	            return current !== HORIZONTAL
	        }
	        if (direction === HORIZONTAL) {
	            return current !== VERTICAL
	        }
	        return current === direction
	    },
	    _updateAllowedDirection: function() {
	        var allowedDirections = this._strategy._allowedDirections();
	        if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
	            this._allowedDirectionValue = BOTH
	        } else {
	            if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {
	                this._allowedDirectionValue = HORIZONTAL
	            } else {
	                if (this._isDirection(VERTICAL) && allowedDirections.vertical) {
	                    this._allowedDirectionValue = VERTICAL
	                } else {
	                    this._allowedDirectionValue = null
	                }
	            }
	        }
	    },
	    _allowedDirection: function() {
	        return this._allowedDirectionValue
	    },
	    _container: function() {
	        return this._$container
	    },
	    content: function() {
	        return this._$content
	    },
	    scrollOffset: function() {
	        var location = this._location();
	        return {
	            top: -location.top,
	            left: -location.left
	        }
	    },
	    scrollTop: function() {
	        return this.scrollOffset().top
	    },
	    scrollLeft: function() {
	        return this.scrollOffset().left
	    },
	    clientHeight: function() {
	        return this._$container.height()
	    },
	    scrollHeight: function() {
	        return this.content().outerHeight() - 2 * this._strategy.verticalOffset()
	    },
	    clientWidth: function() {
	        return this._$container.width()
	    },
	    scrollWidth: function() {
	        return this.content().outerWidth()
	    },
	    update: function() {
	        var that = this;
	        return when(that._strategy.update()).done(function() {
	            that._updateAllowedDirection()
	        })
	    },
	    scrollBy: function(distance) {
	        distance = this._normalizeLocation(distance);
	        if (!distance.top && !distance.left) {
	            return
	        }
	        this._updateIfNeed();
	        this._strategy.scrollBy(distance)
	    },
	    scrollTo: function(targetLocation) {
	        targetLocation = this._normalizeLocation(targetLocation);
	        this._updateIfNeed();
	        var location = this._location();
	        var distance = this._normalizeLocation({
	            left: location.left - commonUtils.ensureDefined(targetLocation.left, location.left),
	            top: location.top - commonUtils.ensureDefined(targetLocation.top, location.top)
	        });
	        if (!distance.top && !distance.left) {
	            return
	        }
	        this._strategy.scrollBy(distance)
	    },
	    scrollToElement: function(element, offset) {
	        offset = offset || {};
	        var $element = $(element);
	        var elementInsideContent = this.content().find(element).length;
	        var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS).length === 0;
	        if (!elementInsideContent || !elementIsInsideContent) {
	            return
	        }
	        var scrollPosition = {
	            top: 0,
	            left: 0
	        };
	        var direction = this.option("direction");
	        if (direction !== VERTICAL) {
	            scrollPosition.left = this._scrollToElementPosition($element, HORIZONTAL, offset)
	        }
	        if (direction !== HORIZONTAL) {
	            scrollPosition.top = this._scrollToElementPosition($element, VERTICAL, offset)
	        }
	        this.scrollTo(scrollPosition)
	    },
	    _scrollToElementPosition: function($element, direction, offset) {
	        var isVertical = direction === VERTICAL;
	        var startOffset = (isVertical ? offset.top : offset.left) || 0;
	        var endOffset = (isVertical ? offset.bottom : offset.right) || 0;
	        var pushBackOffset = isVertical ? this._strategy.verticalOffset() : 0;
	        var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? "top" : "left");
	        var elementPosition = elementPositionRelativeToContent - pushBackOffset;
	        var elementSize = $element[isVertical ? "outerHeight" : "outerWidth"]();
	        var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();
	        var clientSize = isVertical ? this.clientHeight() : this.clientWidth();
	        var startDistance = scrollLocation - elementPosition + startOffset;
	        var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;
	        if (startDistance <= 0 && endDistance >= 0) {
	            return scrollLocation
	        }
	        return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance)
	    },
	    _elementPositionRelativeToContent: function($element, prop) {
	        var result = 0;
	        while (this._hasScrollContent($element)) {
	            result += $element.position()[prop];
	            $element = $element.offsetParent()
	        }
	        return result
	    },
	    _hasScrollContent: function($element) {
	        var $content = this.content();
	        return $element.closest($content).length && !$element.is($content)
	    },
	    _updateIfNeed: function() {
	        if (!this.option("updateManually")) {
	            this.update()
	        }
	    }
	});
	registerComponent(SCROLLABLE, Scrollable);
	exports.default = Scrollable;
	exports.deviceDependentOptions = deviceDependentOptions;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.events.emitter.gesture.scroll.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    abstract = Class.abstract,
	    eventUtils = __webpack_require__(61),
	    GestureEmitter = __webpack_require__(76),
	    registerEmitter = __webpack_require__(74),
	    animationFrame = __webpack_require__(46),
	    realDevice = __webpack_require__(40).real(),
	    compareVersions = __webpack_require__(11).compare;
	var SCROLL_INIT_EVENT = "dxscrollinit",
	    SCROLL_START_EVENT = "dxscrollstart",
	    SCROLL_MOVE_EVENT = "dxscroll",
	    SCROLL_END_EVENT = "dxscrollend",
	    SCROLL_STOP_EVENT = "dxscrollstop",
	    SCROLL_CANCEL_EVENT = "dxscrollcancel";
	var isWheelEvent = function(e) {
	    return "dxmousewheel" === e.type
	};
	var Locker = Class.inherit(function() {
	    var NAMESPACED_SCROLL_EVENT = eventUtils.addNamespace("scroll", "dxScrollEmitter");
	    return {
	        ctor: function(element) {
	            this._element = element;
	            this._locked = false;
	            var that = this;
	            this._proxiedScroll = function(e) {
	                that._scroll(e)
	            };
	            $(this._element).on(NAMESPACED_SCROLL_EVENT, this._proxiedScroll)
	        },
	        _scroll: abstract,
	        check: function(e, callback) {
	            if (this._locked) {
	                callback()
	            }
	        },
	        dispose: function() {
	            $(this._element).off(NAMESPACED_SCROLL_EVENT, this._proxiedScroll)
	        }
	    }
	}());
	var TimeoutLocker = Locker.inherit(function() {
	    return {
	        ctor: function(element, timeout) {
	            this.callBase(element);
	            this._timeout = timeout
	        },
	        _scroll: function() {
	            this._prepare();
	            this._forget()
	        },
	        _prepare: function() {
	            if (this._timer) {
	                this._clearTimer()
	            }
	            this._locked = true
	        },
	        _clearTimer: function() {
	            clearTimeout(this._timer);
	            this._locked = false;
	            this._timer = null
	        },
	        _forget: function() {
	            var that = this;
	            this._timer = setTimeout(function() {
	                that._clearTimer()
	            }, this._timeout)
	        },
	        dispose: function() {
	            this.callBase();
	            this._clearTimer()
	        }
	    }
	}());
	var WheelLocker = TimeoutLocker.inherit(function() {
	    var WHEEL_UNLOCK_TIMEOUT = 400;
	    return {
	        ctor: function(element) {
	            this.callBase(element, WHEEL_UNLOCK_TIMEOUT);
	            this._lastWheelDirection = null
	        },
	        check: function(e, callback) {
	            this._checkDirectionChanged(e);
	            this.callBase(e, callback)
	        },
	        _checkDirectionChanged: function(e) {
	            if (!isWheelEvent(e)) {
	                this._lastWheelDirection = null;
	                return
	            }
	            var direction = e.shiftKey || false,
	                directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
	            this._lastWheelDirection = direction;
	            this._locked = this._locked && !directionChange
	        }
	    }
	}());
	var PointerLocker = TimeoutLocker.inherit(function() {
	    var POINTER_UNLOCK_TIMEOUT = 400;
	    return {
	        ctor: function(element) {
	            this.callBase(element, POINTER_UNLOCK_TIMEOUT)
	        }
	    }
	}());
	! function() {
	    var ios8_greater = realDevice.ios && compareVersions(realDevice.version, [8]) >= 0,
	        android5_greater = realDevice.android && compareVersions(realDevice.version, [5]) >= 0;
	    if (!(ios8_greater || android5_greater)) {
	        return
	    }
	    PointerLocker = Locker.inherit(function() {
	        return {
	            _scroll: function() {
	                this._locked = true;
	                var that = this;
	                this._scrollFrame = animationFrame.requestAnimationFrame(function() {
	                    that._locked = false
	                })
	            },
	            check: function(e, callback) {
	                animationFrame.cancelAnimationFrame(this._scrollFrame);
	                animationFrame.cancelAnimationFrame(this._checkFrame);
	                var that = this,
	                    callBase = this.callBase;
	                this._checkFrame = animationFrame.requestAnimationFrame(function() {
	                    callBase.call(that, e, callback);
	                    that._locked = false
	                })
	            },
	            dispose: function() {
	                this.callBase();
	                animationFrame.cancelAnimationFrame(this._scrollFrame);
	                animationFrame.cancelAnimationFrame(this._checkFrame)
	            }
	        }
	    }())
	}();
	var ScrollEmitter = GestureEmitter.inherit(function() {
	    var INERTIA_TIMEOUT = 100,
	        VELOCITY_CALC_TIMEOUT = 200,
	        FRAME_DURATION = Math.round(1e3 / 60);
	    return {
	        ctor: function(element) {
	            this.callBase.apply(this, arguments);
	            this.direction = "both";
	            this._pointerLocker = new PointerLocker(element);
	            this._wheelLocker = new WheelLocker(element)
	        },
	        validate: function() {
	            return true
	        },
	        configure: function(data) {
	            if (data.scrollTarget) {
	                this._pointerLocker.dispose();
	                this._wheelLocker.dispose();
	                this._pointerLocker = new PointerLocker(data.scrollTarget);
	                this._wheelLocker = new WheelLocker(data.scrollTarget)
	            }
	            this.callBase(data)
	        },
	        _init: function(e) {
	            var that = this;
	            this._wheelLocker.check(e, function() {
	                isWheelEvent(e) && that._accept(e)
	            });
	            this._pointerLocker.check(e, function() {
	                !isWheelEvent(e) && that._accept(e)
	            });
	            this._fireEvent(SCROLL_INIT_EVENT, e);
	            this._prevEventData = eventUtils.eventData(e)
	        },
	        move: function(e) {
	            this.callBase.apply(this, arguments);
	            e.isScrollingEvent = this.isNative || e.isScrollingEvent
	        },
	        _start: function(e) {
	            this._savedEventData = eventUtils.eventData(e);
	            this._fireEvent(SCROLL_START_EVENT, e);
	            this._prevEventData = eventUtils.eventData(e)
	        },
	        _move: function(e) {
	            var currentEventData = eventUtils.eventData(e);
	            this._fireEvent(SCROLL_MOVE_EVENT, e, {
	                delta: eventUtils.eventDelta(this._prevEventData, currentEventData)
	            });
	            var eventDelta = eventUtils.eventDelta(this._savedEventData, currentEventData);
	            if (eventDelta.time > VELOCITY_CALC_TIMEOUT) {
	                this._savedEventData = this._prevEventData
	            }
	            this._prevEventData = eventUtils.eventData(e)
	        },
	        _end: function(e) {
	            var endEventDelta = eventUtils.eventDelta(this._prevEventData, eventUtils.eventData(e));
	            var velocity = {
	                x: 0,
	                y: 0
	            };
	            if (!isWheelEvent(e) && endEventDelta.time < INERTIA_TIMEOUT) {
	                var eventDelta = eventUtils.eventDelta(this._savedEventData, this._prevEventData),
	                    velocityMultiplier = FRAME_DURATION / eventDelta.time;
	                velocity = {
	                    x: eventDelta.x * velocityMultiplier,
	                    y: eventDelta.y * velocityMultiplier
	                }
	            }
	            this._fireEvent(SCROLL_END_EVENT, e, {
	                velocity: velocity
	            })
	        },
	        _stop: function(e) {
	            this._fireEvent(SCROLL_STOP_EVENT, e)
	        },
	        cancel: function(e) {
	            this.callBase.apply(this, arguments);
	            this._fireEvent(SCROLL_CANCEL_EVENT, e)
	        },
	        dispose: function() {
	            this.callBase.apply(this, arguments);
	            this._pointerLocker.dispose();
	            this._wheelLocker.dispose()
	        }
	    }
	}());
	registerEmitter({
	    emitter: ScrollEmitter,
	    events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
	});
	module.exports = {
	    init: SCROLL_INIT_EVENT,
	    start: SCROLL_START_EVENT,
	    move: SCROLL_MOVE_EVENT,
	    end: SCROLL_END_EVENT,
	    stop: SCROLL_STOP_EVENT,
	    cancel: SCROLL_CANCEL_EVENT
	};


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scrollable.simulated.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    math = Math,
	    titleize = __webpack_require__(49).titleize,
	    translator = __webpack_require__(59),
	    Class = __webpack_require__(18),
	    Animator = __webpack_require__(160),
	    devices = __webpack_require__(40),
	    eventUtils = __webpack_require__(61),
	    commonUtils = __webpack_require__(8),
	    Scrollbar = __webpack_require__(161),
	    when = __webpack_require__(10).when;
	var realDevice = devices.real;
	var isSluggishPlatform = "win" === realDevice.platform || "android" === realDevice.platform;
	var SCROLLABLE_SIMULATED = "dxSimulatedScrollable",
	    SCROLLABLE_STRATEGY = "dxScrollableStrategy",
	    SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + "Cursor",
	    SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + "Keyboard",
	    SCROLLABLE_SIMULATED_CLASS = "dx-scrollable-simulated",
	    SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
	    SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible",
	    SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
	    VERTICAL = "vertical",
	    HORIZONTAL = "horizontal",
	    ACCELERATION = isSluggishPlatform ? .95 : .92,
	    OUT_BOUNDS_ACCELERATION = .5,
	    MIN_VELOCITY_LIMIT = 1,
	    FRAME_DURATION = math.round(1e3 / 60),
	    SCROLL_LINE_HEIGHT = 20,
	    BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5,
	    BOUNCE_DURATION = isSluggishPlatform ? 300 : 400,
	    BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION,
	    BOUNCE_ACCELERATION_SUM = (1 - math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
	var KEY_CODES = {
	    PAGE_UP: 33,
	    PAGE_DOWN: 34,
	    END: 35,
	    HOME: 36,
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40
	};
	var InertiaAnimator = Animator.inherit({
	    ctor: function(scroller) {
	        this.callBase();
	        this.scroller = scroller
	    },
	    VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
	    _isFinished: function() {
	        return math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT
	    },
	    _step: function() {
	        this.scroller._scrollStep(this.scroller._velocity);
	        this.scroller._velocity *= this._acceleration()
	    },
	    _acceleration: function() {
	        return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION
	    },
	    _complete: function() {
	        this.scroller._scrollComplete()
	    },
	    _stop: function() {
	        this.scroller._stopComplete()
	    }
	});
	var BounceAnimator = InertiaAnimator.inherit({
	    VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
	    _isFinished: function() {
	        return this.scroller._crossBoundOnNextStep() || this.callBase()
	    },
	    _acceleration: function() {
	        return ACCELERATION
	    },
	    _complete: function() {
	        this.scroller._move(this.scroller._bounceLocation);
	        this.callBase()
	    }
	});
	var isWheelEvent = function(e) {
	    return "dxmousewheel" === e.type
	};
	var Scroller = Class.inherit({
	    ctor: function(options) {
	        this._initOptions(options);
	        this._initAnimators();
	        this._initScrollbar()
	    },
	    _initOptions: function(options) {
	        this._location = 0;
	        this._topReached = false;
	        this._bottomReached = false;
	        this._axis = options.direction === HORIZONTAL ? "x" : "y";
	        this._prop = options.direction === HORIZONTAL ? "left" : "top";
	        this._dimension = options.direction === HORIZONTAL ? "width" : "height";
	        this._scrollProp = options.direction === HORIZONTAL ? "scrollLeft" : "scrollTop";
	        $.each(options, $.proxy(function(optionName, optionValue) {
	            this["_" + optionName] = optionValue
	        }, this))
	    },
	    _initAnimators: function() {
	        this._inertiaAnimator = new InertiaAnimator(this);
	        this._bounceAnimator = new BounceAnimator(this)
	    },
	    _initScrollbar: function() {
	        this._scrollbar = new Scrollbar($("<div>").appendTo(this._$container), {
	            direction: this._direction,
	            visible: this._scrollByThumb,
	            visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
	            expandable: this._scrollByThumb
	        });
	        this._$scrollbar = this._scrollbar.element()
	    },
	    _visibilityModeNormalize: function(mode) {
	        return true === mode ? "onScroll" : false === mode ? "never" : mode
	    },
	    _scrollStep: function(delta) {
	        var prevLocation = this._location;
	        this._location += delta;
	        this._suppressBounce();
	        this._move();
	        if (Math.abs(prevLocation - this._location) < 1) {
	            return
	        }
	        this._$container.triggerHandler({
	            type: "scroll"
	        })
	    },
	    _suppressBounce: function() {
	        if (this._bounceEnabled || this._inBounds(this._location)) {
	            return
	        }
	        this._velocity = 0;
	        this._location = this._boundLocation()
	    },
	    _boundLocation: function(location) {
	        location = void 0 !== location ? location : this._location;
	        return math.max(math.min(location, this._maxOffset), this._minOffset)
	    },
	    _move: function(location) {
	        this._location = void 0 !== location ? location : this._location;
	        this._moveContent();
	        this._moveScrollbar()
	    },
	    _moveContent: function() {
	        var location = this._location;
	        this._$container[this._scrollProp](-location);
	        this._moveContentByTranslator(location)
	    },
	    _moveContentByTranslator: function(location) {
	        var translateOffset, minOffset = -this._maxScrollPropValue;
	        if (location > 0) {
	            translateOffset = location
	        } else {
	            if (location <= minOffset) {
	                translateOffset = location - minOffset
	            } else {
	                translateOffset = location % 1
	            }
	        }
	        if (this._translateOffset === translateOffset) {
	            return
	        }
	        var targetLocation = {};
	        targetLocation[this._prop] = translateOffset;
	        this._translateOffset = translateOffset;
	        if (0 === translateOffset) {
	            translator.resetPosition(this._$content);
	            return
	        }
	        translator.move(this._$content, targetLocation)
	    },
	    _moveScrollbar: function() {
	        this._scrollbar.moveTo(this._location)
	    },
	    _scrollComplete: function() {
	        if (this._inBounds()) {
	            this._hideScrollbar();
	            this._correctLocation();
	            if (this._completeDeferred) {
	                this._completeDeferred.resolve()
	            }
	        }
	        this._scrollToBounds()
	    },
	    _correctLocation: function() {
	        this._location = math.round(this._location);
	        this._move()
	    },
	    _scrollToBounds: function() {
	        if (this._inBounds()) {
	            return
	        }
	        this._bounceAction();
	        this._setupBounce();
	        this._bounceAnimator.start()
	    },
	    _setupBounce: function() {
	        var boundLocation = this._bounceLocation = this._boundLocation(),
	            bounceDistance = boundLocation - this._location;
	        this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM
	    },
	    _inBounds: function(location) {
	        location = void 0 !== location ? location : this._location;
	        return this._boundLocation(location) === location
	    },
	    _crossBoundOnNextStep: function() {
	        var location = this._location,
	            nextLocation = location + this._velocity;
	        return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset
	    },
	    _initHandler: function(e) {
	        this._stopDeferred = $.Deferred();
	        this._stopScrolling();
	        this._prepareThumbScrolling(e);
	        return this._stopDeferred.promise()
	    },
	    _stopScrolling: commonUtils.deferRenderer(function() {
	        this._hideScrollbar();
	        this._inertiaAnimator.stop();
	        this._bounceAnimator.stop()
	    }),
	    _prepareThumbScrolling: function(e) {
	        if (isWheelEvent(e.originalEvent)) {
	            return
	        }
	        var $target = $(e.originalEvent.target);
	        var scrollbarClicked = this._isScrollbar($target);
	        if (scrollbarClicked) {
	            this._moveToMouseLocation(e)
	        }
	        this._thumbScrolling = scrollbarClicked || this._isThumb($target);
	        this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
	        if (this._thumbScrolling) {
	            this._scrollbar.feedbackOn()
	        }
	    },
	    _isThumbScrollingHandler: function($target) {
	        return this._isThumb($target)
	    },
	    _moveToMouseLocation: function(e) {
	        var mouseLocation = e["page" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
	        var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;
	        this._scrollStep(-Math.round(location))
	    },
	    _stopComplete: function() {
	        if (this._stopDeferred) {
	            this._stopDeferred.resolve()
	        }
	    },
	    _startHandler: function() {
	        this._showScrollbar()
	    },
	    _moveHandler: function(delta) {
	        if (this._crossThumbScrolling) {
	            return
	        }
	        if (this._thumbScrolling) {
	            delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio())
	        }
	        this._scrollBy(delta)
	    },
	    _scrollBy: function(delta) {
	        delta = delta[this._axis];
	        if (!this._inBounds()) {
	            delta *= OUT_BOUNDS_ACCELERATION
	        }
	        this._scrollStep(delta)
	    },
	    _scrollByHandler: function(delta) {
	        this._scrollBy(delta);
	        this._scrollComplete()
	    },
	    _containerToContentRatio: function() {
	        return this._scrollbar.containerToContentRatio()
	    },
	    _endHandler: function(velocity) {
	        this._completeDeferred = $.Deferred();
	        this._velocity = velocity[this._axis];
	        this._inertiaHandler();
	        this._resetThumbScrolling();
	        return this._completeDeferred.promise()
	    },
	    _inertiaHandler: function() {
	        this._suppressInertia();
	        this._inertiaAnimator.start()
	    },
	    _suppressInertia: function() {
	        if (!this._inertiaEnabled || this._thumbScrolling) {
	            this._velocity = 0
	        }
	    },
	    _resetThumbScrolling: function() {
	        this._thumbScrolling = false;
	        this._crossThumbScrolling = false
	    },
	    _stopHandler: function() {
	        if (this._thumbScrolling) {
	            this._scrollComplete()
	        }
	        this._resetThumbScrolling();
	        this._scrollToBounds()
	    },
	    _disposeHandler: function() {
	        this._stopScrolling();
	        this._$scrollbar.remove()
	    },
	    _updateHandler: function() {
	        this._update();
	        this._moveToBounds()
	    },
	    _update: function() {
	        var that = this;
	        that._stopScrolling();
	        return commonUtils.deferUpdate(function() {
	            that._updateLocation();
	            that._updateBounds();
	            that._updateScrollbar();
	            commonUtils.deferRender(function() {
	                that._moveScrollbar();
	                that._scrollbar.update()
	            })
	        })
	    },
	    _updateLocation: function() {
	        this._location = translator.locate(this._$content)[this._prop] - this._$container[this._scrollProp]()
	    },
	    _updateBounds: function() {
	        this._maxOffset = Math.round(this._getMaxOffset());
	        this._minOffset = Math.round(this._getMinOffset())
	    },
	    _getMaxOffset: function() {
	        return 0
	    },
	    _getMinOffset: function() {
	        this._maxScrollPropValue = math.max(this._contentSize() - this._containerSize(), 0);
	        return -this._maxScrollPropValue
	    },
	    _updateScrollbar: commonUtils.deferUpdater(function() {
	        var that = this,
	            containerSize = that._containerSize(),
	            contentSize = that._contentSize();
	        commonUtils.deferRender(function() {
	            that._scrollbar.option({
	                containerSize: containerSize,
	                contentSize: contentSize
	            })
	        })
	    }),
	    _moveToBounds: commonUtils.deferRenderer(commonUtils.deferUpdater(commonUtils.deferRenderer(function() {
	        var location = this._boundLocation();
	        var locationChanged = location !== this._location;
	        this._location = location;
	        this._move();
	        if (locationChanged) {
	            this._scrollAction()
	        }
	    }))),
	    _createActionsHandler: function(actions) {
	        this._scrollAction = actions.scroll;
	        this._bounceAction = actions.bounce
	    },
	    _showScrollbar: function() {
	        this._scrollbar.option("visible", true)
	    },
	    _hideScrollbar: function() {
	        this._scrollbar.option("visible", false)
	    },
	    _containerSize: function() {
	        return this._$container[this._dimension]()
	    },
	    _contentSize: function() {
	        var isOverflowHidden = "hidden" === this._$content.css("overflow-" + this._axis),
	            contentSize = this._$content[this._dimension]();
	        if (!isOverflowHidden) {
	            var containerScrollSize = this._$content[0]["scroll" + titleize(this._dimension)];
	            contentSize = math.max(containerScrollSize, contentSize)
	        }
	        return contentSize
	    },
	    _validateEvent: function(e) {
	        var $target = $(e.originalEvent.target);
	        if (this._isThumb($target) || this._isScrollbar($target)) {
	            e.preventDefault();
	            return true
	        }
	        return this._isContent($target)
	    },
	    _isThumb: function($element) {
	        return this._scrollByThumb && this._scrollbar.isThumb($element)
	    },
	    _isScrollbar: function($element) {
	        return this._scrollByThumb && $element && $element.is(this._$scrollbar)
	    },
	    _isContent: function($element) {
	        return this._scrollByContent && !!$element.closest(this._$element).length
	    },
	    _reachedMin: function() {
	        return this._location <= this._minOffset
	    },
	    _reachedMax: function() {
	        return this._location >= this._maxOffset
	    },
	    _cursorEnterHandler: function() {
	        this._scrollbar.cursorEnter()
	    },
	    _cursorLeaveHandler: function() {
	        this._scrollbar.cursorLeave()
	    },
	    dispose: $.noop
	});
	var hoveredScrollable, activeScrollable;
	var SimulatedStrategy = Class.inherit({
	    ctor: function(scrollable) {
	        this._init(scrollable)
	    },
	    _init: function(scrollable) {
	        this._component = scrollable;
	        this._$element = scrollable.element();
	        this._$container = scrollable._$container;
	        this._$wrapper = scrollable._$wrapper;
	        this._$content = scrollable._$content;
	        this.option = $.proxy(scrollable.option, scrollable);
	        this._createActionByOption = $.proxy(scrollable._createActionByOption, scrollable);
	        this._isLocked = $.proxy(scrollable._isLocked, scrollable);
	        this._isDirection = $.proxy(scrollable._isDirection, scrollable);
	        this._allowedDirection = $.proxy(scrollable._allowedDirection, scrollable)
	    },
	    render: function() {
	        this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
	        this._createScrollers();
	        if (this.option("useKeyboard")) {
	            this._$container.prop("tabindex", 0)
	        }
	        this._attachKeyboardHandler();
	        this._attachCursorHandlers()
	    },
	    _createScrollers: function() {
	        this._scrollers = {};
	        if (this._isDirection(HORIZONTAL)) {
	            this._createScroller(HORIZONTAL)
	        }
	        if (this._isDirection(VERTICAL)) {
	            this._createScroller(VERTICAL)
	        }
	        this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
	        this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option("showScrollbar"))
	    },
	    _createScroller: function(direction) {
	        this._scrollers[direction] = new Scroller(this._scrollerOptions(direction))
	    },
	    _scrollerOptions: function(direction) {
	        return {
	            direction: direction,
	            $content: this._$content,
	            $container: this._$container,
	            $wrapper: this._$wrapper,
	            $element: this._$element,
	            scrollByContent: this.option("scrollByContent"),
	            scrollByThumb: this.option("scrollByThumb"),
	            scrollbarVisible: this.option("showScrollbar"),
	            bounceEnabled: this.option("bounceEnabled"),
	            inertiaEnabled: this.option("inertiaEnabled"),
	            isAnyThumbScrolling: $.proxy(this._isAnyThumbScrolling, this)
	        }
	    },
	    _isAnyThumbScrolling: function($target) {
	        var result = false;
	        this._eventHandler("isThumbScrolling", $target).done(function(isThumbScrollingVertical, isThumbScrollingHorizontal) {
	            result = isThumbScrollingVertical || isThumbScrollingHorizontal
	        });
	        return result
	    },
	    handleInit: function(e) {
	        this._suppressDirections(e);
	        this._eventForUserAction = e;
	        this._eventHandler("init", e).done(this._stopAction)
	    },
	    _suppressDirections: function(e) {
	        if (isWheelEvent(e.originalEvent)) {
	            this._prepareDirections(true);
	            return
	        }
	        this._prepareDirections();
	        this._eachScroller(function(scroller, direction) {
	            var isValid = scroller._validateEvent(e);
	            this._validDirections[direction] = isValid
	        })
	    },
	    _prepareDirections: function(value) {
	        value = value || false;
	        this._validDirections = {};
	        this._validDirections[HORIZONTAL] = value;
	        this._validDirections[VERTICAL] = value
	    },
	    _eachScroller: function(callback) {
	        callback = $.proxy(callback, this);
	        $.each(this._scrollers, function(direction, scroller) {
	            callback(scroller, direction)
	        })
	    },
	    handleStart: function(e) {
	        this._eventForUserAction = e;
	        this._eventHandler("start").done(this._startAction)
	    },
	    _saveActive: function() {
	        activeScrollable = this
	    },
	    _resetActive: function() {
	        if (activeScrollable === this) {
	            activeScrollable = null
	        }
	    },
	    handleMove: function(e) {
	        if (this._isLocked()) {
	            e.cancel = true;
	            this._resetActive();
	            return
	        }
	        this._saveActive();
	        e.preventDefault && e.preventDefault();
	        this._adjustDistance(e.delta);
	        this._eventForUserAction = e;
	        this._eventHandler("move", e.delta)
	    },
	    _adjustDistance: function(distance) {
	        distance.x *= this._validDirections[HORIZONTAL];
	        distance.y *= this._validDirections[VERTICAL]
	    },
	    handleEnd: function(e) {
	        this._resetActive();
	        this._refreshCursorState(e.originalEvent && e.originalEvent.target);
	        this._adjustDistance(e.velocity);
	        this._eventForUserAction = e;
	        return this._eventHandler("end", e.velocity).done(this._endAction)
	    },
	    handleCancel: function(e) {
	        this._resetActive();
	        this._eventForUserAction = e;
	        return this._eventHandler("end", {
	            x: 0,
	            y: 0
	        })
	    },
	    handleStop: function() {
	        this._resetActive();
	        this._eventHandler("stop")
	    },
	    handleScroll: function() {
	        this._scrollAction()
	    },
	    _attachKeyboardHandler: function() {
	        this._$element.off("." + SCROLLABLE_SIMULATED_KEYBOARD);
	        if (!this.option("disabled") && this.option("useKeyboard")) {
	            this._$element.on(eventUtils.addNamespace("keydown", SCROLLABLE_SIMULATED_KEYBOARD), $.proxy(this._keyDownHandler, this))
	        }
	    },
	    _keyDownHandler: function(e) {
	        if (!this._$container.is(document.activeElement)) {
	            return
	        }
	        var handled = true;
	        switch (e.keyCode) {
	            case KEY_CODES.DOWN:
	                this._scrollByLine({
	                    y: 1
	                });
	                break;
	            case KEY_CODES.UP:
	                this._scrollByLine({
	                    y: -1
	                });
	                break;
	            case KEY_CODES.RIGHT:
	                this._scrollByLine({
	                    x: 1
	                });
	                break;
	            case KEY_CODES.LEFT:
	                this._scrollByLine({
	                    x: -1
	                });
	                break;
	            case KEY_CODES.PAGE_DOWN:
	                this._scrollByPage(1);
	                break;
	            case KEY_CODES.PAGE_UP:
	                this._scrollByPage(-1);
	                break;
	            case KEY_CODES.HOME:
	                this._scrollToHome();
	                break;
	            case KEY_CODES.END:
	                this._scrollToEnd();
	                break;
	            default:
	                handled = false
	        }
	        if (handled) {
	            e.stopPropagation();
	            e.preventDefault()
	        }
	    },
	    _scrollByLine: function(lines) {
	        this.scrollBy({
	            top: (lines.y || 0) * -SCROLL_LINE_HEIGHT,
	            left: (lines.x || 0) * -SCROLL_LINE_HEIGHT
	        })
	    },
	    _scrollByPage: function(page) {
	        var prop = this._wheelProp(),
	            dimension = this._dimensionByProp(prop);
	        var distance = {};
	        distance[prop] = page * -this._$container[dimension]();
	        this.scrollBy(distance)
	    },
	    _dimensionByProp: function(prop) {
	        return "left" === prop ? "width" : "height"
	    },
	    _scrollToHome: function() {
	        var prop = this._wheelProp();
	        var distance = {};
	        distance[prop] = 0;
	        this._component.scrollTo(distance)
	    },
	    _scrollToEnd: function() {
	        var prop = this._wheelProp(),
	            dimension = this._dimensionByProp(prop);
	        var distance = {};
	        distance[prop] = this._$content[dimension]() - this._$container[dimension]();
	        this._component.scrollTo(distance)
	    },
	    createActions: function() {
	        this._startAction = this._createActionHandler("onStart");
	        this._stopAction = this._createActionHandler("onStop");
	        this._endAction = this._createActionHandler("onEnd");
	        this._updateAction = this._createActionHandler("onUpdated");
	        this._createScrollerActions()
	    },
	    _createScrollerActions: function() {
	        this._scrollAction = this._createActionHandler("onScroll");
	        this._bounceAction = this._createActionHandler("onBounce");
	        this._eventHandler("createActions", {
	            scroll: this._scrollAction,
	            bounce: this._bounceAction
	        })
	    },
	    _createActionHandler: function(optionName) {
	        var that = this,
	            actionHandler = that._createActionByOption(optionName);
	        return function() {
	            actionHandler($.extend(that._createActionArgs(), arguments))
	        }
	    },
	    _createActionArgs: function() {
	        var scrollerX = this._scrollers[HORIZONTAL],
	            scrollerY = this._scrollers[VERTICAL];
	        this._scrollOffset = {
	            top: scrollerY && -scrollerY._location,
	            left: scrollerX && -scrollerX._location
	        };
	        return {
	            jQueryEvent: this._eventForUserAction,
	            scrollOffset: this._scrollOffset,
	            reachedLeft: scrollerX && scrollerX._reachedMax(),
	            reachedRight: scrollerX && scrollerX._reachedMin(),
	            reachedTop: scrollerY && scrollerY._reachedMax(),
	            reachedBottom: scrollerY && scrollerY._reachedMin()
	        }
	    },
	    _eventHandler: function(eventName) {
	        var args = $.makeArray(arguments).slice(1),
	            deferreds = $.map(this._scrollers, function(scroller) {
	                return scroller["_" + eventName + "Handler"].apply(scroller, args)
	            });
	        return when.apply($, deferreds).promise()
	    },
	    location: function() {
	        var location = translator.locate(this._$content);
	        location.top -= this._$container.scrollTop();
	        location.left -= this._$container.scrollLeft();
	        return location
	    },
	    disabledChanged: function() {
	        this._attachCursorHandlers()
	    },
	    _attachCursorHandlers: function() {
	        this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
	        if (!this.option("disabled") && this._isHoverMode()) {
	            this._$element.on(eventUtils.addNamespace("mouseenter", SCROLLABLE_SIMULATED_CURSOR), $.proxy(this._cursorEnterHandler, this)).on(eventUtils.addNamespace("mouseleave", SCROLLABLE_SIMULATED_CURSOR), $.proxy(this._cursorLeaveHandler, this))
	        }
	    },
	    _isHoverMode: function() {
	        return "onHover" === this.option("showScrollbar")
	    },
	    _cursorEnterHandler: function(e) {
	        e = e || {};
	        e.originalEvent = e.originalEvent || {};
	        if (activeScrollable || e.originalEvent._hoverHandled) {
	            return
	        }
	        if (hoveredScrollable) {
	            hoveredScrollable._cursorLeaveHandler()
	        }
	        hoveredScrollable = this;
	        this._eventHandler("cursorEnter");
	        e.originalEvent._hoverHandled = true
	    },
	    _cursorLeaveHandler: function(e) {
	        if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
	            return
	        }
	        this._eventHandler("cursorLeave");
	        hoveredScrollable = null;
	        this._refreshCursorState(e && e.relatedTarget)
	    },
	    _refreshCursorState: function(target) {
	        if (!this._isHoverMode() && (!target || activeScrollable)) {
	            return
	        }
	        var $target = $(target);
	        var $scrollable = $target.closest("." + SCROLLABLE_SIMULATED_CLASS + ":not(.dx-state-disabled)");
	        var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
	        if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
	            hoveredScrollable._cursorLeaveHandler()
	        }
	        if (targetScrollable) {
	            targetScrollable._cursorEnterHandler()
	        }
	    },
	    update: function() {
	        var that = this;
	        var result = this._eventHandler("update").done(this._updateAction);
	        return when(result, commonUtils.deferUpdate(function() {
	            var allowedDirections = that._allowedDirections();
	            var allowedScroll = allowedDirections.vertical || allowedDirections.horizontal;
	            commonUtils.deferRender(function() {
	                that._$container.css("touchAction", allowedScroll ? "none" : "")
	            });
	            return when().promise()
	        }))
	    },
	    _allowedDirections: function() {
	        var bounceEnabled = this.option("bounceEnabled"),
	            verticalScroller = this._scrollers[VERTICAL],
	            horizontalScroller = this._scrollers[HORIZONTAL];
	        return {
	            vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
	            horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
	        }
	    },
	    scrollBy: function(distance) {
	        var verticalScroller = this._scrollers[VERTICAL],
	            horizontalScroller = this._scrollers[HORIZONTAL];
	        if (verticalScroller) {
	            distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location
	        }
	        if (horizontalScroller) {
	            distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location
	        }
	        this._prepareDirections(true);
	        this._startAction();
	        this._eventHandler("scrollBy", {
	            x: distance.left,
	            y: distance.top
	        });
	        this._endAction()
	    },
	    validate: function(e) {
	        if (this.option("disabled")) {
	            return false
	        }
	        if (this.option("bounceEnabled")) {
	            return true
	        }
	        return isWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e)
	    },
	    _validateWheel: function(e) {
	        var scroller = this._scrollers[this._wheelDirection(e)];
	        var reachedMin = scroller._reachedMin();
	        var reachedMax = scroller._reachedMax();
	        var contentGreaterThanContainer = !reachedMin || !reachedMax;
	        var locatedNotAtBound = !reachedMin && !reachedMax;
	        var scrollFromMin = reachedMin && e.delta > 0;
	        var scrollFromMax = reachedMax && e.delta < 0;
	        return contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax)
	    },
	    _validateMove: function(e) {
	        if (!this.option("scrollByContent") && !$(e.target).closest("." + SCROLLABLE_SCROLLBAR_CLASS).length) {
	            return false
	        }
	        return this._allowedDirection()
	    },
	    getDirection: function(e) {
	        return isWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection()
	    },
	    _wheelProp: function() {
	        return this._wheelDirection() === HORIZONTAL ? "left" : "top"
	    },
	    _wheelDirection: function(e) {
	        switch (this.option("direction")) {
	            case HORIZONTAL:
	                return HORIZONTAL;
	            case VERTICAL:
	                return VERTICAL;
	            default:
	                return e && e.shiftKey ? HORIZONTAL : VERTICAL
	        }
	    },
	    verticalOffset: function() {
	        return 0
	    },
	    dispose: function() {
	        this._resetActive();
	        if (hoveredScrollable === this) {
	            hoveredScrollable = null
	        }
	        this._eventHandler("dispose");
	        this._detachEventHandlers();
	        this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
	        this._eventForUserAction = null;
	        clearTimeout(this._gestureEndTimer)
	    },
	    _detachEventHandlers: function() {
	        this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
	        this._$container.off("." + SCROLLABLE_SIMULATED_KEYBOARD)
	    }
	});
	exports.SimulatedStrategy = SimulatedStrategy;
	exports.Scroller = Scroller;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/animator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    abstract = Class.abstract,
	    animationFrame = __webpack_require__(46);
	var Animator = Class.inherit({
	    ctor: function() {
	        this._finished = true;
	        this._stopped = false;
	        this._proxiedStepCore = $.proxy(this._stepCore, this)
	    },
	    start: function() {
	        this._stopped = false;
	        this._finished = false;
	        this._stepCore()
	    },
	    stop: function() {
	        this._stopped = true;
	        animationFrame.cancelAnimationFrame(this._stepAnimationFrame)
	    },
	    _stepCore: function() {
	        if (this._isStopped()) {
	            this._stop();
	            return
	        }
	        if (this._isFinished()) {
	            this._finished = true;
	            this._complete();
	            return
	        }
	        this._step();
	        this._stepAnimationFrame = animationFrame.requestAnimationFrame(this._proxiedStepCore)
	    },
	    _step: abstract,
	    _isFinished: $.noop,
	    _stop: $.noop,
	    _complete: $.noop,
	    _isStopped: function() {
	        return this._stopped
	    },
	    inProgress: function() {
	        return !(this._stopped || this._finished)
	    }
	});
	module.exports = Animator;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scrollbar.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    translator = __webpack_require__(59),
	    Widget = __webpack_require__(84),
	    eventUtils = __webpack_require__(61),
	    commonUtils = __webpack_require__(8),
	    pointerEvents = __webpack_require__(66);
	var SCROLLBAR = "dxScrollbar",
	    SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
	    SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = SCROLLABLE_SCROLLBAR_CLASS + "-active",
	    SCROLLABLE_SCROLL_CLASS = "dx-scrollable-scroll",
	    SCROLLABLE_SCROLL_CONTENT_CLASS = "dx-scrollable-scroll-content",
	    HOVER_ENABLED_STATE = "dx-scrollbar-hoverable",
	    HORIZONTAL = "horizontal",
	    THUMB_MIN_SIZE = 15;
	var SCROLLBAR_VISIBLE = {
	    onScroll: "onScroll",
	    onHover: "onHover",
	    always: "always",
	    never: "never"
	};
	var Scrollbar = Widget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            direction: null,
	            visible: false,
	            activeStateEnabled: false,
	            visibilityMode: SCROLLBAR_VISIBLE.onScroll,
	            containerSize: 0,
	            contentSize: 0,
	            expandable: true
	        })
	    },
	    _init: function() {
	        this.callBase();
	        this._isHovered = false
	    },
	    _render: function() {
	        this._renderThumb();
	        this.callBase();
	        this._renderDirection();
	        this._update();
	        this._attachPointerDownHandler();
	        this.option("hoverStateEnabled", this._isHoverMode());
	        this.element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"))
	    },
	    _renderThumb: function() {
	        this._$thumb = $("<div>").addClass(SCROLLABLE_SCROLL_CLASS);
	        $("<div>").addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
	        this.element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb)
	    },
	    isThumb: function($element) {
	        return !!this.element().find($element).length
	    },
	    _isHoverMode: function() {
	        var visibilityMode = this.option("visibilityMode");
	        return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable")
	    },
	    _renderDirection: function() {
	        var direction = this.option("direction");
	        this.element().addClass("dx-scrollbar-" + direction);
	        this._dimension = direction === HORIZONTAL ? "width" : "height";
	        this._prop = direction === HORIZONTAL ? "left" : "top"
	    },
	    _attachPointerDownHandler: function() {
	        this._$thumb.on(eventUtils.addNamespace(pointerEvents.down, SCROLLBAR), $.proxy(this.feedbackOn, this))
	    },
	    feedbackOn: function() {
	        this.element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
	        activeScrollbar = this
	    },
	    feedbackOff: function() {
	        this.element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
	        activeScrollbar = null
	    },
	    cursorEnter: function() {
	        this._isHovered = true;
	        this.option("visible", true)
	    },
	    cursorLeave: function() {
	        this._isHovered = false;
	        this.option("visible", false)
	    },
	    _renderDimensions: function() {
	        this._$thumb.css({
	            width: this.option("width"),
	            height: this.option("height")
	        })
	    },
	    _toggleVisibility: function(visible) {
	        if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll) {
	            this._$thumb.css("opacity")
	        }
	        visible = this._adjustVisibility(visible);
	        this.option().visible = visible;
	        this._$thumb.toggleClass("dx-state-invisible", !visible)
	    },
	    _adjustVisibility: function(visible) {
	        if (this.containerToContentRatio() && !this._needScrollbar()) {
	            return false
	        }
	        switch (this.option("visibilityMode")) {
	            case SCROLLBAR_VISIBLE.onScroll:
	                break;
	            case SCROLLBAR_VISIBLE.onHover:
	                visible = visible || !!this._isHovered;
	                break;
	            case SCROLLBAR_VISIBLE.never:
	                visible = false;
	                break;
	            case SCROLLBAR_VISIBLE.always:
	                visible = true
	        }
	        return visible
	    },
	    moveTo: function(location) {
	        if (this._isHidden()) {
	            return
	        }
	        if ($.isPlainObject(location)) {
	            location = location[this._prop] || 0
	        }
	        var scrollBarLocation = {};
	        scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
	        translator.move(this._$thumb, scrollBarLocation)
	    },
	    _calculateScrollBarPosition: function(location) {
	        return -location * this._thumbRatio
	    },
	    _update: function() {
	        var containerSize = this.option("containerSize"),
	            contentSize = this.option("contentSize");
	        this._containerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
	        var thumbSize = Math.round(Math.max(Math.round(containerSize * this._containerToContentRatio), THUMB_MIN_SIZE));
	        this._thumbRatio = (containerSize - thumbSize) / (contentSize - containerSize);
	        this.option(this._dimension, thumbSize);
	        this.element().css("display", this._needScrollbar() ? "" : "none")
	    },
	    _isHidden: function() {
	        return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never
	    },
	    _needScrollbar: function() {
	        return !this._isHidden() && this._containerToContentRatio < 1
	    },
	    containerToContentRatio: function() {
	        return this._containerToContentRatio
	    },
	    _normalizeSize: function(size) {
	        return $.isPlainObject(size) ? size[this._dimension] || 0 : size
	    },
	    _clean: function() {
	        this.callBase();
	        if (this === activeScrollbar) {
	            activeScrollbar = null
	        }
	        this._$thumb.off("." + SCROLLBAR)
	    },
	    _optionChanged: function(args) {
	        if (this._isHidden()) {
	            return
	        }
	        switch (args.name) {
	            case "containerSize":
	            case "contentSize":
	                this.option()[args.name] = this._normalizeSize(args.value);
	                this._update();
	                break;
	            case "visibilityMode":
	            case "direction":
	                this._invalidate();
	                break;
	            default:
	                this.callBase.apply(this, arguments)
	        }
	    },
	    update: commonUtils.deferRenderer(function() {
	        this._adjustVisibility() && this.option("visible", true)
	    })
	});
	var activeScrollbar = null;
	$(document).on(eventUtils.addNamespace(pointerEvents.up, SCROLLBAR), function() {
	    if (activeScrollbar) {
	        activeScrollbar.feedbackOff()
	    }
	});
	module.exports = Scrollbar;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scrollable.native.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    Class = __webpack_require__(18),
	    Scrollbar = __webpack_require__(161);
	var SCROLLABLE_NATIVE = "dxNativeScrollable",
	    SCROLLABLE_NATIVE_CLASS = "dx-scrollable-native",
	    SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated",
	    SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
	    VERTICAL = "vertical",
	    HORIZONTAL = "horizontal",
	    HIDE_SCROLLBAR_TIMEOUT = 500;
	var NativeStrategy = Class.inherit({
	    ctor: function(scrollable) {
	        this._init(scrollable)
	    },
	    _init: function(scrollable) {
	        this._component = scrollable;
	        this._$element = scrollable.element();
	        this._$container = scrollable._$container;
	        this._$content = scrollable._$content;
	        this._direction = scrollable.option("direction");
	        this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
	        this._showScrollbar = scrollable.option("showScrollbar");
	        this.option = $.proxy(scrollable.option, scrollable);
	        this._createActionByOption = $.proxy(scrollable._createActionByOption, scrollable);
	        this._isLocked = $.proxy(scrollable._isLocked, scrollable);
	        this._isDirection = $.proxy(scrollable._isDirection, scrollable);
	        this._allowedDirection = $.proxy(scrollable._allowedDirection, scrollable)
	    },
	    render: function() {
	        this._renderPushBackOffset();
	        var device = devices.real(),
	            deviceType = device.platform;
	        this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + "-" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);
	        if (this._showScrollbar && this._useSimulatedScrollbar) {
	            this._renderScrollbars()
	        }
	    },
	    _renderPushBackOffset: function() {
	        var pushBackValue = this.option("pushBackValue");
	        if (!pushBackValue && !this._component._lastPushBackValue) {
	            return
	        }
	        this._$content.css({
	            paddingTop: pushBackValue,
	            paddingBottom: pushBackValue
	        });
	        this._component._lastPushBackValue = pushBackValue
	    },
	    _renderScrollbars: function() {
	        this._scrollbars = {};
	        this._hideScrollbarTimeout = 0;
	        this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
	        this._renderScrollbar(VERTICAL);
	        this._renderScrollbar(HORIZONTAL)
	    },
	    _renderScrollbar: function(direction) {
	        if (!this._isDirection(direction)) {
	            return
	        }
	        this._scrollbars[direction] = new Scrollbar($("<div>").appendTo(this._$element), {
	            direction: direction,
	            expandable: this._component.option("scrollByThumb")
	        })
	    },
	    handleInit: $.noop,
	    handleStart: function() {
	        this._disablePushBack = true
	    },
	    handleMove: function(e) {
	        if (this._isLocked()) {
	            e.cancel = true;
	            return
	        }
	        if (this._allowedDirection()) {
	            e.originalEvent.isScrollingEvent = true
	        }
	    },
	    handleEnd: function() {
	        this._disablePushBack = false
	    },
	    handleStop: $.noop,
	    _eachScrollbar: function(callback) {
	        callback = $.proxy(callback, this);
	        $.each(this._scrollbars || {}, function(direction, scrollbar) {
	            callback(scrollbar, direction)
	        })
	    },
	    createActions: function() {
	        this._scrollAction = this._createActionByOption("onScroll");
	        this._updateAction = this._createActionByOption("onUpdated")
	    },
	    _createActionArgs: function() {
	        var location = this.location();
	        return {
	            jQueryEvent: this._eventForUserAction,
	            scrollOffset: {
	                top: -location.top,
	                left: -location.left
	            },
	            reachedLeft: this._isDirection(HORIZONTAL) ? location.left >= 0 : void 0,
	            reachedRight: this._isDirection(HORIZONTAL) ? location.left <= this._containerSize.width - this._componentContentSize.width : void 0,
	            reachedTop: this._isDirection(VERTICAL) ? location.top >= 0 : void 0,
	            reachedBottom: this._isDirection(VERTICAL) ? location.top <= this._containerSize.height - this._componentContentSize.height : void 0
	        }
	    },
	    handleScroll: function(e) {
	        if (!this._isScrollLocationChanged()) {
	            e.stopImmediatePropagation();
	            return
	        }
	        this._eventForUserAction = e;
	        this._moveScrollbars();
	        this._scrollAction(this._createActionArgs());
	        this._lastLocation = this.location();
	        this._pushBackFromBoundary()
	    },
	    _pushBackFromBoundary: function() {
	        var pushBackValue = this.option("pushBackValue");
	        if (!pushBackValue || this._disablePushBack) {
	            return
	        }
	        var scrollOffset = this._containerSize.height - this._contentSize.height,
	            scrollTopPos = this._$container.scrollTop(),
	            scrollBottomPos = scrollOffset + scrollTopPos - 2 * pushBackValue;
	        if (!scrollTopPos) {
	            this._$container.scrollTop(pushBackValue)
	        } else {
	            if (!scrollBottomPos) {
	                this._$container.scrollTop(pushBackValue - scrollOffset)
	            }
	        }
	    },
	    _isScrollLocationChanged: function() {
	        var currentLocation = this.location(),
	            lastLocation = this._lastLocation || {},
	            isTopChanged = lastLocation.top !== currentLocation.top,
	            isLeftChanged = lastLocation.left !== currentLocation.left;
	        return isTopChanged || isLeftChanged
	    },
	    _moveScrollbars: function() {
	        this._eachScrollbar(function(scrollbar) {
	            scrollbar.moveTo(this.location());
	            scrollbar.option("visible", true)
	        });
	        this._hideScrollbars()
	    },
	    _hideScrollbars: function() {
	        clearTimeout(this._hideScrollbarTimeout);
	        this._hideScrollbarTimeout = setTimeout($.proxy(function() {
	            this._eachScrollbar(function(scrollbar) {
	                scrollbar.option("visible", false)
	            })
	        }, this), HIDE_SCROLLBAR_TIMEOUT)
	    },
	    location: function() {
	        return {
	            left: -this._$container.scrollLeft(),
	            top: this.option("pushBackValue") - this._$container.scrollTop()
	        }
	    },
	    disabledChanged: $.noop,
	    update: function() {
	        this._update();
	        this._updateAction(this._createActionArgs())
	    },
	    _update: function() {
	        this._updateDimensions();
	        this._updateScrollbars()
	    },
	    _updateDimensions: function() {
	        this._containerSize = {
	            height: this._$container.height(),
	            width: this._$container.width()
	        };
	        this._componentContentSize = {
	            height: this._component.content().height(),
	            width: this._component.content().width()
	        };
	        this._contentSize = {
	            height: this._$content.height(),
	            width: this._$content.width()
	        };
	        this._pushBackFromBoundary()
	    },
	    _updateScrollbars: function() {
	        this._eachScrollbar(function(scrollbar, direction) {
	            var dimension = direction === VERTICAL ? "height" : "width";
	            scrollbar.option({
	                containerSize: this._containerSize[dimension],
	                contentSize: this._componentContentSize[dimension]
	            });
	            scrollbar.update()
	        })
	    },
	    _allowedDirections: function() {
	        return {
	            vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
	            horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width
	        }
	    },
	    dispose: function() {
	        this._$element.removeClass(function(index, className) {
	            var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + "\\S*", "g");
	            if (scrollableNativeRegexp.test(className)) {
	                return className.match(scrollableNativeRegexp).join(" ")
	            }
	        });
	        this._$element.off("." + SCROLLABLE_NATIVE);
	        this._$container.off("." + SCROLLABLE_NATIVE);
	        this._removeScrollbars();
	        clearTimeout(this._gestureEndTimer);
	        clearTimeout(this._hideScrollbarTimeout)
	    },
	    _removeScrollbars: function() {
	        this._eachScrollbar(function(scrollbar) {
	            scrollbar.element().remove()
	        })
	    },
	    scrollBy: function(distance) {
	        var location = this.location();
	        this._$container.scrollTop(-location.top - distance.top + this.option("pushBackValue"));
	        this._$container.scrollLeft(-location.left - distance.left)
	    },
	    validate: function() {
	        return !this.option("disabled") && this._allowedDirection()
	    },
	    getDirection: function() {
	        return this._allowedDirection()
	    },
	    verticalOffset: function() {
	        return this.option("pushBackValue")
	    }
	});
	module.exports = NativeStrategy;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.context_menu_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    ContextMenu = __webpack_require__(164);
	var DATAGRID_CLASS = "dx-datagrid",
	    DATAGRID_CONTEXT_MENU = "dx-context-menu",
	    viewName = {
	        columnHeadersView: "header",
	        rowsView: "content",
	        footerView: "footer",
	        headerPanel: "headerPanel"
	    },
	    VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
	exports.ContextMenuController = gridCore.ViewController.inherit({
	    init: function() {
	        this.createAction("onContextMenuPreparing")
	    },
	    getContextMenuItems: function(jQueryEvent) {
	        if (!jQueryEvent) {
	            return false
	        }
	        var view, options, rowIndex, columnIndex, rowOptions, $element, $targetRowElement, $targetCellElement, menuItems, that = this,
	            $targetElement = $(jQueryEvent.target);
	        $.each(VIEW_NAMES, function() {
	            view = that.getView(this);
	            $element = view && view.element();
	            if ($element && ($element.is($targetElement) || $element.find($targetElement).length)) {
	                $targetCellElement = $targetElement.closest("td");
	                $targetRowElement = $targetCellElement.closest(".dx-row");
	                rowIndex = view.getRowIndex($targetRowElement);
	                columnIndex = $targetCellElement[0] && $targetCellElement[0].cellIndex;
	                rowOptions = $targetRowElement.data("options");
	                options = {
	                    jQueryEvent: jQueryEvent,
	                    targetElement: $targetElement,
	                    target: viewName[this],
	                    rowIndex: rowIndex,
	                    row: view._getRows()[rowIndex],
	                    columnIndex: columnIndex,
	                    column: rowOptions && rowOptions.cells[columnIndex].column
	                };
	                options.items = view.getContextMenuItems && view.getContextMenuItems(options);
	                that.executeAction("onContextMenuPreparing", options);
	                that._contextMenuPrepared(options);
	                menuItems = options.items;
	                if (menuItems) {
	                    return false
	                }
	            }
	        });
	        return menuItems
	    },
	    _contextMenuPrepared: $.noop
	});
	exports.ContextMenuView = gridCore.View.inherit({
	    _renderCore: function() {
	        var that = this;
	        this._createComponent(that.element().addClass(DATAGRID_CONTEXT_MENU), ContextMenu, {
	            onPositioning: function(actionArgs) {
	                var event = actionArgs.jQueryEvent,
	                    contextMenuInstance = actionArgs.component,
	                    items = that.getController("contextMenu").getContextMenuItems(event);
	                if (items) {
	                    contextMenuInstance.option("items", items);
	                    event.stopPropagation()
	                } else {
	                    actionArgs.cancel = true
	                }
	            },
	            onItemClick: function(params) {
	                params.itemData.onItemClick && params.itemData.onItemClick(params)
	            },
	            cssClass: DATAGRID_CLASS,
	            target: that.component.element()
	        })
	    }
	});
	gridCore.registerModule("contextMenu", {
	    defaultOptions: function() {
	        return {
	            onContextMenuPreparing: null
	        }
	    },
	    controllers: {
	        contextMenu: exports.ContextMenuController
	    },
	    views: {
	        contextMenuView: exports.ContextMenuView
	    }
	});


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/context_menu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(165);
	module.exports.default = module.exports;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/context_menu/ui.context_menu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    fx = __webpack_require__(58),
	    positionUtils = __webpack_require__(60),
	    devices = __webpack_require__(40),
	    eventUtils = __webpack_require__(61),
	    Overlay = __webpack_require__(97),
	    MenuBase = __webpack_require__(166);
	var DX_MENU_CLASS = "dx-menu",
	    DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
	    DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
	    DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay",
	    DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
	    DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper",
	    DX_SUBMENU_CLASS = "dx-submenu",
	    DX_CONTEXT_MENU_CLASS = "dx-context-menu",
	    DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu",
	    DX_STATE_DISABLED_CLASS = "dx-state-disabled",
	    FOCUS_UP = "up",
	    FOCUS_DOWN = "down",
	    FOCUS_LEFT = "left",
	    FOCUS_RIGHT = "right",
	    FOCUS_FIRST = "first",
	    FOCUS_LAST = "last",
	    ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"],
	    LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST],
	    DEFAULT_SHOW_EVENT = "dxcontextmenu";
	var ContextMenu = MenuBase.inherit(function() {
	    var getShowEvent = function(that) {
	            var result = null,
	                optionValue = that.option("showEvent");
	            if (commonUtils.isObject(optionValue)) {
	                if (null !== optionValue.name) {
	                    result = optionValue.name || DEFAULT_SHOW_EVENT
	                }
	            } else {
	                result = optionValue
	            }
	            return result
	        },
	        getShowDelay = function(that) {
	            var optionValue = that.option("showEvent");
	            return commonUtils.isObject(optionValue) && optionValue.delay
	        };
	    return {
	        _getDefaultOptions: function() {
	            return $.extend(this.callBase(), {
	                showEvent: DEFAULT_SHOW_EVENT,
	                closeOnOutsideClick: true,
	                position: {
	                    at: "top left",
	                    my: "top left"
	                },
	                onShowing: null,
	                onShown: null,
	                onHiding: null,
	                onHidden: null,
	                onPositioning: null,
	                submenuDirection: "auto",
	                visible: false,
	                target: window,
	                onLeftFirstItem: null,
	                onLeftLastItem: null,
	                onCloseRootSubmenu: null,
	                onExpandLastSubmenu: null
	            })
	        },
	        _initActions: function() {
	            this._actions = {};
	            $.each(ACTIONS, $.proxy(function(index, action) {
	                this._actions[action] = this._createActionByOption(action) || $.noop
	            }, this))
	        },
	        _setOptionsByReference: function() {
	            this.callBase();
	            $.extend(this._optionsByReference, {
	                animation: true,
	                selectedItem: true
	            })
	        },
	        _focusInHandler: $.noop,
	        _itemContainer: function() {
	            return this._overlay ? this._overlay.content() : $()
	        },
	        _eventBindingTarget: function() {
	            return this._itemContainer()
	        },
	        itemsContainer: function() {
	            return this._overlay ? this._overlay.content() : void 0
	        },
	        _supportedKeys: function() {
	            var selectItem = function() {
	                var $item = this.option("focusedElement");
	                this.hide();
	                if (!$item || !this._isSelectionEnabled()) {
	                    return
	                }
	                this.selectItem($item[0])
	            };
	            return $.extend(this.callBase(), {
	                space: selectItem,
	                esc: this.hide
	            })
	        },
	        _getActiveItem: function() {
	            var $items = this._getAvailableItems(),
	                $focusedItem = $items.filter(".dx-state-focused"),
	                $hoveredItem = $items.filter(".dx-state-hover"),
	                $hoveredItemContainer = $hoveredItem.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS);
	            if ($hoveredItemContainer.find("." + DX_MENU_ITEM_CLASS).index($focusedItem) >= 0) {
	                return $focusedItem
	            }
	            if ($hoveredItem.length) {
	                return $hoveredItem
	            }
	            return this.callBase()
	        },
	        _moveFocus: function(location) {
	            var $newTarget, $items = this._getItemsByLocation(location),
	                $oldTarget = this._getActiveItem(true),
	                $hoveredItem = this.itemsContainer().find(".dx-state-hover"),
	                $focusedItem = this.option("focusedElement"),
	                $activeItemHighlighted = !!($focusedItem || $hoveredItem.length);
	            switch (location) {
	                case FOCUS_UP:
	                    $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
	                    if ($oldTarget.is($items.first())) {
	                        this._actions.onLeftFirstItem($oldTarget)
	                    }
	                    break;
	                case FOCUS_DOWN:
	                    $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
	                    if ($oldTarget.is($items.last())) {
	                        this._actions.onLeftLastItem($oldTarget)
	                    }
	                    break;
	                case FOCUS_RIGHT:
	                    $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
	                    break;
	                case FOCUS_LEFT:
	                    $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
	                    break;
	                case FOCUS_FIRST:
	                    $newTarget = $items.first();
	                    break;
	                case FOCUS_LAST:
	                    $newTarget = $items.last();
	                    break;
	                default:
	                    return this.callBase(location)
	            }
	            if (0 !== $newTarget.length) {
	                this.option("focusedElement", $newTarget)
	            }
	        },
	        _getItemsByLocation: function(location) {
	            var $items, $activeItem = this._getActiveItem(true);
	            if ($.inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0) {
	                $items = $activeItem.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).children().children()
	            }
	            $items = this._getAvailableItems($items);
	            return $items
	        },
	        _getAriaTarget: function() {
	            return this.element()
	        },
	        _refreshActiveDescendant: function() {
	            if (!this._overlay) {
	                return
	            }
	            var id = this.getFocusedItemId();
	            this.setAria("activedescendant", "", this._overlay.content());
	            this.setAria("activedescendant", id, this._overlay.content())
	        },
	        _hideSubmenuHandler: function() {
	            var $curItem = this._getActiveItem(true),
	                $parentItem = $curItem.parents("." + DX_MENU_ITEM_EXPANDED_CLASS).first();
	            if ($parentItem.length) {
	                this._hideSubmenusOnSameLevel($parentItem);
	                this._hideSubmenu($curItem.closest("." + DX_SUBMENU_CLASS));
	                return $parentItem
	            }
	            this._actions.onCloseRootSubmenu($curItem);
	            return $curItem
	        },
	        _expandSubmenuHandler: function($items, location) {
	            var $curItem = this._getActiveItem(true),
	                node = this._dataAdapter.getNodeByItem(this._getItemData($curItem)),
	                isItemHasSubmenu = this._hasSubmenu(node),
	                $submenu = $curItem.children("." + DX_SUBMENU_CLASS);
	            if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
	                if (!$submenu.length || "hidden" === $submenu.css("visibility")) {
	                    this._showSubmenu($curItem)
	                }
	                return this._nextItem(this._getItemsByLocation(location))
	            }
	            this._actions.onExpandLastSubmenu($curItem);
	            return $curItem
	        },
	        _clean: function() {
	            if (this._overlay) {
	                this._overlay.element().remove();
	                this._overlay = null
	            }
	            this._detachShowContextMenuEvents(this.option("target"));
	            this.option("templatesRenderAsynchronously") && clearTimeout(this._drawSubmenuTimeout);
	            this.callBase()
	        },
	        _render: function() {
	            this.element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
	            this.callBase();
	            this.setAria("role", "menu")
	        },
	        _renderContentImpl: function() {
	            this._detachShowContextMenuEvents(this.option("target"));
	            this._attachShowContextMenuEvents()
	        },
	        _renderContextMenuOverlay: function() {
	            if (this._overlay) {
	                return
	            }
	            var $overlayContent, overlayOptions = this._getOverlayOptions(),
	                $overlayElement = $("<div>");
	            this._overlay = this._createComponent($overlayElement.appendTo(this._$element), Overlay, overlayOptions);
	            $overlayContent = this._overlay.content();
	            $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
	            this._addCustomCssClass($overlayContent);
	            this._addPlatformDependentClass($overlayContent);
	            this._attachContextMenuEvent()
	        },
	        _itemContextMenuHandler: function(e) {
	            this.callBase(e);
	            e.stopPropagation()
	        },
	        _addPlatformDependentClass: function($element) {
	            if (devices.current().phone) {
	                $element.addClass(DX_MENU_PHONE_CLASS)
	            }
	        },
	        _detachShowContextMenuEvents: function(target) {
	            var eventName, showEvent = getShowEvent(this);
	            if (!showEvent) {
	                return
	            }
	            eventName = eventUtils.addNamespace(showEvent, this.NAME);
	            if (this._showContextMenuEventHandler) {
	                $(document).off(eventName, target, this._showContextMenuEventHandler)
	            } else {
	                $(target).off(eventName)
	            }
	        },
	        _attachShowContextMenuEvents: function() {
	            var delay, handler, eventName, contextMenuAction, that = this,
	                target = that.option("target"),
	                showEvent = getShowEvent(that);
	            if (!showEvent) {
	                return
	            }
	            eventName = eventUtils.addNamespace(showEvent, that.NAME);
	            contextMenuAction = that._createAction($.proxy(function(e) {
	                delay = getShowDelay(that);
	                if (delay) {
	                    setTimeout(function() {
	                        that._show(e.jQueryEvent)
	                    }, delay)
	                } else {
	                    that._show(e.jQueryEvent)
	                }
	            }, that), {
	                validatingTargetName: "target"
	            });
	            handler = function(e) {
	                contextMenuAction({
	                    jQueryEvent: e,
	                    target: $(e.currentTarget)
	                })
	            };
	            contextMenuAction = that._createAction(contextMenuAction);
	            if (target.jquery || target.nodeType || $.isWindow(target)) {
	                that._showContextMenuEventHandler = void 0;
	                $(target).on(eventName, handler)
	            } else {
	                that._showContextMenuEventHandler = handler;
	                $(document).on(eventName, target, that._showContextMenuEventHandler)
	            }
	        },
	        _hoverEndHandler: function(e) {
	            e.stopPropagation()
	        },
	        _renderDimensions: $.noop,
	        _renderContainer: function($wrapper, submenuContainer) {
	            var $itemsContainer, $holder = submenuContainer || this._itemContainer();
	            $wrapper = $("<div>");
	            $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css("visibility", submenuContainer ? "hidden" : "visible");
	            $itemsContainer = this.callBase($wrapper);
	            if (submenuContainer) {
	                return $itemsContainer
	            }
	            if (this.option("width")) {
	                return $itemsContainer.css("min-width", this.option("width"))
	            }
	            if (this.option("height")) {
	                return $itemsContainer.css("min-height", this.option("height"))
	            }
	            return $itemsContainer
	        },
	        _renderSubmenuItems: function(node, $itemFrame) {
	            this._renderItems(this._getChildNodes(node), $itemFrame)
	        },
	        _getOverlayOptions: function() {
	            var position = this.option("position"),
	                overlayAnimation = this.option("animation"),
	                overlayOptions = {
	                    focusStateEnabled: this.option("focusStateEnabled"),
	                    animation: overlayAnimation,
	                    closeOnOutsideClick: $.proxy(this._closeOnOutsideClickHandler, this),
	                    closeOnTargetScroll: true,
	                    deferRendering: false,
	                    position: {
	                        at: position.at,
	                        my: position.my,
	                        of: this.option("target"),
	                        collision: "flipfit"
	                    },
	                    shading: false,
	                    showTitle: false,
	                    height: "auto",
	                    width: "auto",
	                    visible: this.option("visible"),
	                    onShown: $.proxy(this._overlayShownActionHandler, this),
	                    onHiding: $.proxy(this._overlayHidingActionHandler, this),
	                    onHidden: $.proxy(this._overlayHiddenActionHandler, this),
	                    onPositioned: $.proxy(this._overlayPositionedActionHandler, this)
	                };
	            return overlayOptions
	        },
	        _overlayShownActionHandler: function(arg) {
	            this._actions.onShown(arg)
	        },
	        _overlayHidingActionHandler: function(arg) {
	            this._actions.onHiding(arg);
	            if (!arg.cancel) {
	                this._hideAllShownSubmenus();
	                this._setOptionSilent("visible", false)
	            }
	        },
	        _overlayHiddenActionHandler: function(arg) {
	            this._actions.onHidden(arg)
	        },
	        _overlayPositionedActionHandler: $.noop,
	        _closeOnOutsideClickHandler: function(e) {
	            var $clickedItem, $activeItemContainer, $itemContainers, $rootItem, isRootItemClicked, isInnerOverlayClicked, closeOnOutsideClick = this.option("closeOnOutsideClick");
	            if (commonUtils.isFunction(closeOnOutsideClick)) {
	                return closeOnOutsideClick(e)
	            }
	            if (!closeOnOutsideClick) {
	                return false
	            }
	            if (e.target === document) {
	                return true
	            }
	            $activeItemContainer = this._getActiveItemsContainer(e.target);
	            $itemContainers = this._getItemsContainers();
	            $clickedItem = this._searchActiveItem(e.target);
	            $rootItem = this.element().parents("." + DX_MENU_ITEM_CLASS);
	            isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
	            isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
	            if (isInnerOverlayClicked || isRootItemClicked) {
	                if ("onClick" === this._getShowSubmenuMode()) {
	                    this._hideAllShownChildSubmenus($clickedItem)
	                }
	                return false
	            }
	            return true
	        },
	        _getActiveItemsContainer: function(target) {
	            return $(target).closest("." + DX_MENU_ITEMS_CONTAINER_CLASS)
	        },
	        _getItemsContainers: function() {
	            return this._overlay._$content.find("." + DX_MENU_ITEMS_CONTAINER_CLASS)
	        },
	        _searchActiveItem: function(target) {
	            return $(target).closest("." + DX_MENU_ITEM_CLASS).eq(0)
	        },
	        _isIncludeOverlay: function($activeOverlay, $allOverlays) {
	            var isSame = false;
	            $.each($allOverlays, function(index, $overlay) {
	                if ($activeOverlay.is($overlay) && !isSame) {
	                    isSame = true
	                }
	            });
	            return isSame
	        },
	        _hideAllShownChildSubmenus: function($clickedItem) {
	            var $context, that = this,
	                $submenuElements = $clickedItem.find("." + DX_SUBMENU_CLASS),
	                shownSubmenus = $.extend([], this._shownSubmenus);
	            if ($submenuElements.length > 0) {
	                $.each(shownSubmenus, function(index, $submenu) {
	                    $context = that._searchActiveItem($submenu.context).parent();
	                    if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
	                        that._hideSubmenu($submenu)
	                    }
	                })
	            }
	        },
	        _showSubmenu: function($item) {
	            var isSubmenuVisible, node = this._dataAdapter.getNodeByItem(this._getItemData($item)),
	                isItemHasSubmenu = this._hasSubmenu(node);
	            this._hideSubmenusOnSameLevel($item);
	            if (isItemHasSubmenu) {
	                this.callBase($item);
	                if (!$item.children("." + DX_SUBMENU_CLASS).length) {
	                    this._renderSubmenuItems(node, $item, 2)
	                }
	                isSubmenuVisible = this._isSubmenuVisible($item.children("." + DX_SUBMENU_CLASS));
	                if (!isSubmenuVisible) {
	                    this._drawSubmenu($item)
	                }
	            }
	        },
	        _hideSubmenusOnSameLevel: function($item) {
	            var $expandedItems = $item.parent("." + DX_MENU_ITEM_WRAPPER_CLASS).siblings().find("." + DX_MENU_ITEM_EXPANDED_CLASS);
	            if ($expandedItems.length) {
	                $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
	                this._hideSubmenu($expandedItems.find("." + DX_SUBMENU_CLASS))
	            }
	        },
	        _hideSubmenuGroup: function($submenu) {
	            if (this._isSubmenuVisible($submenu)) {
	                this._hideSubmenuCore($submenu)
	            }
	        },
	        _isSubmenuVisible: function($submenu) {
	            return "visible" === $submenu.css("visibility")
	        },
	        _drawSubmenu: function($itemElement) {
	            var animation = this.option("animation") ? this.option("animation").show : {},
	                $submenu = $itemElement.children("." + DX_SUBMENU_CLASS),
	                submenuPosition = this._getSubmenuPosition($itemElement);
	            if (this._overlay && this._overlay.option("visible")) {
	                if (!commonUtils.isDefined(this._shownSubmenus)) {
	                    this._shownSubmenus = []
	                }
	                if ($.inArray($submenu, this._shownSubmenus)) {
	                    this._shownSubmenus.push($submenu)
	                }
	                if (animation) {
	                    fx.stop($submenu)
	                }
	                if (this.option("templatesRenderAsynchronously")) {
	                    this._drawSubmenuTimeout = setTimeout(function() {
	                        positionUtils.setup($submenu, submenuPosition)
	                    })
	                } else {
	                    positionUtils.setup($submenu, submenuPosition)
	                }
	                if (animation) {
	                    if ($.isPlainObject(animation.to)) {
	                        animation.to.position = submenuPosition
	                    }
	                    this._animate($submenu, animation)
	                }
	                $submenu.css("visibility", "visible")
	            }
	        },
	        _animate: function($container, options) {
	            fx.animate($container, options)
	        },
	        _getSubmenuPosition: function($rootItem) {
	            var submenuDirection = this.option("submenuDirection").toLowerCase(),
	                $rootItemWrapper = $rootItem.parent("." + DX_MENU_ITEM_WRAPPER_CLASS),
	                position = {
	                    collision: "flip",
	                    of: $rootItemWrapper,
	                    offset: {
	                        h: 0,
	                        v: -1
	                    }
	                };
	            switch (submenuDirection) {
	                case "left":
	                    position.at = "left top";
	                    position.my = "right top";
	                    break;
	                case "right":
	                    position.at = "right top";
	                    position.my = "left top";
	                    break;
	                default:
	                    if (this.option("rtlEnabled")) {
	                        position.at = "left top";
	                        position.my = "right top"
	                    } else {
	                        position.at = "right top";
	                        position.my = "left top"
	                    }
	            }
	            return position
	        },
	        _updateSubmenuVisibilityOnClick: function(actionArgs) {
	            var $itemElement, itemData, node, renderSubmenu, $submenuElement, notCloseMenuOnItemClick;
	            if (!actionArgs.args.length) {
	                return
	            }
	            actionArgs.args[0].jQueryEvent.stopPropagation();
	            $itemElement = actionArgs.args[0].itemElement;
	            itemData = actionArgs.args[0].itemData;
	            node = this._dataAdapter.getNodeByItem(itemData);
	            if (!node) {
	                return
	            }
	            renderSubmenu = node.internalFields.childrenKeys.length && !$itemElement.find("." + DX_SUBMENU_CLASS).length;
	            renderSubmenu && this._renderSubmenuItems(node, $itemElement, 2);
	            notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;
	            $submenuElement = $itemElement.children("." + DX_SUBMENU_CLASS);
	            if ($itemElement.context === $submenuElement.context && "visible" === $submenuElement.css("visibility")) {
	                return
	            }
	            if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
	                return
	            }
	            this._updateSelectedItemOnClick(actionArgs);
	            if (0 === $submenuElement.length) {
	                var $prevSubmenu = $($itemElement.parents("." + DX_SUBMENU_CLASS)[0]);
	                this._hideSubmenu($prevSubmenu);
	                if (!actionArgs.canceled && this._overlay && this._overlay.option("visible")) {
	                    this.option("visible", false)
	                }
	            } else {
	                if (this._shownSubmenus && this._shownSubmenus.length > 0) {
	                    if (this._shownSubmenus[0].is($submenuElement) || 1 === this._shownSubmenus[0].has($submenuElement).length) {
	                        this._hideSubmenu($submenuElement)
	                    } else {
	                        this._hideAllShownSubmenus()
	                    }
	                }
	                this._showSubmenu($itemElement)
	            }
	        },
	        _hideSubmenu: function($curSubmenu) {
	            var that = this,
	                shownSubmenus = $.extend([], that._shownSubmenus);
	            $.each(shownSubmenus, function(index, $submenu) {
	                if ($curSubmenu.is($submenu) || $curSubmenu.has($submenu).length) {
	                    $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
	                    that._hideSubmenuCore($submenu)
	                }
	            })
	        },
	        _hideSubmenuCore: function($submenu) {
	            var index = $.inArray($submenu, this._shownSubmenus),
	                animation = this.option("animation") ? this.option("animation").hide : null;
	            if (index >= 0) {
	                this._shownSubmenus.splice(index, 1)
	            }
	            this._stopAnimate($submenu);
	            animation && this._animate($submenu, animation);
	            $submenu.css("visibility", "hidden")
	        },
	        _stopAnimate: function($container) {
	            fx.stop($container, true)
	        },
	        _hideAllShownSubmenus: function() {
	            var that = this,
	                shownSubmenus = $.extend([], that._shownSubmenus),
	                $expandedItems = this._overlay.content().find("." + DX_MENU_ITEM_EXPANDED_CLASS);
	            $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
	            $.each(shownSubmenus, function(_, $submenu) {
	                that._hideSubmenuCore($submenu)
	            })
	        },
	        _visibilityChanged: function(visible) {
	            if (visible) {
	                this._renderContentImpl()
	            }
	        },
	        _optionChanged: function(args) {
	            if (this._cancelOptionChange === args.name) {
	                return
	            }
	            if ($.inArray(args.name, ACTIONS) > -1) {
	                this._initActions();
	                return
	            }
	            switch (args.name) {
	                case "visible":
	                    this._toggleVisibility(args.value);
	                    break;
	                case "showEvent":
	                case "position":
	                case "submenuDirection":
	                    this._invalidate();
	                    break;
	                case "target":
	                    args.previousValue && this._detachShowContextMenuEvents(args.previousValue);
	                    this.option("position").of = null;
	                    this._invalidate();
	                    break;
	                case "closeOnOutsideClick":
	                    break;
	                default:
	                    this.callBase(args)
	            }
	        },
	        _toggleVisibility: function(showing) {
	            showing ? this._show() : this._hide()
	        },
	        _show: function(jQEvent, position) {
	            var args = {
	                jQEvent: jQEvent
	            };
	            !position && this._actions.onShowing(args);
	            if (args.cancel) {
	                return $.Deferred().reject().promise()
	            }
	            var promise, id = new Guid;
	            position = position || this._positionContextMenu(jQEvent);
	            if (position) {
	                if (this._overlay) {
	                    this._setOptionSilent("visible", true);
	                    this._overlay.option("position", position);
	                    promise = this._overlay.show();
	                    this._overlay.content().attr({
	                        id: id,
	                        role: "menu"
	                    });
	                    this.setAria("owns", id)
	                } else {
	                    this._renderContextMenuOverlay();
	                    this._overlay.content().addClass(this._widgetClass());
	                    this._renderFocusState();
	                    this._attachHoverEvents();
	                    this._attachClickEvent();
	                    this._renderItems(this._dataAdapter.getRootNodes());
	                    this._show(jQEvent, position)
	                }
	            }
	            return promise || $.Deferred().reject().promise()
	        },
	        _getContextMenuPosition: function() {
	            return $.extend({}, this.option("position"), {
	                of: this.option("target")
	            })
	        },
	        _positionContextMenu: function(jQEvent) {
	            var actionArgs, position = this._getContextMenuPosition(),
	                isInitialPosition = this._isInitialOptionValue("position"),
	                positioningAction = this._createActionByOption("onPositioning", actionArgs);
	            if (jQEvent && jQEvent.preventDefault && isInitialPosition) {
	                position.of = jQEvent
	            }
	            actionArgs = {
	                position: position,
	                jQueryEvent: jQEvent
	            };
	            positioningAction(actionArgs);
	            if (actionArgs.cancel) {
	                position = null
	            } else {
	                if (actionArgs.jQueryEvent) {
	                    actionArgs.jQueryEvent.cancel = true;
	                    jQEvent.preventDefault()
	                }
	            }
	            return position
	        },
	        _hide: function() {
	            var promise;
	            if (this._overlay) {
	                this._overlay.content().removeAttr("id");
	                promise = this._overlay.hide();
	                this._setOptionSilent("visible", false)
	            }
	            this.setAria("owns", void 0);
	            return promise || $.Deferred().reject().promise()
	        },
	        toggle: function(showing) {
	            var visible = this.option("visible");
	            showing = void 0 === showing ? !visible : showing;
	            return showing ? this._show() : this._hide()
	        },
	        show: function() {
	            return this.toggle(true)
	        },
	        hide: function() {
	            return this.toggle(false)
	        }
	    }
	}());
	registerComponent("dxContextMenu", ContextMenu);
	module.exports = ContextMenu;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/context_menu/ui.menu_base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    inkRipple = __webpack_require__(115),
	    HierarchicalCollectionWidget = __webpack_require__(167),
	    MenuBaseEditStrategy = __webpack_require__(170),
	    devices = __webpack_require__(40),
	    themes = __webpack_require__(112);
	var DX_MENU_CLASS = "dx-menu",
	    DX_MENU_NO_ICONS_CLASS = DX_MENU_CLASS + "-no-icons",
	    DX_MENU_BASE_CLASS = "dx-menu-base",
	    ITEM_CLASS = DX_MENU_CLASS + "-item",
	    DX_MENU_SELECTED_ITEM_CLASS = ITEM_CLASS + "-selected",
	    DX_MENU_ITEM_WRAPPER_CLASS = ITEM_CLASS + "-wrapper",
	    DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
	    DX_MENU_ITEM_EXPANDED_CLASS = ITEM_CLASS + "-expanded",
	    DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + "-separator",
	    DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS + "-last-group-item",
	    DX_ITEM_HAS_TEXT = ITEM_CLASS + "-has-text",
	    DX_ITEM_HAS_ICON = ITEM_CLASS + "-has-icon",
	    DX_ITEM_HAS_SUBMENU = ITEM_CLASS + "-has-submenu",
	    DX_MENU_ITEM_POPOUT_CLASS = ITEM_CLASS + "-popout",
	    DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = DX_MENU_ITEM_POPOUT_CLASS + "-container",
	    DX_MENU_ITEM_CAPTION_CLASS = ITEM_CLASS + "-text",
	    SINGLE_SELECTION_MODE = "single",
	    DEFAULT_DELAY = {
	        show: 50,
	        hide: 300
	    };
	var MenuBase = HierarchicalCollectionWidget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            items: [],
	            cssClass: "",
	            activeStateEnabled: true,
	            showSubmenuMode: {
	                name: "onHover",
	                delay: {
	                    show: 50,
	                    hide: 300
	                }
	            },
	            animation: {
	                show: {
	                    type: "fade",
	                    from: 0,
	                    to: 1,
	                    duration: 100
	                },
	                hide: {
	                    type: "fade",
	                    from: 1,
	                    to: 0,
	                    duration: 100
	                }
	            },
	            selectByClick: false,
	            focusOnSelectedItem: false,
	            keyExpr: null,
	            _itemAttributes: {
	                role: "menuitem"
	            },
	            useInkRipple: false
	        })
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            selectionByClick: {
	                since: "16.1",
	                alias: "selectByClick"
	            }
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                useInkRipple: true
	            }
	        }])
	    },
	    _activeStateUnit: "." + ITEM_CLASS,
	    _itemDataKey: function() {
	        return "dxMenuItemDataKey"
	    },
	    _itemClass: function() {
	        return ITEM_CLASS
	    },
	    _setAriaSelected: $.noop,
	    _selectedItemClass: function() {
	        return DX_MENU_SELECTED_ITEM_CLASS
	    },
	    _widgetClass: function() {
	        return DX_MENU_BASE_CLASS
	    },
	    _focusTarget: function() {
	        return this._itemContainer()
	    },
	    _supportedKeys: function() {
	        var selectItem = function() {
	            var $item = this.option("focusedElement");
	            if (!$item || !this._isSelectionEnabled()) {
	                return
	            }
	            this.selectItem($item[0])
	        };
	        return $.extend(this.callBase(), {
	            space: selectItem,
	            pageUp: $.noop,
	            pageDown: $.noop
	        })
	    },
	    _isSelectionEnabled: function() {
	        return this.option("selectionMode") === SINGLE_SELECTION_MODE
	    },
	    _init: function() {
	        this.callBase();
	        this._renderSelectedItem();
	        this._initActions()
	    },
	    _getTextContainer: function(itemData) {
	        var itemText = itemData.text,
	            $itemContainer = $("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS),
	            itemContent = $.isPlainObject(itemData) ? itemText : String(itemData);
	        return itemText && $itemContainer.html(itemContent)
	    },
	    _getPopoutContainer: function(itemData) {
	        var $popOutContainer, items = itemData.items;
	        if (items && items.length) {
	            var $popOutImage = $("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS);
	            $popOutContainer = $("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage)
	        }
	        return $popOutContainer
	    },
	    _getDataAdapterOptions: function() {
	        return {
	            rootValue: 0,
	            multipleSelection: false,
	            recursiveSelection: false,
	            recursiveExpansion: false,
	            searchValue: ""
	        }
	    },
	    _selectByItem: function(selectedItem) {
	        if (!selectedItem) {
	            return
	        }
	        var nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
	        this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true)
	    },
	    _renderSelectedItem: function() {
	        var selectedKeys = this._dataAdapter.getSelectedNodesKeys(),
	            selectedKey = selectedKeys.length && selectedKeys[0],
	            selectedItem = this.option("selectedItem");
	        if (!selectedKey) {
	            this._selectByItem(selectedItem);
	            return
	        }
	        var node = this._dataAdapter.getNodeByKey(selectedKey);
	        if (false === node.selectable) {
	            return
	        }
	        if (!selectedItem) {
	            this.option("selectedItem", node.internalFields.item);
	            return
	        }
	        if (selectedItem !== node.internalFields.item) {
	            this._dataAdapter.toggleSelection(selectedKey, false);
	            this._selectByItem(selectedItem)
	        }
	    },
	    _initActions: $.noop,
	    _render: function() {
	        this.callBase();
	        this._addCustomCssClass(this.element());
	        this.option("useInkRipple") && this._renderInkRipple()
	    },
	    _renderInkRipple: function() {
	        this._inkRipple = inkRipple.render()
	    },
	    _toggleActiveState: function($element, value, e) {
	        this.callBase.apply(this, arguments);
	        if (!this._inkRipple) {
	            return
	        }
	        var config = {
	            element: $element,
	            jQueryEvent: e
	        };
	        if (value) {
	            this._inkRipple.showWave(config)
	        } else {
	            this._inkRipple.hideWave(config)
	        }
	    },
	    _getShowSubmenuMode: function() {
	        var defaultValue = "onClick",
	            optionValue = this.option("showSubmenuMode");
	        optionValue = commonUtils.isObject(optionValue) ? optionValue.name : optionValue;
	        return this._isDesktopDevice() ? optionValue : defaultValue
	    },
	    _initSelectedItems: $.noop,
	    _isDesktopDevice: function() {
	        return "desktop" === devices.real().deviceType
	    },
	    _initEditStrategy: function() {
	        var Strategy = MenuBaseEditStrategy;
	        this._editStrategy = new Strategy(this)
	    },
	    _addCustomCssClass: function($element) {
	        $element.addClass(this.option("cssClass"))
	    },
	    _itemWrapperSelector: function() {
	        return "." + DX_MENU_ITEM_WRAPPER_CLASS
	    },
	    _hoverStartHandler: function(e) {
	        var that = this,
	            $itemElement = that._getItemElementByEventArgs(e);
	        if (!$itemElement || that._isItemDisabled($itemElement)) {
	            return
	        }
	        e.stopPropagation();
	        if ("onHover" === that._getShowSubmenuMode()) {
	            clearTimeout(this._showSubmenusTimeout);
	            this._showSubmenusTimeout = setTimeout($.proxy(that._showSubmenu, that, $itemElement), that._getSubmenuDelay("show"))
	        }
	    },
	    _getAvailableItems: function($itemElements) {
	        return this.callBase($itemElements).filter(function() {
	            return "hidden" !== $(this).css("visibility")
	        })
	    },
	    _isItemDisabled: function($item) {
	        return this._disabledGetter($item.data(this._itemDataKey()))
	    },
	    _showSubmenu: function($itemElement) {
	        this._addExpandedClass($itemElement)
	    },
	    _addExpandedClass: function($itemElement) {
	        $itemElement.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
	    },
	    _getSubmenuDelay: function(action) {
	        var delay = this.option("showSubmenuMode").delay;
	        if (!commonUtils.isDefined(delay)) {
	            return DEFAULT_DELAY[action]
	        }
	        return commonUtils.isObject(delay) ? delay[action] : delay
	    },
	    _getItemElementByEventArgs: function(eventArgs) {
	        var $target = $(eventArgs.target);
	        if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget) {
	            return $target
	        }
	        while (!$target.hasClass(this._itemClass())) {
	            $target = $target.parent();
	            if ($target.hasClass("dx-submenu")) {
	                return null
	            }
	        }
	        return $target
	    },
	    _hoverEndHandler: $.noop,
	    _hasSubmenu: function(node) {
	        return node.internalFields.childrenKeys.length
	    },
	    _renderContentImpl: function() {
	        this._renderItems(this._dataAdapter.getRootNodes())
	    },
	    _renderItems: function(nodes, submenuContainer) {
	        var $nodeContainer, that = this;
	        if (nodes.length) {
	            this.hasIcons = false;
	            $nodeContainer = this._renderContainer(this.element(), submenuContainer);
	            $.each(nodes, function(index, node) {
	                that._renderItem(index, node, $nodeContainer)
	            });
	            if (!this.hasIcons) {
	                $nodeContainer.addClass(DX_MENU_NO_ICONS_CLASS)
	            }
	        }
	    },
	    _renderContainer: function($wrapper) {
	        return $("<ul>").appendTo($wrapper).addClass(DX_MENU_ITEMS_CONTAINER_CLASS)
	    },
	    _createDOMElement: function($nodeContainer) {
	        var $node = $("<li>").appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
	        return $node
	    },
	    _renderItem: function(index, node, $nodeContainer) {
	        var $itemFrame, items = this.option("items");
	        this._renderSeparator(node, index, $nodeContainer);
	        if (false === node.internalFields.item.visible) {
	            return
	        }
	        var $node = this._createDOMElement($nodeContainer);
	        if (items[index + 1] && items[index + 1].beginGroup) {
	            $node.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM)
	        }
	        $itemFrame = this.callBase(index, node.internalFields.item, $node);
	        if (node.internalFields.item === this.option("selectedItem")) {
	            $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS)
	        }
	        this._addContentClasses(node, $itemFrame);
	        if (this._hasSubmenu(node)) {
	            this.setAria("haspopup", "true", $itemFrame)
	        }
	    },
	    _addContentClasses: function(node, $itemFrame) {
	        if (this._displayGetter(node)) {
	            $itemFrame.addClass(DX_ITEM_HAS_TEXT)
	        }
	        if (node.icon || node.iconSrc) {
	            $itemFrame.addClass(DX_ITEM_HAS_ICON);
	            this.hasIcons = true
	        }
	        if (this._hasSubmenu(node)) {
	            $itemFrame.addClass(DX_ITEM_HAS_SUBMENU)
	        }
	    },
	    _postprocessRenderItem: function(args) {
	        var node, $itemElement = $(args.itemElement),
	            selectedIndex = this._dataAdapter.getSelectedNodesKeys();
	        if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
	            this._setAriaSelected($itemElement, "false");
	            return
	        }
	        node = this._dataAdapter.getNodeByItem(args.itemData);
	        if (node.internalFields.key === selectedIndex[0]) {
	            $itemElement.addClass(this._selectedItemClass());
	            this._setAriaSelected($itemElement, "true")
	        } else {
	            this._setAriaSelected($itemElement, "false")
	        }
	    },
	    _isItemSelectable: function(item) {
	        return false !== item.selectable
	    },
	    _renderSeparator: function(node, index, $itemsContainer) {
	        if (node.beginGroup && index > 0) {
	            this._needSeparate = true
	        }
	        if (false !== node.visible && this._needSeparate) {
	            if (index > 0) {
	                $("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS)
	            }
	            this._needSeparate = false
	        }
	    },
	    _itemClickHandler: function(e) {
	        var itemClickActionHandler = this._createAction($.proxy(this._updateSubmenuVisibilityOnClick, this));
	        this._itemJQueryEventHandler(e, "onItemClick", {}, {
	            afterExecute: $.proxy(itemClickActionHandler, this)
	        })
	    },
	    _updateSubmenuVisibilityOnClick: function(actionArgs) {
	        this._updateSelectedItemOnClick(actionArgs);
	        if ("onClick" === this._getShowSubmenuMode()) {
	            this._addExpandedClass(actionArgs.args[0].itemElement)
	        }
	    },
	    _updateSelectedItemOnClick: function(actionArgs) {
	        var selectedItemKey, args = actionArgs.args ? actionArgs.args[0] : actionArgs;
	        if (!this._isItemSelectionAllowed(args.itemData)) {
	            return
	        }
	        selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
	        var selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
	        if (selectedNode) {
	            this._toggleItemSelection(selectedNode, false)
	        }
	        if (!selectedNode || selectedNode.internalFields.item !== args.itemData) {
	            this.selectItem(args.itemData)
	        } else {
	            this._fireSelectionChangeEvent(null, this.option("selectedItem"));
	            this._setOptionSilent("selectedItem", null)
	        }
	    },
	    _isItemSelectionAllowed: function(item) {
	        var isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectByClick");
	        return !this._isContainerEmpty() && isSelectionByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item)
	    },
	    _isContainerEmpty: function() {
	        return this._itemContainer().is(":empty")
	    },
	    _syncSelectionOptions: $.noop,
	    _optionChanged: function(args) {
	        if (this._cancelOptionChange === args.name) {
	            return
	        }
	        switch (args.name) {
	            case "showSubmenuMode":
	                break;
	            case "selectedItem":
	                var itemData = args.value,
	                    node = this._dataAdapter.getNodeByItem(itemData),
	                    selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
	                if (node && node.internalFields.key !== selectedKey) {
	                    if (false === node.selectable) {
	                        break
	                    }
	                    if (selectedKey) {
	                        this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false)
	                    }
	                    this._toggleItemSelection(node, true);
	                    this._updateSelectedItems()
	                }
	                break;
	            case "cssClass":
	            case "position":
	            case "selectByClick":
	            case "animation":
	            case "useInkRipple":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _toggleItemSelection: function(node, value) {
	        var itemElement = this._getElementByItem(node.internalFields.item);
	        itemElement && $(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
	        this._dataAdapter.toggleSelection(node.internalFields.key, value)
	    },
	    _getElementByItem: function(itemData) {
	        var result, that = this;
	        $.each(this._itemElements(), function(_, itemElement) {
	            if ($(itemElement).data(that._itemDataKey()) !== itemData) {
	                return true
	            }
	            result = itemElement;
	            return false
	        });
	        return result
	    },
	    _updateSelectedItems: function(oldSelection, newSelection) {
	        if (oldSelection || newSelection) {
	            this._updateSelection(newSelection, oldSelection);
	            this._fireSelectionChangeEvent(newSelection, oldSelection)
	        }
	    },
	    _fireSelectionChangeEvent: function(addedSelection, removedSelection) {
	        this._createActionByOption("onSelectionChanged", {
	            excludeValidators: ["disabled", "readOnly"]
	        })({
	            addedItems: [addedSelection],
	            removedItems: [removedSelection]
	        })
	    },
	    selectItem: function(itemElement) {
	        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
	            node = this._dataAdapter.getNodeByItem(itemData),
	            selectedKey = this._dataAdapter.getSelectedNodesKeys()[0],
	            selectedItem = this.option("selectedItem");
	        if (node.internalFields.key !== selectedKey) {
	            if (selectedKey) {
	                this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false)
	            }
	            this._toggleItemSelection(node, true);
	            this._updateSelectedItems(selectedItem, itemData);
	            this._setOptionSilent("selectedItem", itemData)
	        }
	    },
	    unselectItem: function(itemElement) {
	        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
	            node = this._dataAdapter.getNodeByItem(itemData),
	            selectedItem = this.option("selectedItem");
	        if (node.internalFields.selected) {
	            this._toggleItemSelection(node, false);
	            this._updateSelectedItems(selectedItem, null);
	            this._setOptionSilent("selectedItem", null)
	        }
	    }
	});
	module.exports = MenuBase;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/hierarchical_collection/ui.hierarchical_collection_widget.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    dataCoreUtils = __webpack_require__(35),
	    devices = __webpack_require__(40),
	    iconUtils = __webpack_require__(104),
	    HierarchicalDataAdapter = __webpack_require__(168),
	    CollectionWidget = __webpack_require__(117),
	    BindableTemplate = __webpack_require__(134);
	var DISABLED_STATE_CLASS = "dx-state-disabled";
	var HierarchicalCollectionWidget = CollectionWidget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            keyExpr: "id",
	            displayExpr: "text",
	            selectedExpr: "selected",
	            disabledExpr: "disabled",
	            itemsExpr: "items",
	            hoverStateEnabled: true,
	            parentIdExpr: "parentId",
	            expandedExpr: "expanded"
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this._initAccessors();
	        this._initDataAdapter();
	        this._initDynamicTemplates()
	    },
	    _initDataSource: function() {
	        this.callBase();
	        this._dataSource && this._dataSource.paginate(false)
	    },
	    _initDataAdapter: function() {
	        var accessors = this._createDataAdapterAccessors();
	        this._dataAdapter = new HierarchicalDataAdapter($.extend({
	            dataAccessors: {
	                getters: accessors.getters,
	                setters: accessors.setters
	            },
	            items: this.option("items")
	        }, this._getDataAdapterOptions()))
	    },
	    _getDataAdapterOptions: $.noop,
	    _initDynamicTemplates: function() {
	        this._defaultTemplates.item = new BindableTemplate(function($container, itemData) {
	            $container.html(itemData.html).append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData)).append(this._getPopoutContainer(itemData))
	        }.bind(this), ["text", "html", "items", "icon", "iconSrc"], this.option("integrationOptions.watchMethod"), {
	            text: this._displayGetter,
	            items: this._itemsGetter
	        })
	    },
	    _getIconContainer: function(itemData) {
	        var icon = itemData.icon || itemData.iconSrc;
	        return icon ? iconUtils.getImageContainer(icon) : void 0
	    },
	    _getTextContainer: function(itemData) {
	        return $("<span>").text(itemData.text)
	    },
	    _getPopoutContainer: $.noop,
	    _initAccessors: function() {
	        var that = this;
	        $.each(this._getAccessors(), function(_, accessor) {
	            that._compileAccessor(accessor)
	        })
	    },
	    _getAccessors: function() {
	        return ["key", "display", "selected", "items", "disabled", "parentId", "expanded"]
	    },
	    _getChildNodes: function(node) {
	        var that = this,
	            arr = [];
	        $.each(node.internalFields.childrenKeys, function(_, key) {
	            var childNode = that._dataAdapter.getNodeByKey(key);
	            arr.push(childNode)
	        });
	        return arr
	    },
	    _hasChildren: function(node) {
	        return node && node.internalFields.childrenKeys.length
	    },
	    _compileAccessor: function(optionName) {
	        var getter = "_" + optionName + "Getter",
	            setter = "_" + optionName + "Setter",
	            optionExpr = this.option(optionName + "Expr");
	        if (!optionExpr) {
	            this[getter] = $.noop;
	            this[setter] = $.noop;
	            return
	        } else {
	            if ($.isFunction(optionExpr)) {
	                this[setter] = function(obj, value) {
	                    obj[optionExpr()] = value
	                };
	                this[getter] = function(obj) {
	                    return obj[optionExpr()]
	                };
	                return
	            }
	        }
	        this[getter] = dataCoreUtils.compileGetter(optionExpr);
	        this[setter] = dataCoreUtils.compileSetter(optionExpr)
	    },
	    _createDataAdapterAccessors: function() {
	        var that = this,
	            accessors = {
	                getters: {},
	                setters: {}
	            };
	        $.each(this._getAccessors(), function(_, accessor) {
	            var getterName = "_" + accessor + "Getter",
	                setterName = "_" + accessor + "Setter",
	                newAccessor = "parentId" === accessor ? "parentKey" : accessor;
	            accessors.getters[newAccessor] = that[getterName];
	            accessors.setters[newAccessor] = that[setterName]
	        });
	        return accessors
	    },
	    _render: function() {
	        this.callBase();
	        this._focusTarget().addClass(this._widgetClass())
	    },
	    _widgetClass: $.noop,
	    _renderItemFrame: function(index, itemData) {
	        var $itemFrame = this.callBase.apply(this, arguments);
	        $itemFrame.toggleClass(DISABLED_STATE_CLASS, !!this._disabledGetter(itemData));
	        return $itemFrame
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "displayExpr":
	            case "keyExpr":
	                this._initAccessors();
	                this._initDynamicTemplates();
	                this.repaint();
	                break;
	            case "itemsExpr":
	            case "selectedExpr":
	            case "disabledExpr":
	            case "expandedExpr":
	            case "parentIdExpr":
	                this._initAccessors();
	                this._initDataAdapter();
	                this.repaint();
	                break;
	            case "items":
	                this._initDataAdapter();
	                this.callBase(args);
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	module.exports = HierarchicalCollectionWidget;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/hierarchical_collection/ui.data_adapter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    query = __webpack_require__(125),
	    HierarchicalDataConverter = __webpack_require__(169);
	var EXPANDED = "expanded",
	    SELECTED = "selected",
	    DISABLED = "disabled";
	var DataAdapter = Class.inherit({
	    ctor: function(options) {
	        this.options = {};
	        $.extend(this.options, this._defaultOptions(), options);
	        this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
	        this._selectedNodesKeys = [];
	        this._expandedNodesKeys = [];
	        this._dataStructure = [];
	        this._createInternalDataStructure();
	        this.getTreeNodes()
	    },
	    setOption: function(name, value) {
	        this.options[name] = value;
	        if ("recursiveSelection" === name) {
	            this._updateSelection()
	        }
	    },
	    _defaultOptions: function() {
	        return {
	            dataAccessors: void 0,
	            items: [],
	            multipleSelection: true,
	            recursiveSelection: false,
	            recursiveExpansion: false,
	            rootValue: 0,
	            searchValue: "",
	            dataType: "tree",
	            dataConverter: new HierarchicalDataConverter,
	            onNodeChanged: $.noop
	        }
	    },
	    _createInternalDataStructure: function() {
	        this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
	        this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
	        this.options.dataConverter._dataStructure = this._dataStructure;
	        this._updateSelection();
	        this._updateExpansion()
	    },
	    _updateSelection: function() {
	        if (this.options.recursiveSelection) {
	            this._setChildrenSelection();
	            this._setParentSelection()
	        }
	        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
	    },
	    _updateExpansion: function(key) {
	        if (this.options.recursiveExpansion) {
	            key ? this._updateOneBranch(key) : this._setParentExpansion()
	        }
	        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
	    },
	    _updateNodesKeysArray: function(property) {
	        var that = this,
	            array = [];
	        $.each(this._dataStructure, function(_, node) {
	            if (!that._isNodeVisible(node)) {
	                return
	            }
	            if (!!node.internalFields[property]) {
	                if (property === EXPANDED || that.options.multipleSelection) {
	                    array.push(node.internalFields.key)
	                } else {
	                    array.length && that.toggleSelection(array[0], false, true);
	                    array = [node.internalFields.key]
	                }
	            }
	        });
	        return array
	    },
	    _isNodeVisible: function(node) {
	        return false !== node.internalFields.item.visible
	    },
	    _getByKey: function(data, key) {
	        return data === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data, key)
	    },
	    _setChildrenSelection: function() {
	        var that = this;
	        $.each(this._dataStructure, function(_, node) {
	            if (!node.internalFields.childrenKeys.length) {
	                return
	            }
	            var isSelected = node.internalFields.selected;
	            true === isSelected && that._toggleChildrenSelection(node, isSelected)
	        })
	    },
	    _setParentSelection: function() {
	        var length = this._dataStructure.length;
	        for (var i = length - 1; i >= 0; i--) {
	            var node = this._dataStructure[i],
	                parent = this.options.dataConverter._getByKey(node.internalFields.parentKey);
	            if (parent && node.internalFields.parentKey !== this.options.rootValue) {
	                var newParentState = this._calculateSelectedState(parent);
	                this._setFieldState(parent, SELECTED, newParentState)
	            }
	        }
	    },
	    _setParentExpansion: function() {
	        var that = this;
	        $.each(this._dataStructure, function(_, node) {
	            if (!node.internalFields.expanded) {
	                return
	            }
	            that._updateOneBranch(node.internalFields.key)
	        })
	    },
	    _updateOneBranch: function(key) {
	        var that = this,
	            node = this.getNodeByKey(key);
	        that._iterateParents(node, function(parent) {
	            that._setFieldState(parent, EXPANDED, true)
	        })
	    },
	    _iterateChildren: function(node, recursive, callback) {
	        var that = this;
	        $.each(node.internalFields.childrenKeys, function(_, key) {
	            var child = that.options.dataConverter._getByKey(key);
	            $.isFunction(callback) && callback(child);
	            if (child.internalFields.childrenKeys.length && recursive) {
	                that._iterateChildren(child, recursive, callback)
	            }
	        })
	    },
	    _iterateParents: function(node, callback) {
	        if (node.internalFields.parentKey === this.options.rootValue) {
	            return
	        }
	        var parent = this.options.dataConverter._getByKey(node.internalFields.parentKey);
	        if (parent) {
	            $.isFunction(callback) && callback(parent);
	            if (parent.internalFields.parentKey !== this.options.rootValue) {
	                this._iterateParents(parent, callback)
	            }
	        }
	    },
	    _calculateSelectedState: function(node) {
	        var itemsCount = node.internalFields.childrenKeys.length,
	            selectedItemsCount = 0,
	            invisibleItemsCount = 0,
	            result = false;
	        for (var i = 0; i <= itemsCount - 1; i++) {
	            var childNode = this.options.dataConverter._getByKey(node.internalFields.childrenKeys[i]),
	                isChildInvisible = false === childNode.internalFields.item.visible,
	                childState = childNode.internalFields.selected;
	            if (isChildInvisible) {
	                invisibleItemsCount++;
	                continue
	            }
	            if (childState) {
	                selectedItemsCount++
	            } else {
	                if (void 0 === childState) {
	                    selectedItemsCount += .5
	                }
	            }
	        }
	        if (selectedItemsCount) {
	            result = selectedItemsCount === itemsCount - invisibleItemsCount ? true : void 0
	        }
	        return result
	    },
	    _toggleChildrenSelection: function(node, state) {
	        var that = this;
	        this._iterateChildren(node, true, function(child) {
	            if (that._isNodeVisible(child)) {
	                that._setFieldState(child, SELECTED, state)
	            }
	        })
	    },
	    _setFieldState: function(node, field, state) {
	        if (node.internalFields[field] === state) {
	            return
	        }
	        node.internalFields[field] = state;
	        if (node.internalFields.publicNode) {
	            node.internalFields.publicNode[field] = state
	        }
	        this.options.dataAccessors.setters[field](node.internalFields.item, state);
	        this.options.onNodeChanged(node)
	    },
	    _markChildren: function(keys) {
	        var that = this;
	        $.each(keys, function(_, key) {
	            var index = that.getIndexByKey(key),
	                node = that.getNodeByKey(key);
	            that._dataStructure[index] = 0;
	            node.internalFields.childrenKeys.length && that._markChildren(node.internalFields.childrenKeys)
	        })
	    },
	    _removeNode: function(key) {
	        var node = this.getNodeByKey(key);
	        this._dataStructure[this.getIndexByKey(key)] = 0;
	        this._markChildren(node.internalFields.childrenKeys);
	        var that = this,
	            counter = 0,
	            items = $.extend([], this._dataStructure);
	        $.each(items, function(index, item) {
	            if (!item) {
	                that._dataStructure.splice(index - counter, 1);
	                counter++
	            }
	        })
	    },
	    _addNode: function(item) {
	        var dataConverter = this.options.dataConverter,
	            node = dataConverter._convertItemToNode(item, this.options.dataAccessors.getters.parentKey(item));
	        this._dataStructure = this._dataStructure.concat(node);
	        this._initialDataStructure = this._initialDataStructure.concat(node);
	        dataConverter._dataStructure = dataConverter._dataStructure.concat(node)
	    },
	    _updateFields: function() {
	        this.options.dataConverter.updateChildrenKeys();
	        this._updateSelection();
	        this._updateExpansion()
	    },
	    getSelectedNodesKeys: function() {
	        return this._selectedNodesKeys
	    },
	    getExpandedNodesKeys: function() {
	        return this._expandedNodesKeys
	    },
	    getData: function() {
	        return this._dataStructure
	    },
	    getFullData: function() {
	        return this._initialDataStructure
	    },
	    getNodeByItem: function(item) {
	        var result = null;
	        $.each(this._dataStructure, function(_, node) {
	            if (node.internalFields.item === item) {
	                result = node;
	                return false
	            }
	        });
	        return result
	    },
	    getNodesByItems: function(items) {
	        var that = this,
	            nodes = [];
	        $.each(items, function(_, item) {
	            var node = that.getNodeByItem(item);
	            node && nodes.push(node)
	        });
	        return nodes
	    },
	    getNodeByKey: function(key) {
	        return this._getByKey(this._dataStructure, key)
	    },
	    getTreeNodes: function() {
	        return this.options.dataConverter.convertToPublicNodes(this.getRootNodes())
	    },
	    getItemsCount: function() {
	        return this.options.dataConverter.getItemsCount()
	    },
	    getVisibleItemsCount: function() {
	        return this.options.dataConverter.getVisibleItemsCount()
	    },
	    getPublicNode: function(node) {
	        return node.internalFields.publicNode
	    },
	    getRootNodes: function() {
	        return this.getChildrenNodes(this.options.rootValue)
	    },
	    getChildrenNodes: function(parentKey) {
	        return query(this._dataStructure).filter(["internalFields.parentKey", parentKey]).toArray()
	    },
	    getIndexByKey: function(key) {
	        return this.options.dataConverter.getIndexByKey(key)
	    },
	    addItem: function(item) {
	        this._addNode(item);
	        this._updateFields()
	    },
	    removeItem: function(key) {
	        this._removeNode(key);
	        this._updateFields()
	    },
	    toggleSelection: function(key, state, selectRecursive) {
	        var node = !selectRecursive ? this._getByKey(this._dataStructure, key) : this._getByKey(this._initialDataStructure, key);
	        this._setFieldState(node, SELECTED, state);
	        if (this.options.recursiveSelection && !selectRecursive) {
	            state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
	            this._setParentSelection()
	        }
	        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
	    },
	    toggleNodeDisabledState: function(key, state) {
	        var node = this._getByKey(this._dataStructure, key);
	        this._setFieldState(node, DISABLED, state)
	    },
	    toggleSelectAll: function(state) {
	        if (!commonUtils.isDefined(state)) {
	            return
	        }
	        var that = this;
	        $.each(this._dataStructure, function(_, node) {
	            if (!that._isNodeVisible(node)) {
	                return
	            }
	            that._setFieldState(node, SELECTED, state);
	            that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED)
	        })
	    },
	    isAllSelected: function() {
	        if (this.getSelectedNodesKeys().length) {
	            return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : void 0
	        } else {
	            return false
	        }
	    },
	    toggleExpansion: function(key, state) {
	        var node = this._getByKey(this._dataStructure, key);
	        this._setFieldState(node, EXPANDED, state);
	        if (state) {
	            this._updateExpansion(key)
	        }
	        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
	    },
	    _filterDataStructure: function(substring) {
	        var text, matches = [],
	            dataStructure = this._initialDataStructure,
	            escaped = commonUtils.escapeRegExp(substring),
	            reg = new RegExp(escaped, "i");
	        for (var i = 0, size = dataStructure.length; i < size; i++) {
	            text = this.options.dataAccessors.getters.display(dataStructure[i]);
	            reg.test(text) && matches.push(dataStructure[i])
	        }
	        return matches
	    },
	    search: function(substring) {
	        var that = this,
	            matches = this._filterDataStructure(substring),
	            dataConverter = this.options.dataConverter;

	        function lookForParents(matches, index) {
	            var length = matches.length;
	            while (index < length) {
	                var parent, parentKey = matches[index].internalFields.parentKey;
	                if (parentKey === that.options.rootValue) {
	                    index++;
	                    continue
	                }
	                parent = dataConverter._getByKey(parentKey);
	                if (!parent.internalFields.expanded) {
	                    that._setFieldState(parent, EXPANDED, true)
	                }
	                if ($.inArray(parent, matches) > -1) {
	                    index++;
	                    continue
	                }
	                matches.splice(index, 0, parent);
	                lookForParents(matches, index)
	            }
	        }
	        lookForParents(matches, 0);
	        dataConverter._indexByKey = {};
	        $.each(matches, function(index, node) {
	            node.internalFields.childrenKeys = [];
	            dataConverter._indexByKey[node.internalFields.key] = index
	        });
	        dataConverter._dataStructure = matches;
	        dataConverter.setChildrenKeys();
	        return dataConverter._dataStructure
	    }
	});
	module.exports = DataAdapter;


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/hierarchical_collection/ui.data_converter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    errors = __webpack_require__(15),
	    commonUtils = __webpack_require__(8);
	var DataConverter = Class.inherit({
	    ctor: function() {
	        this._dataStructure = [];
	        this._itemsCount = 0;
	        this._visibleItemsCount = 0
	    },
	    _indexByKey: {},
	    _convertItemsToNodes: function(items, parentKey) {
	        var that = this;
	        $.each(items, function(_, item) {
	            var parentId = commonUtils.isDefined(parentKey) ? parentKey : that._getParentId(item),
	                node = that._convertItemToNode(item, parentId);
	            that._dataStructure.push(node);
	            that._checkForDuplicateId(node.internalFields.key);
	            that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
	            if (that._itemHasChildren(item)) {
	                that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key)
	            }
	        })
	    },
	    _checkForDuplicateId: function(key) {
	        if (commonUtils.isDefined(this._indexByKey[key])) {
	            throw errors.Error("E1040")
	        }
	    },
	    _getParentId: function(item) {
	        return "plain" === this._dataType ? this._dataAccessors.getters.parentKey(item) : void 0
	    },
	    _itemHasChildren: function(item) {
	        var items = this._dataAccessors.getters.items(item);
	        return items && items.length
	    },
	    _getUniqueKey: function(item) {
	        var keyGetter = this._dataAccessors.getters.key,
	            itemKey = keyGetter(item),
	            isCorrectKey = keyGetter && (itemKey || 0 === itemKey) && commonUtils.isPrimitive(itemKey);
	        return isCorrectKey ? itemKey : this.getItemsCount()
	    },
	    _convertItemToNode: function(item, parentKey) {
	        this._itemsCount++;
	        false !== item.visible && this._visibleItemsCount++;
	        var that = this,
	            node = {
	                internalFields: {
	                    disabled: that._dataAccessors.getters.disabled(item) || false,
	                    expanded: that._dataAccessors.getters.expanded(item) || false,
	                    selected: that._dataAccessors.getters.selected(item) || false,
	                    key: that._getUniqueKey(item),
	                    parentKey: commonUtils.isDefined(parentKey) ? parentKey : that._rootValue,
	                    item: that._makeObjectFromPrimitive(item),
	                    childrenKeys: []
	                }
	            };
	        $.extend(true, node, item);
	        delete node.items;
	        return node
	    },
	    setChildrenKeys: function() {
	        var that = this;
	        $.each(this._dataStructure, function(_, node) {
	            if (node.internalFields.parentKey === that._rootValue) {
	                return
	            }
	            var parent = that._getByKey(node.internalFields.parentKey);
	            parent && parent.internalFields.childrenKeys.push(node.internalFields.key)
	        })
	    },
	    _makeObjectFromPrimitive: function(item) {
	        if (commonUtils.isPrimitive(item)) {
	            var key = item;
	            item = {};
	            this._dataAccessors.setters.key(item, key)
	        }
	        return item
	    },
	    _convertToPublicNode: function(node, parent) {
	        if (!node) {
	            return null
	        }
	        var publicNode = {
	            text: this._dataAccessors.getters.display(node),
	            key: node.internalFields.key,
	            selected: node.internalFields.selected,
	            expanded: node.internalFields.expanded,
	            disabled: node.internalFields.disabled,
	            parent: parent || null,
	            itemData: node.internalFields.item,
	            children: [],
	            items: []
	        };
	        if (publicNode.parent) {
	            publicNode.parent.children.push(publicNode);
	            publicNode.parent.items.push(publicNode)
	        }
	        return publicNode
	    },
	    convertToPublicNodes: function(data, parent) {
	        if (!data.length) {
	            return []
	        }
	        var that = this,
	            publicNodes = [];
	        $.each(data, function(_, node) {
	            node = commonUtils.isPrimitive(node) ? that._getByKey(node) : node;
	            var publicNode = that._convertToPublicNode(node, parent);
	            publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
	            publicNodes.push(publicNode);
	            node.internalFields.publicNode = publicNode
	        });
	        return publicNodes
	    },
	    setDataAccessors: function(accessors) {
	        this._dataAccessors = accessors
	    },
	    _getByKey: function(key) {
	        return this._dataStructure[this.getIndexByKey(key)] || null
	    },
	    getByKey: function(data, key) {
	        var result = null,
	            that = this;
	        var getByKey = function(data, key) {
	            $.each(data, function(_, element) {
	                var currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element),
	                    items = that._dataAccessors.getters.items(element);
	                if (currentElementKey === key) {
	                    result = element;
	                    return false
	                }
	                if (items) {
	                    getByKey(items, key)
	                }
	            });
	            return result
	        };
	        return getByKey(data, key)
	    },
	    getItemsCount: function() {
	        return this._itemsCount
	    },
	    getVisibleItemsCount: function() {
	        return this._visibleItemsCount
	    },
	    updateIndexByKey: function() {
	        var that = this;
	        this._indexByKey = {};
	        $.each(this._dataStructure, function(index, node) {
	            that._checkForDuplicateId(node.internalFields.key);
	            that._indexByKey[node.internalFields.key] = index
	        })
	    },
	    updateChildrenKeys: function() {
	        this._indexByKey = {};
	        this.removeChildrenKeys();
	        this.updateIndexByKey();
	        this.setChildrenKeys()
	    },
	    removeChildrenKeys: function() {
	        this._indexByKey = {};
	        $.each(this._dataStructure, function(index, node) {
	            node.internalFields.childrenKeys = []
	        })
	    },
	    getIndexByKey: function(key) {
	        return this._indexByKey[key]
	    },
	    createPlainStructure: function(items, rootValue, dataType) {
	        this._itemsCount = 0;
	        this._visibleItemsCount = 0;
	        this._rootValue = rootValue;
	        this._dataType = dataType;
	        this._indexByKey = {};
	        this._convertItemsToNodes(items);
	        this.setChildrenKeys();
	        return this._dataStructure
	    }
	});
	module.exports = DataConverter;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/context_menu/ui.menu_base.edit.strategy.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    PlainEditStrategy = __webpack_require__(135);
	var MenuBaseEditStrategy = PlainEditStrategy.inherit({
	    _getPlainItems: function() {
	        return $.map(this._collectionWidget.option("items"), function getMenuItems(item) {
	            return item.items ? [item].concat($.map(item.items, getMenuItems)) : item
	        })
	    },
	    _stringifyItem: function(item) {
	        var that = this;
	        return JSON.stringify(item, function(key, value) {
	            if ("template" === key) {
	                return that._getTemplateString(value)
	            }
	            return value
	        })
	    },
	    _getTemplateString: function(template) {
	        var result;
	        if ("object" === typeof template) {
	            result = $(template).text()
	        } else {
	            result = template.toString()
	        }
	        return result
	    }
	});
	module.exports = MenuBaseEditStrategy;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.error_handling.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    clickEvent = __webpack_require__(65),
	    gridCore = __webpack_require__(144);
	var DATAGRID_ERROR_ROW_CLASS = "dx-error-row",
	    DATAGRID_ERROR_MESSAGE_CLASS = "dx-error-message",
	    DATAGRID_ERROR_CLOSEBUTTON_CLASS = "dx-closebutton",
	    DATAGRID_ACTION_CLASS = "dx-datagrid-action";
	exports.ErrorHandlingController = gridCore.ViewController.inherit({
	    init: function() {
	        var that = this;
	        that._columnHeadersView = that.getView("columnHeadersView");
	        that._rowsView = that.getView("rowsView")
	    },
	    _createErrorRow: function(message, $tableElements) {
	        var that = this,
	            $errorRow = $("<tr />").addClass(DATAGRID_ERROR_ROW_CLASS),
	            $errorMessage = $("<div/>").addClass(DATAGRID_ERROR_MESSAGE_CLASS).text(message),
	            $closeButton = $("<div/>").addClass(DATAGRID_ERROR_CLOSEBUTTON_CLASS).addClass(DATAGRID_ACTION_CLASS);
	        $closeButton.on(clickEvent.name, that.createAction(function(args) {
	            var $errorRow, e = args.jQueryEvent,
	                errorRowIndex = $(e.currentTarget).closest("." + DATAGRID_ERROR_ROW_CLASS).index();
	            e.stopPropagation();
	            $.each($tableElements, function(_, tableElement) {
	                $errorRow = $(tableElement).children("tbody").children("tr").eq(errorRowIndex);
	                that.removeErrorRow($errorRow)
	            })
	        }));
	        $("<td/>").attr({
	            colspan: that.getController("columns").getVisibleColumns().length,
	            role: "presentation"
	        }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
	        return $errorRow
	    },
	    renderErrorRow: function(message, rowIndex) {
	        var $row, $errorRow, rowElements, that = this,
	            viewElement = rowIndex >= 0 ? that._rowsView : that._columnHeadersView,
	            $tableElements = viewElement.getTableElements();
	        $.each($tableElements, function(_, tableElement) {
	            $errorRow = that._createErrorRow(message, $tableElements);
	            rowElements = $(tableElement).children("tbody").children("tr");
	            if (rowIndex >= 0) {
	                $row = viewElement._getRowElements($(tableElement)).eq(rowIndex);
	                that.removeErrorRow(rowElements.eq($row.index() + 1));
	                $errorRow.insertAfter($row)
	            } else {
	                that.removeErrorRow(rowElements.last());
	                $(tableElement).append($errorRow)
	            }
	        })
	    },
	    removeErrorRow: function($row) {
	        var $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
	        $row = $row || $columnHeaders && $columnHeaders.find("." + DATAGRID_ERROR_ROW_CLASS);
	        $row && $row.hasClass(DATAGRID_ERROR_ROW_CLASS) && $row.remove()
	    },
	    optionChanged: function(args) {
	        var that = this;
	        switch (args.name) {
	            case "errorRowEnabled":
	                args.handled = true;
	                break;
	            default:
	                that.callBase(args)
	        }
	    }
	});
	gridCore.registerModule("errorHandling", {
	    defaultOptions: function() {
	        return {
	            errorRowEnabled: true
	        }
	    },
	    controllers: {
	        errorHandling: exports.ErrorHandlingController
	    },
	    extenders: {
	        controllers: {
	            data: {
	                init: function() {
	                    var that = this,
	                        errorHandlingController = that.getController("errorHandling");
	                    that.callBase();
	                    that.dataErrorOccurred.add(function(error) {
	                        var message = error && error.message || error;
	                        if (that.option("errorRowEnabled")) {
	                            errorHandlingController.renderErrorRow(message)
	                        }
	                    });
	                    that.changed.add(function() {
	                        var errorHandlingController = that.getController("errorHandling"),
	                            editingController = that.getController("editing");
	                        if (editingController && !editingController.hasChanges()) {
	                            errorHandlingController && errorHandlingController.removeErrorRow()
	                        }
	                    })
	                }
	            }
	        }
	    }
	});


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.grid_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    commonUtils = __webpack_require__(8),
	    messageLocalization = __webpack_require__(79),
	    when = __webpack_require__(10).when;
	var DATAGRID_CLASS = "dx-datagrid",
	    DATAGRID_HIDDEN_CLASS = "dx-hidden",
	    DATAGRID_TABLE_CLASS = "dx-datagrid-table",
	    DATAGRID_BORDERS_CLASS = "dx-datagrid-borders",
	    DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
	    DATAGRID_IMPORTANT_MARGIN_CLASS = "dx-datagrid-important-margin",
	    DATAGRID_HIDDEN_COLUMNS_WIDTH = "adaptiveHidden",
	    DATAGRID_EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])",
	    EMPTY_GRID_ROWS_HEIGHT = 100,
	    LOADPANEL_MARGIN = 50,
	    VIEW_NAMES = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView"];
	var isPercentWidth = function(width) {
	    return commonUtils.isString(width) && "%" === width.slice(-1)
	};
	var mergeArraysByMaxValue = function(values1, values2) {
	    var i, result = [];
	    if (values1 && values2 && values1.length && values1.length === values2.length) {
	        for (i = 0; i < values1.length; i++) {
	            result.push(values1[i] > values2[i] ? values1[i] : values2[i])
	        }
	    } else {
	        if (values1 && values1.length) {
	            result = values1
	        } else {
	            if (values2) {
	                result = values2
	            }
	        }
	    }
	    return result
	};
	exports.ResizingController = gridCore.ViewController.inherit({
	    _initPostRenderHandlers: function() {
	        var that = this;
	        if (!that._refreshSizesHandler) {
	            that._refreshSizesHandler = function(e) {
	                that._dataController.changed.remove(that._refreshSizesHandler);
	                var resizeDeferred, changeType = e && e.changeType,
	                    isDelayed = e && e.isDelayed;
	                if (!e || "refresh" === changeType || "prepend" === changeType || "append" === changeType) {
	                    if (!isDelayed) {
	                        resizeDeferred = that.resize()
	                    }
	                } else {
	                    if ("update" === changeType) {
	                        if (that._dataController.items().length > 1 || "insert" !== e.changeTypes[0]) {
	                            that._rowsView.resize()
	                        } else {
	                            resizeDeferred = that.resize()
	                        }
	                    }
	                }
	                if (changeType && "updateSelection" !== changeType && !isDelayed) {
	                    when(resizeDeferred).done(function() {
	                        that.component._fireContentReadyAction()
	                    })
	                }
	            };
	            that._dataController.changed.add(function() {
	                that._dataController.changed.add(that._refreshSizesHandler)
	            })
	        }
	    },
	    _getBestFitWidths: function() {
	        var rowsColumnWidths, headerColumnWidths, footerColumnWidths, resultWidths, that = this;
	        rowsColumnWidths = that._rowsView.getColumnWidths();
	        headerColumnWidths = that._columnHeadersView && that._columnHeadersView.getColumnWidths();
	        footerColumnWidths = that._footerView && that._footerView.getColumnWidths();
	        resultWidths = mergeArraysByMaxValue(rowsColumnWidths, headerColumnWidths);
	        resultWidths = mergeArraysByMaxValue(resultWidths, footerColumnWidths);
	        return resultWidths
	    },
	    _setVisibleWidths: function(visibleColumns, widths) {
	        var columnsController = this._columnsController;
	        columnsController.beginUpdate();
	        $.each(visibleColumns, function(index, column) {
	            var columnId = column.command ? "command:" + column.command : column.index;
	            columnsController.columnOption(columnId, "visibleWidth", widths[index])
	        });
	        columnsController.endUpdate()
	    },
	    _toggleBestFitMode: function(isBestFit) {
	        var $element = this.component.element();
	        $element.find("." + DATAGRID_TABLE_CLASS).toggleClass(DATAGRID_TABLE_FIXED_CLASS, !isBestFit);
	        $element.find(DATAGRID_EDITORS_INPUT_SELECTOR).toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
	        $element.find(".dx-group-cell").toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
	        $element.find(".dx-header-row .dx-datagrid-text-content").css("max-width", "")
	    },
	    _synchronizeColumns: function() {
	        var resetBestFitMode, that = this,
	            columnsController = that._columnsController,
	            visibleColumns = columnsController.getVisibleColumns(),
	            columnAutoWidth = that.option("columnAutoWidth"),
	            needBestFit = columnAutoWidth || that._maxHeightHappened,
	            isLastWidthReset = false,
	            resultWidths = [],
	            normalizeWidthsByExpandColumns = function() {
	                var expandColumnWidth;
	                $.each(visibleColumns, function(index, column) {
	                    if ("expand" === column.command) {
	                        expandColumnWidth = resultWidths[index]
	                    }
	                });
	                $.each(visibleColumns, function(index, column) {
	                    if ("expand" === column.command && expandColumnWidth) {
	                        resultWidths[index] = expandColumnWidth
	                    }
	                })
	            };
	        !needBestFit && $.each(visibleColumns, function(index, column) {
	            if ("auto" === column.width || column.fixed) {
	                needBestFit = true;
	                return false
	            }
	        });
	        that._setVisibleWidths(visibleColumns, []);
	        if (that._isNeedToCalcBestFitWidths(needBestFit)) {
	            that._toggleBestFitMode(true);
	            resetBestFitMode = true
	        }
	        commonUtils.deferUpdate(function() {
	            if (that._isNeedToCalcBestFitWidths(needBestFit)) {
	                resultWidths = that._getBestFitWidths();
	                $.each(visibleColumns, function(index, column) {
	                    var columnId = column.command ? "command:" + column.command : column.index;
	                    columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true)
	                })
	            }
	            $.each(visibleColumns, function(index) {
	                if ("auto" !== this.width) {
	                    if (this.width) {
	                        resultWidths[index] = this.width
	                    } else {
	                        if (!columnAutoWidth) {
	                            resultWidths[index] = void 0
	                        }
	                    }
	                }
	            });
	            isLastWidthReset = that._correctColumnWidths(resultWidths, visibleColumns);
	            if (columnAutoWidth) {
	                normalizeWidthsByExpandColumns();
	                that._processStretch(resultWidths, visibleColumns)
	            }
	            commonUtils.deferRender(function() {
	                if (resetBestFitMode) {
	                    that._toggleBestFitMode(false);
	                    resetBestFitMode = false
	                }
	                if (needBestFit || isLastWidthReset) {
	                    that._setVisibleWidths(visibleColumns, resultWidths)
	                }
	            })
	        })
	    },
	    _isNeedToCalcBestFitWidths: function(needBestFit) {
	        return needBestFit
	    },
	    _correctColumnWidths: function(resultWidths, visibleColumns) {
	        var lastColumnIndex, that = this,
	            hasPercentWidth = false,
	            hasAutoWidth = false,
	            isLastWidthReset = false,
	            $element = that.component.element(),
	            hasWidth = that._hasWidth;
	        $.each(visibleColumns, function(index) {
	            if ("auto" !== this.width) {
	                if (this.width) {
	                    if (resultWidths[index] !== DATAGRID_HIDDEN_COLUMNS_WIDTH) {
	                        resultWidths[index] = this.width
	                    }
	                } else {
	                    hasAutoWidth = true
	                }
	            }
	            if (isPercentWidth(this.width)) {
	                hasPercentWidth = true
	            }
	        });
	        if ($element && that._maxWidth) {
	            delete that._maxWidth;
	            $element.css("max-width", "")
	        }
	        if (!hasAutoWidth && resultWidths.length) {
	            var contentWidth = that._rowsView.contentWidth(),
	                totalWidth = that._getTotalWidth(resultWidths, contentWidth);
	            if (totalWidth <= contentWidth) {
	                lastColumnIndex = resultWidths.length - 1;
	                while (lastColumnIndex >= 0 && visibleColumns[lastColumnIndex] && (visibleColumns[lastColumnIndex].command || resultWidths[lastColumnIndex] === DATAGRID_HIDDEN_COLUMNS_WIDTH)) {
	                    lastColumnIndex--
	                }
	                if (lastColumnIndex >= 0) {
	                    resultWidths[lastColumnIndex] = "auto";
	                    isLastWidthReset = true;
	                    if (!hasWidth && !hasPercentWidth) {
	                        that._maxWidth = that.option("showBorders") ? totalWidth + 2 : totalWidth;
	                        $element.css("max-width", that._maxWidth)
	                    }
	                }
	            }
	        }
	        return isLastWidthReset
	    },
	    _processStretch: function(resultSizes, visibleColumns) {
	        var diff, diffElement, onePixelElementsCount, i, groupSize = this._rowsView.contentWidth(),
	            tableSize = this._getTotalWidth(resultSizes, groupSize),
	            unusedIndexes = {
	                length: 0
	            };
	        if (!resultSizes.length) {
	            return
	        }
	        $.each(visibleColumns, function(index) {
	            if (this.width || resultSizes[index] === DATAGRID_HIDDEN_COLUMNS_WIDTH) {
	                unusedIndexes[index] = true;
	                unusedIndexes.length++
	            }
	        });
	        diff = groupSize - tableSize;
	        diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
	        onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
	        if (diff >= 0) {
	            for (i = 0; i < resultSizes.length; i++) {
	                if (unusedIndexes[i]) {
	                    continue
	                }
	                resultSizes[i] += diffElement;
	                if (onePixelElementsCount) {
	                    resultSizes[i]++;
	                    onePixelElementsCount--
	                }
	            }
	        }
	    },
	    _getTotalWidth: function(widths, groupWidth) {
	        var width, i, result = 0;
	        for (i = 0; i < widths.length; i++) {
	            width = widths[i];
	            if (width && width !== DATAGRID_HIDDEN_COLUMNS_WIDTH) {
	                result += isPercentWidth(width) ? parseInt(width) * groupWidth / 100 : parseInt(width)
	            }
	        }
	        return Math.round(result)
	    },
	    updateSize: function($rootElement) {
	        var $groupElement, width, that = this;
	        if (void 0 === that._hasHeight && $rootElement && $rootElement.is(":visible")) {
	            $groupElement = $rootElement.children("." + DATAGRID_CLASS);
	            if ($groupElement.length) {
	                $groupElement.detach()
	            }
	            that._hasHeight = !!$rootElement.height();
	            width = $rootElement.width();
	            $rootElement.addClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
	            that._hasWidth = $rootElement.width() === width;
	            $rootElement.removeClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
	            if ($groupElement.length) {
	                $groupElement.appendTo($rootElement)
	            }
	        }
	    },
	    publicMethods: function() {
	        return ["resize", "updateDimensions"]
	    },
	    resize: function() {
	        return !this.component._requireResize && this.updateDimensions()
	    },
	    updateDimensions: function(checkSize) {
	        var that = this;
	        that._initPostRenderHandlers();
	        if (!that._checkSize(checkSize)) {
	            return
	        }
	        return commonUtils.deferRender(function() {
	            var scrollTop, scrollable = that._rowsView.getScrollable();
	            if (that._dataController.isLoaded()) {
	                that._synchronizeColumns();
	                scrollTop = scrollable && scrollable._container().get(0).scrollTop;
	                that._rowsView.height("auto")
	            }
	            commonUtils.deferUpdate(function() {
	                commonUtils.deferRender(function() {
	                    commonUtils.deferUpdate(function() {
	                        that._updateDimensionsCore(scrollTop)
	                    })
	                })
	            })
	        })
	    },
	    _checkSize: function(checkSize) {
	        var $rootElement = this.component.element();
	        if (checkSize && (this._lastWidth === $rootElement.width() && this._lastHeight === $rootElement.height() || !$rootElement.is(":visible"))) {
	            return false
	        }
	        return true
	    },
	    _updateDimensionsCore: function(scrollTop) {
	        var rowsViewHeight, $testDiv, that = this,
	            scrollable = that._rowsView.getScrollable(),
	            dataController = that._dataController,
	            rowsView = that._rowsView,
	            columnHeadersView = that._columnHeadersView,
	            footerView = that._footerView,
	            $rootElement = that.component.element(),
	            rootElementHeight = $rootElement && ($rootElement.get(0).clientHeight || $rootElement.height()),
	            maxHeight = parseFloat($rootElement.css("maxHeight")),
	            maxHeightHappened = maxHeight && rootElementHeight >= maxHeight,
	            loadPanelOptions = that.option("loadPanel"),
	            height = that.option("height") || $rootElement.get(0).style.height,
	            editorFactory = that.getController("editorFactory");
	        that._maxHeightHappened = maxHeightHappened;
	        that.updateSize($rootElement);
	        if (height && that._hasHeight ^ "auto" !== height) {
	            $testDiv = $("<div>").height(height).appendTo($rootElement);
	            that._hasHeight = !!$testDiv.height();
	            $testDiv.remove()
	        }
	        if (that.option("scrolling") && (that._hasHeight && rootElementHeight > 0 || maxHeightHappened)) {
	            rowsViewHeight = rootElementHeight;
	            $.each(that.getViews(), function() {
	                if (this.isVisible() && this.getHeight) {
	                    rowsViewHeight -= this.getHeight()
	                }
	            })
	        } else {
	            if (!that._hasHeight && 0 === dataController.items().length) {
	                rowsViewHeight = loadPanelOptions && loadPanelOptions.enabled ? loadPanelOptions.height + LOADPANEL_MARGIN : EMPTY_GRID_ROWS_HEIGHT
	            } else {
	                rowsViewHeight = "auto"
	            }
	        }
	        commonUtils.deferRender(function() {
	            rowsView.height(rowsViewHeight, that._hasHeight || maxHeightHappened);
	            if (scrollTop && scrollable) {
	                scrollable._container().get(0).scrollTop = scrollTop
	            }
	            if (!dataController.isLoaded()) {
	                rowsView.setLoading(true);
	                return
	            }
	            commonUtils.deferUpdate(function() {
	                that._updateLastSizes($rootElement);
	                var vScrollbarWidth = rowsView.getScrollbarWidth();
	                var hScrollbarWidth = rowsView.getScrollbarWidth(true);
	                commonUtils.deferRender(function() {
	                    columnHeadersView && columnHeadersView.setScrollerSpacing(vScrollbarWidth);
	                    footerView && footerView.setScrollerSpacing(vScrollbarWidth);
	                    rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth)
	                });
	                $.each(VIEW_NAMES, function(index, viewName) {
	                    var view = that.getView(viewName);
	                    if (view) {
	                        view.resize()
	                    }
	                });
	                editorFactory && editorFactory.resize()
	            })
	        })
	    },
	    _updateLastSizes: function($rootElement) {
	        this._lastWidth = $rootElement.width();
	        this._lastHeight = $rootElement.height()
	    },
	    optionChanged: function(args) {
	        switch (args.name) {
	            case "width":
	            case "height":
	                this.component._renderDimensions();
	                this.resize();
	            default:
	                this.callBase(args)
	        }
	    },
	    init: function() {
	        var that = this;
	        that._dataController = that.getController("data");
	        that._columnsController = that.getController("columns");
	        that._columnHeadersView = that.getView("columnHeadersView");
	        that._footerView = that.getView("footerView");
	        that._rowsView = that.getView("rowsView")
	    }
	});
	exports.SynchronizeScrollingController = gridCore.ViewController.inherit({
	    _scrollChangedHandler: function(views, pos, viewName) {
	        for (var j = 0; j < views.length; j++) {
	            if (views[j].name !== viewName) {
	                views[j].scrollTo({
	                    left: pos.left,
	                    top: pos.top
	                })
	            }
	        }
	    },
	    init: function() {
	        var view, i, views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
	        for (i = 0; i < views.length; i++) {
	            view = views[i];
	            if (view) {
	                view.scrollChanged.add($.proxy(this._scrollChangedHandler, this, views))
	            }
	        }
	    }
	});
	exports.GridView = gridCore.View.inherit({
	    _endUpdateCore: function() {
	        if (this.component._requireResize) {
	            this.component._requireResize = false;
	            this._resizingController.resize()
	        }
	    },
	    init: function() {
	        var that = this;
	        that._resizingController = this.getController("resizing");
	        that._dataController = that.getController("data")
	    },
	    getView: function(name) {
	        return this.component._views[name]
	    },
	    element: function() {
	        return this._groupElement
	    },
	    optionChanged: function(args) {
	        var that = this;
	        if (commonUtils.isDefined(that._groupElement) && "showBorders" === args.name) {
	            that._groupElement.toggleClass(DATAGRID_BORDERS_CLASS, !!args.value);
	            args.handled = true
	        } else {
	            that.callBase(args)
	        }
	    },
	    _renderViews: function($groupElement) {
	        var that = this;
	        $.each(VIEW_NAMES, function(index, viewName) {
	            var view = that.getView(viewName);
	            if (view) {
	                view.render($groupElement)
	            }
	        })
	    },
	    render: function($rootElement) {
	        var that = this,
	            isFirstRender = !that._groupElement,
	            $groupElement = that._groupElement || $("<div>").addClass(DATAGRID_CLASS);
	        $groupElement.toggleClass(DATAGRID_BORDERS_CLASS, !!that.option("showBorders"));
	        that.component.setAria({
	            role: "application",
	            label: messageLocalization.format("dxDataGrid-ariaDataGrid")
	        }, $rootElement);
	        that._rootElement = $rootElement || that._rootElement;
	        if (isFirstRender) {
	            that._groupElement = $groupElement;
	            that.getController("resizing").updateSize($rootElement);
	            $groupElement.appendTo($rootElement)
	        }
	        that._renderViews($groupElement);
	        that.update()
	    },
	    update: function() {
	        var that = this,
	            $rootElement = that._rootElement,
	            $groupElement = that._groupElement,
	            resizingController = that.getController("resizing");
	        if ($rootElement && $groupElement) {
	            resizingController.resize();
	            if (that._dataController.isLoaded()) {
	                that.component._fireContentReadyAction()
	            }
	        }
	    }
	});
	gridCore.registerModule("gridView", {
	    defaultOptions: function() {
	        return {
	            showBorders: false
	        }
	    },
	    controllers: {
	        resizing: exports.ResizingController,
	        synchronizeScrolling: exports.SynchronizeScrollingController
	    },
	    views: {
	        gridView: exports.GridView
	    }
	});


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.header_panel.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    Toolbar = __webpack_require__(174),
	    columnsView = __webpack_require__(147),
	    commonUtils = __webpack_require__(8);
	__webpack_require__(189);
	var DATAGRID_HEADER_PANEL_CLASS = "dx-datagrid-header-panel",
	    DATAGRID_TOOLBAR_BUTTON_CLASS = "dx-datagrid-toolbar-button";
	exports.HeaderPanel = columnsView.ColumnsView.inherit({
	    _getToolbarItems: function() {
	        return []
	    },
	    _getButtonContainer: function() {
	        return $("<div />").addClass(DATAGRID_TOOLBAR_BUTTON_CLASS)
	    },
	    _getToolbarButtonClass: function(specificClass) {
	        var secondClass = specificClass ? " " + specificClass : "";
	        return DATAGRID_TOOLBAR_BUTTON_CLASS + secondClass
	    },
	    _getToolbarOptions: function() {
	        var toolbarItems, options = {
	            toolbarOptions: {
	                items: this._getToolbarItems()
	            }
	        };
	        this.executeAction("onToolbarPreparing", options);
	        if (options.toolbarOptions && !commonUtils.isDefined(options.toolbarOptions.visible)) {
	            toolbarItems = options.toolbarOptions.items;
	            options.toolbarOptions.visible = !!(toolbarItems && toolbarItems.length)
	        }
	        return options.toolbarOptions
	    },
	    _renderCore: function() {
	        if (!this._toolbar) {
	            this.element().addClass(DATAGRID_HEADER_PANEL_CLASS);
	            this._toolbar = this._createComponent($("<div />").appendTo(this.element()), Toolbar, this._toolbarOptions)
	        }
	    },
	    init: function() {
	        this.callBase();
	        this.createAction("onToolbarPreparing", {
	            excludeValidators: ["designMode", "disabled", "readOnly"]
	        })
	    },
	    render: function() {
	        this._toolbarOptions = this._toolbarOptions || this._getToolbarOptions();
	        this.callBase.apply(this, arguments)
	    },
	    updateToolbar: function() {
	        this._toolbarOptions = this._getToolbarOptions();
	        if (this._toolbar) {
	            this._toolbar.option(this._toolbarOptions)
	        }
	    },
	    updateToolbarItemOption: function(name, optionName, optionValue) {
	        var toolbarInstance = this._toolbar;
	        if (toolbarInstance) {
	            var items = toolbarInstance.option("items");
	            if (items && items.length) {
	                var itemIndex;
	                $.each(items, function(index, item) {
	                    if (item.name === name) {
	                        itemIndex = index;
	                        return false
	                    }
	                });
	                if (void 0 !== itemIndex) {
	                    if (commonUtils.isObject(optionName)) {
	                        toolbarInstance.option("items[" + itemIndex + "]", optionName)
	                    } else {
	                        toolbarInstance.option("items[" + itemIndex + "]." + optionName, optionValue);
	                        if ("disabled" === optionName) {
	                            var widgetOptions = toolbarInstance.option("items[" + itemIndex + "].options") || {};
	                            widgetOptions.disabled = optionValue;
	                            toolbarInstance.option("items[" + itemIndex + "].options", widgetOptions)
	                        }
	                    }
	                }
	            }
	        }
	    },
	    getToolbarItemOption: function(name, optionName) {
	        var toolbarInstance = this._toolbar;
	        if (toolbarInstance) {
	            var items = toolbarInstance.option("items");
	            if (items && items.length) {
	                var optionValue;
	                $.each(items, function(index, item) {
	                    if (item.name === name) {
	                        optionValue = item[optionName];
	                        return false
	                    }
	                });
	                return optionValue
	            }
	        }
	    },
	    getHeaderPanel: function() {
	        return this.element()
	    },
	    getHeight: function() {
	        var $element = this.element();
	        return $element ? $element.outerHeight(true) : 0
	    },
	    optionChanged: function(args) {
	        if ("onToolbarPreparing" === args.name) {
	            this.updateToolbar();
	            args.handled = true
	        }
	        this.callBase(args)
	    },
	    isVisible: function() {
	        return this._toolbarOptions && this._toolbarOptions.visible
	    }
	});
	gridCore.registerModule("headerPanel", {
	    defaultOptions: function() {
	        return {}
	    },
	    views: {
	        headerPanel: exports.HeaderPanel
	    }
	});


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    themes = __webpack_require__(112),
	    registerComponent = __webpack_require__(44),
	    ActionSheetStrategy = __webpack_require__(175),
	    DropDownMenuStrategy = __webpack_require__(179),
	    ListBottomStrategy = __webpack_require__(207),
	    ListTopStrategy = __webpack_require__(210),
	    ToolbarBase = __webpack_require__(116),
	    ChildDefaultTemplate = __webpack_require__(89);
	var STRATEGIES = {
	    actionSheet: ActionSheetStrategy,
	    dropDownMenu: DropDownMenuStrategy,
	    listBottom: ListBottomStrategy,
	    listTop: ListTopStrategy
	};
	var TOOLBAR_AUTO_HIDE_ITEM_CLASS = "dx-toolbar-item-auto-hide",
	    TOOLBAR_AUTO_HIDE_TEXT_CLASS = "dx-toolbar-text-auto-hide",
	    TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
	var Toolbar = ToolbarBase.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            menuItemTemplate: "menuItem",
	            submenuType: "dropDownMenu"
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return /ios7.*/.test(themes.current())
	            },
	            options: {
	                submenuType: "actionSheet"
	            }
	        }, {
	            device: function() {
	                return /android5.*/.test(themes.current())
	            },
	            options: {
	                submenuType: "dropDownMenu"
	            }
	        }, {
	            device: function() {
	                return /win8.*/.test(themes.current())
	            },
	            options: {
	                submenuType: "listBottom"
	            }
	        }, {
	            device: function() {
	                return /win10.*/.test(themes.current())
	            },
	            options: {
	                submenuType: "listTop"
	            }
	        }])
	    },
	    _dimensionChanged: function(dimension) {
	        if ("height" === dimension) {
	            return
	        }
	        this._menuStrategy.toggleMenuVisibility(false, true);
	        this.callBase();
	        this._menuStrategy.renderMenuItems()
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.actionSheetItem = new ChildDefaultTemplate("item", this)
	    },
	    _render: function() {
	        this.callBase();
	        this._menuStrategy.renderMenuItems()
	    },
	    _renderContentImpl: function() {
	        this.callBase();
	        this._hideOverflowItems();
	        this._renderMenu()
	    },
	    _renderItem: function(index, item, itemContainer, $after) {
	        var itemElement = this.callBase(index, item, itemContainer, $after);
	        if ("auto" === item.locateInMenu) {
	            itemElement.addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS)
	        }
	        if ("dxButton" === item.widget && "inMenu" === item.showText) {
	            itemElement.toggleClass(TOOLBAR_AUTO_HIDE_TEXT_CLASS)
	        }
	        return itemElement
	    },
	    _hideOverflowItems: function(elementWidth) {
	        var overflowItems = this.element().find("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS);
	        if (!overflowItems.length) {
	            return
	        }
	        elementWidth = elementWidth || this.element().width();
	        $(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
	        var beforeWidth = this._$beforeSection.outerWidth(),
	            centerWidth = this._$centerSection.outerWidth(),
	            afterWidth = this._$afterSection.outerWidth(),
	            itemsWidth = beforeWidth + centerWidth + afterWidth;
	        while (overflowItems.length && elementWidth < itemsWidth) {
	            var $item = overflowItems.eq(-1);
	            itemsWidth -= $item.outerWidth();
	            $item.addClass(TOOLBAR_HIDDEN_ITEM);
	            overflowItems.splice(-1, 1)
	        }
	    },
	    _getMenuItems: function() {
	        var that = this;
	        var menuItems = $.grep(this.option("items") || [], function(item) {
	            return that._isMenuItem(item)
	        });
	        var $hiddenItems = this._itemContainer().children("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS + "." + TOOLBAR_HIDDEN_ITEM).not(".dx-state-invisible");
	        this._restoreItems = this._restoreItems || [];
	        var overflowItems = $.map($hiddenItems, function(item) {
	            var itemData = that._getItemData(item),
	                $itemContainer = $(item).children(),
	                $itemMarkup = $itemContainer.children();
	            return $.extend({
	                menuItemTemplate: function() {
	                    that._restoreItems.push({
	                        container: $itemContainer,
	                        item: $itemMarkup
	                    });
	                    var $container = $("<div>").addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS);
	                    return $container.append($itemMarkup)
	                }
	            }, itemData)
	        });
	        return $.merge(overflowItems, menuItems)
	    },
	    _getToolbarItems: function() {
	        var that = this;
	        return $.grep(this.option("items") || [], function(item) {
	            return !that._isMenuItem(item)
	        })
	    },
	    _renderMenu: function() {
	        this._renderMenuStrategy();
	        this._menuStrategy.render()
	    },
	    _renderMenuStrategy: function() {
	        var strategyName = this.option("submenuType");
	        if (this._requireDropDownStrategy()) {
	            strategyName = "dropDownMenu"
	        }
	        var strategy = STRATEGIES[strategyName];
	        if (!(this._menuStrategy && this._menuStrategy.NAME === strategyName)) {
	            this._menuStrategy = new strategy(this)
	        }
	    },
	    _requireDropDownStrategy: function() {
	        var strategyName = this.option("submenuType");
	        if (("listBottom" === strategyName || "listTop" === strategyName) && "topToolbar" === this.option("renderAs")) {
	            return true
	        }
	        var items = this.option("items") || [],
	            result = false;
	        $.each(items, function(index, item) {
	            if ("auto" === item.locateInMenu) {
	                result = true
	            } else {
	                if ("always" === item.locateInMenu && item.widget) {
	                    result = true
	                }
	            }
	        });
	        return result
	    },
	    _arrangeItems: function() {
	        if (this.element().is(":hidden")) {
	            return
	        }
	        this._$centerSection.css({
	            margin: "0 auto",
	            "float": "none"
	        });
	        $.each(this._restoreItems || [], function(_, obj) {
	            $(obj.container).append(obj.item)
	        });
	        this._restoreItems = [];
	        var elementWidth = this.element().width();
	        this._hideOverflowItems(elementWidth);
	        this.callBase(elementWidth)
	    },
	    _itemOptionChanged: function(item, property, value) {
	        if (this._isMenuItem(item)) {
	            this._menuStrategy.renderMenuItems()
	        } else {
	            if (this._isToolbarItem(item)) {
	                this.callBase(item, property, value)
	            } else {
	                this.callBase(item, property, value);
	                this._menuStrategy.renderMenuItems()
	            }
	        }
	    },
	    _isMenuItem: function(itemData) {
	        return "menu" === itemData.location || "always" === itemData.locateInMenu
	    },
	    _isToolbarItem: function(itemData) {
	        return void 0 === itemData.location || "never" === itemData.locateInMenu
	    },
	    _optionChanged: function(args) {
	        var name = args.name;
	        var value = args.value;
	        switch (name) {
	            case "submenuType":
	                this._invalidate();
	                break;
	            case "visible":
	                this.callBase.apply(this, arguments);
	                this._menuStrategy.handleToolbarVisibilityChange(value);
	                break;
	            case "menuItemTemplate":
	                this._changeMenuOption("itemTemplate", this._getTemplate(value));
	                break;
	            case "onItemClick":
	                this._changeMenuOption(name, value);
	                this.callBase.apply(this, arguments);
	                break;
	            default:
	                this.callBase.apply(this, arguments)
	        }
	    },
	    _changeMenuOption: function(name, value) {
	        this._menuStrategy.widgetOption(name, value)
	    }
	});
	registerComponent("dxToolbar", Toolbar);
	module.exports = Toolbar;
	module.exports.default = module.exports;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.strategy.action_sheet.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ToolbarStrategy = __webpack_require__(176),
	    ActionSheet = __webpack_require__(177);
	var ActionSheetStrategy = ToolbarStrategy.inherit({
	    NAME: "actionSheet",
	    _getMenuItemTemplate: function() {
	        return this._toolbar._getTemplate("actionSheetItem")
	    },
	    render: function() {
	        if (!this._hasVisibleMenuItems()) {
	            return
	        }
	        this.callBase()
	    },
	    _menuWidgetClass: function() {
	        return ActionSheet
	    },
	    _menuContainer: function() {
	        return this._toolbar.element()
	    },
	    _widgetOptions: function() {
	        return $.extend({}, this.callBase(), {
	            target: this._$button,
	            showTitle: false
	        })
	    },
	    _menuButtonOptions: function() {
	        return $.extend({}, this.callBase(), {
	            icon: "overflow"
	        })
	    },
	    _toggleMenu: function() {
	        this.callBase.apply(this, arguments);
	        this._menu.toggle(this._menuShown);
	        this._menuShown = false
	    }
	});
	module.exports = ActionSheetStrategy;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.strategy.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    compileGetter = __webpack_require__(35).compileGetter,
	    Class = __webpack_require__(18),
	    Button = __webpack_require__(114),
	    abstract = Class.abstract;
	var TOOLBAR_MENU_CONTAINER_CLASS = "dx-toolbar-menu-container",
	    TOOLBAR_MENU_BUTTON_CLASS = "dx-toolbar-menu-button";
	var ToolbarStrategy = Class.inherit({
	    ctor: function(toolbar) {
	        this._toolbar = toolbar
	    },
	    render: function() {
	        this._renderMenuButton();
	        this._renderWidget()
	    },
	    _widgetOptions: function() {
	        var itemClickAction = this._toolbar._createActionByOption("onItemClick");
	        return {
	            itemTemplate: $.proxy(this._getMenuItemTemplate, this),
	            onItemClick: $.proxy(function(e) {
	                this._toggleMenu(false, true);
	                itemClickAction(e)
	            }, this)
	        }
	    },
	    _getMenuItemTemplate: function() {
	        return this._toolbar._getTemplateByOption("menuItemTemplate")
	    },
	    _renderWidget: function() {
	        var $menu = $("<div>").appendTo(this._menuContainer());
	        this._menu = this._toolbar._createComponent($menu, this._menuWidgetClass(), this._widgetOptions());
	        this.renderMenuItems()
	    },
	    _menuContainer: abstract,
	    _menuWidgetClass: abstract,
	    _hasVisibleMenuItems: function() {
	        var menuItems = this._toolbar.option("items"),
	            result = false;
	        var optionGetter = compileGetter("visible"),
	            overflowGetter = compileGetter("locateInMenu");
	        var menuLocation = false;
	        $.each(menuItems, function(index, item) {
	            var itemVisible = optionGetter(item, {
	                    functionsAsIs: true
	                }),
	                itemOverflow = overflowGetter(item, {
	                    functionsAsIs: true
	                });
	            if ("menu" === item.location) {
	                menuLocation = true
	            }
	            if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow || "menu" === item.location)) {
	                result = true
	            }
	        });
	        if (menuLocation) {
	            errors.log("W0001", "dxToolbar - 'location' item field", "menu", "16.1", "Use 'locateInMenu' item field instead.")
	        }
	        return result
	    },
	    _getMenuItems: function() {
	        return this._toolbar._getMenuItems()
	    },
	    _renderMenuButton: function() {
	        var buttonOptions = this._menuButtonOptions();
	        this._renderMenuButtonContainer();
	        this._$button = $("<div>").appendTo(this._$menuButtonContainer).addClass(TOOLBAR_MENU_BUTTON_CLASS);
	        this._toolbar._createComponent(this._$button, Button, buttonOptions)
	    },
	    _menuButtonOptions: function() {
	        return {
	            onClick: $.proxy(this._menuButtonClickHandler, this)
	        }
	    },
	    _menuButtonClickHandler: function() {
	        this._toggleMenu(!this._menuShown, true)
	    },
	    _renderMenuButtonContainer: function() {
	        var $afterSection = this._toolbar._$afterSection;
	        this._$menuButtonContainer = $("<div>").appendTo($afterSection).addClass(this._toolbar._buttonClass()).addClass(TOOLBAR_MENU_CONTAINER_CLASS)
	    },
	    renderMenuItems: function() {
	        this._menu && this._menu.option("items", this._getMenuItems())
	    },
	    toggleMenuVisibility: function(visible, animate) {
	        this._menu && this._toggleMenu(visible, animate)
	    },
	    _toggleMenu: function(visible) {
	        this._menuShown = visible
	    },
	    getMenuWidget: function() {
	        return this._menu
	    },
	    widgetOption: function(name, value) {
	        this._menu && this._menu.option(name, value)
	    },
	    handleToolbarVisibilityChange: $.noop
	});
	module.exports = ToolbarStrategy;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/action_sheet.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    messageLocalization = __webpack_require__(79),
	    registerComponent = __webpack_require__(44),
	    Button = __webpack_require__(114),
	    CollectionWidget = __webpack_require__(117),
	    Popup = __webpack_require__(113),
	    Popover = __webpack_require__(178),
	    BindableTemplate = __webpack_require__(134);
	var ACTION_SHEET_CLASS = "dx-actionsheet",
	    ACTION_SHEET_CONTAINER_CLASS = "dx-actionsheet-container",
	    ACTION_SHEET_POPUP_WRAPPER_CLASS = "dx-actionsheet-popup-wrapper",
	    ACTION_SHEET_POPOVER_WRAPPER_CLASS = "dx-actionsheet-popover-wrapper",
	    ACTION_SHEET_CANCEL_BUTTON_CLASS = "dx-actionsheet-cancel",
	    ACTION_SHEET_ITEM_CLASS = "dx-actionsheet-item",
	    ACTION_SHEET_ITEM_DATA_KEY = "dxActionSheetItemData",
	    ACTION_SHEET_WITHOUT_TITLE_CLASS = "dx-actionsheet-without-title";
	var ActionSheet = CollectionWidget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            usePopover: false,
	            target: null,
	            title: "",
	            showTitle: true,
	            showCancelButton: true,
	            cancelText: messageLocalization.format("Cancel"),
	            onCancelClick: null,
	            visible: false,
	            noDataText: "",
	            focusStateEnabled: false,
	            selectionByClick: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: {
	                platform: "ios",
	                tablet: true
	            },
	            options: {
	                usePopover: true
	            }
	        }])
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.item = new BindableTemplate(function($container, data) {
	            var button = new Button($("<div>"), $.extend({
	                onClick: data && data.click
	            }, data));
	            $container.append(button.element())
	        }, ["disabled", "icon", "text", "type", "onClick", "click"], this.option("integrationOptions.watchMethod"))
	    },
	    _itemContainer: function() {
	        return this._$itemContainer
	    },
	    _itemClass: function() {
	        return ACTION_SHEET_ITEM_CLASS
	    },
	    _itemDataKey: function() {
	        return ACTION_SHEET_ITEM_DATA_KEY
	    },
	    _toggleVisibility: $.noop,
	    _renderDimensions: $.noop,
	    _render: function() {
	        this.element().addClass(ACTION_SHEET_CLASS);
	        this._createItemContainer();
	        this._renderPopup()
	    },
	    _createItemContainer: function() {
	        this._$itemContainer = $("<div>").addClass(ACTION_SHEET_CONTAINER_CLASS);
	        this._renderDisabled()
	    },
	    _renderDisabled: function() {
	        this._$itemContainer.toggleClass("dx-state-disabled", this.option("disabled"))
	    },
	    _renderPopup: function() {
	        this._$popup = $("<div>").appendTo(this.element());
	        this._isPopoverMode() ? this._createPopover() : this._createPopup();
	        this._renderPopupTitle();
	        this._mapPopupOption("visible")
	    },
	    _mapPopupOption: function(optionName) {
	        this._popup.option(optionName, this.option(optionName))
	    },
	    _isPopoverMode: function() {
	        return this.option("usePopover") && this.option("target")
	    },
	    _renderPopupTitle: function() {
	        this._mapPopupOption("showTitle");
	        this._popup._wrapper().toggleClass(ACTION_SHEET_WITHOUT_TITLE_CLASS, !this.option("showTitle"))
	    },
	    _clean: function() {
	        if (this._$popup) {
	            this._$popup.remove()
	        }
	        this.callBase()
	    },
	    _overlayConfig: function() {
	        return {
	            onInitialized: $.proxy(function(args) {
	                this._popup = args.component
	            }, this),
	            disabled: false,
	            showTitle: true,
	            title: this.option("title"),
	            deferRendering: !window.angular,
	            onContentReady: $.proxy(this._popupContentReadyAction, this),
	            onHidden: $.proxy(this.hide, this)
	        }
	    },
	    _createPopover: function() {
	        this._createComponent(this._$popup, Popover, $.extend(this._overlayConfig(), {
	            width: this.option("width") || 200,
	            height: this.option("height") || "auto",
	            target: this.option("target")
	        }));
	        this._popup._wrapper().addClass(ACTION_SHEET_POPOVER_WRAPPER_CLASS)
	    },
	    _createPopup: function() {
	        this._createComponent(this._$popup, Popup, $.extend(this._overlayConfig(), {
	            dragEnabled: false,
	            width: this.option("width") || "100%",
	            height: this.option("height") || "auto",
	            showCloseButton: false,
	            position: {
	                my: "bottom",
	                at: "bottom",
	                of: window
	            },
	            animation: {
	                show: {
	                    type: "slide",
	                    duration: 400,
	                    from: {
	                        position: {
	                            my: "top",
	                            at: "bottom",
	                            of: window
	                        }
	                    },
	                    to: {
	                        position: {
	                            my: "bottom",
	                            at: "bottom",
	                            of: window
	                        }
	                    }
	                },
	                hide: {
	                    type: "slide",
	                    duration: 400,
	                    from: {
	                        position: {
	                            my: "bottom",
	                            at: "bottom",
	                            of: window
	                        }
	                    },
	                    to: {
	                        position: {
	                            my: "top",
	                            at: "bottom",
	                            of: window
	                        }
	                    }
	                }
	            }
	        }));
	        this._popup._wrapper().addClass(ACTION_SHEET_POPUP_WRAPPER_CLASS)
	    },
	    _popupContentReadyAction: function() {
	        this._popup.content().append(this._$itemContainer);
	        this._attachClickEvent();
	        this._attachHoldEvent();
	        this._renderContent();
	        this._renderCancelButton()
	    },
	    _renderCancelButton: function() {
	        if (this._isPopoverMode()) {
	            return
	        }
	        if (this._$cancelButton) {
	            this._$cancelButton.remove()
	        }
	        if (this.option("showCancelButton")) {
	            var cancelClickAction = this._createActionByOption("onCancelClick") || $.noop,
	                that = this;
	            this._$cancelButton = $("<div>").addClass(ACTION_SHEET_CANCEL_BUTTON_CLASS).appendTo(this._popup.content());
	            this._createComponent(this._$cancelButton, Button, {
	                disabled: false,
	                text: this.option("cancelText"),
	                onClick: function(e) {
	                    var hidingArgs = {
	                        jQueryEvent: e,
	                        cancel: false
	                    };
	                    cancelClickAction(hidingArgs);
	                    if (!hidingArgs.cancel) {
	                        that.hide()
	                    }
	                },
	                integrationOptions: {}
	            })
	        }
	    },
	    _attachItemClickEvent: $.noop,
	    _itemClickHandler: function(e) {
	        this.callBase(e);
	        if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
	            this.hide()
	        }
	    },
	    _itemHoldHandler: function(e) {
	        this.callBase(e);
	        if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
	            this.hide()
	        }
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "width":
	            case "height":
	            case "visible":
	            case "title":
	                this._mapPopupOption(args.name);
	                break;
	            case "disabled":
	                this._renderDisabled();
	                break;
	            case "showTitle":
	                this._renderPopupTitle();
	                break;
	            case "showCancelButton":
	            case "onCancelClick":
	            case "cancelText":
	                this._renderCancelButton();
	                break;
	            case "target":
	            case "usePopover":
	            case "items":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    toggle: function(showing) {
	        var that = this,
	            d = $.Deferred();
	        that._popup.toggle(showing).done(function() {
	            that.option("visible", showing);
	            d.resolveWith(that)
	        });
	        return d.promise()
	    },
	    show: function() {
	        return this.toggle(true)
	    },
	    hide: function() {
	        return this.toggle(false)
	    }
	});
	registerComponent("dxActionSheet", ActionSheet);
	module.exports = ActionSheet;
	module.exports.default = module.exports;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/popover.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    stringUtils = __webpack_require__(7),
	    translator = __webpack_require__(59),
	    positionUtils = __webpack_require__(60),
	    commonUtils = __webpack_require__(8),
	    mathUtils = __webpack_require__(77),
	    eventUtils = __webpack_require__(61),
	    Popup = __webpack_require__(113);
	var POPOVER_CLASS = "dx-popover",
	    POPOVER_WRAPPER_CLASS = "dx-popover-wrapper",
	    POPOVER_ARROW_CLASS = "dx-popover-arrow",
	    POPOVER_WITHOUT_TITLE_CLASS = "dx-popover-without-title",
	    POSITION_FLIP_MAP = {
	        left: "right",
	        top: "bottom",
	        right: "left",
	        bottom: "top",
	        center: "center"
	    },
	    WEIGHT_OF_SIDES = {
	        left: -1,
	        top: -1,
	        center: 0,
	        right: 1,
	        bottom: 1
	    },
	    POSITION_ALIASES = {
	        top: {
	            my: "bottom center",
	            at: "top center",
	            collision: "fit flip"
	        },
	        bottom: {
	            my: "top center",
	            at: "bottom center",
	            collision: "fit flip"
	        },
	        right: {
	            my: "left center",
	            at: "right center",
	            collision: "flip fit"
	        },
	        left: {
	            my: "right center",
	            at: "left center",
	            collision: "flip fit"
	        }
	    },
	    getEventName = function(that, optionName) {
	        var optionValue = that.option(optionName);
	        return commonUtils.isObject(optionValue) ? optionValue.name : optionValue
	    },
	    getEventDelay = function(that, optionName) {
	        var optionValue = that.option(optionName);
	        return commonUtils.isObject(optionValue) && optionValue.delay
	    },
	    attachEvent = function(that, name) {
	        var delay, action, handler, eventName, target = that.option("target"),
	            event = getEventName(that, name + "Event");
	        if (!event || that.option("disabled")) {
	            return
	        }
	        eventName = eventUtils.addNamespace(event, that.NAME);
	        action = that._createAction($.proxy(function() {
	            delay = getEventDelay(that, name + "Event");
	            if (delay) {
	                setTimeout(function() {
	                    that[name]()
	                }, delay)
	            } else {
	                that[name]()
	            }
	        }, that), {
	            validatingTargetName: "target"
	        });
	        handler = function(e) {
	            action({
	                jQueryEvent: e,
	                target: $(e.currentTarget)
	            })
	        };
	        if (target.jquery || target.nodeType || $.isWindow(target)) {
	            that["_" + name + "EventHandler"] = void 0;
	            $(target).on(eventName, handler)
	        } else {
	            that["_" + name + "EventHandler"] = handler;
	            $(document).on(eventName, target, handler)
	        }
	    },
	    detachEvent = function(that, target, name) {
	        var eventName, event = getEventName(that, name + "Event");
	        if (!event) {
	            return
	        }
	        eventName = eventUtils.addNamespace(event, that.NAME);
	        if (that["_" + name + "EventHandler"]) {
	            $(document).off(eventName, target, that["_" + name + "EventHandler"])
	        } else {
	            $(target).off(eventName)
	        }
	    };
	var Popover = Popup.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            target: window,
	            shading: false,
	            position: "bottom",
	            closeOnOutsideClick: true,
	            animation: {
	                show: {
	                    type: "fade",
	                    from: 0,
	                    to: 1
	                },
	                hide: {
	                    type: "fade",
	                    to: 0
	                }
	            },
	            showTitle: false,
	            width: "auto",
	            height: "auto",
	            dragEnabled: false,
	            resizeEnabled: false,
	            fullScreen: false,
	            closeOnTargetScroll: true,
	            arrowPosition: "",
	            arrowOffset: 0,
	            boundaryOffset: {
	                h: 10,
	                v: 10
	            }
	        })
	    },
	    _defaultOptionsRules: function() {
	        return [{
	            device: {
	                platform: "ios"
	            },
	            options: {
	                arrowPosition: {
	                    boundaryOffset: {
	                        h: 20,
	                        v: -10
	                    },
	                    collision: "fit"
	                }
	            }
	        }]
	    },
	    _init: function() {
	        this.callBase();
	        this._renderArrow();
	        this.element().addClass(POPOVER_CLASS);
	        this._wrapper().addClass(POPOVER_WRAPPER_CLASS)
	    },
	    _render: function() {
	        this.callBase.apply(this, arguments);
	        this._detachEvents(this.option("target"));
	        this._attachEvents()
	    },
	    _detachEvents: function(target) {
	        detachEvent(this, target, "show");
	        detachEvent(this, target, "hide")
	    },
	    _attachEvents: function() {
	        attachEvent(this, "show");
	        attachEvent(this, "hide")
	    },
	    _renderArrow: function() {
	        this._$arrow = $("<div>").addClass(POPOVER_ARROW_CLASS).prependTo(this.overlayContent())
	    },
	    _documentDownHandler: function(e) {
	        if (this._isOutsideClick(e)) {
	            return this.callBase(e)
	        }
	    },
	    _isOutsideClick: function(e) {
	        return !$(e.target).closest(this.option("target")).length
	    },
	    _animate: function(animation) {
	        if (animation && animation.to) {
	            $.extend(animation.to, {
	                position: this._getContainerPosition()
	            })
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _stopAnimation: function() {
	        this.callBase.apply(this, arguments)
	    },
	    _renderTitle: function() {
	        this._wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
	        this.callBase()
	    },
	    _renderPosition: function() {
	        this.callBase();
	        this._renderOverlayPosition()
	    },
	    _renderOverlayBoundaryOffset: $.noop,
	    _renderOverlayPosition: function() {
	        this._resetOverlayPosition();
	        this._updateContentSize();
	        var contentPosition = this._getContainerPosition();
	        var resultLocation = positionUtils.setup(this._$content, contentPosition);
	        var positionSide = this._getSideByLocation(resultLocation);
	        this._togglePositionClass("dx-position-" + positionSide);
	        this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
	        this._renderArrowPosition(positionSide)
	    },
	    _resetOverlayPosition: function() {
	        this._setContentHeight(true);
	        this._togglePositionClass("dx-position-" + this._positionSide);
	        translator.move(this._$content, {
	            left: 0,
	            top: 0
	        });
	        this._$arrow.css({
	            top: "auto",
	            right: "auto",
	            bottom: "auto",
	            left: "auto"
	        })
	    },
	    _updateContentSize: function() {
	        if (!this._$popupContent) {
	            return
	        }
	        var containerLocation = positionUtils.calculate(this._$content, this._getContainerPosition());
	        if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
	            var newContainerWidth = this._$content.width() - containerLocation.h.oversize;
	            this._$content.width(newContainerWidth)
	        }
	        if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
	            var newOverlayContentHeight = this._$content.height() - containerLocation.v.oversize,
	                newPopupContentHeight = this._$popupContent.height() - containerLocation.v.oversize;
	            this._$content.height(newOverlayContentHeight);
	            this._$popupContent.height(newPopupContentHeight)
	        }
	    },
	    _getContainerPosition: function() {
	        var offset = stringUtils.pairToObject(this._position.offset || "");
	        var hOffset = offset.h;
	        var vOffset = offset.v;
	        var isPopoverInside = this._isPopoverInside();
	        var sign = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
	        var arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
	        if (this._isVerticalSide()) {
	            vOffset += sign * (this._$arrow.height() - arrowSizeCorrection)
	        } else {
	            if (this._isHorizontalSide()) {
	                hOffset += sign * (this._$arrow.width() - arrowSizeCorrection)
	            }
	        }
	        return $.extend({}, this._position, {
	            offset: hOffset + " " + vOffset
	        })
	    },
	    _getContentBorderWidth: function(side) {
	        var borderWidth = this._$content.css("border-" + side + "-width");
	        return parseInt(borderWidth) || 0
	    },
	    _getSideByLocation: function(location) {
	        var isFlippedByVertical = location.v.flip;
	        var isFlippedByHorizontal = location.h.flip;
	        return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionSide] : this._positionSide
	    },
	    _togglePositionClass: function(positionClass) {
	        this._$wrapper.removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass)
	    },
	    _toggleFlippedClass: function(isFlippedHorizontal, isFlippedVertical) {
	        this._$wrapper.toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical)
	    },
	    _renderArrowPosition: function(side) {
	        this._$arrow.css(POSITION_FLIP_MAP[side], -(this._isVerticalSide(side) ? this._$arrow.height() : this._$arrow.width()));
	        var axis = this._isVerticalSide(side) ? "left" : "top";
	        var sizeProperty = this._isVerticalSide(side) ? "outerWidth" : "outerHeight";
	        var $target = $(this._position.of);
	        var targetOffset = positionUtils.offset($target) || {
	            top: 0,
	            left: 0
	        };
	        var contentOffset = positionUtils.offset(this._$content);
	        var arrowSize = this._$arrow[sizeProperty]();
	        var contentLocation = contentOffset[axis];
	        var contentSize = this._$content[sizeProperty]();
	        var targetLocation = targetOffset[axis];
	        var targetSize = $target.get(0).preventDefault ? 0 : $target[sizeProperty]();
	        var min = Math.max(contentLocation, targetLocation);
	        var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
	        var arrowLocation;
	        if ("start" === this.option("arrowPosition")) {
	            arrowLocation = min - contentLocation
	        } else {
	            if ("end" === this.option("arrowPosition")) {
	                arrowLocation = max - contentLocation - arrowSize
	            } else {
	                arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2
	            }
	        }
	        var borderWidth = this._getContentBorderWidth(side);
	        var finalArrowLocation = mathUtils.fitIntoRange(arrowLocation - borderWidth + this.option("arrowOffset"), borderWidth, contentSize - arrowSize - 2 * borderWidth);
	        this._$arrow.css(axis, finalArrowLocation)
	    },
	    _isPopoverInside: function() {
	        var position = this._getPosition();
	        var my = positionUtils.setup.normalizeAlign(position.my);
	        var at = positionUtils.setup.normalizeAlign(position.at);
	        return my.h === at.h && my.v === at.v
	    },
	    _getPosition: function() {
	        var position = this.option("position");
	        if (commonUtils.isString(position)) {
	            position = $.extend({}, POSITION_ALIASES[position])
	        }
	        return position
	    },
	    _setContentHeight: function(fullUpdate) {
	        if (fullUpdate) {
	            this.callBase()
	        }
	    },
	    _renderShadingPosition: function() {
	        if (this.option("shading")) {
	            this._$wrapper.css({
	                top: 0,
	                left: 0
	            })
	        }
	    },
	    _renderShadingDimensions: function() {
	        if (this.option("shading")) {
	            this._$wrapper.css({
	                width: "100%",
	                height: "100%"
	            })
	        }
	    },
	    _normalizePosition: function() {
	        var position = $.extend({}, this._getPosition());
	        if (!position.of) {
	            position.of = this.option("target")
	        }
	        if (!position.collision) {
	            position.collision = "flip"
	        }
	        if (!position.boundaryOffset) {
	            position.boundaryOffset = this.option("boundaryOffset")
	        }
	        this._positionSide = this._getDisplaySide(position);
	        this._position = position
	    },
	    _getDisplaySide: function(position) {
	        var my = positionUtils.setup.normalizeAlign(position.my),
	            at = positionUtils.setup.normalizeAlign(position.at);
	        var weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1,
	            horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]),
	            verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
	        return horizontalWeight > verticalWeight ? at.h : at.v
	    },
	    _isVerticalSide: function(side) {
	        side = side || this._positionSide;
	        return "top" === side || "bottom" === side
	    },
	    _isHorizontalSide: function(side) {
	        side = side || this._positionSide;
	        return "left" === side || "right" === side
	    },
	    _clean: function() {
	        this._detachEvents(this.option("target"));
	        this.callBase.apply(this, arguments)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "showTitle":
	            case "title":
	            case "titleTemplate":
	                this.callBase(args);
	                this._renderGeometry();
	                break;
	            case "boundaryOffset":
	            case "arrowPosition":
	            case "arrowOffset":
	                this._renderGeometry();
	                break;
	            case "fullScreen":
	                if (args.value) {
	                    this.option("fullScreen", false)
	                }
	                break;
	            case "target":
	                args.previousValue && this._detachEvents(args.previousValue);
	                this.callBase(args);
	                break;
	            case "showEvent":
	            case "hideEvent":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    show: function(target) {
	        if (target) {
	            this.option("target", target)
	        }
	        return this.callBase()
	    }
	});
	registerComponent("dxPopover", Popover);
	module.exports = Popover;
	module.exports.default = module.exports;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.strategy.drop_down_menu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ToolbarStrategy = __webpack_require__(176),
	    ToolbarMenu = __webpack_require__(180),
	    DropDownMenu = __webpack_require__(189);
	var DropDownMenuStrategy = ToolbarStrategy.inherit({
	    NAME: "dropDownMenu",
	    render: function() {
	        if (!this._hasVisibleMenuItems()) {
	            return
	        }
	        this._renderMenuButtonContainer();
	        this._renderWidget()
	    },
	    renderMenuItems: function() {
	        if (!this._menu) {
	            this.render()
	        }
	        this.callBase();
	        if (this._menu && !this._menu.option("items").length) {
	            this._menu.close()
	        }
	    },
	    _menuWidgetClass: function() {
	        return DropDownMenu
	    },
	    _widgetOptions: function() {
	        return $.extend(this.callBase(), {
	            deferRendering: true,
	            menuWidget: ToolbarMenu,
	            popupPosition: {
	                at: "bottom right",
	                my: "top right"
	            }
	        })
	    },
	    _getMenuItems: function() {
	        var menuItems = this.callBase();
	        this._toggleMenuVisibility(menuItems.length);
	        return menuItems
	    },
	    _toggleMenuVisibility: function(value) {
	        if (!this._menuContainer()) {
	            return
	        }
	        this._menuContainer().toggleClass("dx-state-invisible", !value)
	    },
	    _menuContainer: function() {
	        return this._$menuButtonContainer
	    }
	});
	module.exports = DropDownMenuStrategy;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.menu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    List = __webpack_require__(181);
	var TOOLBAR_MENU_ACTION_CLASS = "dx-toolbar-menu-action",
	    TOOLBAR_HIDDEN_BUTTON_CLASS = "dx-toolbar-hidden-button",
	    TOOLBAR_MENU_SECTION_CLASS = "dx-toolbar-menu-section",
	    TOOLBAR_MENU_LAST_SECTION_CLASS = "dx-toolbar-menu-last-section";
	var ToolbarMenu = List.inherit({
	    _activeStateUnit: "." + TOOLBAR_MENU_ACTION_CLASS,
	    _render: function() {
	        this._renderSections();
	        this.callBase()
	    },
	    _getSections: function() {
	        return this._itemContainer().children()
	    },
	    _itemElements: function() {
	        return this._getSections().children(this._itemSelector())
	    },
	    _renderSections: function() {
	        var that = this,
	            $container = this._itemContainer();
	        $.each(["before", "center", "after", "menu"], function() {
	            var sectionName = "_$" + this + "Section",
	                $section = that[sectionName];
	            if (!$section) {
	                that[sectionName] = $section = $("<div>").addClass(TOOLBAR_MENU_SECTION_CLASS)
	            }
	            $section.appendTo($container)
	        })
	    },
	    _renderItems: function() {
	        this.callBase.apply(this, arguments);
	        this._updateSections()
	    },
	    _updateSections: function() {
	        var $sections = this.element().find("." + TOOLBAR_MENU_SECTION_CLASS);
	        $sections.removeClass(TOOLBAR_MENU_LAST_SECTION_CLASS);
	        $sections.not(":empty").eq(-1).addClass(TOOLBAR_MENU_LAST_SECTION_CLASS)
	    },
	    _renderItem: function(index, item, itemContainer, $after) {
	        var itemElement, location = item.location || "menu",
	            $container = this["_$" + location + "Section"];
	        itemElement = this.callBase(index, item, $container, $after);
	        if (this._getItemTemplateName({
	                itemData: item
	            })) {
	            itemElement.addClass("dx-toolbar-menu-custom")
	        }
	        if ("menu" === location || "dxButton" === item.widget || item.isAction) {
	            itemElement.addClass(TOOLBAR_MENU_ACTION_CLASS)
	        }
	        if ("dxButton" === item.widget) {
	            itemElement.addClass(TOOLBAR_HIDDEN_BUTTON_CLASS)
	        }
	        return itemElement
	    },
	    _getItemTemplateName: function(args) {
	        var template = this.callBase(args);
	        var data = args.itemData,
	            menuTemplate = data && data.menuItemTemplate;
	        return menuTemplate || template
	    },
	    _itemClickHandler: function(e, args, config) {
	        if ($(e.target).closest("." + TOOLBAR_MENU_ACTION_CLASS).length) {
	            this.callBase(e, args, config)
	        }
	    },
	    _clean: function() {
	        this._getSections().empty();
	        this.callBase()
	    }
	});
	registerComponent("dxToolbarMenu", ToolbarMenu);
	module.exports = ToolbarMenu;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    compileGetter = __webpack_require__(35).compileGetter,
	    clickEvent = __webpack_require__(65),
	    swipeEvents = __webpack_require__(182),
	    support = __webpack_require__(48),
	    messageLocalization = __webpack_require__(79),
	    inkRipple = __webpack_require__(115),
	    devices = __webpack_require__(40),
	    ListItem = __webpack_require__(183),
	    Button = __webpack_require__(114),
	    eventUtils = __webpack_require__(61),
	    themes = __webpack_require__(112),
	    ScrollModule = __webpack_require__(184),
	    deviceDependentOptions = __webpack_require__(157).deviceDependentOptions,
	    CollectionWidget = __webpack_require__(117),
	    BindableTemplate = __webpack_require__(134);
	var LIST_CLASS = "dx-list",
	    LIST_ITEM_CLASS = "dx-list-item",
	    LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS,
	    LIST_GROUP_CLASS = "dx-list-group",
	    LIST_GROUP_HEADER_CLASS = "dx-list-group-header",
	    LIST_GROUP_BODY_CLASS = "dx-list-group-body",
	    LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups",
	    LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed",
	    LIST_HAS_NEXT_CLASS = "dx-has-next",
	    LIST_NEXT_BUTTON_CLASS = "dx-list-next-button",
	    LIST_ITEM_DATA_KEY = "dxListItemData",
	    LIST_FEEDBACK_SHOW_TIMEOUT = 70;
	var groupItemsGetter = compileGetter("items");
	var ListBase = CollectionWidget.inherit({
	    _activeStateUnit: LIST_ITEM_SELECTOR,
	    _supportedKeys: function() {
	        var that = this;
	        var moveFocusPerPage = function(direction) {
	            var $item = getEdgeVisibleItem(direction),
	                isFocusedItem = $item.is(that.option("focusedElement"));
	            if (isFocusedItem) {
	                scrollListTo($item, direction);
	                $item = getEdgeVisibleItem(direction)
	            }
	            that.option("focusedElement", $item);
	            that.scrollToItem($item)
	        };
	        var getEdgeVisibleItem = function(direction) {
	            var scrollTop = that.scrollTop(),
	                containerHeight = that.element().height();
	            var $item = that.option("focusedElement"),
	                isItemVisible = true;
	            if (!$item) {
	                return $()
	            }
	            while (isItemVisible) {
	                var $nextItem = $item[direction]();
	                if (!$nextItem.length) {
	                    break
	                }
	                var nextItemLocation = $nextItem.position().top + $nextItem.outerHeight() / 2;
	                isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
	                if (isItemVisible) {
	                    $item = $nextItem
	                }
	            }
	            return $item
	        };
	        var scrollListTo = function($item, direction) {
	            var resultPosition = $item.position().top;
	            if ("prev" === direction) {
	                resultPosition = $item.position().top - that.element().height() + $item.outerHeight()
	            }
	            that.scrollTo(resultPosition)
	        };
	        return $.extend(this.callBase(), {
	            leftArrow: $.noop,
	            rightArrow: $.noop,
	            pageUp: function() {
	                moveFocusPerPage("prev");
	                return false
	            },
	            pageDown: function() {
	                moveFocusPerPage("next");
	                return false
	            }
	        })
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            autoPagingEnabled: {
	                since: "15.1",
	                message: "Use the 'pageLoadMode' option instead"
	            },
	            showNextButton: {
	                since: "15.1",
	                message: "Use the 'pageLoadMode' option instead"
	            }
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            hoverStateEnabled: true,
	            pullRefreshEnabled: false,
	            scrollingEnabled: true,
	            showScrollbar: "onScroll",
	            useNativeScrolling: true,
	            bounceEnabled: true,
	            scrollByContent: true,
	            scrollByThumb: false,
	            pullingDownText: messageLocalization.format("dxList-pullingDownText"),
	            pulledDownText: messageLocalization.format("dxList-pulledDownText"),
	            refreshingText: messageLocalization.format("dxList-refreshingText"),
	            pageLoadingText: messageLocalization.format("dxList-pageLoadingText"),
	            onScroll: null,
	            onPullRefresh: null,
	            onPageLoading: null,
	            pageLoadMode: "scrollBottom",
	            nextButtonText: messageLocalization.format("dxList-nextButtonText"),
	            onItemSwipe: null,
	            grouped: false,
	            onGroupRendered: null,
	            collapsibleGroups: false,
	            groupTemplate: "group",
	            indicateLoading: true,
	            activeStateEnabled: true,
	            _itemAttributes: {
	                role: "option"
	            },
	            useInkRipple: false,
	            showChevronExpr: function(data) {
	                return data ? data.showChevron : void 0
	            },
	            badgeExpr: function(data) {
	                return data ? data.badge : void 0
	            }
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat(deviceDependentOptions(), [{
	            device: function() {
	                return !support.nativeScrolling
	            },
	            options: {
	                useNativeScrolling: false
	            }
	        }, {
	            device: function(device) {
	                return !support.nativeScrolling && !devices.isSimulator() && "generic" === devices.real().platform && "generic" === device.platform
	            },
	            options: {
	                showScrollbar: "onHover",
	                pageLoadMode: "nextButton"
	            }
	        }, {
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                useInkRipple: true
	            }
	        }, {
	            device: function() {
	                return "win" === devices.current().platform && devices.isSimulator()
	            },
	            options: {
	                bounceEnabled: false
	            }
	        }])
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._updateLoadingState(true)
	        }
	    },
	    _itemClass: function() {
	        return LIST_ITEM_CLASS
	    },
	    _itemDataKey: function() {
	        return LIST_ITEM_DATA_KEY
	    },
	    _itemContainer: function() {
	        return this._$container
	    },
	    _itemElements: function() {
	        if (!this.option("grouped")) {
	            return this._itemContainer().children(this._itemSelector())
	        }
	        return this._itemContainer().children("." + LIST_GROUP_CLASS).children("." + LIST_GROUP_BODY_CLASS).children(this._itemSelector())
	    },
	    _itemSelectHandler: function(e) {
	        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
	            return
	        }
	        this.callBase(e)
	    },
	    _allowDynamicItemsAppend: function() {
	        return true
	    },
	    _init: function() {
	        this.callBase();
	        this._$container = this.element();
	        this._initScrollView();
	        this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT;
	        this._createGroupRenderAction();
	        this.setAria("role", "listbox")
	    },
	    _dataSourceOptions: function() {
	        this._suppressDeprecatedWarnings();
	        var pagingEnabled = this.option("autoPagingEnabled");
	        pagingEnabled = commonUtils.isDefined(this.option("showNextButton")) ? pagingEnabled || this.option("showNextButton") : pagingEnabled;
	        this._resumeDeprecatedWarnings();
	        return $.extend(this.callBase(), {
	            paginate: commonUtils.isDefined(pagingEnabled) ? pagingEnabled : true
	        })
	    },
	    _initScrollView: function() {
	        this._suppressDeprecatedWarnings();
	        var scrollingEnabled = this.option("scrollingEnabled"),
	            pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled"),
	            autoPagingEnabled = scrollingEnabled && commonUtils.ensureDefined(this.option("autoPagingEnabled"), "scrollBottom" === this.option("pageLoadMode")) && !!this._dataSource;
	        this._resumeDeprecatedWarnings();
	        this._scrollView = this._createComponent(this.element(), ScrollModule.ScrollView, {
	            disabled: this.option("disabled") || !scrollingEnabled,
	            onScroll: $.proxy(this._scrollHandler, this),
	            onPullDown: pullRefreshEnabled ? $.proxy(this._pullDownHandler, this) : null,
	            onReachBottom: autoPagingEnabled ? $.proxy(this._scrollBottomHandler, this) : null,
	            showScrollbar: this.option("showScrollbar"),
	            useNative: this.option("useNativeScrolling"),
	            bounceEnabled: this.option("bounceEnabled"),
	            scrollByContent: this.option("scrollByContent"),
	            scrollByThumb: this.option("scrollByThumb"),
	            pullingDownText: this.option("pullingDownText"),
	            pulledDownText: this.option("pulledDownText"),
	            refreshingText: this.option("refreshingText"),
	            reachBottomText: this.option("pageLoadingText"),
	            useKeyboard: false
	        });
	        this._$container = this._scrollView.content();
	        this._createScrollViewActions()
	    },
	    _createScrollViewActions: function() {
	        this._scrollAction = this._createActionByOption("onScroll");
	        this._pullRefreshAction = this._createActionByOption("onPullRefresh");
	        this._pageLoadingAction = this._createActionByOption("onPageLoading")
	    },
	    _scrollHandler: function(e) {
	        this._scrollAction && this._scrollAction(e)
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.group = new BindableTemplate(function($container, data) {
	            if ($.isPlainObject(data)) {
	                if (data.key) {
	                    $container.text(data.key)
	                }
	            } else {
	                $container.html(String(data))
	            }
	        }, ["key"], this.option("integrationOptions.watchMethod"))
	    },
	    _updateLoadingState: function(tryLoadMore) {
	        this._suppressDeprecatedWarnings();
	        var isDataLoaded = !tryLoadMore || this._isLastPage(),
	            autoPagingEnabled = commonUtils.ensureDefined(this.option("autoPagingEnabled"), "scrollBottom" === this.option("pageLoadMode")),
	            stopLoading = isDataLoaded || !autoPagingEnabled,
	            hideLoadIndicator = stopLoading && !this._isDataSourceLoading();
	        this._resumeDeprecatedWarnings();
	        if (stopLoading || this._scrollViewIsFull()) {
	            this._scrollView.release(hideLoadIndicator);
	            this._toggleNextButton(this._shouldRenderNextButton() && !isDataLoaded);
	            this._loadIndicationSuppressed(false)
	        } else {
	            this._infiniteDataLoading()
	        }
	    },
	    _shouldRenderNextButton: function() {
	        this._suppressDeprecatedWarnings();
	        var result = commonUtils.ensureDefined(this.option("showNextButton"), "nextButton" === this.option("pageLoadMode")) && this._dataSource && this._dataSource.isLoaded();
	        this._resumeDeprecatedWarnings();
	        return result
	    },
	    _dataSourceLoadingChangedHandler: function(isLoading) {
	        if (this._loadIndicationSuppressed()) {
	            return
	        }
	        if (isLoading && this.option("indicateLoading")) {
	            this._showLoadingIndicatorTimer = setTimeout($.proxy(function() {
	                var isEmpty = !this._itemElements().length;
	                if (this._scrollView && !isEmpty) {
	                    this._scrollView.startLoading()
	                }
	            }, this))
	        } else {
	            clearTimeout(this._showLoadingIndicatorTimer);
	            this._scrollView && this._scrollView.finishLoading()
	        }
	    },
	    _dataSourceChangedHandler: function(newItems) {
	        if (!this._shouldAppendItems()) {
	            this._scrollView && this._scrollView.scrollTo(0)
	        }
	        this.callBase(newItems)
	    },
	    _hideLoadingIfLoadIndicationOff: function() {
	        if (!this.option("indicateLoading")) {
	            this._dataSourceLoadingChangedHandler(false)
	        }
	    },
	    _loadIndicationSuppressed: function(value) {
	        if (!arguments.length) {
	            return this._isLoadIndicationSuppressed
	        }
	        this._isLoadIndicationSuppressed = value
	    },
	    _scrollViewIsFull: function() {
	        return !this._scrollView || this._scrollView.isFull()
	    },
	    _pullDownHandler: function(e) {
	        this._pullRefreshAction(e);
	        if (this._dataSource && !this._isDataSourceLoading()) {
	            this._clearSelectedItems();
	            this._dataSource.pageIndex(0);
	            this._dataSource.load()
	        } else {
	            this._updateLoadingState()
	        }
	    },
	    _infiniteDataLoading: function() {
	        var isElementVisible = this.element().is(":visible");
	        if (isElementVisible && !this._scrollViewIsFull() && !this._isDataSourceLoading() && !this._isLastPage()) {
	            clearTimeout(this._loadNextPageTimer);
	            this._loadNextPageTimer = setTimeout($.proxy(this._loadNextPage, this))
	        }
	    },
	    _scrollBottomHandler: function(e) {
	        this._pageLoadingAction(e);
	        if (!this._isDataSourceLoading() && !this._isLastPage()) {
	            this._loadNextPage()
	        } else {
	            this._updateLoadingState()
	        }
	    },
	    _renderItems: function(items) {
	        if (this.option("grouped")) {
	            $.each(items, $.proxy(this._renderGroup, this));
	            this._attachGroupCollapseEvent();
	            this._renderEmptyMessage()
	        } else {
	            this.callBase.apply(this, arguments)
	        }
	        this._updateLoadingState(true)
	    },
	    _attachGroupCollapseEvent: function() {
	        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME),
	            selector = "." + LIST_GROUP_HEADER_CLASS,
	            $element = this.element(),
	            collapsibleGroups = this.option("collapsibleGroups");
	        $element.toggleClass(LIST_COLLAPSIBLE_GROUPS_CLASS, collapsibleGroups);
	        $element.off(eventName, selector);
	        if (collapsibleGroups) {
	            $element.on(eventName, selector, $.proxy(function(e) {
	                this._createAction($.proxy(function(e) {
	                    var $group = $(e.jQueryEvent.currentTarget).parent();
	                    this._collapseGroupHandler($group);
	                    if (this.option("focusStateEnabled")) {
	                        this.option("focusedElement", $group.find("." + LIST_ITEM_CLASS).eq(0))
	                    }
	                }, this), {
	                    validatingTargetName: "element"
	                })({
	                    jQueryEvent: e
	                })
	            }, this))
	        }
	    },
	    _collapseGroupHandler: function($group, toggle) {
	        var deferred = $.Deferred(),
	            $groupBody = $group.children("." + LIST_GROUP_BODY_CLASS);
	        $group.toggleClass(LIST_GROUP_COLLAPSED_CLASS, toggle);
	        var slideMethod = "slideToggle";
	        if (true === toggle) {
	            slideMethod = "slideUp"
	        }
	        if (false === toggle) {
	            slideMethod = "slideDown"
	        }
	        $groupBody[slideMethod]({
	            duration: 200,
	            complete: $.proxy(function() {
	                this.updateDimensions();
	                this._updateLoadingState(true);
	                deferred.resolve()
	            }, this)
	        });
	        return deferred.promise()
	    },
	    _dataSourceLoadErrorHandler: function() {
	        this._forgetNextPageLoading();
	        if (this._initialized) {
	            this._renderEmptyMessage();
	            this._updateLoadingState()
	        }
	    },
	    _render: function() {
	        this.element().addClass(LIST_CLASS);
	        this.callBase();
	        this.option("useInkRipple") && this._renderInkRipple()
	    },
	    _renderInkRipple: function() {
	        this._inkRipple = inkRipple.render()
	    },
	    _toggleActiveState: function($element, value, e) {
	        this.callBase.apply(this, arguments);
	        if (!this._inkRipple) {
	            return
	        }
	        var config = {
	            element: $element,
	            jQueryEvent: e
	        };
	        if (value) {
	            this._inkRipple.showWave(config)
	        } else {
	            this._inkRipple.hideWave(config)
	        }
	    },
	    _postprocessRenderItem: function(args) {
	        this.callBase.apply(this, arguments);
	        if (this.option("onItemSwipe")) {
	            this._attachSwipeEvent($(args.itemElement))
	        }
	    },
	    _attachSwipeEvent: function($itemElement) {
	        var endEventName = eventUtils.addNamespace(swipeEvents.end, this.NAME);
	        $itemElement.on(endEventName, $.proxy(this._itemSwipeEndHandler, this))
	    },
	    _itemSwipeEndHandler: function(e) {
	        this._itemJQueryEventHandler(e, "onItemSwipe", {
	            direction: e.offset < 0 ? "left" : "right"
	        })
	    },
	    _nextButtonHandler: function() {
	        var source = this._dataSource;
	        if (source && !source.isLoading()) {
	            this._scrollView.toggleLoading(true);
	            this._$nextButton.detach();
	            this._loadIndicationSuppressed(true);
	            this._loadNextPage()
	        }
	    },
	    _renderGroup: function(index, group) {
	        var $groupElement = $("<div>").addClass(LIST_GROUP_CLASS).appendTo(this._itemContainer());
	        var $groupHeaderElement = $("<div>").addClass(LIST_GROUP_HEADER_CLASS).appendTo($groupElement);
	        var groupTemplateName = this.option("groupTemplate"),
	            groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index, $groupHeaderElement),
	            renderArgs = {
	                index: index,
	                itemData: group,
	                container: $groupHeaderElement
	            };
	        this._createItemByTemplate(groupTemplate, renderArgs);
	        this._renderingGroupIndex = index;
	        var $groupBody = $("<div>").addClass(LIST_GROUP_BODY_CLASS).appendTo($groupElement);
	        $.each(groupItemsGetter(group) || [], $.proxy(function(index, item) {
	            this._renderItem(index, item, $groupBody)
	        }, this));
	        this._groupRenderAction({
	            groupElement: $groupElement,
	            groupIndex: index,
	            groupData: group
	        })
	    },
	    _createGroupRenderAction: function() {
	        this._groupRenderAction = this._createActionByOption("onGroupRendered")
	    },
	    _clean: function() {
	        if (this._$nextButton) {
	            this._$nextButton.remove();
	            this._$nextButton = null
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _dispose: function() {
	        clearTimeout(this._holdTimer);
	        clearTimeout(this._loadNextPageTimer);
	        clearTimeout(this._showLoadingIndicatorTimer);
	        this.callBase()
	    },
	    _toggleDisabledState: function(value) {
	        this.callBase(value);
	        this._scrollView.option("disabled", value || !this.option("scrollingEnabled"))
	    },
	    _toggleNextButton: function(value) {
	        var dataSource = this._dataSource,
	            $nextButton = this._getNextButton();
	        this.element().toggleClass(LIST_HAS_NEXT_CLASS, value);
	        if (value && dataSource && dataSource.isLoaded()) {
	            $nextButton.appendTo(this._itemContainer())
	        }
	        if (!value) {
	            $nextButton.detach()
	        }
	    },
	    _getNextButton: function() {
	        if (!this._$nextButton) {
	            this._$nextButton = this._createNextButton()
	        }
	        return this._$nextButton
	    },
	    _createNextButton: function() {
	        var $result = $("<div>").addClass(LIST_NEXT_BUTTON_CLASS);
	        var $button = $("<div>").appendTo($result);
	        this._createComponent($button, Button, {
	            text: this.option("nextButtonText"),
	            onClick: $.proxy(this._nextButtonHandler, this),
	            integrationOptions: {}
	        });
	        return $result
	    },
	    _moveFocus: function() {
	        this.callBase.apply(this, arguments);
	        this.scrollToItem(this.option("focusedElement"))
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "pageLoadMode":
	                this._toggleNextButton(args.value);
	                this._initScrollView();
	                break;
	            case "showNextButton":
	                this._toggleNextButton(args.value);
	                break;
	            case "dataSource":
	                this.callBase(args);
	                this._initScrollView();
	                break;
	            case "pullingDownText":
	            case "pulledDownText":
	            case "refreshingText":
	            case "pageLoadingText":
	            case "useNative":
	            case "showScrollbar":
	            case "bounceEnabled":
	            case "scrollByContent":
	            case "scrollByThumb":
	            case "scrollingEnabled":
	            case "pullRefreshEnabled":
	            case "autoPagingEnabled":
	                this._initScrollView();
	                this._updateLoadingState();
	                break;
	            case "nextButtonText":
	            case "onItemSwipe":
	            case "useInkRipple":
	                this._invalidate();
	                break;
	            case "onScroll":
	            case "onPullRefresh":
	            case "onPageLoading":
	                this._createScrollViewActions();
	                this._invalidate();
	                break;
	            case "grouped":
	            case "collapsibleGroups":
	            case "groupTemplate":
	                this._invalidate();
	                break;
	            case "onGroupRendered":
	                this._createGroupRenderAction();
	                break;
	            case "width":
	            case "height":
	                this.callBase(args);
	                this._scrollView.update();
	                break;
	            case "indicateLoading":
	                this._hideLoadingIfLoadIndicationOff();
	                break;
	            case "visible":
	                this.callBase(args);
	                this._scrollView.update();
	                break;
	            case "rtlEnabled":
	                this._initScrollView();
	                this.callBase(args);
	                break;
	            case "showChevronExpr":
	            case "badgeExpr":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _extendActionArgs: function($itemElement) {
	        if (!this.option("grouped")) {
	            return this.callBase($itemElement)
	        }
	        var $group = $itemElement.closest("." + LIST_GROUP_CLASS);
	        var $item = $group.find("." + LIST_ITEM_CLASS);
	        return $.extend(this.callBase($itemElement), {
	            itemIndex: {
	                group: $group.index(),
	                item: $item.index($itemElement)
	            }
	        })
	    },
	    expandGroup: function(groupIndex) {
	        var deferred = $.Deferred(),
	            $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
	        this._collapseGroupHandler($group, false).done($.proxy(function() {
	            deferred.resolveWith(this)
	        }, this));
	        return deferred.promise()
	    },
	    collapseGroup: function(groupIndex) {
	        var deferred = $.Deferred(),
	            $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
	        this._collapseGroupHandler($group, true).done($.proxy(function() {
	            deferred.resolveWith(this)
	        }, this));
	        return deferred
	    },
	    updateDimensions: function() {
	        var that = this,
	            deferred = $.Deferred();
	        if (that._scrollView) {
	            that._scrollView.update().done(function() {
	                deferred.resolveWith(that)
	            })
	        } else {
	            deferred.resolveWith(that)
	        }
	        return deferred.promise()
	    },
	    reload: function() {
	        this.scrollTo(0);
	        this._pullDownHandler()
	    },
	    repaint: function() {
	        this.scrollTo(0);
	        this.callBase()
	    },
	    scrollTop: function() {
	        return this._scrollView.scrollOffset().top
	    },
	    clientHeight: function() {
	        return this._scrollView.clientHeight()
	    },
	    scrollHeight: function() {
	        return this._scrollView.scrollHeight()
	    },
	    scrollBy: function(distance) {
	        this._scrollView.scrollBy(distance)
	    },
	    scrollTo: function(location) {
	        this._scrollView.scrollTo(location)
	    },
	    scrollToItem: function(itemElement) {
	        var $item = this._editStrategy.getItemElement(itemElement);
	        this._scrollView.scrollToElement($item)
	    }
	});
	ListBase.ItemClass = ListItem;
	module.exports = ListBase;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/swipe.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var eventUtils = __webpack_require__(61),
	    GestureEmitter = __webpack_require__(76),
	    registerEmitter = __webpack_require__(74);
	var SWIPE_START_EVENT = "dxswipestart",
	    SWIPE_EVENT = "dxswipe",
	    SWIPE_END_EVENT = "dxswipeend";
	var HorizontalStrategy = {
	    defaultItemSizeFunc: function() {
	        return this.getElement().width()
	    },
	    getBounds: function() {
	        return [this._maxLeftOffset, this._maxRightOffset]
	    },
	    calcOffsetRatio: function(e) {
	        var endEventData = eventUtils.eventData(e);
	        return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e)
	    },
	    isFastSwipe: function(e) {
	        var endEventData = eventUtils.eventData(e);
	        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time
	    }
	};
	var VerticalStrategy = {
	    defaultItemSizeFunc: function() {
	        return this.getElement().height()
	    },
	    getBounds: function() {
	        return [this._maxTopOffset, this._maxBottomOffset]
	    },
	    calcOffsetRatio: function(e) {
	        var endEventData = eventUtils.eventData(e);
	        return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e)
	    },
	    isFastSwipe: function(e) {
	        var endEventData = eventUtils.eventData(e);
	        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time
	    }
	};
	var STRATEGIES = {
	    horizontal: HorizontalStrategy,
	    vertical: VerticalStrategy
	};
	var SwipeEmitter = GestureEmitter.inherit({
	    TICK_INTERVAL: 300,
	    FAST_SWIPE_SPEED_LIMIT: 10,
	    ctor: function(element) {
	        this.callBase(element);
	        this.direction = "horizontal";
	        this.elastic = true
	    },
	    _getStrategy: function() {
	        return STRATEGIES[this.direction]
	    },
	    _defaultItemSizeFunc: function() {
	        return this._getStrategy().defaultItemSizeFunc.call(this)
	    },
	    _itemSizeFunc: function() {
	        return this.itemSizeFunc || this._defaultItemSizeFunc
	    },
	    _init: function(e) {
	        this._tickData = eventUtils.eventData(e)
	    },
	    _start: function(e) {
	        this._savedEventData = eventUtils.eventData(e);
	        e = this._fireEvent(SWIPE_START_EVENT, e);
	        if (!e.cancel) {
	            this._maxLeftOffset = e.maxLeftOffset;
	            this._maxRightOffset = e.maxRightOffset;
	            this._maxTopOffset = e.maxTopOffset;
	            this._maxBottomOffset = e.maxBottomOffset
	        }
	    },
	    _move: function(e) {
	        var strategy = this._getStrategy(),
	            moveEventData = eventUtils.eventData(e),
	            offset = strategy.calcOffsetRatio.call(this, e);
	        offset = this._fitOffset(offset, this.elastic);
	        if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
	            this._tickData = moveEventData
	        }
	        this._fireEvent(SWIPE_EVENT, e, {
	            offset: offset
	        });
	        e.preventDefault()
	    },
	    _end: function(e) {
	        var strategy = this._getStrategy(),
	            offsetRatio = strategy.calcOffsetRatio.call(this, e),
	            isFast = strategy.isFastSwipe.call(this, e),
	            startOffset = offsetRatio,
	            targetOffset = this._calcTargetOffset(offsetRatio, isFast);
	        startOffset = this._fitOffset(startOffset, this.elastic);
	        targetOffset = this._fitOffset(targetOffset, false);
	        this._fireEvent(SWIPE_END_EVENT, e, {
	            offset: startOffset,
	            targetOffset: targetOffset
	        })
	    },
	    _fitOffset: function(offset, elastic) {
	        var strategy = this._getStrategy(),
	            bounds = strategy.getBounds.call(this);
	        if (offset < -bounds[0]) {
	            return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0]
	        }
	        if (offset > bounds[1]) {
	            return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1]
	        }
	        return offset
	    },
	    _calcTargetOffset: function(offsetRatio, isFast) {
	        var result;
	        if (isFast) {
	            result = Math.ceil(Math.abs(offsetRatio));
	            if (offsetRatio < 0) {
	                result = -result
	            }
	        } else {
	            result = Math.round(offsetRatio)
	        }
	        return result
	    }
	});
	registerEmitter({
	    emitter: SwipeEmitter,
	    events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
	});
	exports.swipe = SWIPE_EVENT;
	exports.start = SWIPE_START_EVENT;
	exports.end = SWIPE_END_EVENT;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/item.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    CollectionWidgetItem = __webpack_require__(131);
	var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
	    LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
	    BADGE_CLASS = "dx-badge",
	    LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
	    LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
	var ListItem = CollectionWidgetItem.inherit({
	    _renderWatchers: function() {
	        this.callBase();
	        this._startWatcher("badge", this._renderBadge.bind(this));
	        this._startWatcher("showChevron", this._renderShowChevron.bind(this))
	    },
	    _renderBadge: function(badge) {
	        this._$element.children("." + LIST_ITEM_BADGE_CONTAINER_CLASS).remove();
	        if (!badge) {
	            return
	        }
	        var $badge = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).append($("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge));
	        var $chevron = this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).first();
	        $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element)
	    },
	    _renderShowChevron: function(showChevron) {
	        this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).remove();
	        if (!showChevron) {
	            return
	        }
	        var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS),
	            $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
	        $chevronContainer.append($chevron).appendTo(this._$element)
	    }
	});
	module.exports = ListItem;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scroll_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    messageLocalization = __webpack_require__(79),
	    registerComponent = __webpack_require__(44),
	    PullDownStrategy = __webpack_require__(185),
	    SwipeDownStrategy = __webpack_require__(186),
	    SlideDownStrategy = __webpack_require__(187),
	    SimulatedStrategy = __webpack_require__(188),
	    Scrollable = __webpack_require__(157).default,
	    LoadIndicator = __webpack_require__(150),
	    config = __webpack_require__(9),
	    LoadPanel = __webpack_require__(149);
	var SCROLLVIEW_CLASS = "dx-scrollview",
	    SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + "-content",
	    SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket",
	    SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket",
	    SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down",
	    SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom",
	    SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-indicator",
	    SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-text",
	    SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + "-loadpanel";
	var refreshStrategies = {
	    pullDown: PullDownStrategy,
	    swipeDown: SwipeDownStrategy,
	    slideDown: SlideDownStrategy,
	    simulated: SimulatedStrategy
	};
	var ScrollView = Scrollable.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            pullingDownText: messageLocalization.format("dxScrollView-pullingDownText"),
	            pulledDownText: messageLocalization.format("dxScrollView-pulledDownText"),
	            refreshingText: messageLocalization.format("dxScrollView-refreshingText"),
	            reachBottomText: messageLocalization.format("dxScrollView-reachBottomText"),
	            onPullDown: null,
	            onReachBottom: null,
	            refreshStrategy: "pullDown"
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                var realDevice = devices.real();
	                return "android" === realDevice.platform
	            },
	            options: {
	                refreshStrategy: "swipeDown"
	            }
	        }, {
	            device: function() {
	                return "win" === devices.real().platform
	            },
	            options: {
	                refreshStrategy: "slideDown"
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this._loadingIndicatorEnabled = true
	    },
	    _initMarkup: function() {
	        this.callBase();
	        this.element().addClass(SCROLLVIEW_CLASS);
	        this._initContent();
	        this._initTopPocket();
	        this._initBottomPocket();
	        this._initLoadPanel()
	    },
	    _initContent: function() {
	        var $content = $("<div>").addClass(SCROLLVIEW_CONTENT_CLASS);
	        this._$content.wrapInner($content)
	    },
	    _initTopPocket: function() {
	        var $topPocket = this._$topPocket = $("<div>").addClass(SCROLLVIEW_TOP_POCKET_CLASS),
	            $pullDown = this._$pullDown = $("<div>").addClass(SCROLLVIEW_PULLDOWN_CLASS);
	        $topPocket.append($pullDown);
	        this._$content.prepend($topPocket)
	    },
	    _initBottomPocket: function() {
	        var $bottomPocket = this._$bottomPocket = $("<div>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS),
	            $reachBottom = this._$reachBottom = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_CLASS),
	            $loadContainer = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS),
	            $loadIndicator = new LoadIndicator($("<div>")).element(),
	            $text = this._$reachBottomText = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
	        this._updateReachBottomText();
	        $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
	        $bottomPocket.append($reachBottom);
	        this._$content.append($bottomPocket)
	    },
	    _initLoadPanel: function() {
	        this._loadPanel = this._createComponent($("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.element()), LoadPanel, {
	            shading: false,
	            delay: 400,
	            message: this.option("refreshingText"),
	            position: {
	                of: this.element()
	            }
	        })
	    },
	    _updateReachBottomText: function() {
	        this._$reachBottomText.text(this.option("reachBottomText"))
	    },
	    _createStrategy: function() {
	        var strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
	        var strategyClass = refreshStrategies[strategyName];
	        if (!strategyClass) {
	            throw Error("E1030", this.option("refreshStrategy"))
	        }
	        this._strategy = new strategyClass(this);
	        this._strategy.pullDownCallbacks.add($.proxy(this._pullDownHandler, this));
	        this._strategy.releaseCallbacks.add($.proxy(this._releaseHandler, this));
	        this._strategy.reachBottomCallbacks.add($.proxy(this._reachBottomHandler, this))
	    },
	    _createActions: function() {
	        this.callBase();
	        this._pullDownAction = this._createActionByOption("onPullDown");
	        this._reachBottomAction = this._createActionByOption("onReachBottom");
	        this._refreshPocketState()
	    },
	    _refreshPocketState: function() {
	        this._pullDownEnable(this.hasActionSubscription("onPullDown") && !config().designMode);
	        this._reachBottomEnable(this.hasActionSubscription("onReachBottom") && !config().designMode)
	    },
	    on: function(eventName) {
	        this.callBase.apply(this, arguments);
	        if ("pullDown" === eventName || "reachBottom" === eventName) {
	            this._refreshPocketState()
	        }
	    },
	    _pullDownEnable: function(enabled) {
	        if (0 === arguments.length) {
	            return this._pullDownEnabled
	        }
	        this._$pullDown.toggle(enabled);
	        this._strategy.pullDownEnable(enabled);
	        this._pullDownEnabled = enabled
	    },
	    _reachBottomEnable: function(enabled) {
	        if (0 === arguments.length) {
	            return this._reachBottomEnabled
	        }
	        this._$reachBottom.toggle(enabled);
	        this._strategy.reachBottomEnable(enabled);
	        this._reachBottomEnabled = enabled
	    },
	    _pullDownHandler: function() {
	        this._loadingIndicator(false);
	        this._pullDownLoading()
	    },
	    _loadingIndicator: function(value) {
	        if (arguments.length < 1) {
	            return this._loadingIndicatorEnabled
	        }
	        this._loadingIndicatorEnabled = value
	    },
	    _pullDownLoading: function() {
	        this.startLoading();
	        this._pullDownAction()
	    },
	    _reachBottomHandler: function() {
	        this._loadingIndicator(false);
	        this._reachBottomLoading()
	    },
	    _reachBottomLoading: function() {
	        this.startLoading();
	        this._reachBottomAction()
	    },
	    _releaseHandler: function() {
	        this.finishLoading();
	        this._loadingIndicator(true)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "onPullDown":
	            case "onReachBottom":
	                this._createActions();
	                break;
	            case "pullingDownText":
	            case "pulledDownText":
	            case "refreshingText":
	            case "refreshStrategy":
	                this._invalidate();
	                break;
	            case "reachBottomText":
	                this._updateReachBottomText();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    isEmpty: function() {
	        return !this.content().children().length
	    },
	    content: function() {
	        return this._$content.children().eq(1)
	    },
	    release: function(preventReachBottom) {
	        if (void 0 !== preventReachBottom) {
	            this.toggleLoading(!preventReachBottom)
	        }
	        return this._strategy.release()
	    },
	    toggleLoading: function(showOrHide) {
	        this._reachBottomEnable(showOrHide)
	    },
	    isFull: function() {
	        return this.content().height() > this._$container.height()
	    },
	    refresh: function() {
	        if (!this.hasActionSubscription("onPullDown")) {
	            return
	        }
	        this._strategy.pendingRelease();
	        this._pullDownLoading()
	    },
	    startLoading: function() {
	        if (this._loadingIndicator() && this.element().is(":visible")) {
	            this._loadPanel.show()
	        }
	        this._lock()
	    },
	    finishLoading: function() {
	        this._loadPanel.hide();
	        this._unlock()
	    },
	    _dispose: function() {
	        this._strategy.dispose();
	        this.callBase();
	        if (this._loadPanel) {
	            this._loadPanel.element().remove()
	        }
	    }
	});
	registerComponent("dxScrollView", ScrollView);
	exports.ScrollView = ScrollView;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scroll_view.native.pull_down.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    translator = __webpack_require__(59),
	    NativeStrategy = __webpack_require__(162),
	    LoadIndicator = __webpack_require__(150);
	var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
	    SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
	    SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
	    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
	    SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
	    STATE_RELEASED = 0,
	    STATE_READY = 1,
	    STATE_REFRESHING = 2,
	    STATE_LOADING = 3;
	var PullDownNativeScrollViewStrategy = NativeStrategy.inherit({
	    _init: function(scrollView) {
	        this.callBase(scrollView);
	        this._$topPocket = scrollView._$topPocket;
	        this._$pullDown = scrollView._$pullDown;
	        this._$bottomPocket = scrollView._$bottomPocket;
	        this._$refreshingText = scrollView._$refreshingText;
	        this._$scrollViewContent = scrollView.content();
	        this._initCallbacks()
	    },
	    _initCallbacks: function() {
	        this.pullDownCallbacks = $.Callbacks();
	        this.releaseCallbacks = $.Callbacks();
	        this.reachBottomCallbacks = $.Callbacks()
	    },
	    render: function() {
	        this.callBase();
	        this._renderPullDown();
	        this._releaseState()
	    },
	    _renderPullDown: function() {
	        var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
	            $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
	            $loadIndicator = new LoadIndicator($("<div>")).element(),
	            $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
	        this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
	        this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
	        this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
	        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
	    },
	    _releaseState: function() {
	        this._state = STATE_RELEASED;
	        this._refreshPullDownText()
	    },
	    _pushBackFromBoundary: function() {
	        if (!this._isLocked() && !this._component.isEmpty()) {
	            this.callBase()
	        }
	    },
	    _refreshPullDownText: function() {
	        this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
	        this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
	        this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
	    },
	    update: function() {
	        this.callBase();
	        this._setTopPocketOffset()
	    },
	    _updateDimensions: function() {
	        this.callBase();
	        this._topPocketSize = this._$topPocket.height();
	        this._bottomPocketSize = this._$bottomPocket.height();
	        this._scrollOffset = this._$container.height() - this._$content.height()
	    },
	    _allowedDirections: function() {
	        var allowedDirections = this.callBase();
	        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
	        return allowedDirections
	    },
	    _setTopPocketOffset: function() {
	        this._$topPocket.css({
	            top: -this._topPocketSize
	        })
	    },
	    handleEnd: function() {
	        this.callBase();
	        this._complete()
	    },
	    handleStop: function() {
	        this.callBase();
	        this._complete()
	    },
	    _complete: function() {
	        if (this._state === STATE_READY) {
	            this._setPullDownOffset(this._topPocketSize);
	            clearTimeout(this._pullDownRefreshTimeout);
	            this._pullDownRefreshTimeout = setTimeout($.proxy(function() {
	                this._pullDownRefreshing()
	            }, this), 400)
	        }
	    },
	    _setPullDownOffset: function(offset) {
	        translator.move(this._$topPocket, {
	            top: offset
	        });
	        translator.move(this._$scrollViewContent, {
	            top: offset
	        })
	    },
	    handleScroll: function(e) {
	        this.callBase(e);
	        if (this._state === STATE_REFRESHING) {
	            return
	        }
	        this._location = this.location().top;
	        if (this._isPullDown()) {
	            this._pullDownReady()
	        } else {
	            if (this._isReachBottom()) {
	                this._reachBottom()
	            } else {
	                this._stateReleased()
	            }
	        }
	    },
	    _isPullDown: function() {
	        return this._pullDownEnabled && this._location >= this._topPocketSize
	    },
	    _isReachBottom: function() {
	        return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
	    },
	    _reachBottom: function() {
	        if (this._state === STATE_LOADING) {
	            return
	        }
	        this._state = STATE_LOADING;
	        this.reachBottomCallbacks.fire()
	    },
	    _pullDownReady: function() {
	        if (this._state === STATE_READY) {
	            return
	        }
	        this._state = STATE_READY;
	        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
	        this._refreshPullDownText()
	    },
	    _stateReleased: function() {
	        if (this._state === STATE_RELEASED) {
	            return
	        }
	        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
	        this._releaseState()
	    },
	    _pullDownRefreshing: function() {
	        if (this._state === STATE_REFRESHING) {
	            return
	        }
	        this._state = STATE_REFRESHING;
	        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
	        this._refreshPullDownText();
	        this.pullDownCallbacks.fire()
	    },
	    pullDownEnable: function(enabled) {
	        if (enabled) {
	            this._updateDimensions();
	            this._setTopPocketOffset()
	        }
	        this._pullDownEnabled = enabled
	    },
	    reachBottomEnable: function(enabled) {
	        this._reachBottomEnabled = enabled
	    },
	    pendingRelease: function() {
	        this._state = STATE_READY
	    },
	    release: function() {
	        var deferred = $.Deferred();
	        this._updateDimensions();
	        clearTimeout(this._releaseTimeout);
	        this._releaseTimeout = setTimeout($.proxy(function() {
	            this._setPullDownOffset(0);
	            this._stateReleased();
	            this.releaseCallbacks.fire();
	            this._updateAction();
	            deferred.resolve()
	        }, this), 400);
	        return deferred.promise()
	    },
	    dispose: function() {
	        clearTimeout(this._pullDownRefreshTimeout);
	        clearTimeout(this._releaseTimeout);
	        this.callBase()
	    }
	});
	module.exports = PullDownNativeScrollViewStrategy;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scroll_view.native.swipe_down.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    translator = __webpack_require__(59),
	    eventUtils = __webpack_require__(61),
	    NativeStrategy = __webpack_require__(162),
	    LoadIndicator = __webpack_require__(150);
	var SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = "dx-scrollview-pull-down-loading",
	    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
	    SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-refreshing",
	    PULLDOWN_ICON_CLASS = "dx-icon-pulldown",
	    STATE_RELEASED = 0,
	    STATE_READY = 1,
	    STATE_REFRESHING = 2,
	    STATE_TOUCHED = 4,
	    STATE_PULLED = 5;
	var SwipeDownNativeScrollViewStrategy = NativeStrategy.inherit({
	    _init: function(scrollView) {
	        this.callBase(scrollView);
	        this._$topPocket = scrollView._$topPocket;
	        this._$bottomPocket = scrollView._$bottomPocket;
	        this._$pullDown = scrollView._$pullDown;
	        this._$scrollViewContent = scrollView.content();
	        this._initCallbacks();
	        this._location = 0
	    },
	    _initCallbacks: function() {
	        this.pullDownCallbacks = $.Callbacks();
	        this.releaseCallbacks = $.Callbacks();
	        this.reachBottomCallbacks = $.Callbacks()
	    },
	    render: function() {
	        this.callBase();
	        this._renderPullDown();
	        this._releaseState()
	    },
	    _renderPullDown: function() {
	        var $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
	            $loadIndicator = new LoadIndicator($("<div>")).element();
	        this._$icon = $("<div>").addClass(PULLDOWN_ICON_CLASS);
	        this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator))
	    },
	    _releaseState: function() {
	        this._state = STATE_RELEASED;
	        this._releasePullDown();
	        this._updateDimensions()
	    },
	    _releasePullDown: function() {
	        this._$pullDown.css({
	            opacity: 0
	        })
	    },
	    _updateDimensions: function() {
	        this.callBase();
	        this._topPocketSize = this._$topPocket.height();
	        this._bottomPocketSize = this._$bottomPocket.height();
	        this._scrollOffset = this._$container.height() - this._$content.height()
	    },
	    _allowedDirections: function() {
	        var allowedDirections = this.callBase();
	        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
	        return allowedDirections
	    },
	    handleInit: function(e) {
	        this.callBase(e);
	        if (this._state === STATE_RELEASED && 0 === this._location) {
	            this._startClientY = eventUtils.eventData(e.originalEvent).y;
	            this._state = STATE_TOUCHED
	        }
	    },
	    handleMove: function(e) {
	        this.callBase(e);
	        this._deltaY = eventUtils.eventData(e.originalEvent).y - this._startClientY;
	        if (this._state === STATE_TOUCHED) {
	            if (this._pullDownEnabled && this._deltaY > 0) {
	                this._state = STATE_PULLED
	            } else {
	                this._complete()
	            }
	        }
	        if (this._state === STATE_PULLED) {
	            e.preventDefault();
	            this._movePullDown()
	        }
	    },
	    _movePullDown: function() {
	        var pullDownHeight = this._getPullDownHeight(),
	            top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition()),
	            angle = 180 * top / pullDownHeight / 3;
	        this._$pullDown.css({
	            opacity: 1
	        }).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS, top < pullDownHeight);
	        translator.move(this._$pullDown, {
	            top: top
	        });
	        this._$icon.css({
	            transform: "rotate(" + angle + "deg)"
	        })
	    },
	    _isPullDown: function() {
	        return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition()
	    },
	    _getPullDownHeight: function() {
	        return Math.round(.05 * this._$element.outerHeight())
	    },
	    _getPullDownStartPosition: function() {
	        return -Math.round(1.5 * this._$pullDown.outerHeight())
	    },
	    handleEnd: function() {
	        if (this._isPullDown()) {
	            this._pullDownRefreshing()
	        }
	        this._complete()
	    },
	    handleStop: function() {
	        this._complete()
	    },
	    _complete: function() {
	        if (this._state === STATE_TOUCHED || this._state === STATE_PULLED) {
	            this._releaseState()
	        }
	    },
	    handleScroll: function(e) {
	        this.callBase(e);
	        if (this._state === STATE_REFRESHING) {
	            return
	        }
	        var currentLocation = this.location().top,
	            scrollDelta = this._location - currentLocation;
	        this._location = currentLocation;
	        if (scrollDelta > 0 && this._isReachBottom()) {
	            this._reachBottom()
	        } else {
	            this._stateReleased()
	        }
	    },
	    _isReachBottom: function() {
	        return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
	    },
	    _reachBottom: function() {
	        this.reachBottomCallbacks.fire()
	    },
	    _stateReleased: function() {
	        if (this._state === STATE_RELEASED) {
	            return
	        }
	        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
	        this._releaseState()
	    },
	    _pullDownRefreshing: function() {
	        this._state = STATE_REFRESHING;
	        this._pullDownRefreshHandler()
	    },
	    _pullDownRefreshHandler: function() {
	        this._refreshPullDown();
	        this.pullDownCallbacks.fire()
	    },
	    _refreshPullDown: function() {
	        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
	        translator.move(this._$pullDown, {
	            top: this._getPullDownHeight()
	        })
	    },
	    pullDownEnable: function(enabled) {
	        this._$topPocket.toggle(enabled);
	        this._pullDownEnabled = enabled
	    },
	    reachBottomEnable: function(enabled) {
	        this._reachBottomEnabled = enabled
	    },
	    pendingRelease: function() {
	        this._state = STATE_READY
	    },
	    release: function() {
	        var deferred = $.Deferred();
	        this._updateDimensions();
	        clearTimeout(this._releaseTimeout);
	        this._releaseTimeout = setTimeout($.proxy(function() {
	            this._stateReleased();
	            this.releaseCallbacks.fire();
	            this._updateAction();
	            deferred.resolve()
	        }, this), 800);
	        return deferred.promise()
	    },
	    dispose: function() {
	        clearTimeout(this._pullDownRefreshTimeout);
	        clearTimeout(this._releaseTimeout);
	        this.callBase()
	    }
	});
	module.exports = SwipeDownNativeScrollViewStrategy;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scroll_view.native.slide_down.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    NativeStrategy = __webpack_require__(162);
	var STATE_RELEASED = 0,
	    STATE_READY = 1,
	    STATE_LOADING = 2,
	    LOADING_HEIGHT = 80;
	var SlideDownNativeScrollViewStrategy = NativeStrategy.inherit({
	    _init: function(scrollView) {
	        this.callBase(scrollView);
	        this._$topPocket = scrollView._$topPocket;
	        this._$bottomPocket = scrollView._$bottomPocket;
	        this._initCallbacks()
	    },
	    _initCallbacks: function() {
	        this.pullDownCallbacks = $.Callbacks();
	        this.releaseCallbacks = $.Callbacks();
	        this.reachBottomCallbacks = $.Callbacks()
	    },
	    render: function() {
	        this.callBase();
	        this._renderPullDown();
	        this._renderBottom();
	        this._releaseState();
	        this._updateDimensions()
	    },
	    _renderPullDown: function() {
	        this._$topPocket.empty()
	    },
	    _renderBottom: function() {
	        this._$bottomPocket.empty().append("<progress>")
	    },
	    _releaseState: function() {
	        if (this._state === STATE_RELEASED) {
	            return
	        }
	        this._state = STATE_RELEASED
	    },
	    _updateDimensions: function() {
	        this._scrollOffset = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
	        this._containerSize = {
	            height: this._$container.prop("clientHeight"),
	            width: this._$container.prop("clientWidth")
	        };
	        this._contentSize = this._componentContentSize = {
	            height: this._$container.prop("scrollHeight"),
	            width: this._$container.prop("scrollWidth")
	        }
	    },
	    handleScroll: function(e) {
	        this.callBase(e);
	        if (this._isReachBottom(this._lastLocation.top)) {
	            this._reachBottom()
	        }
	    },
	    _isReachBottom: function(location) {
	        this._scrollContent = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
	        return this._reachBottomEnabled && location < -this._scrollContent + LOADING_HEIGHT
	    },
	    _reachBottom: function() {
	        if (this._state === STATE_LOADING) {
	            return
	        }
	        this._state = STATE_LOADING;
	        this.reachBottomCallbacks.fire()
	    },
	    pullDownEnable: function(enabled) {
	        this._pullDownEnabled = enabled
	    },
	    reachBottomEnable: function(enabled) {
	        this._reachBottomEnabled = enabled;
	        this._$bottomPocket.toggle(enabled)
	    },
	    pendingRelease: function() {
	        this._state = STATE_READY
	    },
	    release: function() {
	        var deferred = $.Deferred();
	        this._state = STATE_RELEASED;
	        this.releaseCallbacks.fire();
	        this.update();
	        return deferred.resolve().promise()
	    }
	});
	module.exports = SlideDownNativeScrollViewStrategy;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/scroll_view/ui.scroll_view.simulated.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    math = Math,
	    simulatedStrategy = __webpack_require__(159),
	    LoadIndicator = __webpack_require__(150);
	var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
	    SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
	    SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
	    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
	    SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
	    STATE_RELEASED = 0,
	    STATE_READY = 1,
	    STATE_REFRESHING = 2,
	    STATE_LOADING = 3;
	var ScrollViewScroller = simulatedStrategy.Scroller.inherit({
	    ctor: function() {
	        this._topPocketSize = 0;
	        this.callBase.apply(this, arguments);
	        this._initCallbacks();
	        this._releaseState()
	    },
	    _releaseState: function() {
	        this._state = STATE_RELEASED;
	        this._refreshPullDownText()
	    },
	    _refreshPullDownText: function() {
	        this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
	        this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
	        this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
	    },
	    _initCallbacks: function() {
	        this.pullDownCallbacks = $.Callbacks();
	        this.releaseCallbacks = $.Callbacks();
	        this.reachBottomCallbacks = $.Callbacks()
	    },
	    _updateBounds: function() {
	        var considerPockets = "horizontal" !== this._direction;
	        this._topPocketSize = considerPockets ? this._$topPocket[this._dimension]() : 0;
	        this._bottomPocketSize = considerPockets ? this._$bottomPocket[this._dimension]() : 0;
	        this.callBase();
	        this._bottomBound = this._minOffset + this._bottomPocketSize
	    },
	    _updateScrollbar: function() {
	        this._scrollbar.option({
	            containerSize: this._containerSize(),
	            contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize
	        })
	    },
	    _moveContent: function() {
	        this.callBase();
	        if (this._isPullDown()) {
	            this._pullDownReady()
	        } else {
	            if (this._isReachBottom()) {
	                this._reachBottomReady()
	            } else {
	                if (this._state !== STATE_RELEASED) {
	                    this._stateReleased()
	                }
	            }
	        }
	    },
	    _moveScrollbar: function() {
	        this._scrollbar.moveTo(this._topPocketSize + this._location)
	    },
	    _isPullDown: function() {
	        return this._pullDownEnabled && this._location >= 0
	    },
	    _isReachBottom: function() {
	        return this._reachBottomEnabled && this._location <= this._bottomBound
	    },
	    _scrollComplete: function() {
	        if (this._inBounds() && this._state === STATE_READY) {
	            this._pullDownRefreshing()
	        } else {
	            if (this._inBounds() && this._state === STATE_LOADING) {
	                this._reachBottomLoading()
	            } else {
	                this.callBase()
	            }
	        }
	    },
	    _reachBottomReady: function() {
	        if (this._state === STATE_LOADING) {
	            return
	        }
	        this._state = STATE_LOADING;
	        this._minOffset = this._getMinOffset()
	    },
	    _getMaxOffset: function() {
	        return -this._topPocketSize
	    },
	    _getMinOffset: function() {
	        return math.min(this.callBase(), -this._topPocketSize)
	    },
	    _reachBottomLoading: function() {
	        this.reachBottomCallbacks.fire()
	    },
	    _pullDownReady: function() {
	        if (this._state === STATE_READY) {
	            return
	        }
	        this._state = STATE_READY;
	        this._maxOffset = 0;
	        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
	        this._refreshPullDownText()
	    },
	    _stateReleased: function() {
	        if (this._state === STATE_RELEASED) {
	            return
	        }
	        this._releaseState();
	        this._updateBounds();
	        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
	        this.releaseCallbacks.fire()
	    },
	    _pullDownRefreshing: function() {
	        if (this._state === STATE_REFRESHING) {
	            return
	        }
	        this._state = STATE_REFRESHING;
	        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
	        this._refreshPullDownText();
	        this.pullDownCallbacks.fire()
	    },
	    _releaseHandler: function() {
	        if (this._state === STATE_RELEASED) {
	            this._moveToBounds()
	        }
	        this._update();
	        if (this._releaseTask) {
	            this._releaseTask.abort()
	        }
	        this._releaseTask = commonUtils.executeAsync($.proxy(this._release, this));
	        return this._releaseTask.promise
	    },
	    _release: function() {
	        this._stateReleased();
	        this._scrollComplete()
	    },
	    _reachBottomEnablingHandler: function(enabled) {
	        if (this._reachBottomEnabled === enabled) {
	            return
	        }
	        this._reachBottomEnabled = enabled;
	        this._updateBounds()
	    },
	    _pullDownEnablingHandler: function(enabled) {
	        if (this._pullDownEnabled === enabled) {
	            return
	        }
	        this._pullDownEnabled = enabled;
	        this._considerTopPocketChange();
	        this._updateHandler()
	    },
	    _considerTopPocketChange: function() {
	        this._location -= this._$topPocket.height() || -this._topPocketSize;
	        this._maxOffset = 0;
	        this._move()
	    },
	    _pendingReleaseHandler: function() {
	        this._state = STATE_READY
	    },
	    dispose: function() {
	        if (this._releaseTask) {
	            this._releaseTask.abort()
	        }
	        this.callBase()
	    }
	});
	var SimulatedScrollViewStrategy = simulatedStrategy.SimulatedStrategy.inherit({
	    _init: function(scrollView) {
	        this.callBase(scrollView);
	        this._$pullDown = scrollView._$pullDown;
	        this._$topPocket = scrollView._$topPocket;
	        this._$bottomPocket = scrollView._$bottomPocket;
	        this._initCallbacks()
	    },
	    _initCallbacks: function() {
	        this.pullDownCallbacks = $.Callbacks();
	        this.releaseCallbacks = $.Callbacks();
	        this.reachBottomCallbacks = $.Callbacks()
	    },
	    render: function() {
	        this._renderPullDown();
	        this.callBase()
	    },
	    _renderPullDown: function() {
	        var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
	            $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
	            $loadIndicator = new LoadIndicator($("<div>")).element(),
	            $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
	        this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
	        this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
	        this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
	        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
	    },
	    pullDownEnable: function(enabled) {
	        this._eventHandler("pullDownEnabling", enabled)
	    },
	    reachBottomEnable: function(enabled) {
	        this._eventHandler("reachBottomEnabling", enabled)
	    },
	    _createScroller: function(direction) {
	        var that = this;
	        var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
	        scroller.pullDownCallbacks.add(function() {
	            that.pullDownCallbacks.fire()
	        });
	        scroller.releaseCallbacks.add(function() {
	            that.releaseCallbacks.fire()
	        });
	        scroller.reachBottomCallbacks.add(function() {
	            that.reachBottomCallbacks.fire()
	        })
	    },
	    _scrollerOptions: function(direction) {
	        return $.extend(this.callBase(direction), {
	            $topPocket: this._$topPocket,
	            $bottomPocket: this._$bottomPocket,
	            $pullDown: this._$pullDown,
	            $pullDownText: this._$pullDownText,
	            $pullingDownText: this._$pullingDownText,
	            $pulledDownText: this._$pulledDownText,
	            $refreshingText: this._$refreshingText
	        })
	    },
	    pendingRelease: function() {
	        this._eventHandler("pendingRelease")
	    },
	    release: function() {
	        return this._eventHandler("release").done(this._updateAction)
	    },
	    location: function() {
	        var location = this.callBase();
	        location.top += this._$topPocket.height();
	        return location
	    },
	    dispose: function() {
	        $.each(this._scrollers, function() {
	            this.dispose()
	        });
	        this.callBase()
	    }
	});
	module.exports = SimulatedScrollViewStrategy;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/drop_down_menu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    Widget = __webpack_require__(84),
	    Button = __webpack_require__(114),
	    Popover = __webpack_require__(178),
	    DataHelperMixin = __webpack_require__(120),
	    List = __webpack_require__(190),
	    ChildDefaultTemplate = __webpack_require__(89);
	var DROP_DOWN_MENU_CLASS = "dx-dropdownmenu",
	    DROP_DOWN_MENU_POPUP_CLASS = "dx-dropdownmenu-popup",
	    DROP_DOWN_MENU_POPUP_WRAPPER_CLASS = "dx-dropdownmenu-popup-wrapper",
	    DROP_DOWN_MENU_LIST_CLASS = "dx-dropdownmenu-list",
	    DROP_DOWN_MENU_BUTTON_CLASS = "dx-dropdownmenu-button";
	var POPUP_OPTION_MAP = {
	    popupWidth: "width",
	    popupHeight: "height"
	};
	var BUTTON_OPTION_MAP = {
	    buttonIcon: "icon",
	    buttonText: "text",
	    buttonWidth: "width",
	    buttonHeight: "height",
	    buttonTemplate: "template"
	};
	var DropDownMenu = Widget.inherit({
	    _supportedKeys: function() {
	        var extension = {};
	        if (!this.option("opened") || !this._list.option("focusedElement")) {
	            extension = this._button._supportedKeys()
	        }
	        return $.extend(this.callBase(), extension, {
	            tab: function() {
	                this._popup.hide()
	            }
	        })
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            buttonIconSrc: {
	                since: "15.1",
	                alias: "buttonIcon"
	            }
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            items: [],
	            onItemClick: null,
	            dataSource: null,
	            itemTemplate: "item",
	            buttonText: "",
	            buttonIcon: "overflow",
	            buttonWidth: void 0,
	            buttonHeight: void 0,
	            buttonTemplate: "content",
	            onButtonClick: null,
	            usePopover: false,
	            popupWidth: "auto",
	            popupHeight: "auto",
	            activeStateEnabled: true,
	            hoverStateEnabled: true,
	            opened: false,
	            deferRendering: false,
	            popupPosition: {
	                my: "top center",
	                at: "bottom center",
	                collision: "fit flip",
	                offset: {
	                    v: 1
	                }
	            },
	            popupAnimation: void 0,
	            onItemRendered: null,
	            menuWidget: List
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: [{
	                platform: "ios"
	            }],
	            options: {
	                usePopover: true
	            }
	        }, {
	            device: [{
	                platform: "generic"
	            }],
	            options: {
	                popupPosition: {
	                    offset: {
	                        v: 4
	                    }
	                }
	            }
	        }, {
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }, {
	            device: [{
	                platform: "android"
	            }],
	            options: {
	                popupPosition: {
	                    my: "top " + (this.option("rtlEnabled") ? "left" : "right"),
	                    at: "top " + (this.option("rtlEnabled") ? "left" : "right"),
	                    collision: "flipfit"
	                },
	                popupAnimation: {
	                    show: {
	                        type: "pop",
	                        duration: 200,
	                        from: {
	                            scale: 0
	                        },
	                        to: {
	                            scale: 1
	                        }
	                    },
	                    hide: {
	                        type: "pop",
	                        duration: 200,
	                        from: {
	                            scale: 1
	                        },
	                        to: {
	                            scale: 0
	                        }
	                    }
	                }
	            }
	        }])
	    },
	    _initOptions: function(options) {
	        if ("android" === devices.current().platform) {
	            if (!options.popupPosition) {
	                options.popupPosition = {
	                    at: (options.usePopover ? "bottom " : "top ") + (options.rtlEnabled ? "left" : "right")
	                }
	            }
	        }
	        this.callBase(options)
	    },
	    _dataSourceOptions: function() {
	        return {
	            paginate: false
	        }
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(DROP_DOWN_MENU_CLASS);
	        this._initDataSource();
	        this._initItemClickAction();
	        this._initButtonClickAction()
	    },
	    _initItemClickAction: function() {
	        this._itemClickAction = this._createActionByOption("onItemClick")
	    },
	    _initButtonClickAction: function() {
	        this._buttonClickAction = this._createActionByOption("onButtonClick")
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.item = new ChildDefaultTemplate("item", this);
	        this._defaultTemplates.content = new ChildDefaultTemplate("content", this)
	    },
	    _render: function() {
	        this._renderButton();
	        this.callBase();
	        this.setAria({
	            role: "menubar",
	            haspopup: true,
	            expanded: this.option("opened")
	        })
	    },
	    _renderContentImpl: function() {
	        if (this.option("opened")) {
	            this._renderPopup()
	        }
	    },
	    _clean: function() {
	        this._cleanFocusState();
	        if (this._popup) {
	            this._popup.element().remove();
	            delete this._$popup
	        }
	    },
	    _renderButton: function() {
	        var $button = this.element().addClass(DROP_DOWN_MENU_BUTTON_CLASS),
	            config = this._buttonOptions();
	        this._button = this._createComponent($button, Button, config)
	    },
	    _buttonOptions: function() {
	        return {
	            text: this.option("buttonText"),
	            icon: this.option("buttonIcon"),
	            width: this.option("buttonWidth"),
	            height: this.option("buttonHeight"),
	            template: this.option("buttonTemplate"),
	            focusStateEnabled: false,
	            onClick: $.proxy(function(e) {
	                this.option("opened", !this.option("opened"));
	                this._buttonClickAction(e)
	            }, this)
	        }
	    },
	    _toggleMenuVisibility: function(opened) {
	        var state = void 0 === opened ? !this._popup.option("visible") : opened;
	        if (opened) {
	            this._renderPopup()
	        }
	        this._popup.toggle(state);
	        this.setAria("expanded", state)
	    },
	    _renderPopup: function() {
	        if (this._$popup) {
	            return
	        }
	        var $popup = this._$popup = $("<div>").appendTo(this.element()),
	            config = this._popupOptions();
	        this._popup = this._createComponent($popup, Popover, config)
	    },
	    _popupOptions: function() {
	        var usePopup = !this.option("usePopover");
	        return {
	            onInitialized: function(args) {
	                args.component._wrapper().addClass(DROP_DOWN_MENU_POPUP_WRAPPER_CLASS).toggleClass(DROP_DOWN_MENU_POPUP_CLASS, usePopup)
	            },
	            visible: this.option("opened"),
	            onContentReady: $.proxy(this._popupContentReadyHandler, this),
	            deferRendering: false,
	            position: this.option("popupPosition"),
	            animation: this.option("popupAnimation"),
	            onOptionChanged: $.proxy(function(args) {
	                if ("visible" === args.name) {
	                    this.option("opened", args.value)
	                }
	            }, this),
	            target: this.element(),
	            height: this.option("popupHeight"),
	            width: this.option("popupWidth")
	        }
	    },
	    _popupContentReadyHandler: function() {
	        var popup = Popover.getInstance(this._$popup);
	        this._renderList(popup)
	    },
	    _renderList: function(instance) {
	        var $content = instance.content(),
	            listConfig = this._listOptions();
	        $content.addClass(DROP_DOWN_MENU_LIST_CLASS);
	        this._list = this._createComponent($content, this.option("menuWidget"), listConfig);
	        this._list._getAriaTarget = $.proxy(function() {
	            return this.element()
	        }, this);
	        this._setListDataSource();
	        var listMaxHeight = .5 * $(window).height();
	        if ($content.height() > listMaxHeight) {
	            $content.height(listMaxHeight)
	        }
	    },
	    _listOptions: function() {
	        return {
	            _keyboardProcessor: this._listProcessor,
	            pageLoadMode: "scrollBottom",
	            indicateLoading: false,
	            noDataText: "",
	            itemTemplate: this._getTemplateByOption("itemTemplate"),
	            onItemClick: $.proxy(function(e) {
	                this.option("opened", false);
	                this._itemClickAction(e)
	            }, this),
	            tabIndex: -1,
	            focusStateEnabled: this.option("focusStateEnabled"),
	            activeStateEnabled: this.option("activeStateEnabled"),
	            onItemRendered: this.option("onItemRendered"),
	            _itemAttributes: {
	                role: "menuitem"
	            }
	        }
	    },
	    _setListDataSource: function() {
	        if (this._list) {
	            this._list.option("dataSource", this._dataSource || this.option("items"))
	        }
	        delete this._deferRendering
	    },
	    _attachKeyboardEvents: function() {
	        this.callBase.apply(this, arguments);
	        this._listProcessor = this._keyboardProcessor.attachChildProcessor();
	        if (this._list) {
	            this._list.option("_keyboardProcessor", this._listProcessor)
	        }
	    },
	    _cleanFocusState: function() {
	        this.callBase.apply(this, arguments);
	        delete this._listProcessor
	    },
	    _toggleVisibility: function(visible) {
	        this.callBase(visible);
	        this._button.option("visible", visible)
	    },
	    _optionChanged: function(args) {
	        var name = args.name;
	        var value = args.value;
	        switch (name) {
	            case "items":
	            case "dataSource":
	                if (this.option("deferRendering") && !this.option("opened")) {
	                    this._deferRendering = true
	                } else {
	                    this._refreshDataSource();
	                    this._setListDataSource()
	                }
	                break;
	            case "itemTemplate":
	                if (this._list) {
	                    this._list.option(name, this._getTemplate(value))
	                }
	                break;
	            case "onItemClick":
	                this._initItemClickAction();
	                break;
	            case "onButtonClick":
	                this._buttonClickAction();
	                break;
	            case "buttonIcon":
	            case "buttonText":
	            case "buttonWidth":
	            case "buttonHeight":
	            case "buttonTemplate":
	                this._button.option(BUTTON_OPTION_MAP[name], value);
	                this._renderPopup();
	                break;
	            case "popupWidth":
	            case "popupHeight":
	                this._popup.option(POPUP_OPTION_MAP[name], value);
	                break;
	            case "usePopover":
	            case "menuWidget":
	                this._invalidate();
	                break;
	            case "focusStateEnabled":
	            case "activeStateEnabled":
	                if (this._list) {
	                    this._list.option(name, value)
	                }
	                this.callBase(args);
	                break;
	            case "onItemRendered":
	                if (this._list) {
	                    this._list.option(name, value)
	                }
	                break;
	            case "opened":
	                if (this._deferRendering) {
	                    this._refreshDataSource();
	                    this._setListDataSource()
	                }
	                this._toggleMenuVisibility(value);
	                break;
	            case "deferRendering":
	            case "popupPosition":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    open: function() {
	        this.option("opened", true)
	    },
	    close: function() {
	        this.option("opened", false)
	    }
	}).include(DataHelperMixin);
	registerComponent("dxDropDownMenu", DropDownMenu);
	module.exports = DropDownMenu;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var ListEdit = __webpack_require__(191),
	    registerComponent = __webpack_require__(44);
	registerComponent("dxList", ListEdit);
	module.exports = ListEdit;
	module.exports.default = module.exports;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    eventUtils = __webpack_require__(61),
	    GroupedEditStrategy = __webpack_require__(192),
	    messageLocalization = __webpack_require__(79),
	    EditProvider = __webpack_require__(193),
	    ListBase = __webpack_require__(181);
	var LIST_ITEM_SELECTED_CLASS = "dx-list-item-selected",
	    LIST_ITEM_RESPONSE_WAIT_CLASS = "dx-list-item-response-wait";
	var ListEdit = ListBase.inherit({
	    _supportedKeys: function() {
	        var that = this,
	            parent = this.callBase();
	        var deleteFocusedItem = function(e) {
	            if (that.option("allowItemDeleting")) {
	                e.preventDefault();
	                that.deleteItem(that.option("focusedElement"))
	            }
	        };
	        var moveFocusedItemUp = function(e) {
	            if (e.shiftKey && that.option("allowItemReordering")) {
	                e.preventDefault();
	                var focusedItemIndex = that._editStrategy.getNormalizedIndex(that.option("focusedElement")),
	                    $prevItem = that._editStrategy.getItemElement(focusedItemIndex - 1);
	                that.reorderItem(that.option("focusedElement"), $prevItem);
	                that.scrollToItem(that.option("focusedElement"))
	            } else {
	                parent.upArrow(e)
	            }
	        };
	        var moveFocusedItemDown = function(e) {
	            if (e.shiftKey && that.option("allowItemReordering")) {
	                e.preventDefault();
	                var focusedItemIndex = that._editStrategy.getNormalizedIndex(that.option("focusedElement")),
	                    $nextItem = that._editStrategy.getItemElement(focusedItemIndex + 1);
	                that.reorderItem(that.option("focusedElement"), $nextItem);
	                that.scrollToItem(that.option("focusedElement"))
	            } else {
	                parent.downArrow(e)
	            }
	        };
	        return $.extend({}, parent, {
	            del: deleteFocusedItem,
	            upArrow: moveFocusedItemUp,
	            downArrow: moveFocusedItemDown
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            showSelectionControls: false,
	            selectionMode: "none",
	            selectAllMode: "page",
	            onSelectAllValueChanged: null,
	            selectAllText: messageLocalization.format("dxList-selectAll"),
	            menuItems: [],
	            menuMode: "context",
	            allowItemDeleting: false,
	            itemDeleteMode: "toggle",
	            allowItemReordering: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function(device) {
	                return "ios" === device.platform
	            },
	            options: {
	                menuMode: "slide",
	                itemDeleteMode: "slideItem"
	            }
	        }, {
	            device: {
	                platform: "android"
	            },
	            options: {
	                itemDeleteMode: "swipe"
	            }
	        }, {
	            device: {
	                platform: "win"
	            },
	            options: {
	                itemDeleteMode: "context"
	            }
	        }, {
	            device: {
	                platform: "generic"
	            },
	            options: {
	                itemDeleteMode: "static"
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this._initEditProvider()
	    },
	    _initEditProvider: function() {
	        this._editProvider = new EditProvider(this)
	    },
	    _disposeEditProvider: function() {
	        if (this._editProvider) {
	            this._editProvider.dispose()
	        }
	    },
	    _refreshEditProvider: function() {
	        this._disposeEditProvider();
	        this._initEditProvider()
	    },
	    _initEditStrategy: function() {
	        if (this.option("grouped")) {
	            this._editStrategy = new GroupedEditStrategy(this)
	        } else {
	            this.callBase()
	        }
	    },
	    _render: function() {
	        this._refreshEditProvider();
	        this.callBase()
	    },
	    _renderItems: function() {
	        this.callBase.apply(this, arguments);
	        this._editProvider.afterItemsRendered()
	    },
	    _selectedItemClass: function() {
	        return LIST_ITEM_SELECTED_CLASS
	    },
	    _itemResponseWaitClass: function() {
	        return LIST_ITEM_RESPONSE_WAIT_CLASS
	    },
	    _itemClickHandler: function(e) {
	        var $itemElement = $(e.currentTarget);
	        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
	            return
	        }
	        var handledByEditProvider = this._editProvider.handleClick($itemElement, e);
	        if (handledByEditProvider) {
	            return
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _shouldAttachContextMenuEvent: function() {
	        return this.callBase.apply(this, arguments) || this._editProvider.contextMenuHandlerExists()
	    },
	    _itemHoldHandler: function(e) {
	        var $itemElement = $(e.currentTarget);
	        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
	            return
	        }
	        var isTouchEvent = eventUtils.isTouchEvent(e),
	            handledByEditProvider = isTouchEvent && this._editProvider.handleContextMenu($itemElement, e);
	        if (handledByEditProvider) {
	            e.handledByEditProvider = true;
	            return
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _itemContextMenuHandler: function(e) {
	        var $itemElement = $(e.currentTarget);
	        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
	            return
	        }
	        var handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
	        if (handledByEditProvider) {
	            e.preventDefault();
	            return
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _postprocessRenderItem: function(args) {
	        this.callBase.apply(this, arguments);
	        this._editProvider.modifyItemElement(args)
	    },
	    _clean: function() {
	        this._disposeEditProvider();
	        this.callBase()
	    },
	    _dataSourceChangedHandler: function(newItems) {
	        this.callBase(newItems);
	        this._editProvider && this._editProvider.handleDataSourceChanged()
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "grouped":
	                this._clearSelectedItems();
	                delete this._renderingGroupIndex;
	                this._initEditStrategy();
	                this.callBase(args);
	                break;
	            case "showSelectionControls":
	            case "menuItems":
	            case "menuMode":
	            case "allowItemDeleting":
	            case "itemDeleteMode":
	            case "allowItemReordering":
	            case "selectAllText":
	                this._invalidate();
	                break;
	            case "onSelectAllValueChanged":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    isSelectAll: function() {
	        return this._selection.getSelectAllState("page" === this.option("selectAllMode"))
	    },
	    getFlatIndexByItemElement: function(itemElement) {
	        return this._itemElements().index(itemElement)
	    },
	    getItemElementByFlatIndex: function(flatIndex) {
	        var $itemElements = this._itemElements();
	        if (flatIndex < 0 || flatIndex >= $itemElements.length) {
	            return $()
	        }
	        return $itemElements.eq(flatIndex)
	    },
	    getItemByIndex: function(index) {
	        return this._getItemData(this._itemElements().eq(index))
	    }
	});
	module.exports = ListEdit;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.strategy.grouped.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    EditStrategy = __webpack_require__(135);
	var LIST_ITEM_CLASS = "dx-list-item",
	    LIST_GROUP_CLASS = "dx-list-group";
	var SELECTION_SHIFT = 20,
	    SELECTION_MASK = 2303;
	var combineIndex = function(indices) {
	    return (indices.group << SELECTION_SHIFT) + indices.item
	};
	var splitIndex = function(combinedIndex) {
	    return {
	        group: combinedIndex >> SELECTION_SHIFT,
	        item: combinedIndex & SELECTION_MASK
	    }
	};
	var GroupedEditStrategy = EditStrategy.inherit({
	    _groupElements: function() {
	        return this._collectionWidget._itemContainer().find("." + LIST_GROUP_CLASS)
	    },
	    _groupItemElements: function($group) {
	        return $group.find("." + LIST_ITEM_CLASS)
	    },
	    getIndexByItemData: function(itemData) {
	        var groups = this._collectionWidget.option("items"),
	            index = false;
	        if (!itemData) {
	            return false
	        }
	        if (itemData.items && itemData.items.length) {
	            itemData = itemData.items[0]
	        }
	        $.each(groups, function(groupIndex, group) {
	            if (!group.items) {
	                return false
	            }
	            $.each(group.items, function(itemIndex, item) {
	                if (item !== itemData) {
	                    return true
	                }
	                index = {
	                    group: groupIndex,
	                    item: itemIndex
	                };
	                return false
	            });
	            if (index) {
	                return false
	            }
	        });
	        return index
	    },
	    getItemDataByIndex: function(index) {
	        var items = this._collectionWidget.option("items");
	        return index && items[index.group] && items[index.group].items[index.item] || null
	    },
	    itemsGetter: function() {
	        var resultItems = [],
	            items = this._collectionWidget.option("items");
	        for (var i = 0; i < items.length; i++) {
	            if (items[i] && items[i].items) {
	                resultItems = resultItems.concat(items[i].items)
	            } else {
	                resultItems.push(items[i])
	            }
	        }
	        return resultItems
	    },
	    deleteItemAtIndex: function(index) {
	        var indices = splitIndex(index),
	            itemGroup = this._collectionWidget.option("items")[indices.group].items;
	        itemGroup.splice(indices.item, 1)
	    },
	    getKeysByItems: function(items) {
	        var plainItems = [];
	        for (var i = 0; i < items.length; i++) {
	            if (items[i] && items[i].items) {
	                plainItems = plainItems.concat(items[i].items)
	            } else {
	                plainItems.push(items[i])
	            }
	        }
	        var keyOf = this._collectionWidget._dataSource && this._collectionWidget._dataSource.store() && this._collectionWidget._dataSource.store().keyOf.bind(this._collectionWidget._dataSource.store());
	        var result = plainItems;
	        if (keyOf) {
	            result = [];
	            for (i = 0; i < plainItems.length; i++) {
	                result.push(keyOf(plainItems[i]))
	            }
	        }
	        return result
	    },
	    getIndexByKey: function(key) {
	        var groups = this._collectionWidget.option("items"),
	            index = -1,
	            that = this;
	        $.each(groups, function(groupIndex, group) {
	            if (!group.items) {
	                return
	            }
	            var keys = that.getKeysByItems(group.items);
	            $.each(keys, function(keyIndex, itemKey) {
	                if (that._equalKeys(itemKey, key)) {
	                    index = {
	                        group: groupIndex,
	                        item: keyIndex
	                    };
	                    return false
	                }
	            });
	            if (index !== -1) {
	                return false
	            }
	        });
	        return index
	    },
	    getItemsByKeys: function(keys) {
	        var that = this,
	            groups = that._collectionWidget.option("items"),
	            items = [];
	        $.each(keys, function(_, key) {
	            var index = that.getIndexByKey(key);
	            if (!index) {
	                return
	            }
	            var selectedGroup, group = groups[index.group],
	                groupKey = group.key,
	                item = group.items[index.item];
	            $.each(items, function(_, item) {
	                if (item.key === groupKey) {
	                    selectedGroup = item;
	                    return false
	                }
	            });
	            if (!selectedGroup) {
	                selectedGroup = {
	                    key: groupKey,
	                    items: []
	                };
	                items.push(selectedGroup)
	            }
	            selectedGroup.items.push(item)
	        });
	        return items
	    },
	    moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
	        var items = this._collectionWidget.option("items"),
	            movingIndices = splitIndex(movingIndex),
	            destinationIndices = splitIndex(destinationIndex),
	            movingItemGroup = items[movingIndices.group].items,
	            destinationItemGroup = items[destinationIndices.group].items,
	            movedItemData = movingItemGroup[movingIndices.item];
	        movingItemGroup.splice(movingIndices.item, 1);
	        destinationItemGroup.splice(destinationIndices.item, 0, movedItemData)
	    },
	    _isItemIndex: function(index) {
	        return $.isNumeric(index.group) && $.isNumeric(index.item)
	    },
	    _getNormalizedItemIndex: function(itemElement) {
	        var $item = $(itemElement),
	            $group = $item.closest("." + LIST_GROUP_CLASS);
	        if (!$group.length) {
	            return -1
	        }
	        return combineIndex({
	            group: this._groupElements().index($group),
	            item: this._groupItemElements($group).index($item)
	        })
	    },
	    _normalizeItemIndex: function(index) {
	        return combineIndex(index)
	    },
	    _denormalizeItemIndex: function(index) {
	        return splitIndex(index)
	    },
	    _getItemByNormalizedIndex: function(index) {
	        var indices = splitIndex(index),
	            $group = this._groupElements().eq(indices.group);
	        return this._groupItemElements($group).eq(indices.item)
	    },
	    _itemsFromSameParent: function(firstIndex, secondIndex) {
	        return splitIndex(firstIndex).group === splitIndex(secondIndex).group
	    }
	});
	module.exports = GroupedEditStrategy;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.provider.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    errors = __webpack_require__(15),
	    decoratorRegistry = __webpack_require__(194);
	__webpack_require__(195);
	__webpack_require__(197);
	__webpack_require__(199);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(206);
	var editOptionsRegistry = [];
	var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
	    editOptionsRegistry.push({
	        enabled: enabledFunc,
	        decoratorType: decoratorTypeFunc,
	        decoratorSubType: decoratorSubTypeFunc
	    })
	};
	registerOption(function() {
	    return this.option("menuItems").length
	}, function() {
	    return "menu"
	}, function() {
	    return this.option("menuMode")
	});
	registerOption(function() {
	    return !this.option("menuItems").length && this.option("allowItemDeleting")
	}, function() {
	    var mode = this.option("itemDeleteMode");
	    return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu"
	}, function() {
	    var mode = this.option("itemDeleteMode");
	    if ("slideItem" === mode) {
	        mode = "slide"
	    }
	    if ("hold" === mode) {
	        mode = "context"
	    }
	    return mode
	});
	registerOption(function() {
	    return "none" !== this.option("selectionMode") && this.option("showSelectionControls")
	}, function() {
	    return "selection"
	}, function() {
	    return "default"
	});
	registerOption(function() {
	    return this.option("allowItemReordering")
	}, function() {
	    return "reorder"
	}, function() {
	    return "default"
	});
	var LIST_ITEM_BEFORE_BAG_CLASS = "dx-list-item-before-bag",
	    LIST_ITEM_AFTER_BAG_CLASS = "dx-list-item-after-bag",
	    DECORATOR_BEFORE_BAG_CREATE_METHOD = "beforeBag",
	    DECORATOR_AFTER_BAG_CREATE_METHOD = "afterBag",
	    DECORATOR_MODIFY_ELEMENT_METHOD = "modifyElement",
	    DECORATOR_AFTER_RENDER_METHOD = "afterRender";
	var EditProvider = Class.inherit({
	    ctor: function(list) {
	        this._list = list;
	        this._fetchRequiredDecorators()
	    },
	    dispose: function() {
	        if (this._decorators && this._decorators.length) {
	            $.each(this._decorators, function(_, decorator) {
	                decorator.dispose()
	            })
	        }
	    },
	    _fetchRequiredDecorators: function() {
	        this._decorators = [];
	        $.each(editOptionsRegistry, $.proxy(function(_, option) {
	            var optionEnabled = option.enabled.call(this._list);
	            if (optionEnabled) {
	                var decoratorType = option.decoratorType.call(this._list),
	                    decoratorSubType = option.decoratorSubType.call(this._list),
	                    decorator = this._createDecorator(decoratorType, decoratorSubType);
	                this._decorators.push(decorator)
	            }
	        }, this))
	    },
	    _createDecorator: function(type, subType) {
	        var decoratorClass = this._findDecorator(type, subType);
	        return new decoratorClass(this._list)
	    },
	    _findDecorator: function(type, subType) {
	        var foundDecorator = decoratorRegistry.registry[type][subType];
	        if (!foundDecorator) {
	            throw errors.Error("E1012", type, subType)
	        }
	        return foundDecorator
	    },
	    modifyItemElement: function(args) {
	        var $itemElement = $(args.itemElement);
	        var config = {
	            $itemElement: $itemElement
	        };
	        this._prependBeforeBags($itemElement, config);
	        this._appendAfterBags($itemElement, config);
	        this._applyDecorators(DECORATOR_MODIFY_ELEMENT_METHOD, config)
	    },
	    afterItemsRendered: function() {
	        this._applyDecorators(DECORATOR_AFTER_RENDER_METHOD)
	    },
	    _prependBeforeBags: function($itemElement, config) {
	        var $beforeBags = this._collectDecoratorsMarkup(DECORATOR_BEFORE_BAG_CREATE_METHOD, config, LIST_ITEM_BEFORE_BAG_CLASS);
	        $itemElement.prepend($beforeBags)
	    },
	    _appendAfterBags: function($itemElement, config) {
	        var $afterBags = this._collectDecoratorsMarkup(DECORATOR_AFTER_BAG_CREATE_METHOD, config, LIST_ITEM_AFTER_BAG_CLASS);
	        $itemElement.append($afterBags)
	    },
	    _collectDecoratorsMarkup: function(method, config, containerClass) {
	        var $collector = $("<div />");
	        $.each(this._decorators, function() {
	            var $container = $("<div />").addClass(containerClass);
	            this[method]($.extend({
	                $container: $container
	            }, config));
	            if ($container.children().length) {
	                $collector.append($container)
	            }
	        });
	        return $collector.children()
	    },
	    _applyDecorators: function(method, config) {
	        $.each(this._decorators, function() {
	            this[method](config)
	        })
	    },
	    _handlerExists: function(name) {
	        if (!this._decorators) {
	            return false
	        }
	        var decorators = this._decorators,
	            length = decorators.length;
	        for (var i = 0; i < length; i++) {
	            if (decorators[i][name] !== $.noop) {
	                return true
	            }
	        }
	        return false
	    },
	    _eventHandler: function(name, $itemElement, e) {
	        if (!this._decorators) {
	            return false
	        }
	        var response = false,
	            decorators = this._decorators,
	            length = decorators.length;
	        for (var i = 0; i < length; i++) {
	            response = decorators[i][name]($itemElement, e);
	            if (response) {
	                break
	            }
	        }
	        return response
	    },
	    handleClick: function($itemElement, e) {
	        return this._eventHandler("handleClick", $itemElement, e)
	    },
	    contextMenuHandlerExists: function() {
	        return this._handlerExists("handleContextMenu")
	    },
	    handleContextMenu: function($itemElement, e) {
	        return this._eventHandler("handleContextMenu", $itemElement, e)
	    },
	    handleDataSourceChanged: function() {
	        return this._eventHandler("handleDataSourceChanged")
	    }
	});
	module.exports = EditProvider;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator_registry.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5);
	exports.registry = {};
	exports.register = function(option, type, decoratorClass) {
	    var decoratorsRegistry = exports.registry;
	    var decoratorConfig = {};
	    decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
	    decoratorConfig[option][type] = decoratorClass;
	    decoratorsRegistry = $.extend(decoratorsRegistry, decoratorConfig)
	};


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.static.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Button = __webpack_require__(114),
	    registerDecorator = __webpack_require__(194).register,
	    EditDecorator = __webpack_require__(196);
	var STATIC_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-static-delete-button-container",
	    STATIC_DELETE_BUTTON_CLASS = "dx-list-static-delete-button";
	registerDecorator("delete", "static", EditDecorator.inherit({
	    afterBag: function(config) {
	        var $itemElement = config.$itemElement,
	            $container = config.$container;
	        var $button = $("<div>").addClass(STATIC_DELETE_BUTTON_CLASS);
	        this._list._createComponent($button, Button, {
	            icon: "remove",
	            onClick: $.proxy(function(args) {
	                args.jQueryEvent.stopPropagation();
	                this._deleteItem($itemElement)
	            }, this),
	            integrationOptions: {}
	        });
	        $container.addClass(STATIC_DELETE_BUTTON_CONTAINER_CLASS).append($button)
	    },
	    _deleteItem: function($itemElement) {
	        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
	            return
	        }
	        this._list.deleteItem($itemElement)
	    }
	}));


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    swipeEvents = __webpack_require__(182),
	    eventUtils = __webpack_require__(61);
	var LIST_EDIT_DECORATOR = "dxListEditDecorator",
	    SWIPE_START_EVENT_NAME = eventUtils.addNamespace(swipeEvents.start, LIST_EDIT_DECORATOR),
	    SWIPE_UPDATE_EVENT_NAME = eventUtils.addNamespace(swipeEvents.swipe, LIST_EDIT_DECORATOR),
	    SWIPE_END_EVENT_NAME = eventUtils.addNamespace(swipeEvents.end, LIST_EDIT_DECORATOR);
	var EditDecorator = Class.inherit({
	    ctor: function(list) {
	        this._list = list;
	        this._init()
	    },
	    _init: $.noop,
	    _shouldHandleSwipe: false,
	    _attachSwipeEvent: function(config) {
	        var swipeConfig = {
	            itemSizeFunc: $.proxy(function() {
	                if (this._clearSwipeCache) {
	                    this._itemWidthCache = this._list.element().width();
	                    this._clearSwipeCache = false
	                }
	                return this._itemWidthCache
	            }, this)
	        };
	        config.$itemElement.on(SWIPE_START_EVENT_NAME, swipeConfig, $.proxy(this._itemSwipeStartHandler, this)).on(SWIPE_UPDATE_EVENT_NAME, $.proxy(this._itemSwipeUpdateHandler, this)).on(SWIPE_END_EVENT_NAME, $.proxy(this._itemSwipeEndHandler, this))
	    },
	    _itemSwipeStartHandler: function(e) {
	        var $itemElement = $(e.currentTarget);
	        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
	            e.cancel = true;
	            return
	        }
	        this._swipeStartHandler($itemElement, e)
	    },
	    _itemSwipeUpdateHandler: function(e) {
	        var $itemElement = $(e.currentTarget);
	        this._swipeUpdateHandler($itemElement, e)
	    },
	    _itemSwipeEndHandler: function(e) {
	        var $itemElement = $(e.currentTarget);
	        this._swipeEndHandler($itemElement, e);
	        this._clearSwipeCache = true
	    },
	    beforeBag: $.noop,
	    afterBag: $.noop,
	    _commonOptions: function() {
	        return {
	            activeStateEnabled: this._list.option("activeStateEnabled"),
	            hoverStateEnabled: this._list.option("hoverStateEnabled"),
	            focusStateEnabled: this._list.option("focusStateEnabled")
	        }
	    },
	    modifyElement: function(config) {
	        if (this._shouldHandleSwipe) {
	            this._attachSwipeEvent(config);
	            this._clearSwipeCache = true
	        }
	    },
	    afterRender: $.noop,
	    handleClick: $.noop,
	    handleContextMenu: $.noop,
	    handleDataSourceChanged: $.noop,
	    _swipeStartHandler: $.noop,
	    _swipeUpdateHandler: $.noop,
	    _swipeEndHandler: $.noop,
	    visibilityChange: $.noop,
	    dispose: $.noop
	});
	module.exports = EditDecorator;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.button.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    fx = __webpack_require__(58),
	    Button = __webpack_require__(114),
	    messageLocalization = __webpack_require__(79),
	    registerDecorator = __webpack_require__(194).register,
	    SwitchableEditDecorator = __webpack_require__(198);
	var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container",
	    SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS = "dx-list-switchable-delete-button-wrapper",
	    SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS = "dx-list-switchable-delete-button-inner-wrapper",
	    SWITCHABLE_DELETE_BUTTON_CLASS = "dx-list-switchable-delete-button",
	    SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION = 200;
	var SwitchableButtonEditDecorator = SwitchableEditDecorator.inherit({
	    _init: function() {
	        this.callBase.apply(this, arguments);
	        var $buttonContainer = $("<div >").addClass(SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS),
	            $buttonWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS),
	            $buttonInnerWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS),
	            $button = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_CLASS);
	        this._list._createComponent($button, Button, {
	            text: messageLocalization.format("dxListEditDecorator-delete"),
	            type: "danger",
	            onClick: $.proxy(function(e) {
	                this._deleteItem();
	                e.jQueryEvent.stopPropagation()
	            }, this),
	            integrationOptions: {}
	        });
	        $buttonContainer.append($buttonWrapper);
	        $buttonWrapper.append($buttonInnerWrapper);
	        $buttonInnerWrapper.append($button);
	        this._$buttonContainer = $buttonContainer
	    },
	    _enablePositioning: function($itemElement) {
	        this.callBase.apply(this, arguments);
	        fx.stop(this._$buttonContainer, true);
	        this._$buttonContainer.appendTo($itemElement)
	    },
	    _disablePositioning: function() {
	        this.callBase.apply(this, arguments);
	        this._$buttonContainer.detach()
	    },
	    _animatePrepareDeleteReady: function() {
	        var rtl = this._isRtlEnabled(),
	            listWidth = this._list.element().width(),
	            buttonWidth = this._buttonWidth(),
	            fromValue = rtl ? listWidth : -buttonWidth,
	            toValue = rtl ? listWidth - buttonWidth : 0;
	        return fx.animate(this._$buttonContainer, {
	            type: "custom",
	            duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
	            from: {
	                right: fromValue
	            },
	            to: {
	                right: toValue
	            }
	        })
	    },
	    _animateForgetDeleteReady: function() {
	        var rtl = this._isRtlEnabled(),
	            listWidth = this._list.element().width(),
	            buttonWidth = this._buttonWidth(),
	            fromValue = rtl ? listWidth - buttonWidth : 0,
	            toValue = rtl ? listWidth : -buttonWidth;
	        return fx.animate(this._$buttonContainer, {
	            type: "custom",
	            duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
	            from: {
	                right: fromValue
	            },
	            to: {
	                right: toValue
	            }
	        })
	    },
	    _buttonWidth: function() {
	        if (!this._buttonContainerWidth) {
	            this._buttonContainerWidth = this._$buttonContainer.outerWidth()
	        }
	        return this._buttonContainerWidth
	    },
	    dispose: function() {
	        if (this._$buttonContainer) {
	            this._$buttonContainer.remove()
	        }
	        this.callBase.apply(this, arguments)
	    }
	});
	var TOGGLE_DELETE_SWITCH_CONTAINER_CLASS = "dx-list-toggle-delete-switch-container",
	    TOGGLE_DELETE_SWITCH_CLASS = "dx-list-toggle-delete-switch";
	registerDecorator("delete", "toggle", SwitchableButtonEditDecorator.inherit({
	    beforeBag: function(config) {
	        var $itemElement = config.$itemElement,
	            $container = config.$container;
	        var $toggle = $("<div />").addClass(TOGGLE_DELETE_SWITCH_CLASS);
	        this._list._createComponent($toggle, Button, {
	            icon: "toggle-delete",
	            onClick: $.proxy(function(e) {
	                this._toggleDeleteReady($itemElement);
	                e.jQueryEvent.stopPropagation()
	            }, this),
	            integrationOptions: {}
	        });
	        $container.addClass(TOGGLE_DELETE_SWITCH_CONTAINER_CLASS);
	        $container.append($toggle)
	    }
	}));
	registerDecorator("delete", "slideButton", SwitchableButtonEditDecorator.inherit({
	    _shouldHandleSwipe: true,
	    _swipeEndHandler: function($itemElement, args) {
	        if (0 !== args.targetOffset) {
	            this._toggleDeleteReady($itemElement)
	        }
	        return true
	    }
	}));
	module.exports = SwitchableButtonEditDecorator;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    EditDecorator = __webpack_require__(196),
	    abstract = EditDecorator.abstract,
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    feedbackEvents = __webpack_require__(93);
	var LIST_EDIT_DECORATOR = "dxListEditDecorator",
	    POINTER_DOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, LIST_EDIT_DECORATOR),
	    ACTIVE_EVENT_NAME = eventUtils.addNamespace(feedbackEvents.active, LIST_EDIT_DECORATOR),
	    LIST_ITEM_CONTENT_CLASS = "dx-list-item-content",
	    SWITCHABLE_DELETE_READY_CLASS = "dx-list-switchable-delete-ready",
	    SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-shield-positioning",
	    SWITCHABLE_DELETE_TOP_SHIELD_CLASS = "dx-list-switchable-delete-top-shield",
	    SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS = "dx-list-switchable-delete-bottom-shield",
	    SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-item-shield-positioning",
	    SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS = "dx-list-switchable-delete-item-content-shield";
	var SwitchableEditDecorator = EditDecorator.inherit({
	    _init: function() {
	        this._$topShield = $("<div />").addClass(SWITCHABLE_DELETE_TOP_SHIELD_CLASS);
	        this._$bottomShield = $("<div />").addClass(SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS);
	        this._$itemContentShield = $("<div />").addClass(SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS);
	        this._$topShield.on(POINTER_DOWN_EVENT_NAME, $.proxy(this._cancelDeleteReadyItem, this));
	        this._$bottomShield.on(POINTER_DOWN_EVENT_NAME, $.proxy(this._cancelDeleteReadyItem, this));
	        this._list.element().append(this._$topShield.toggle(false)).append(this._$bottomShield.toggle(false))
	    },
	    handleClick: function() {
	        return this._cancelDeleteReadyItem()
	    },
	    _cancelDeleteReadyItem: function() {
	        if (!this._$readyToDeleteItem) {
	            return false
	        }
	        this._cancelDelete(this._$readyToDeleteItem);
	        return true
	    },
	    _cancelDelete: function($itemElement) {
	        this._toggleDeleteReady($itemElement, false)
	    },
	    _toggleDeleteReady: function($itemElement, readyToDelete) {
	        if (void 0 === readyToDelete) {
	            readyToDelete = !this._isReadyToDelete($itemElement)
	        }
	        this._toggleShields($itemElement, readyToDelete);
	        this._toggleScrolling(readyToDelete);
	        this._cacheReadyToDeleteItem($itemElement, readyToDelete);
	        this._animateToggleDelete($itemElement, readyToDelete)
	    },
	    _isReadyToDelete: function($itemElement) {
	        return $itemElement.hasClass(SWITCHABLE_DELETE_READY_CLASS)
	    },
	    _toggleShields: function($itemElement, enabled) {
	        this._list.element().toggleClass(SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS, enabled);
	        this._$topShield.toggle(enabled);
	        this._$bottomShield.toggle(enabled);
	        if (enabled) {
	            this._updateShieldsHeight($itemElement)
	        }
	        this._toggleContentShield($itemElement, enabled)
	    },
	    _updateShieldsHeight: function($itemElement) {
	        var $list = this._list.element(),
	            listTopOffset = $list.offset().top,
	            listHeight = $list.outerHeight(),
	            itemTopOffset = $itemElement.offset().top,
	            itemHeight = $itemElement.outerHeight(),
	            dirtyTopShieldHeight = itemTopOffset - listTopOffset,
	            dirtyBottomShieldHeight = listHeight - itemHeight - dirtyTopShieldHeight;
	        this._$topShield.height(Math.max(dirtyTopShieldHeight, 0));
	        this._$bottomShield.height(Math.max(dirtyBottomShieldHeight, 0))
	    },
	    _toggleContentShield: function($itemElement, enabled) {
	        if (enabled) {
	            $itemElement.find("." + LIST_ITEM_CONTENT_CLASS).first().append(this._$itemContentShield)
	        } else {
	            this._$itemContentShield.detach()
	        }
	    },
	    _toggleScrolling: function(readyToDelete) {
	        var scrollView = this._list.element().dxScrollView("instance");
	        if (readyToDelete) {
	            scrollView.on("start", this._cancelScrolling)
	        } else {
	            scrollView.off("start", this._cancelScrolling)
	        }
	    },
	    _cancelScrolling: function(args) {
	        args.jQueryEvent.cancel = true
	    },
	    _cacheReadyToDeleteItem: function($itemElement, cache) {
	        if (cache) {
	            this._$readyToDeleteItem = $itemElement
	        } else {
	            delete this._$readyToDeleteItem
	        }
	    },
	    _animateToggleDelete: function($itemElement, readyToDelete) {
	        if (readyToDelete) {
	            this._enablePositioning($itemElement);
	            this._prepareDeleteReady($itemElement);
	            this._animatePrepareDeleteReady($itemElement)
	        } else {
	            this._forgetDeleteReady($itemElement);
	            this._animateForgetDeleteReady($itemElement).done($.proxy(this._disablePositioning, this, $itemElement))
	        }
	    },
	    _enablePositioning: function($itemElement) {
	        $itemElement.addClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
	        $itemElement.on(ACTIVE_EVENT_NAME, $.noop)
	    },
	    _disablePositioning: function($itemElement) {
	        $itemElement.removeClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
	        $itemElement.off(ACTIVE_EVENT_NAME)
	    },
	    _prepareDeleteReady: function($itemElement) {
	        $itemElement.addClass(SWITCHABLE_DELETE_READY_CLASS)
	    },
	    _forgetDeleteReady: function($itemElement) {
	        $itemElement.removeClass(SWITCHABLE_DELETE_READY_CLASS)
	    },
	    _animatePrepareDeleteReady: abstract,
	    _animateForgetDeleteReady: abstract,
	    _deleteItem: function($itemElement) {
	        $itemElement = $itemElement || this._$readyToDeleteItem;
	        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
	            return
	        }
	        this._list.deleteItem($itemElement).always($.proxy(this._cancelDelete, this, $itemElement))
	    },
	    _isRtlEnabled: function() {
	        return this._list.option("rtlEnabled")
	    },
	    dispose: function() {
	        if (this._$topShield) {
	            this._$topShield.remove()
	        }
	        if (this._$bottomShield) {
	            this._$bottomShield.remove()
	        }
	        this.callBase.apply(this, arguments)
	    }
	});
	module.exports = SwitchableEditDecorator;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.slide.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    clickEvent = __webpack_require__(65),
	    messageLocalization = __webpack_require__(79),
	    translator = __webpack_require__(59),
	    eventUtils = __webpack_require__(61),
	    feedbackEvents = __webpack_require__(93),
	    EditDecoratorMenuHelperMixin = __webpack_require__(200),
	    registerDecorator = __webpack_require__(194).register,
	    SwitchableEditDecorator = __webpack_require__(198),
	    fx = __webpack_require__(58),
	    ActionSheet = __webpack_require__(177);
	var LIST_EDIT_DECORATOR = "dxListEditDecorator",
	    CLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, LIST_EDIT_DECORATOR),
	    ACTIVE_EVENT_NAME = eventUtils.addNamespace(feedbackEvents.active, LIST_EDIT_DECORATOR),
	    SLIDE_MENU_CLASS = "dx-list-slide-menu",
	    SLIDE_MENU_WRAPPER_CLASS = "dx-list-slide-menu-wrapper",
	    SLIDE_MENU_CONTENT_CLASS = "dx-list-slide-menu-content",
	    SLIDE_MENU_BUTTONS_CONTAINER_CLASS = "dx-list-slide-menu-buttons-container",
	    SLIDE_MENU_BUTTONS_CLASS = "dx-list-slide-menu-buttons",
	    SLIDE_MENU_BUTTON_CLASS = "dx-list-slide-menu-button",
	    SLIDE_MENU_BUTTON_MENU_CLASS = "dx-list-slide-menu-button-menu",
	    SLIDE_MENU_BUTTON_DELETE_CLASS = "dx-list-slide-menu-button-delete",
	    SLIDE_MENU_ANIMATION_DURATION = 400,
	    SLIDE_MENU_ANIMATION_EASING = "cubic-bezier(0.075, 0.82, 0.165, 1)";
	registerDecorator("menu", "slide", SwitchableEditDecorator.inherit({
	    _shouldHandleSwipe: true,
	    _init: function() {
	        this.callBase.apply(this, arguments);
	        this._$buttonsContainer = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CONTAINER_CLASS).on(ACTIVE_EVENT_NAME, $.noop);
	        this._$buttons = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CLASS).appendTo(this._$buttonsContainer);
	        this._renderMenu();
	        this._renderDeleteButton()
	    },
	    _renderMenu: function() {
	        if (!this._menuEnabled()) {
	            return
	        }
	        var menuItems = this._menuItems();
	        if (1 === menuItems.length) {
	            var menuItem = menuItems[0];
	            this._renderMenuButton(menuItem.text, $.proxy(function(e) {
	                e.stopPropagation();
	                this._fireAction(menuItem)
	            }, this))
	        } else {
	            var $menu = $("<div />").addClass(SLIDE_MENU_CLASS);
	            this._menu = this._list._createComponent($menu, ActionSheet, {
	                showTitle: false,
	                items: menuItems,
	                onItemClick: $.proxy(function(args) {
	                    this._fireAction(args.itemData)
	                }, this),
	                integrationOptions: {}
	            });
	            $menu.appendTo(this._list.element());
	            var $menuButton = this._renderMenuButton(messageLocalization.format("dxListEditDecorator-more"), $.proxy(function(e) {
	                e.stopPropagation();
	                this._menu.show()
	            }, this));
	            this._menu.option("target", $menuButton)
	        }
	    },
	    _renderMenuButton: function(text, action) {
	        var $menuButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_MENU_CLASS).text(text);
	        this._$buttons.append($menuButton);
	        $menuButton.on(CLICK_EVENT_NAME, action);
	        return $menuButton
	    },
	    _renderDeleteButton: function() {
	        if (!this._deleteEnabled()) {
	            return
	        }
	        var $deleteButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_DELETE_CLASS).text(messageLocalization.format("dxListEditDecorator-delete"));
	        $deleteButton.on(CLICK_EVENT_NAME, $.proxy(function(e) {
	            e.stopPropagation();
	            this._deleteItem()
	        }, this));
	        this._$buttons.append($deleteButton)
	    },
	    _fireAction: function(menuItem) {
	        this._fireMenuAction($(this._cachedNode), menuItem.action);
	        this._cancelDeleteReadyItem()
	    },
	    modifyElement: function(config) {
	        this.callBase.apply(this, arguments);
	        var $itemElement = config.$itemElement;
	        $itemElement.addClass(SLIDE_MENU_WRAPPER_CLASS);
	        var $slideMenuContent = $("<div/>").addClass(SLIDE_MENU_CONTENT_CLASS);
	        $itemElement.wrapInner($slideMenuContent)
	    },
	    handleClick: function(_, e) {
	        if ($(e.target).closest("." + SLIDE_MENU_CONTENT_CLASS).length) {
	            return this.callBase.apply(this, arguments)
	        }
	        return false
	    },
	    _swipeStartHandler: function($itemElement) {
	        this._enablePositioning($itemElement);
	        this._cacheItemData($itemElement);
	        this._setPositions(this._getPositions(0))
	    },
	    _swipeUpdateHandler: function($itemElement, args) {
	        var rtl = this._isRtlEnabled(),
	            signCorrection = rtl ? -1 : 1,
	            isItemReadyToDelete = this._isReadyToDelete($itemElement),
	            moveJustStarted = this._getCurrentPositions().content === this._getStartPositions().content;
	        if (moveJustStarted && !isItemReadyToDelete && args.offset * signCorrection > 0) {
	            args.cancel = true;
	            return
	        }
	        var offset = this._cachedItemWidth * args.offset,
	            startOffset = isItemReadyToDelete ? -this._cachedButtonWidth * signCorrection : 0,
	            correctedOffset = (offset + startOffset) * signCorrection,
	            percent = correctedOffset < 0 ? Math.abs((offset + startOffset) / this._cachedButtonWidth) : 0;
	        this._setPositions(this._getPositions(percent));
	        return true
	    },
	    _getStartPositions: function() {
	        var rtl = this._isRtlEnabled(),
	            signCorrection = rtl ? -1 : 1;
	        return {
	            content: 0,
	            buttonsContainer: rtl ? -this._cachedButtonWidth : this._cachedItemWidth,
	            buttons: -this._cachedButtonWidth * signCorrection
	        }
	    },
	    _getPositions: function(percent) {
	        var rtl = this._isRtlEnabled(),
	            signCorrection = rtl ? -1 : 1,
	            startPositions = this._getStartPositions();
	        return {
	            content: startPositions.content - percent * this._cachedButtonWidth * signCorrection,
	            buttonsContainer: startPositions.buttonsContainer - Math.min(percent, 1) * this._cachedButtonWidth * signCorrection,
	            buttons: startPositions.buttons + Math.min(percent, 1) * this._cachedButtonWidth * signCorrection
	        }
	    },
	    _getCurrentPositions: function() {
	        return {
	            content: translator.locate(this._$cachedContent).left,
	            buttonsContainer: translator.locate(this._$buttonsContainer).left,
	            buttons: translator.locate(this._$buttons).left
	        }
	    },
	    _setPositions: function(positions) {
	        translator.move(this._$cachedContent, {
	            left: positions.content
	        });
	        translator.move(this._$buttonsContainer, {
	            left: positions.buttonsContainer
	        });
	        translator.move(this._$buttons, {
	            left: positions.buttons
	        })
	    },
	    _cacheItemData: function($itemElement) {
	        if ($itemElement[0] === this._cachedNode) {
	            return
	        }
	        this._$cachedContent = $itemElement.find("." + SLIDE_MENU_CONTENT_CLASS);
	        this._cachedItemWidth = $itemElement.outerWidth();
	        this._cachedButtonWidth = this._cachedButtonWidth || this._$buttons.outerWidth();
	        this._$buttonsContainer.width(this._cachedButtonWidth);
	        if (this._$cachedContent.length) {
	            this._cachedNode = $itemElement[0]
	        }
	    },
	    _minButtonContainerLeftOffset: function() {
	        return this._cachedItemWidth - this._cachedButtonWidth
	    },
	    _swipeEndHandler: function($itemElement, args) {
	        this._cacheItemData($itemElement);
	        var signCorrection = this._isRtlEnabled() ? 1 : -1,
	            offset = this._cachedItemWidth * args.offset,
	            endedAtReadyToDelete = !this._isReadyToDelete($itemElement) && offset * signCorrection > .2 * this._cachedButtonWidth,
	            readyToDelete = args.targetOffset === signCorrection && endedAtReadyToDelete;
	        this._toggleDeleteReady($itemElement, readyToDelete);
	        return true
	    },
	    _enablePositioning: function($itemElement) {
	        fx.stop(this._$cachedContent, true);
	        this.callBase.apply(this, arguments);
	        this._$buttonsContainer.appendTo($itemElement)
	    },
	    _disablePositioning: function() {
	        this.callBase.apply(this, arguments);
	        this._$buttonsContainer.detach()
	    },
	    _animatePrepareDeleteReady: function() {
	        return this._animateToPositions(this._getPositions(1))
	    },
	    _animateForgetDeleteReady: function($itemElement) {
	        this._cacheItemData($itemElement);
	        return this._animateToPositions(this._getPositions(0))
	    },
	    _animateToPositions: function(positions) {
	        var that = this,
	            currentPosition = this._getCurrentPositions(),
	            durationTimePart = Math.min(Math.abs(currentPosition.content - positions.content) / this._cachedButtonWidth, 1);
	        return fx.animate(this._$cachedContent, {
	            from: currentPosition,
	            to: positions,
	            easing: SLIDE_MENU_ANIMATION_EASING,
	            duration: SLIDE_MENU_ANIMATION_DURATION * durationTimePart,
	            strategy: "frame",
	            draw: function(positions) {
	                that._setPositions(positions)
	            }
	        })
	    },
	    dispose: function() {
	        if (this._menu) {
	            this._menu.element().remove()
	        }
	        if (this._$buttonsContainer) {
	            this._$buttonsContainer.remove()
	        }
	        this.callBase.apply(this, arguments)
	    }
	}).include(EditDecoratorMenuHelperMixin));


/***/ },
/* 200 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator_menu_helper.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var EditDecoratorMenuHelperMixin = {
	    _menuEnabled: function() {
	        return !!this._menuItems().length
	    },
	    _menuItems: function() {
	        return this._list.option("menuItems")
	    },
	    _deleteEnabled: function() {
	        return this._list.option("allowItemDeleting")
	    },
	    _fireMenuAction: function($itemElement, action) {
	        this._list._itemEventHandlerByHandler($itemElement, action, {}, {
	            excludeValidators: ["disabled", "readOnly"]
	        })
	    }
	};
	module.exports = EditDecoratorMenuHelperMixin;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.swipe.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    translator = __webpack_require__(59),
	    fx = __webpack_require__(58),
	    registerDecorator = __webpack_require__(194).register,
	    EditDecorator = __webpack_require__(196);
	registerDecorator("delete", "swipe", EditDecorator.inherit({
	    _shouldHandleSwipe: true,
	    _renderItemPosition: function($itemElement, offset, animate) {
	        var deferred = $.Deferred(),
	            itemOffset = offset * this._itemElementWidth;
	        if (animate) {
	            fx.animate($itemElement, {
	                to: {
	                    left: itemOffset
	                },
	                type: "slide",
	                complete: function() {
	                    deferred.resolve($itemElement, offset)
	                }
	            })
	        } else {
	            translator.move($itemElement, {
	                left: itemOffset
	            });
	            deferred.resolve()
	        }
	        return deferred.promise()
	    },
	    _swipeStartHandler: function($itemElement) {
	        this._itemElementWidth = $itemElement.width();
	        return true
	    },
	    _swipeUpdateHandler: function($itemElement, args) {
	        this._renderItemPosition($itemElement, args.offset);
	        return true
	    },
	    _swipeEndHandler: function($itemElement, args) {
	        var offset = args.targetOffset;
	        this._renderItemPosition($itemElement, offset, true).done($.proxy(function($itemElement, offset) {
	            if (Math.abs(offset)) {
	                this._list.deleteItem($itemElement).fail($.proxy(function() {
	                    this._renderItemPosition($itemElement, 0, true)
	                }, this))
	            }
	        }, this));
	        return true
	    }
	}));


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.context.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    EditDecoratorMenuHelperMixin = __webpack_require__(200),
	    messageLocalization = __webpack_require__(79),
	    registerDecorator = __webpack_require__(194).register,
	    EditDecorator = __webpack_require__(196),
	    Overlay = __webpack_require__(97),
	    ListBase = __webpack_require__(181);
	var CONTEXTMENU_CLASS = "dx-list-context-menu",
	    CONTEXTMENU_MENUCONTENT_CLASS = "dx-list-context-menucontent";
	registerDecorator("menu", "context", EditDecorator.inherit({
	    _init: function() {
	        var $menu = $("<div/>").addClass(CONTEXTMENU_CLASS);
	        this._list.element().append($menu);
	        this._menu = this._renderOverlay($menu)
	    },
	    _renderOverlay: function($element) {
	        return this._list._createComponent($element, Overlay, {
	            shading: false,
	            deferRendering: true,
	            closeOnTargetScroll: true,
	            closeOnOutsideClick: function(e) {
	                return !$(e.target).closest("." + CONTEXTMENU_CLASS).length
	            },
	            animation: {
	                show: {
	                    type: "slide",
	                    duration: 300,
	                    from: {
	                        height: 0,
	                        opacity: 1
	                    },
	                    to: {
	                        height: $.proxy(function() {
	                            return this._$menuList.outerHeight()
	                        }, this),
	                        opacity: 1
	                    }
	                },
	                hide: {
	                    type: "slide",
	                    duration: 0,
	                    from: {
	                        opacity: 1
	                    },
	                    to: {
	                        opacity: 0
	                    }
	                }
	            },
	            height: $.proxy(function() {
	                return this._$menuList ? this._$menuList.outerHeight() : 0
	            }, this),
	            width: $.proxy(function() {
	                return this._list.element().outerWidth()
	            }, this),
	            onContentReady: $.proxy(this._renderMenuContent, this)
	        })
	    },
	    _renderMenuContent: function(e) {
	        var $overlayContent = e.component.content();
	        var items = this._menuItems().slice();
	        if (this._deleteEnabled()) {
	            items.push({
	                text: messageLocalization.format("dxListEditDecorator-delete"),
	                action: $.proxy(this._deleteItem, this)
	            })
	        }
	        this._$menuList = $("<div>");
	        this._list._createComponent(this._$menuList, ListBase, {
	            items: items,
	            onItemClick: $.proxy(this._menuItemClickHandler, this),
	            height: "auto",
	            integrationOptions: {}
	        });
	        $overlayContent.addClass(CONTEXTMENU_MENUCONTENT_CLASS);
	        $overlayContent.append(this._$menuList)
	    },
	    _menuItemClickHandler: function(args) {
	        this._menu.hide();
	        this._fireMenuAction(this._$itemWithMenu, args.itemData.action)
	    },
	    _deleteItem: function() {
	        this._list.deleteItem(this._$itemWithMenu)
	    },
	    handleContextMenu: function($itemElement) {
	        this._$itemWithMenu = $itemElement;
	        this._menu.option({
	            position: {
	                my: "top",
	                at: "bottom",
	                of: $itemElement,
	                collision: "flip"
	            }
	        });
	        this._menu.show();
	        return true
	    },
	    dispose: function() {
	        if (this._menu) {
	            this._menu.element().remove()
	        }
	        this.callBase.apply(this, arguments)
	    }
	}).include(EditDecoratorMenuHelperMixin));


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.selection.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    clickEvent = __webpack_require__(65),
	    CheckBox = __webpack_require__(204),
	    RadioButton = __webpack_require__(205),
	    eventUtils = __webpack_require__(61),
	    registerDecorator = __webpack_require__(194).register,
	    EditDecorator = __webpack_require__(196);
	var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled",
	    SELECT_DECORATOR_SELECT_ALL_CLASS = "dx-list-select-all",
	    SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox",
	    SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS = "dx-list-select-all-label",
	    SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container",
	    SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox",
	    SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container",
	    SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
	var CLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, "dxListEditDecorator");
	registerDecorator("selection", "default", EditDecorator.inherit({
	    _init: function() {
	        this.callBase.apply(this, arguments);
	        var selectionMode = this._list.option("selectionMode");
	        this._singleStrategy = "single" === selectionMode;
	        this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
	        this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
	        this._controlWidget = this._singleStrategy ? RadioButton : CheckBox;
	        this._list.element().addClass(SELECT_DECORATOR_ENABLED_CLASS)
	    },
	    beforeBag: function(config) {
	        var $itemElement = config.$itemElement,
	            $container = config.$container;
	        var $control = $("<div />").addClass(this._controlClass);
	        new this._controlWidget($control, $.extend(this._commonOptions(), {
	            value: this._isSelected($itemElement),
	            focusStateEnabled: false,
	            hoverStateEnabled: false,
	            onValueChanged: $.proxy(function(e) {
	                this._processCheckedState($itemElement, e.value);
	                e.jQueryEvent && e.jQueryEvent.stopPropagation()
	            }, this)
	        }));
	        $container.addClass(this._containerClass);
	        $container.append($control)
	    },
	    modifyElement: function(config) {
	        this.callBase.apply(this, arguments);
	        var $itemElement = config.$itemElement,
	            control = this._controlWidget.getInstance($itemElement.find("." + this._controlClass));
	        $itemElement.on("stateChanged", $.proxy(function() {
	            control.option("value", this._isSelected($itemElement));
	            this._updateSelectAllState()
	        }, this))
	    },
	    _updateSelectAllState: function() {
	        if (!this._$selectAll) {
	            return
	        }
	        this._selectAllCheckBox.option("value", this._list.isSelectAll())
	    },
	    handleDataSourceChanged: function() {
	        this._updateSelectAllState()
	    },
	    afterRender: function() {
	        if ("all" !== this._list.option("selectionMode")) {
	            return
	        }
	        if (!this._$selectAll) {
	            this._renderSelectAll()
	        }
	    },
	    _renderSelectAll: function() {
	        var $selectAll = this._$selectAll = $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CLASS);
	        this._selectAllCheckBox = this._list._createComponent($("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS).appendTo($selectAll), CheckBox);
	        $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS).text(this._list.option("selectAllText")).appendTo($selectAll);
	        this._list.itemsContainer().prepend($selectAll);
	        this._updateSelectAllState();
	        this._attachSelectAllHandler()
	    },
	    _attachSelectAllHandler: function() {
	        this._selectAllCheckBox.option("onValueChanged", $.proxy(this._selectAllHandler, this));
	        this._$selectAll.off(CLICK_EVENT_NAME).on(CLICK_EVENT_NAME, $.proxy(this._selectAllClickHandler, this))
	    },
	    _selectAllHandler: function(e) {
	        e.jQueryEvent && e.jQueryEvent.stopPropagation();
	        var isSelectedAll = this._selectAllCheckBox.option("value");
	        var result = this._list._createActionByOption("onSelectAllValueChanged")({
	            value: isSelectedAll
	        });
	        if (false === result) {
	            return
	        }
	        if (true === isSelectedAll) {
	            this._selectAllItems()
	        } else {
	            if (false === isSelectedAll) {
	                this._unselectAllItems()
	            }
	        }
	    },
	    _selectAllItems: function() {
	        this._list._selection.selectAll("page" === this._list.option("selectAllMode"))
	    },
	    _unselectAllItems: function() {
	        this._list._selection.deselectAll("page" === this._list.option("selectAllMode"))
	    },
	    _selectAllClickHandler: function() {
	        this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"))
	    },
	    _isSelected: function($itemElement) {
	        return this._list.isItemSelected($itemElement)
	    },
	    _processCheckedState: function($itemElement, checked) {
	        if (checked) {
	            this._list.selectItem($itemElement)
	        } else {
	            this._list.unselectItem($itemElement)
	        }
	    },
	    dispose: function() {
	        this._disposeSelectAll();
	        this._list.element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
	        this.callBase.apply(this, arguments)
	    },
	    _disposeSelectAll: function() {
	        if (this._$selectAll) {
	            this._$selectAll.remove();
	            this._$selectAll = null
	        }
	    }
	}));


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/check_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    inkRipple = __webpack_require__(115),
	    Editor = __webpack_require__(95),
	    registerComponent = __webpack_require__(44),
	    eventUtils = __webpack_require__(61),
	    themes = __webpack_require__(112),
	    clickEvent = __webpack_require__(65);
	var CHECKBOX_CLASS = "dx-checkbox",
	    CHECKBOX_ICON_CLASS = "dx-checkbox-icon",
	    CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked",
	    CHECKBOX_CONTAINER_CLASS = "dx-checkbox-container",
	    CHECKBOX_TEXT_CLASS = "dx-checkbox-text",
	    CHECKBOX_HAS_TEXT_CLASS = "dx-checkbox-has-text",
	    CHECKBOX_INDETERMINATE_CLASS = "dx-checkbox-indeterminate",
	    CHECKBOX_FEEDBACK_HIDE_TIMEOUT = 100;
	var CheckBox = Editor.inherit({
	    _supportedKeys: function() {
	        var click = function(e) {
	            e.preventDefault();
	            this._clickAction({
	                jQueryEvent: e
	            })
	        };
	        return $.extend(this.callBase(), {
	            space: click
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            hoverStateEnabled: true,
	            activeStateEnabled: true,
	            value: false,
	            text: "",
	            useInkRipple: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                useInkRipple: true
	            }
	        }])
	    },
	    _feedbackHideTimeout: CHECKBOX_FEEDBACK_HIDE_TIMEOUT,
	    _render: function() {
	        this._renderSubmitElement();
	        this.callBase();
	        this._$container = $("<div>").addClass(CHECKBOX_CONTAINER_CLASS);
	        this.setAria("role", "checkbox");
	        this._renderClick();
	        this._renderValue();
	        this._renderIcon();
	        this._renderText();
	        this.option("useInkRipple") && this._renderInkRipple();
	        this.element().addClass(CHECKBOX_CLASS).append(this._$container)
	    },
	    _renderSubmitElement: function() {
	        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
	    },
	    _getSubmitElement: function() {
	        return this._$submitElement
	    },
	    _renderInkRipple: function() {
	        this._inkRipple = inkRipple.render({
	            waveSizeCoefficient: 2.5,
	            useHoldAnimation: false,
	            wavesNumber: 2,
	            isCentered: true
	        })
	    },
	    _renderInkWave: function(element, jQueryEvent, doRender, waveIndex) {
	        if (!this._inkRipple) {
	            return
	        }
	        var config = {
	            element: element,
	            jQueryEvent: jQueryEvent,
	            wave: waveIndex
	        };
	        if (doRender) {
	            this._inkRipple.showWave(config)
	        } else {
	            this._inkRipple.hideWave(config)
	        }
	    },
	    _updateFocusState: function(e, value) {
	        this.callBase.apply(this, arguments);
	        this._renderInkWave(this._$icon, e, value, 0)
	    },
	    _toggleActiveState: function($element, value, e) {
	        this.callBase.apply(this, arguments);
	        this._renderInkWave(this._$icon, e, value, 1)
	    },
	    _renderIcon: function() {
	        this._$icon = $("<span>").addClass(CHECKBOX_ICON_CLASS).prependTo(this._$container)
	    },
	    _renderText: function() {
	        var textValue = this.option("text");
	        if (!textValue) {
	            if (this._$text) {
	                this._$text.remove();
	                this.element().removeClass(CHECKBOX_HAS_TEXT_CLASS)
	            }
	            return
	        }
	        if (!this._$text) {
	            this._$text = $("<span>").addClass(CHECKBOX_TEXT_CLASS)
	        }
	        this._$text.text(textValue);
	        this._$container.append(this._$text);
	        this.element().addClass(CHECKBOX_HAS_TEXT_CLASS)
	    },
	    _renderClick: function() {
	        var that = this,
	            eventName = eventUtils.addNamespace(clickEvent.name, that.NAME);
	        that._clickAction = that._createAction(that._clickHandler);
	        that.element().off(eventName).on(eventName, function(e) {
	            that._clickAction({
	                jQueryEvent: e
	            })
	        })
	    },
	    _clickHandler: function(args) {
	        var that = args.component;
	        that._saveValueChangeEvent(args.jQueryEvent);
	        that.option("value", !that.option("value"))
	    },
	    _renderValue: function() {
	        var $element = this.element(),
	            checked = this.option("value"),
	            indeterminate = void 0 === checked;
	        $element.toggleClass(CHECKBOX_CHECKED_CLASS, Boolean(checked));
	        $element.toggleClass(CHECKBOX_INDETERMINATE_CLASS, indeterminate);
	        this._$submitElement.val(checked);
	        this.setAria("checked", indeterminate ? "mixed" : checked || "false")
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "useInkRipple":
	                this._invalidate();
	                break;
	            case "value":
	                this._renderValue();
	                this.callBase(args);
	                break;
	            case "text":
	                this._renderText();
	                this._renderDimensions();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxCheckBox", CheckBox);
	module.exports = CheckBox;
	module.exports.default = module.exports;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/radio_group/radio_button.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    inkRipple = __webpack_require__(115),
	    registerComponent = __webpack_require__(44),
	    Editor = __webpack_require__(95),
	    eventUtils = __webpack_require__(61),
	    themes = __webpack_require__(112),
	    clickEvent = __webpack_require__(65);
	var RADIO_BUTTON_CLASS = "dx-radiobutton",
	    RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon",
	    RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot",
	    RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked";
	var RadioButton = Editor.inherit({
	    _supportedKeys: function() {
	        var click = function(e) {
	            e.preventDefault();
	            this._clickAction({
	                jQueryEvent: e
	            })
	        };
	        return $.extend(this.callBase(), {
	            space: click
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            hoverStateEnabled: true,
	            activeStateEnabled: true,
	            value: false,
	            useInkRipple: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                useInkRipple: true
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(RADIO_BUTTON_CLASS)
	    },
	    _render: function() {
	        this.callBase();
	        this._renderIcon();
	        this.option("useInkRipple") && this._renderInkRipple();
	        this._renderCheckedState(this.option("value"));
	        this._renderClick();
	        this.setAria("role", "radio")
	    },
	    _renderInkRipple: function() {
	        this._inkRipple = inkRipple.render({
	            waveSizeCoefficient: 3.3,
	            useHoldAnimation: false,
	            wavesNumber: 2,
	            isCentered: true
	        })
	    },
	    _renderInkWave: function(element, jQueryEvent, doRender, waveIndex) {
	        if (!this._inkRipple) {
	            return
	        }
	        var config = {
	            element: element,
	            jQueryEvent: jQueryEvent,
	            wave: waveIndex
	        };
	        if (doRender) {
	            this._inkRipple.showWave(config)
	        } else {
	            this._inkRipple.hideWave(config)
	        }
	    },
	    _updateFocusState: function(e, value) {
	        this.callBase.apply(this, arguments);
	        this._renderInkWave(this._$icon, e, value, 0)
	    },
	    _toggleActiveState: function($element, value, e) {
	        this.callBase.apply(this, arguments);
	        this._renderInkWave(this._$icon, e, value, 1)
	    },
	    _renderIcon: function() {
	        this._$icon = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
	        $("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo(this._$icon);
	        this.element().append(this._$icon)
	    },
	    _renderCheckedState: function(checked) {
	        this.element().toggleClass(RADIO_BUTTON_CHECKED_CLASS, checked);
	        this.setAria("checked", checked)
	    },
	    _renderClick: function() {
	        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
	        this._clickAction = this._createAction($.proxy(function(args) {
	            this._clickHandler(args.jQueryEvent)
	        }, this));
	        this.element().off(eventName).on(eventName, $.proxy(function(e) {
	            this._clickAction({
	                jQueryEvent: e
	            })
	        }, this))
	    },
	    _clickHandler: function(e) {
	        this._saveValueChangeEvent(e);
	        this.option("value", true)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "useInkRipple":
	                this._invalidate();
	                break;
	            case "value":
	                this._renderCheckedState(args.value);
	                this.callBase(args);
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxRadioButton", RadioButton);
	module.exports = RadioButton;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/list/ui.list.edit.decorator.reorder.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    translator = __webpack_require__(59),
	    fx = __webpack_require__(58),
	    dragEvents = __webpack_require__(98),
	    support = __webpack_require__(48),
	    mathUtils = __webpack_require__(77),
	    Animator = __webpack_require__(160),
	    eventUtils = __webpack_require__(61),
	    registerDecorator = __webpack_require__(194).register,
	    EditDecorator = __webpack_require__(196);
	var ReorderScrollAnimator = Animator.inherit({
	    ctor: function(strategy) {
	        this.callBase();
	        this._strategy = strategy
	    },
	    _isFinished: function() {
	        return this._strategy.scrollFinished()
	    },
	    _step: function() {
	        this._strategy.scrollByStep()
	    }
	});
	var LIST_EDIT_DECORATOR = "dxListEditDecorator",
	    DRAG_START_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, LIST_EDIT_DECORATOR),
	    DRAG_UPDATE_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, LIST_EDIT_DECORATOR),
	    DRAG_END_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, LIST_EDIT_DECORATOR),
	    REORDER_HANDLE_CONTAINER_CLASS = "dx-list-reorder-handle-container",
	    REORDER_HANDLE_CLASS = "dx-list-reorder-handle",
	    REOREDERING_ITEM_CLASS = "dx-list-item-reordering",
	    REOREDERING_ITEM_GHOST_CLASS = "dx-list-item-ghost-reordering",
	    LIST_REORDER_COMPATIBILITY_MODE_CLASS = "dx-list-reorder-compatibility-mode";
	registerDecorator("reorder", "default", EditDecorator.inherit({
	    _init: function() {
	        this._groupedEnabled = this._list.option("grouped");
	        this._initAnimator()
	    },
	    _initAnimator: function() {
	        this._scrollAnimator = new ReorderScrollAnimator(this)
	    },
	    _startAnimator: function() {
	        if (!this._scrollAnimator.inProgress()) {
	            this._scrollAnimator.start()
	        }
	    },
	    _stopAnimator: function() {
	        this._scrollAnimator.stop()
	    },
	    afterBag: function(config) {
	        var $itemElement = config.$itemElement,
	            $container = config.$container;
	        var $handle = $("<div>").addClass(REORDER_HANDLE_CLASS);
	        var lockedDrag = false;
	        $handle.on("dxpointerdown", function(e) {
	            lockedDrag = !eventUtils.isMouseEvent(e)
	        });
	        $handle.on("dxhold", {
	            timeout: 30
	        }, function(e) {
	            e.cancel = true;
	            lockedDrag = false
	        });
	        $handle.on(DRAG_START_EVENT_NAME, {
	            direction: "vertical",
	            immediate: true
	        }, $.proxy(function(e) {
	            if (lockedDrag) {
	                e.cancel = true;
	                return
	            }
	            this._dragStartHandler($itemElement, e)
	        }, this));
	        $handle.on(DRAG_UPDATE_EVENT_NAME, $.proxy(this._dragHandler, this, $itemElement));
	        $handle.on(DRAG_END_EVENT_NAME, $.proxy(this._dragEndHandler, this, $itemElement));
	        $container.addClass(REORDER_HANDLE_CONTAINER_CLASS);
	        $container.append($handle)
	    },
	    _dragStartHandler: function($itemElement, e) {
	        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
	            e.cancel = true;
	            return
	        }
	        this._stopPreviousAnimation();
	        e.targetElements = [];
	        this._cacheItemsPositions();
	        this._startPointerOffset = e.pageY - $itemElement.offset().top;
	        this._elementHeight = $itemElement.outerHeight();
	        var itemIndex = this._list.getFlatIndexByItemElement($itemElement);
	        this._startIndex = itemIndex;
	        this._lastIndex = itemIndex;
	        this._cacheScrollData();
	        this._toggleCompatibilityMode(true);
	        var that = this;
	        this._createGhostTimeout = setTimeout(function() {
	            that._createGhost($itemElement);
	            that._updateGhostPosition();
	            $itemElement.addClass(REOREDERING_ITEM_CLASS)
	        })
	    },
	    _stopPreviousAnimation: function() {
	        fx.stop(this._$ghostItem, true)
	    },
	    _toggleCompatibilityMode: function(enabled) {
	        this._list.element().toggleClass(LIST_REORDER_COMPATIBILITY_MODE_CLASS, !support.transform && enabled)
	    },
	    _cacheItemsPositions: function() {
	        var itemPositions = this._itemPositions = [];
	        $.each(this._list.itemElements(), function(index, item) {
	            var cachedPosition = null;
	            itemPositions.push(function() {
	                cachedPosition = null === cachedPosition ? $(item).position().top : cachedPosition;
	                return cachedPosition
	            })
	        })
	    },
	    _getDraggingElementPosition: function() {
	        return this._itemPositions[this._startIndex]()
	    },
	    _getLastElementPosition: function() {
	        return this._itemPositions[this._lastIndex]()
	    },
	    _cacheScrollData: function() {
	        this._list.updateDimensions();
	        this._startScrollTop = this._list.scrollTop();
	        this._scrollOffset = 0;
	        this._scrollHeight = this._list.scrollHeight();
	        this._clientHeight = this._list.clientHeight()
	    },
	    _scrollTop: function() {
	        return this._startScrollTop + this._scrollOffset
	    },
	    _createGhost: function($itemElement) {
	        this._$ghostItem = $itemElement.clone();
	        this._$ghostItem.addClass(REOREDERING_ITEM_GHOST_CLASS).appendTo(this._list.itemsContainer());
	        this._startGhostPosition = this._getDraggingElementPosition() - this._$ghostItem.position().top;
	        translator.move(this._$ghostItem, {
	            top: this._startGhostPosition
	        })
	    },
	    _dragHandler: function($itemElement, e) {
	        this._topOffset = e.offset.y;
	        this._updateItemPositions();
	        var pointerPosition = this._getPointerPosition();
	        this._toggleScroll(pointerPosition)
	    },
	    _getPointerPosition: function() {
	        return this._getDraggingElementPosition() + this._startPointerOffset + this._scrollOffset + this._topOffset
	    },
	    _toggleScroll: function(pointerPosition) {
	        if (this._scrollHeight <= this._clientHeight) {
	            return
	        }
	        var minOffset = .7 * this._elementHeight,
	            topOffset = this._clientHeight - (pointerPosition - this._scrollTop()),
	            topOffsetRatio = topOffset / minOffset,
	            bottomOffset = pointerPosition - this._scrollTop(),
	            bottomOffsetRatio = bottomOffset / minOffset;
	        if (topOffsetRatio < 1) {
	            this._stepSize = this._adjustRationIntoRange(topOffsetRatio);
	            this._startAnimator()
	        } else {
	            if (bottomOffsetRatio < 1) {
	                this._stepSize = -this._adjustRationIntoRange(bottomOffsetRatio);
	                this._startAnimator()
	            } else {
	                this._stopAnimator()
	            }
	        }
	    },
	    _adjustRationIntoRange: function(ratio) {
	        return mathUtils.fitIntoRange(Math.round(7 * Math.abs(ratio - 1)), 1, 7)
	    },
	    _updateItemPositions: function() {
	        this._updateGhostPosition();
	        this._updateOthersPositions()
	    },
	    _updateGhostPosition: function() {
	        if (!this._$ghostItem) {
	            return
	        }
	        translator.move(this._$ghostItem, {
	            top: this._startGhostPosition + this._scrollOffset + this._topOffset
	        })
	    },
	    _updateOthersPositions: function() {
	        var currentIndex = this._findItemIndexByPosition(this._getPointerPosition());
	        if (this._lastIndex === currentIndex || this._groupedEnabled && !this._sameParent(currentIndex)) {
	            return
	        }
	        var currentIndexOffset = currentIndex - this._startIndex,
	            currentDirection = mathUtils.sign(currentIndexOffset),
	            minIndex = Math.min(currentIndex, this._lastIndex),
	            maxIndex = Math.max(currentIndex, this._lastIndex);
	        for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
	            if (itemIndex === this._startIndex) {
	                continue
	            }
	            var $item = this._list.getItemElementByFlatIndex(itemIndex),
	                itemIndexOffset = itemIndex - this._startIndex,
	                itemDirection = mathUtils.sign(itemIndexOffset),
	                offsetsDifference = Math.abs(itemIndexOffset) <= Math.abs(currentIndexOffset),
	                sameDirections = currentDirection === itemDirection,
	                setupPosition = offsetsDifference && sameDirections,
	                resetPosition = !offsetsDifference || !sameDirections;
	            fx.stop($item);
	            if (setupPosition) {
	                fx.animate($item, {
	                    type: "slide",
	                    to: {
	                        top: this._elementHeight * -currentDirection
	                    },
	                    duration: 300
	                })
	            }
	            if (resetPosition) {
	                fx.animate($item, {
	                    type: "slide",
	                    to: {
	                        top: 0
	                    },
	                    duration: 300
	                })
	            }
	        }
	        this._lastIndex = currentIndex
	    },
	    _sameParent: function(index) {
	        var $dragging = this._list.getItemElementByFlatIndex(this._startIndex),
	            $over = this._list.getItemElementByFlatIndex(index);
	        return $over.parent().get(0) === $dragging.parent().get(0)
	    },
	    scrollByStep: function() {
	        this._scrollOffset += this._stepSize;
	        this._list.scrollBy(this._stepSize);
	        this._updateItemPositions()
	    },
	    scrollFinished: function() {
	        var scrollTop = this._scrollTop(),
	            rejectScrollTop = scrollTop <= 0 && this._stepSize < 0,
	            rejectScrollBottom = scrollTop >= this._scrollHeight - this._clientHeight && this._stepSize > 0;
	        return rejectScrollTop || rejectScrollBottom
	    },
	    _dragEndHandler: function($itemElement) {
	        this._scrollAnimator.stop();
	        fx.animate(this._$ghostItem, {
	            type: "slide",
	            to: {
	                top: this._startGhostPosition + this._getLastElementPosition() - this._getDraggingElementPosition()
	            },
	            duration: 300
	        }).done($.proxy(function() {
	            $itemElement.removeClass(REOREDERING_ITEM_CLASS);
	            this._resetPositions();
	            this._list.reorderItem($itemElement, this._list.getItemElementByFlatIndex(this._lastIndex));
	            this._deleteGhost();
	            this._toggleCompatibilityMode(false)
	        }, this))
	    },
	    _deleteGhost: function() {
	        if (!this._$ghostItem) {
	            return
	        }
	        this._$ghostItem.remove()
	    },
	    _resetPositions: function() {
	        var minIndex = Math.min(this._startIndex, this._lastIndex),
	            maxIndex = Math.max(this._startIndex, this._lastIndex);
	        for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
	            var $item = this._list.getItemElementByFlatIndex(itemIndex);
	            translator.resetPosition($item)
	        }
	    },
	    _findItemIndexByPosition: function(position) {
	        var minIndex = 0;
	        var maxIndex = this._itemPositions.length - 1;
	        var currentIndex;
	        var currentPosition;
	        while (minIndex <= maxIndex) {
	            currentIndex = (minIndex + maxIndex) / 2 | 0;
	            currentPosition = this._itemPositions[currentIndex]();
	            if (currentPosition < position) {
	                minIndex = currentIndex + 1
	            } else {
	                if (currentPosition > position) {
	                    maxIndex = currentIndex - 1
	                } else {
	                    return currentIndex
	                }
	            }
	        }
	        return mathUtils.fitIntoRange(minIndex, 0, Math.max(maxIndex, 0))
	    },
	    dispose: function() {
	        clearTimeout(this._createGhostTimeout);
	        this.callBase.apply(this, arguments)
	    }
	}));


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.strategy.list_bottom.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ListStrategy = __webpack_require__(208),
	    Swipeable = __webpack_require__(209);
	var ListBottomStrategy = ListStrategy.inherit({
	    NAME: "listBottom",
	    _renderWidget: function() {
	        this._renderContainerSwipe();
	        this.callBase();
	        this._toolbar._$toolbarItemsContainer.prependTo(this._listOverlay.content())
	    },
	    _renderContainerSwipe: function() {
	        this._toolbar._createComponent(this._toolbar._$toolbarItemsContainer, Swipeable, {
	            elastic: false,
	            onStart: $.proxy(this._swipeStartHandler, this),
	            onUpdated: $.proxy(this._swipeUpdateHandler, this),
	            onEnd: $.proxy(this._swipeEndHandler, this),
	            itemSizeFunc: $.proxy(this._getListHeight, this),
	            direction: "vertical"
	        })
	    },
	    _swipeStartHandler: function(e) {
	        e.jQueryEvent.maxTopOffset = this._menuShown ? 0 : 1;
	        e.jQueryEvent.maxBottomOffset = this._menuShown ? 1 : 0
	    },
	    _swipeUpdateHandler: function(e) {
	        var offset = this._menuShown ? e.jQueryEvent.offset : 1 + e.jQueryEvent.offset;
	        this._renderMenuPosition(offset, false)
	    },
	    _swipeEndHandler: function(e) {
	        var targetOffset = e.jQueryEvent.targetOffset;
	        targetOffset -= this._menuShown - 1;
	        this._toggleMenu(0 === targetOffset, true)
	    }
	});
	module.exports = ListBottomStrategy;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.strategy.list_base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ToolbarStrategy = __webpack_require__(176),
	    translator = __webpack_require__(59),
	    hideTopOverlayCallback = __webpack_require__(53).hideCallback,
	    fx = __webpack_require__(58),
	    Overlay = __webpack_require__(97),
	    List = __webpack_require__(181);
	var TOOLBAR_LIST_VISIBLE_CLASS = "dx-toolbar-list-visible",
	    SUBMENU_ANIMATION_EASING = "easeOutCubic",
	    SUBMENU_HIDE_DURATION = 200,
	    SUBMENU_SHOW_DURATION = 400;
	var ListStrategy = ToolbarStrategy.inherit({
	    render: function() {
	        this._renderListOverlay();
	        this.callBase();
	        this._changeListVisible(this._toolbar.option("visible"))
	    },
	    _renderWidget: function() {
	        if (!this._hasVisibleMenuItems()) {
	            return
	        }
	        this.callBase()
	    },
	    _menuWidgetClass: function() {
	        return List
	    },
	    _menuContainer: function() {
	        return this._listOverlay.content()
	    },
	    _menuButtonOptions: function() {
	        return $.extend({}, this.callBase(), {
	            activeStateEnabled: false,
	            text: "..."
	        })
	    },
	    _widgetOptions: function() {
	        return $.extend({}, this.callBase(), {
	            width: "100%",
	            indicateLoading: false
	        })
	    },
	    _renderListOverlay: function() {
	        var $listOverlay = $("<div>").appendTo(this._toolbar.element());
	        this._listOverlay = this._toolbar._createComponent($listOverlay, Overlay, this._listOverlayConfig())
	    },
	    _listOverlayConfig: function() {
	        return {
	            container: false,
	            deferRendering: false,
	            shading: false,
	            height: "auto",
	            width: "100%",
	            showTitle: false,
	            closeOnOutsideClick: $.proxy(this._listOutsideClickHandler, this),
	            position: null,
	            animation: null,
	            closeOnBackButton: false
	        }
	    },
	    _listOutsideClickHandler: function(e) {
	        if (!$(e.target).closest(this._listOverlay.content()).length) {
	            this._toggleMenu(false, true)
	        }
	    },
	    _getListHeight: function() {
	        var listHeight = this._listOverlay.content().find(".dx-list").height(),
	            semiHiddenHeight = this._toolbar._$toolbarItemsContainer.height() - this._toolbar.element().height();
	        return listHeight + semiHiddenHeight
	    },
	    _hideTopOverlayHandler: function() {
	        this._toggleMenu(false, true)
	    },
	    _toggleHideTopOverlayCallback: function() {
	        if (this._closeCallback) {
	            hideTopOverlayCallback.remove(this._closeCallback)
	        }
	        if (this._menuShown) {
	            this._closeCallback = $.proxy(this._hideTopOverlayHandler, this);
	            hideTopOverlayCallback.add(this._closeCallback)
	        }
	    },
	    _calculatePixelOffset: function(offset) {
	        offset = (offset || 0) - 1;
	        var maxOffset = this._getListHeight();
	        return offset * maxOffset
	    },
	    _renderMenuPosition: function(offset, animate) {
	        var pos = this._calculatePixelOffset(offset),
	            element = this._listOverlay.content();
	        if (animate) {
	            return this._animateMenuToggling(element, pos, this._menuShown)
	        }
	        translator.move(element, {
	            top: pos
	        });
	        return $.Deferred().resolve().promise()
	    },
	    _animateMenuToggling: function($element, position, isShowAnimation) {
	        var duration = isShowAnimation ? SUBMENU_SHOW_DURATION : SUBMENU_HIDE_DURATION;
	        return fx.animate($element, {
	            type: "slide",
	            to: {
	                top: position
	            },
	            easing: SUBMENU_ANIMATION_EASING,
	            duration: duration
	        })
	    },
	    _toggleMenu: function(visible, animate) {
	        this.callBase.apply(this, arguments);
	        this._toggleHideTopOverlayCallback();
	        this._renderMenuPosition(this._menuShown ? 0 : 1, animate).done($.proxy(function() {
	            this._toolbar.element().toggleClass(TOOLBAR_LIST_VISIBLE_CLASS, visible)
	        }, this))
	    },
	    _changeListVisible: function(value) {
	        if (this._listOverlay) {
	            this._listOverlay.option("visible", value);
	            this._toggleMenu(false, false)
	        }
	    },
	    handleToolbarVisibilityChange: function(value) {
	        this._changeListVisible(value)
	    }
	});
	module.exports = ListStrategy;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/gesture/swipeable.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    swipeEvents = __webpack_require__(182),
	    DOMComponent = __webpack_require__(28),
	    eventUtils = __webpack_require__(61),
	    publicComponentUtils = __webpack_require__(30);
	var DX_SWIPEABLE = "dxSwipeable",
	    SWIPEABLE_CLASS = "dx-swipeable",
	    ACTION_TO_EVENT_MAP = {
	        onStart: swipeEvents.start,
	        onUpdated: swipeEvents.swipe,
	        onEnd: swipeEvents.end,
	        onCancel: "dxswipecancel"
	    };
	var Swipeable = DOMComponent.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            elastic: true,
	            immediate: false,
	            direction: "horizontal",
	            itemSizeFunc: null,
	            onStart: null,
	            onUpdated: null,
	            onEnd: null,
	            onCancel: null
	        })
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(SWIPEABLE_CLASS);
	        this._attachEventHandlers()
	    },
	    _attachEventHandlers: function() {
	        this._detachEventHandlers();
	        if (this.option("disabled")) {
	            return
	        }
	        var NAME = this.NAME;
	        this._createEventData();
	        $.each(ACTION_TO_EVENT_MAP, $.proxy(function(actionName, eventName) {
	            var action = this._createActionByOption(actionName, {
	                context: this
	            });
	            eventName = eventUtils.addNamespace(eventName, NAME);
	            this.element().on(eventName, this._eventData, function(e) {
	                return action({
	                    jQueryEvent: e
	                })
	            })
	        }, this))
	    },
	    _createEventData: function() {
	        this._eventData = {
	            elastic: this.option("elastic"),
	            itemSizeFunc: this.option("itemSizeFunc"),
	            direction: this.option("direction"),
	            immediate: this.option("immediate")
	        }
	    },
	    _detachEventHandlers: function() {
	        this.element().off("." + DX_SWIPEABLE)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "disabled":
	            case "onStart":
	            case "onUpdated":
	            case "onEnd":
	            case "onCancel":
	            case "elastic":
	            case "immediate":
	            case "itemSizeFunc":
	            case "direction":
	                this._detachEventHandlers();
	                this._attachEventHandlers();
	                break;
	            case "rtlEnabled":
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	publicComponentUtils.name(Swipeable, DX_SWIPEABLE);
	module.exports = Swipeable;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/toolbar/ui.toolbar.strategy.list_top.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    ListStrategy = __webpack_require__(208),
	    translator = __webpack_require__(59);
	var ListTopStrategy = ListStrategy.inherit({
	    NAME: "listTop",
	    _listOverlayConfig: function() {
	        var config = this.callBase();
	        return $.extend({}, config, {
	            onContentReady: $.proxy(this._setItemsContainerZIndex, this)
	        })
	    },
	    _setItemsContainerZIndex: function(e) {
	        var overlayZIndex = e.component.content().css("z-index");
	        this._toolbar._$toolbarItemsContainer.css("z-index", overlayZIndex + 1)
	    },
	    _renderMenuPosition: function(offset, animate) {
	        var $element = this._toolbar._$toolbarItemsContainer;
	        var pos = this._calculateItemsContainerOffset(offset);
	        if (animate) {
	            this._animateMenuToggling($element, pos, this._menuShown)
	        } else {
	            translator.move($element, {
	                top: pos
	            })
	        }
	        return this.callBase(offset, animate)
	    },
	    _calculateItemsContainerOffset: function(offset) {
	        offset = (offset || 0) - 1;
	        var maxOffset = this._getItemsContainerHeight();
	        return offset * maxOffset
	    },
	    _getItemsContainerHeight: function() {
	        var semiHiddenHeight = this._toolbar._$toolbarItemsContainer.height() - this._toolbar.element().height();
	        return semiHiddenHeight
	    },
	    _listOutsideClickHandler: function(e) {
	        var $target = $(e.target);
	        var isOverlayClick = $target.closest(this._listOverlay.content()).length > 0;
	        var isItemsContainerClick = $target.closest(this._toolbar._$toolbarItemsContainer).length > 0;
	        if (!isOverlayClick && !isItemsContainerClick) {
	            this._toggleMenu(false, true)
	        }
	    }
	});
	module.exports = ListTopStrategy;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.state_storing.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    commonUtils = __webpack_require__(8),
	    stateStoringCore = __webpack_require__(212),
	    equalByValue = commonUtils.equalByValue;
	var processLoadState = function(that) {
	    var columnsController = that.getController("columns"),
	        selectionController = that.getController("selection"),
	        exportController = that.getController("export"),
	        dataController = that.getController("data"),
	        pagerView = that.getView("pagerView");
	    if (columnsController) {
	        columnsController.columnsChanged.add(function() {
	            var columnsState = columnsController.getUserState(),
	                columnsStateHash = commonUtils.getKeyHash(columnsState),
	                currentColumnsStateHash = commonUtils.getKeyHash(that._state.columns);
	            if (!equalByValue(currentColumnsStateHash, columnsStateHash)) {
	                $.extend(that._state, {
	                    columns: columnsState
	                });
	                that.isEnabled() && that.save()
	            }
	        })
	    }
	    if (selectionController) {
	        selectionController.selectionChanged.add(function(e) {
	            $.extend(that._state, {
	                selectedRowKeys: e.selectedRowKeys,
	                selectionFilter: e.selectionFilter
	            });
	            that.isEnabled() && that.save()
	        })
	    }
	    if (dataController) {
	        that._initialPageSize = that.option("paging.pageSize");
	        dataController.changed.add(function() {
	            $.extend(that._state, {
	                searchText: that.option("searchPanel.text"),
	                pageIndex: dataController.pageIndex(),
	                pageSize: dataController.pageSize(),
	                allowedPageSizes: pagerView ? pagerView.getPageSizes() : void 0
	            });
	            that.isEnabled() && that.save()
	        })
	    }
	    if (exportController) {
	        exportController.selectionOnlyChanged.add(function() {
	            $.extend(that._state, {
	                exportSelectionOnly: exportController.selectionOnly()
	            });
	            that.isEnabled() && that.save()
	        })
	    }
	};
	var applyState = function(that, state) {
	    var allowedPageSizes = state.allowedPageSizes,
	        searchText = state.searchText,
	        selectedRowKeys = state.selectedRowKeys,
	        selectionFilter = state.selectionFilter,
	        exportController = that.getController("export"),
	        columnsController = that.getController("columns"),
	        scrollingMode = that.option("scrolling.mode");
	    that.component.beginUpdate();
	    if (columnsController) {
	        columnsController.setUserState(state.columns)
	    }
	    if (exportController) {
	        exportController.selectionOnly(state.exportSelectionOnly)
	    }
	    that.option("selectedRowKeys", selectedRowKeys || []);
	    that.option("selectionFilter", selectionFilter);
	    if (allowedPageSizes && "auto" === that.option("pager.allowedPageSizes")) {
	        that.option("pager").allowedPageSizes = allowedPageSizes
	    }
	    that.component.endUpdate();
	    that.option("searchPanel.text", searchText || "");
	    that.option("paging.pageSize", "virtual" !== scrollingMode && "infinite" !== scrollingMode && state.pageSize ? state.pageSize : that._initialPageSize);
	    that.option("paging.pageIndex", state.pageIndex || 0)
	};
	gridCore.registerModule("stateStoring", {
	    defaultOptions: function() {
	        return {
	            stateStoring: {
	                enabled: false,
	                storageKey: null,
	                type: "localStorage",
	                customLoad: null,
	                customSave: null,
	                savingTimeout: 2e3
	            }
	        }
	    },
	    controllers: {
	        stateStoring: stateStoringCore.StateStoringController
	    },
	    extenders: {
	        controllers: {
	            stateStoring: {
	                init: function() {
	                    this.callBase.apply(this, arguments);
	                    processLoadState(this)
	                },
	                state: function(state) {
	                    var result = this.callBase.apply(this, arguments);
	                    if (void 0 !== state) {
	                        applyState(this, $.extend({}, state))
	                    }
	                    return result
	                }
	            },
	            columns: {
	                getVisibleColumns: function() {
	                    var visibleColumns = this.callBase.apply(this, arguments),
	                        stateStoringController = this.getController("stateStoring");
	                    return stateStoringController.isEnabled() && !stateStoringController.isLoaded() ? [] : visibleColumns
	                }
	            },
	            data: {
	                _refreshDataSource: function() {
	                    var that = this,
	                        callBase = that.callBase,
	                        stateStoringController = that.getController("stateStoring");
	                    if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
	                        clearTimeout(that._restoreStateTimeoutID);
	                        that._restoreStateTimeoutID = setTimeout(function() {
	                            stateStoringController.load().always(function() {
	                                that._restoreStateTimeoutID = null;
	                                callBase.call(that)
	                            })
	                        })
	                    } else {
	                        if (!that._restoreStateTimeoutID) {
	                            callBase.call(that)
	                        }
	                    }
	                },
	                isLoading: function() {
	                    var that = this,
	                        stateStoringController = that.getController("stateStoring");
	                    return this.callBase() || stateStoringController.isLoading()
	                },
	                isLoaded: function() {
	                    return this.callBase() && !this._restoreStateTimeoutID
	                },
	                dispose: function() {
	                    clearTimeout(this._restoreStateTimeoutID);
	                    this.callBase()
	                }
	            }
	        }
	    }
	});


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/grid_core/ui.grid_core.state_storing.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    modules = __webpack_require__(145),
	    errors = __webpack_require__(15),
	    browser = __webpack_require__(16),
	    sessionStorage = __webpack_require__(41).sessionStorage,
	    commonUtils = __webpack_require__(8);
	var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
	var parseDates = function(state) {
	    if (!state) {
	        return
	    }
	    $.each(state, function(key, value) {
	        var date;
	        if ($.isPlainObject(value) || $.isArray(value)) {
	            parseDates(value)
	        } else {
	            if ("string" === typeof value) {
	                date = DATE_REGEX.exec(value);
	                if (date) {
	                    state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
	                }
	            }
	        }
	    })
	};
	exports.StateStoringController = modules.ViewController.inherit(function() {
	    var getStorage = function(options) {
	        var storage = "sessionStorage" === options.type ? sessionStorage() : localStorage;
	        if (!storage) {
	            if ("file:" === window.location.protocol && browser.msie) {
	                throw new Error("E1038")
	            } else {
	                throw new Error("E1007")
	            }
	        }
	        return storage
	    };
	    var getUniqueStorageKey = function(options) {
	        return commonUtils.isDefined(options.storageKey) ? options.storageKey : "storage"
	    };
	    return {
	        _loadState: function() {
	            var options = this.option("stateStoring");
	            if ("custom" === options.type) {
	                return options.customLoad && options.customLoad()
	            }
	            try {
	                return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)))
	            } catch (e) {
	                errors.log(e.message)
	            }
	        },
	        _saveState: function(state) {
	            var options = this.option("stateStoring");
	            if ("custom" === options.type) {
	                options.customSave && options.customSave(state);
	                return
	            }
	            try {
	                getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
	            } catch (e) {}
	        },
	        publicMethods: function() {
	            return ["state"]
	        },
	        isEnabled: function() {
	            return this.option("stateStoring.enabled")
	        },
	        init: function() {
	            var that = this;
	            that._state = {};
	            that._isLoaded = false;
	            that._isLoading = false;
	            that._windowUnloadHandler = function() {
	                if (void 0 !== that._savingTimeoutID) {
	                    that._saveState(that.state())
	                }
	            };
	            $(window).on("unload", that._windowUnloadHandler);
	            return that
	        },
	        isLoaded: function() {
	            return this._isLoaded
	        },
	        isLoading: function() {
	            return this._isLoading
	        },
	        load: function() {
	            var loadResult, that = this;
	            that._isLoading = true;
	            loadResult = that._loadState();
	            if (!loadResult || !$.isFunction(loadResult.done)) {
	                loadResult = $.Deferred().resolve(loadResult)
	            }
	            loadResult.done(function(state) {
	                that._isLoaded = true;
	                that._isLoading = false;
	                that.state(state)
	            });
	            return loadResult
	        },
	        state: function(state) {
	            var that = this;
	            if (!arguments.length) {
	                return $.extend(true, {}, that._state)
	            } else {
	                that._state = $.extend({}, state);
	                parseDates(that._state)
	            }
	        },
	        save: function() {
	            var that = this;
	            clearTimeout(that._savingTimeoutID);
	            that._savingTimeoutID = setTimeout(function() {
	                that._saveState(that.state());
	                that._savingTimeoutID = void 0
	            }, that.option("stateStoring.savingTimeout"))
	        },
	        optionChanged: function(args) {
	            var that = this;
	            switch (args.name) {
	                case "stateStoring":
	                    if (that.isEnabled() && that.isLoaded()) {
	                        that.load()
	                    }
	                    args.handled = true;
	                    break;
	                default:
	                    that.callBase(args)
	            }
	        },
	        dispose: function() {
	            clearTimeout(this._savingTimeoutID);
	            $(window).off("unload", this._windowUnloadHandler)
	        }
	    }
	}());


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.selection.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    commonUtils = __webpack_require__(8),
	    support = __webpack_require__(48),
	    clickEvent = __webpack_require__(65),
	    messageLocalization = __webpack_require__(79),
	    eventUtils = __webpack_require__(61),
	    holdEvent = __webpack_require__(132),
	    Selection = __webpack_require__(137);
	var DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
	    DATAGRID_ROW_CLASS = "dx-row",
	    DATAGRID_ROW_SELECTION_CLASS = "dx-selection",
	    DATAGRID_SELECT_CHECKBOX_CLASS = "dx-select-checkbox",
	    DATAGRID_CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden",
	    DATAGRID_COMMAND_SELECT_CLASS = "dx-command-select",
	    DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled",
	    DATAGRID_DATA_ROW_CLASS = "dx-data-row";
	var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode",
	    SELECTION_MODE = "selection.mode";
	var processLongTap = function(that, jQueryEvent) {
	    var selectionController = that.getController("selection"),
	        rowsView = that.getView("rowsView"),
	        $row = $(jQueryEvent.target).closest("." + DATAGRID_DATA_ROW_CLASS),
	        rowIndex = rowsView.getRowIndex($row);
	    if (rowIndex < 0) {
	        return
	    }
	    if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE)) {
	        if (selectionController.isSelectionWithCheckboxes()) {
	            selectionController.stopSelectionWithCheckboxes()
	        } else {
	            selectionController.startSelectionWithCheckboxes()
	        }
	    } else {
	        if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
	            selectionController.startSelectionWithCheckboxes()
	        }
	        if ("always" !== that.option(SHOW_CHECKBOXES_MODE)) {
	            selectionController.changeItemSelection(rowIndex, {
	                control: true
	            })
	        }
	    }
	};
	exports.SelectionController = gridCore.Controller.inherit(function() {
	    var updateSelectColumn = function(that) {
	        var columnsController = that.getController("columns"),
	            isSelectColumnVisible = that.isSelectColumnVisible();
	        columnsController.addCommandColumn({
	            command: "select",
	            visible: isSelectColumnVisible,
	            visibleIndex: -1,
	            dataType: "boolean",
	            alignment: "center",
	            cssClass: DATAGRID_COMMAND_SELECT_CLASS,
	            width: "auto"
	        });
	        columnsController.columnOption("command:select", "visible", isSelectColumnVisible)
	    };
	    return {
	        init: function() {
	            var that = this,
	                dataController = that.getController("data"),
	                selectionOptions = that.option("selection") || {};
	            that._selectionMode = that.option(SELECTION_MODE);
	            that._isSelectionWithCheckboxes = false;
	            that._selection = that._createSelection({
	                selectedKeys: that.option("selectedRowKeys"),
	                mode: that._selectionMode,
	                deferred: selectionOptions.deferred,
	                maxFilterLengthInRequest: selectionOptions.maxFilterLengthInRequest,
	                selectionFilter: that.option("selectionFilter"),
	                key: function() {
	                    var store = dataController.store();
	                    return store && store.key()
	                },
	                keyOf: function(item) {
	                    var store = dataController.store();
	                    return store && store.keyOf(item)
	                },
	                dataFields: function() {
	                    return dataController.dataSource() && dataController.dataSource().select()
	                },
	                load: function(options) {
	                    return dataController.dataSource() && dataController.dataSource().load(options) || $.Deferred().resolve([])
	                },
	                plainItems: function() {
	                    return dataController.items()
	                },
	                isItemSelected: function(item) {
	                    return item.selected
	                },
	                isSelectableItem: function(item) {
	                    return item && "data" === item.rowType && !item.inserted
	                },
	                getItemData: function(item) {
	                    return item && (item.oldData || item.data || item)
	                },
	                filter: function() {
	                    return dataController.getCombinedFilter()
	                },
	                totalCount: function() {
	                    return dataController.totalCount()
	                },
	                onSelectionChanged: $.proxy(that._updateSelectedItems, this)
	            });
	            updateSelectColumn(that);
	            that.createAction("onSelectionChanged", {
	                excludeValidators: ["disabled", "readOnly"]
	            })
	        },
	        _createSelection: function(options) {
	            return new Selection(options)
	        },
	        _fireSelectionChanged: function() {
	            var argument = this.option("selection.deferred") ? {
	                selectionFilter: this.option("selectionFilter")
	            } : {
	                selectedRowKeys: this.option("selectedRowKeys")
	            };
	            this.selectionChanged.fire(argument)
	        },
	        _updateSelectedItems: function(args) {
	            var that = this,
	                dataController = that.getController("data"),
	                items = dataController.items();
	            if (!items) {
	                return
	            }
	            var isSelectionWithCheckboxes = that.isSelectionWithCheckboxes();
	            var changedItemIndexes = that.getChangedItemIndexes(items);
	            if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
	                if (args.selectedItemKeys.length > 1) {
	                    that.startSelectionWithCheckboxes()
	                } else {
	                    if (0 === args.selectedItemKeys.length && args.removedItemKeys.length) {
	                        that.stopSelectionWithCheckboxes()
	                    }
	                }
	            }
	            if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes()) {
	                dataController.updateItems({
	                    changeType: "updateSelection",
	                    itemIndexes: changedItemIndexes
	                })
	            }
	            if (this.option("selection.deferred")) {
	                that.option("selectionFilter", that._selection.selectionFilter());
	                that._fireSelectionChanged();
	                that.executeAction("onSelectionChanged", {})
	            }
	            if (args.addedItemKeys.length || args.removedItemKeys.length) {
	                that._selectedItemsInternalChange = true;
	                that.option("selectedRowKeys", args.selectedItemKeys.slice(0));
	                that._selectedItemsInternalChange = false;
	                that._fireSelectionChanged();
	                that.executeAction("onSelectionChanged", {
	                    selectedRowsData: args.selectedItems,
	                    selectedRowKeys: args.selectedItemKeys,
	                    currentSelectedRowKeys: args.addedItemKeys,
	                    currentDeselectedRowKeys: args.removedItemKeys
	                })
	            }
	        },
	        getChangedItemIndexes: function(items) {
	            var that = this,
	                itemIndexes = [],
	                isDeferredSelection = this.option("selection.deferred");
	            for (var i = 0, length = items.length; i < length; i++) {
	                var row = items[i];
	                var isItemSelected = that._selection.isItemSelected(isDeferredSelection ? row.data : row.key);
	                if (that._selection.isDataItem(row) && row.isSelected !== isItemSelected) {
	                    itemIndexes.push(i)
	                }
	            }
	            return itemIndexes
	        },
	        callbackNames: function() {
	            return ["selectionChanged"]
	        },
	        optionChanged: function(args) {
	            var that = this;
	            that.callBase(args);
	            switch (args.name) {
	                case "selection":
	                    var oldSelectionMode = that._selectionMode;
	                    that.init();
	                    var selectionMode = that._selectionMode;
	                    var selectedRowKeys = that.option("selectedRowKeys");
	                    if (oldSelectionMode !== selectionMode) {
	                        if ("single" === selectionMode) {
	                            if (selectedRowKeys.length > 1) {
	                                selectedRowKeys = [selectedRowKeys[0]]
	                            }
	                        } else {
	                            if ("multiple" !== selectionMode) {
	                                selectedRowKeys = []
	                            }
	                        }
	                    }
	                    that.selectRows(selectedRowKeys).always(function() {
	                        that._fireSelectionChanged()
	                    });
	                    that.getController("columns").updateColumns();
	                    args.handled = true;
	                    break;
	                case "selectionFilter":
	                    this._selection.selectionFilter(args.value);
	                    args.handled = true;
	                    break;
	                case "selectedRowKeys":
	                    if (commonUtils.isArray(args.value) && !that._selectedItemsInternalChange) {
	                        that.selectRows(args.value)
	                    }
	                    args.handled = true
	            }
	        },
	        publicMethods: function() {
	            return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"]
	        },
	        isRowSelected: function(arg) {
	            return this._selection.isItemSelected(arg)
	        },
	        isSelectColumnVisible: function() {
	            return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || "onClick" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes)
	        },
	        _isOnePageSelectAll: function() {
	            return "page" === this.option("selection.selectAllMode")
	        },
	        isSelectAll: function() {
	            return this._selection.getSelectAllState(this._isOnePageSelectAll())
	        },
	        selectAll: function() {
	            if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
	                this.startSelectionWithCheckboxes()
	            }
	            return this._selection.selectAll(this._isOnePageSelectAll())
	        },
	        deselectAll: function() {
	            return this._selection.deselectAll(this._isOnePageSelectAll())
	        },
	        clearSelection: function() {
	            return this.selectedItemKeys([])
	        },
	        refresh: function() {
	            if (this.option("selection.deferred")) {
	                return $.Deferred().resolve().promise()
	            } else {
	                return this.selectedItemKeys(this.option("selectedRowKeys") || [])
	            }
	        },
	        selectedItemKeys: function(value, preserve, isDeselect, isSelectAll) {
	            return this._selection.selectedItemKeys(value, preserve, isDeselect, isSelectAll)
	        },
	        getSelectedRowKeys: function() {
	            return this._selection.getSelectedItemKeys()
	        },
	        selectRows: function(keys, preserve) {
	            return this.selectedItemKeys(keys, preserve)
	        },
	        deselectRows: function(keys) {
	            return this.selectedItemKeys(keys, true, true)
	        },
	        selectRowsByIndexes: function(indexes) {
	            var items = this.getController("data").items(),
	                keys = [];
	            if (!commonUtils.isArray(indexes)) {
	                indexes = Array.prototype.slice.call(arguments, 0)
	            }
	            $.each(indexes, function() {
	                var item = items[this];
	                if (item && "data" === item.rowType) {
	                    keys.push(item.key)
	                }
	            });
	            return this.selectRows(keys)
	        },
	        getSelectedRowsData: function() {
	            return this._selection.getSelectedItems()
	        },
	        changeItemSelection: function(itemIndex, keys) {
	            keys = keys || {};
	            if (this.isSelectionWithCheckboxes()) {
	                keys.control = true
	            }
	            return this._selection.changeItemSelection(itemIndex, keys)
	        },
	        focusedItemIndex: function(itemIndex) {
	            var that = this;
	            if (commonUtils.isDefined(itemIndex)) {
	                that._selection._focusedItemIndex = itemIndex
	            } else {
	                return that._selection._focusedItemIndex
	            }
	        },
	        isSelectionWithCheckboxes: function() {
	            return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes)
	        },
	        startSelectionWithCheckboxes: function() {
	            var that = this,
	                isSelectColumnVisible = that.isSelectColumnVisible();
	            if ("multiple" === that.option(SELECTION_MODE) && !that.isSelectionWithCheckboxes()) {
	                that._isSelectionWithCheckboxes = true;
	                updateSelectColumn(that);
	                if (isSelectColumnVisible === that.isSelectColumnVisible() && "onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
	                    that._selection.onSelectionChanged()
	                }
	                return true
	            }
	            return false
	        },
	        stopSelectionWithCheckboxes: function() {
	            var that = this;
	            if (that._isSelectionWithCheckboxes) {
	                that._isSelectionWithCheckboxes = false;
	                updateSelectColumn(that);
	                return true
	            }
	            return false
	        }
	    }
	}());
	gridCore.registerModule("selection", {
	    defaultOptions: function() {
	        return {
	            selection: {
	                mode: "none",
	                showCheckBoxesMode: "onClick",
	                allowSelectAll: true,
	                selectAllMode: "allPages",
	                maxFilterLengthInRequest: 1500,
	                deferred: false
	            },
	            selectionFilter: [],
	            selectedRowKeys: []
	        }
	    },
	    controllers: {
	        selection: exports.SelectionController
	    },
	    extenders: {
	        controllers: {
	            data: {
	                setDataSource: function(dataSource) {
	                    this.callBase(dataSource);
	                    if (dataSource) {
	                        this.getController("selection").refresh()
	                    }
	                },
	                pageIndex: function(value) {
	                    var that = this,
	                        dataSource = that._dataSource;
	                    if (dataSource && value && dataSource.pageIndex() !== value) {
	                        that.getController("selection").focusedItemIndex(-1)
	                    }
	                    return that.callBase(value)
	                },
	                _processDataItem: function(item, options) {
	                    var that = this,
	                        selectionController = that.getController("selection"),
	                        hasSelectColumn = selectionController.isSelectColumnVisible(),
	                        isDeferredSelection = options.isDeferredSelection = void 0 === options.isDeferredSelection ? this.option("selection.deferred") : options.isDeferredSelection,
	                        dataItem = this.callBase.apply(this, arguments);
	                    dataItem.isSelected = selectionController.isRowSelected(isDeferredSelection ? dataItem.data : dataItem.key);
	                    if (hasSelectColumn && dataItem.values) {
	                        for (var i = 0; i < options.visibleColumns.length; i++) {
	                            if ("select" === options.visibleColumns[i].command) {
	                                dataItem.values[i] = dataItem.isSelected;
	                                break
	                            }
	                        }
	                    }
	                    return dataItem
	                },
	                refresh: function() {
	                    var that = this,
	                        d = $.Deferred();
	                    this.callBase.apply(this, arguments).done(function() {
	                        that.getController("selection").refresh().done(d.resolve).fail(d.reject)
	                    }).fail(d.reject);
	                    return d.promise()
	                }
	            },
	            contextMenu: {
	                _contextMenuPrepared: function(options) {
	                    var jQueryEvent = options.jQueryEvent;
	                    if (jQueryEvent.originalEvent && "dxhold" !== jQueryEvent.originalEvent.type || options.items && options.items.length > 0) {
	                        return
	                    }
	                    processLongTap(this, jQueryEvent)
	                }
	            }
	        },
	        views: {
	            columnHeadersView: {
	                init: function() {
	                    var that = this;
	                    that.callBase();
	                    that.getController("selection").selectionChanged.add($.proxy(that._updateSelectAllValue, that))
	                },
	                _updateSelectAllValue: function() {
	                    var that = this,
	                        $element = that.element(),
	                        $editor = $element && $element.find("." + DATAGRID_SELECT_CHECKBOX_CLASS);
	                    if ($element && $editor.length && "multiple" === that.option("selection.mode")) {
	                        $editor.dxCheckBox("instance").option("value", that.getController("selection").isSelectAll())
	                    }
	                },
	                _handleDataChanged: function(e) {
	                    this.callBase(e);
	                    if (!e || "refresh" === e.changeType) {
	                        this._updateSelectAllValue()
	                    }
	                },
	                _getDefaultTemplate: function(column) {
	                    var groupElement, that = this,
	                        selectionController = that.getController("selection");
	                    if ("select" === column.command) {
	                        return function($cell, options) {
	                            var column = options.column;
	                            if ("select" === column.command) {
	                                $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
	                                groupElement = $("<div />").appendTo($cell).addClass(DATAGRID_SELECT_CHECKBOX_CLASS);
	                                that.setAria("label", messageLocalization.format("dxDataGrid-ariaSelectAll"), $cell);
	                                that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
	                                    parentType: "headerRow",
	                                    value: selectionController.isSelectAll(),
	                                    editorOptions: {
	                                        visible: that.option("selection.allowSelectAll") || false !== selectionController.isSelectAll()
	                                    },
	                                    tabIndex: -1,
	                                    setValue: function(value, e) {
	                                        var allowSelectAll = that.option("selection.allowSelectAll");
	                                        e.component.option("visible", allowSelectAll || false !== e.component.option("value"));
	                                        if (!e.jQueryEvent || selectionController.isSelectAll() === value) {
	                                            return
	                                        }
	                                        if (e.value && !allowSelectAll) {
	                                            e.component.option("value", false)
	                                        } else {
	                                            e.value ? selectionController.selectAll() : selectionController.deselectAll()
	                                        }
	                                        e.jQueryEvent.preventDefault()
	                                    }
	                                }));
	                                $cell.on(clickEvent.name, that.createAction(function(e) {
	                                    var event = e.jQueryEvent;
	                                    if (!$(event.target).closest("." + DATAGRID_SELECT_CHECKBOX_CLASS).length) {
	                                        $(event.currentTarget).children().trigger(clickEvent.name)
	                                    }
	                                    event.preventDefault()
	                                }))
	                            }
	                        }
	                    } else {
	                        return that.callBase(column)
	                    }
	                }
	            },
	            rowsView: {
	                _getDefaultTemplate: function(column) {
	                    var groupElement, that = this;
	                    if ("select" === column.command) {
	                        return function(container, options) {
	                            if ("data" === options.rowType && !options.row.inserted) {
	                                container.addClass(DATAGRID_EDITOR_CELL_CLASS);
	                                container.on(clickEvent.name, that.createAction(function(e) {
	                                    var selectionController = that.getController("selection"),
	                                        event = e.jQueryEvent,
	                                        rowIndex = that.getRowIndex($(event.currentTarget).closest("." + DATAGRID_ROW_CLASS));
	                                    if (rowIndex >= 0) {
	                                        selectionController.startSelectionWithCheckboxes();
	                                        selectionController.changeItemSelection(rowIndex, {
	                                            shift: event.shiftKey
	                                        })
	                                    }
	                                }));
	                                that.setAria("label", messageLocalization.format("dxDataGrid-ariaSelectRow"), container);
	                                groupElement = $("<div />").addClass(DATAGRID_SELECT_CHECKBOX_CLASS).appendTo(container);
	                                that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
	                                    parentType: "dataRow",
	                                    value: options.value,
	                                    tabIndex: -1,
	                                    setValue: function(value, e) {
	                                        if (e && e.jQueryEvent && "keydown" === e.jQueryEvent.type) {
	                                            container.trigger(clickEvent.name, e)
	                                        }
	                                    }
	                                }))
	                            }
	                        }
	                    } else {
	                        return that.callBase(column)
	                    }
	                },
	                _update: function(change) {
	                    var that = this,
	                        tableElements = that.getTableElements();
	                    if ("updateSelection" === change.changeType) {
	                        if (tableElements.length > 0) {
	                            $.each(tableElements, function(_, tableElement) {
	                                $.each(change.itemIndexes || [], function(_, index) {
	                                    var $row, isSelected;
	                                    if (change.items[index]) {
	                                        $row = that._getRowElements($(tableElement)).eq(index);
	                                        isSelected = !!change.items[index].isSelected;
	                                        $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected).find("." + DATAGRID_SELECT_CHECKBOX_CLASS).dxCheckBox("option", "value", isSelected);
	                                        that.setAria("selected", isSelected, $row)
	                                    }
	                                })
	                            });
	                            that._updateCheckboxesClass()
	                        }
	                    } else {
	                        that.callBase(change)
	                    }
	                },
	                _createTable: function() {
	                    var that = this,
	                        selectionMode = that.option("selection.mode"),
	                        $table = that.callBase.apply(that, arguments);
	                    if ("none" !== selectionMode) {
	                        if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE) || !support.touch) {
	                            $table.on(eventUtils.addNamespace(holdEvent.name, "dxDataGridRowsView"), "." + DATAGRID_DATA_ROW_CLASS, that.createAction(function(e) {
	                                processLongTap(that.component, e.jQueryEvent);
	                                e.jQueryEvent.stopPropagation()
	                            }))
	                        }
	                        $table.on("mousedown selectstart", that.createAction(function(e) {
	                            var event = e.jQueryEvent;
	                            if (event.shiftKey) {
	                                event.preventDefault()
	                            }
	                        }))
	                    }
	                    return $table
	                },
	                _createRow: function(row) {
	                    var isSelected, $row = this.callBase(row);
	                    if (row) {
	                        isSelected = !!row.isSelected;
	                        if (isSelected) {
	                            $row.addClass(DATAGRID_ROW_SELECTION_CLASS)
	                        }
	                        this.setAria("selected", isSelected, $row)
	                    }
	                    return $row
	                },
	                _rowClick: function(e) {
	                    var that = this,
	                        jQueryEvent = e.jQueryEvent,
	                        isSelectionDisabled = $(jQueryEvent.target).closest("." + DATAGRID_SELECTION_DISABLED_CLASS).length;
	                    if (!that.isClickableElement($(jQueryEvent.target))) {
	                        if (!isSelectionDisabled && ("multiple" !== that.option(SELECTION_MODE) || "always" !== that.option(SHOW_CHECKBOXES_MODE))) {
	                            if (that.getController("selection").changeItemSelection(e.rowIndex, {
	                                    control: jQueryEvent.ctrlKey,
	                                    shift: jQueryEvent.shiftKey
	                                })) {
	                                jQueryEvent.preventDefault();
	                                e.handled = true
	                            }
	                        }
	                        that.callBase(e)
	                    }
	                },
	                isClickableElement: function($target) {
	                    var isCommandSelect = $target.closest("." + DATAGRID_COMMAND_SELECT_CLASS).length;
	                    return !!isCommandSelect
	                },
	                _renderCore: function(change) {
	                    this.callBase(change);
	                    this._updateCheckboxesClass()
	                },
	                _updateCheckboxesClass: function() {
	                    var tableElements = this.getTableElements(),
	                        selectionController = this.getController("selection"),
	                        isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
	                    $.each(tableElements, function(_, tableElement) {
	                        $(tableElement).toggleClass(DATAGRID_CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden)
	                    })
	                }
	            }
	        }
	    }
	});


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.column_chooser_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    columnsView = __webpack_require__(147),
	    commonUtils = __webpack_require__(8),
	    messageLocalization = __webpack_require__(79),
	    themes = __webpack_require__(112),
	    Button = __webpack_require__(114),
	    TreeView = __webpack_require__(215),
	    devices = __webpack_require__(40),
	    Popup = __webpack_require__(113);
	var DATAGRID_COLUMN_CHOOSER_CLASS = "dx-datagrid-column-chooser",
	    DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS = "dx-datagrid-column-chooser-button",
	    DATAGRID_COLUMN_CHOOSER_ICON_NAME = "column-chooser",
	    DATAGRID_COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item",
	    DATAGRID_NOTOUCH_ACTION_CLASS = "dx-datagrid-notouch-action",
	    DATAGRID_COLUMN_CHOOSER_LIST_CLASS = "dx-datagrid-column-chooser-list",
	    DATAGRID_COLUMN_CHOOSER_DRAG_CLASS = "dx-datagrid-column-chooser-mode-drag",
	    DATAGRID_COLUMN_CHOOSER_SELECT_CLASS = "dx-datagrid-column-chooser-mode-select",
	    DATAGRID_CLICK_TIMEOUT = 300,
	    processItems = function(that, chooserColumns) {
	        var item, items = [],
	            isSelectMode = "select" === that.option("columnChooser.mode");
	        if (chooserColumns.length) {
	            $.each(chooserColumns, function(index, column) {
	                item = {
	                    text: column.caption,
	                    cssClass: column.cssClass,
	                    allowHiding: column.allowHiding,
	                    expanded: true,
	                    id: column.index,
	                    parentId: commonUtils.isDefined(column.ownerBand) ? column.ownerBand : null
	                };
	                if (isSelectMode) {
	                    item.selected = column.visible
	                }
	                items.push(item)
	            })
	        }
	        return items
	    };
	exports.ColumnChooserController = gridCore.ViewController.inherit({
	    renderShowColumnChooserButton: function($element) {
	        var $columnChooserButton, that = this,
	            columnChooserEnabled = that.option("columnChooser.enabled"),
	            $showColumnChooserButton = $element.find("." + DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS);
	        if (columnChooserEnabled) {
	            if (!$showColumnChooserButton.length) {
	                $columnChooserButton = $("<div />").addClass(DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS).appendTo($element);
	                that._createComponent($columnChooserButton, Button, {
	                    icon: DATAGRID_COLUMN_CHOOSER_ICON_NAME,
	                    onClick: function() {
	                        that.getView("columnChooserView").showColumnChooser()
	                    },
	                    hint: that.option("columnChooser.title"),
	                    integrationOptions: {}
	                })
	            } else {
	                $showColumnChooserButton.show()
	            }
	        } else {
	            $showColumnChooserButton.hide()
	        }
	    },
	    getPosition: function() {
	        var rowsView = this.getView("rowsView");
	        return {
	            my: "right bottom",
	            at: "right bottom",
	            of: rowsView && rowsView.element(),
	            collision: "fit",
	            offset: "-2 -2",
	            boundaryOffset: "2 2"
	        }
	    }
	});
	exports.ColumnChooserView = columnsView.ColumnsView.inherit({
	    _resizeCore: $.noop,
	    _isWinDevice: function() {
	        return !!devices.real().win
	    },
	    _updateList: function(allowUpdate) {
	        var items, $popupContent = this._popupContainer.content(),
	            isSelectMode = "select" === this.option("columnChooser.mode"),
	            chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
	        if (!isSelectMode || !this._columnChooserList || allowUpdate) {
	            this._popupContainer._wrapper().toggleClass(DATAGRID_COLUMN_CHOOSER_DRAG_CLASS, !isSelectMode).toggleClass(DATAGRID_COLUMN_CHOOSER_SELECT_CLASS, isSelectMode);
	            items = processItems(this, chooserColumns);
	            this._renderColumnChooserList($popupContent, items)
	        }
	    },
	    _initializePopupContainer: function() {
	        var that = this,
	            $element = that.element().addClass(DATAGRID_COLUMN_CHOOSER_CLASS),
	            columnChooserOptions = that.option("columnChooser"),
	            theme = themes.current(),
	            isGenericTheme = theme && theme.indexOf("generic") > -1,
	            isAndroid5Theme = theme && theme.indexOf("android5") > -1,
	            dxPopupOptions = {
	                visible: false,
	                shading: false,
	                showCloseButton: false,
	                dragEnabled: true,
	                resizeEnabled: true,
	                toolbarItems: [{
	                    text: columnChooserOptions.title,
	                    toolbar: "top",
	                    location: isGenericTheme || isAndroid5Theme ? "before" : "center"
	                }],
	                position: that.getController("columnChooser").getPosition(),
	                width: columnChooserOptions.width,
	                height: columnChooserOptions.height,
	                rtlEnabled: that.option("rtlEnabled"),
	                onHidden: function() {
	                    if (that._isWinDevice()) {
	                        $(document.body).removeClass(DATAGRID_NOTOUCH_ACTION_CLASS)
	                    }
	                },
	                container: columnChooserOptions.container
	            };
	        if (isGenericTheme) {
	            $.extend(dxPopupOptions, {
	                showCloseButton: true
	            })
	        } else {
	            dxPopupOptions.toolbarItems[dxPopupOptions.toolbarItems.length] = {
	                shortcut: "cancel"
	            }
	        }
	        if (!commonUtils.isDefined(this._popupContainer)) {
	            that._popupContainer = that._createComponent($element, Popup, dxPopupOptions);
	            that._popupContainer.on("optionChanged", function(args) {
	                if ("visible" === args.name) {
	                    that.renderCompleted.fire()
	                }
	            })
	        } else {
	            this._popupContainer.option(dxPopupOptions)
	        }
	    },
	    _renderCore: function(allowUpdate) {
	        if (this._popupContainer) {
	            this._updateList(allowUpdate)
	        }
	    },
	    _renderColumnChooserList: function($container, items) {
	        var isSelectMode = "select" === this.option("columnChooser.mode"),
	            listConfig = {
	                items: items,
	                dataStructure: "plain",
	                activeStateEnabled: true,
	                focusStateEnabled: true,
	                hoverStateEnabled: true,
	                itemTemplate: "item",
	                showCheckBoxesMode: "none",
	                rootValue: null
	            };
	        if (this._isWinDevice()) {
	            listConfig.useNativeScrolling = false
	        }
	        $.extend(listConfig, isSelectMode ? this._prepareSelectModeConfig() : this._prepareDragModeConfig());
	        if (this._columnChooserList) {
	            this._columnChooserList.option(listConfig)
	        } else {
	            this._columnChooserList = this._createComponent($container, TreeView, listConfig);
	            $container.addClass(DATAGRID_COLUMN_CHOOSER_LIST_CLASS)
	        }
	    },
	    _prepareDragModeConfig: function() {
	        var columnChooserOptions = this.option("columnChooser");
	        return {
	            noDataText: columnChooserOptions.emptyPanelText,
	            activeStateEnabled: false,
	            focusStateEnabled: false,
	            hoverStateEnabled: false,
	            itemTemplate: function(data, index, $item) {
	                $item.text(data.text).parent().addClass(data.cssClass).addClass(DATAGRID_COLUMN_CHOOSER_ITEM_CLASS)
	            }
	        }
	    },
	    _prepareSelectModeConfig: function() {
	        var that = this,
	            selectionChangedHandler = function(e) {
	                var visibleColumns = that._columnsController.getVisibleColumns().filter(function(item) {
	                        return !item.command
	                    }),
	                    isLastColumnUnselected = 1 === visibleColumns.length && !e.itemData.selected;
	                if (isLastColumnUnselected) {
	                    e.component.selectItem(e.itemElement)
	                } else {
	                    setTimeout(function() {
	                        that._columnsController.columnOption(e.itemData.id, "visible", e.itemData.selected)
	                    }, DATAGRID_CLICK_TIMEOUT)
	                }
	            };
	        return {
	            selectNodesRecursive: false,
	            showCheckBoxesMode: "normal",
	            onItemSelectionChanged: selectionChangedHandler
	        }
	    },
	    _columnOptionChanged: function(e) {
	        var optionNames = e.optionNames,
	            isSelectMode = "select" === this.option("columnChooser.mode");
	        this.callBase(e);
	        if (isSelectMode && optionNames.showInColumnChooser) {
	            this.render(null, true)
	        }
	    },
	    optionChanged: function(args) {
	        switch (args.name) {
	            case "columnChooser":
	                this.render(null, true);
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    getColumnElements: function() {
	        var $content = this._popupContainer && this._popupContainer.content();
	        return $content && $content.find("." + DATAGRID_COLUMN_CHOOSER_ITEM_CLASS)
	    },
	    getName: function() {
	        return "columnChooser"
	    },
	    getColumns: function() {
	        return this._columnsController.getChooserColumns()
	    },
	    allowDragging: function(column, sourceLocation) {
	        var columnVisible = column && column.allowHiding && ("columnChooser" !== sourceLocation || !column.visible && this._columnsController.isParentColumnVisible(column.index));
	        return this.isColumnChooserVisible() && columnVisible
	    },
	    getBoundingRect: function() {
	        var offset, that = this,
	            container = that._popupContainer && that._popupContainer._container();
	        if (container && container.is(":visible")) {
	            offset = container.offset();
	            return {
	                left: offset.left,
	                top: offset.top,
	                right: offset.left + container.outerWidth(),
	                bottom: offset.top + container.outerHeight()
	            }
	        }
	        return null
	    },
	    showColumnChooser: function() {
	        if (!this._popupContainer) {
	            this._initializePopupContainer();
	            this.render()
	        }
	        this._popupContainer.show();
	        if (this._isWinDevice()) {
	            $(document.body).addClass(DATAGRID_NOTOUCH_ACTION_CLASS)
	        }
	    },
	    hideColumnChooser: function() {
	        if (this._popupContainer) {
	            this._popupContainer.hide()
	        }
	    },
	    isColumnChooserVisible: function() {
	        var popupContainer = this._popupContainer;
	        return popupContainer && popupContainer.option("visible")
	    },
	    publicMethods: function() {
	        return ["showColumnChooser", "hideColumnChooser"]
	    }
	});
	gridCore.registerModule("columnChooser", {
	    defaultOptions: function() {
	        return {
	            columnChooser: {
	                enabled: false,
	                mode: "dragAndDrop",
	                width: 250,
	                height: 260,
	                title: messageLocalization.format("dxDataGrid-columnChooserTitle"),
	                emptyPanelText: messageLocalization.format("dxDataGrid-columnChooserEmptyText"),
	                container: void 0
	            }
	        }
	    },
	    controllers: {
	        columnChooser: exports.ColumnChooserController
	    },
	    views: {
	        columnChooserView: exports.ColumnChooserView
	    },
	    extenders: {
	        views: {
	            headerPanel: {
	                _getToolbarItems: function() {
	                    var items = this.callBase();
	                    return this._appendColumnChooserItem(items)
	                },
	                _appendColumnChooserItem: function(items) {
	                    var that = this,
	                        columnChooserEnabled = that.option("columnChooser.enabled");
	                    if (columnChooserEnabled) {
	                        var onClickHandler = function() {
	                                that.component.getView("columnChooserView").showColumnChooser()
	                            },
	                            onInitialized = function(e) {
	                                e.element.addClass(that._getToolbarButtonClass(DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS))
	                            },
	                            hintText = that.option("columnChooser.title"),
	                            toolbarItem = {
	                                widget: "dxButton",
	                                options: {
	                                    icon: DATAGRID_COLUMN_CHOOSER_ICON_NAME,
	                                    onClick: onClickHandler,
	                                    hint: hintText,
	                                    text: hintText,
	                                    onInitialized: onInitialized
	                                },
	                                showText: "inMenu",
	                                location: "after",
	                                name: "columnChooserButton",
	                                locateInMenu: "auto"
	                            };
	                        items.push(toolbarItem)
	                    }
	                    return items
	                },
	                optionChanged: function(args) {
	                    switch (args.name) {
	                        case "columnChooser":
	                            this.updateToolbar();
	                            args.handled = true;
	                            break;
	                        default:
	                            this.callBase(args)
	                    }
	                },
	                isVisible: function() {
	                    var that = this,
	                        columnChooserEnabled = that.option("columnChooser.enabled");
	                    return that.callBase() || columnChooserEnabled
	                }
	            }
	        },
	        controllers: {
	            columns: {
	                allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
	                    var columnChooserMode = this.option("columnChooser.mode"),
	                        isMoveColumnDisallowed = "select" === columnChooserMode && "columnChooser" === targetLocation;
	                    return isMoveColumnDisallowed ? false : this.callBase(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation)
	                }
	            }
	        }
	    }
	});


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/tree_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    messageLocalization = __webpack_require__(79),
	    clickEvent = __webpack_require__(65),
	    commonUtils = __webpack_require__(8),
	    registerComponent = __webpack_require__(44),
	    CheckBox = __webpack_require__(204),
	    HierarchicalCollectionWidget = __webpack_require__(167),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    dblclickEvent = __webpack_require__(216),
	    fx = __webpack_require__(58),
	    Scrollable = __webpack_require__(157).default,
	    LoadIndicator = __webpack_require__(150),
	    when = __webpack_require__(10).when;
	var WIDGET_CLASS = "dx-treeview",
	    NODE_CONTAINER_CLASS = "dx-treeview-node-container",
	    OPENED_NODE_CONTAINER_CLASS = "dx-treeview-node-container-opened",
	    NODE_CLASS = "dx-treeview-node",
	    ITEM_CLASS = "dx-treeview-item",
	    ITEM_WITH_CHECKBOX_CLASS = "dx-treeview-item-with-checkbox",
	    ITEM_DATA_KEY = "dx-treeview-item-data",
	    IS_LEAF = "dx-treeview-node-is-leaf",
	    EXPAND_EVENT_NAMESPACE = "dxTreeView_expand",
	    TOGGLE_ITEM_VISIBILITY_CLASS = "dx-treeview-toggle-item-visibility",
	    LOAD_INDICATOR_CLASS = "dx-treeview-loadindicator",
	    LOAD_INDICATOR_WRAPPER_CLASS = "dx-treeview-loadindicator-wrapper",
	    NODE_LOAD_INDICATOR_CLASS = "dx-treeview-node-loadindicator",
	    TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "dx-treeview-toggle-item-visibility-opened",
	    SELECT_ALL_ITEM_CLASS = "dx-treeview-select-all-item",
	    DISABLED_STATE_CLASS = "dx-state-disabled",
	    SELECTED_ITEM_CLASS = "dx-state-selected",
	    DATA_ITEM_ID = "data-item-id";
	var TreeView = HierarchicalCollectionWidget.inherit({
	    _supportedKeys: function(e) {
	        var click = function(e) {
	            var $itemElement = this.option("focusedElement");
	            if (!$itemElement) {
	                return
	            }
	            e.target = $itemElement;
	            e.currentTarget = $itemElement;
	            this._itemClickHandler(e, $itemElement.find(">." + ITEM_CLASS))
	        };
	        var select = function(e) {
	            e.preventDefault();
	            this._changeCheckBoxState(this.option("focusedElement"))
	        };
	        var toggleExpandedNestedItems = function(state, e) {
	            if (!this.option("expandAllEnabled")) {
	                return
	            }
	            e.preventDefault();
	            var $rootElement = this.option("focusedElement");
	            if (!$rootElement) {
	                return
	            }
	            var rootItem = this._getItemData($rootElement.find("." + ITEM_CLASS));
	            this._toggleExpandedNestedItems([rootItem], state)
	        };
	        return $.extend(this.callBase(), {
	            enter: this._showCheckboxes() ? select : click,
	            space: this._showCheckboxes() ? select : click,
	            asterisk: $.proxy(toggleExpandedNestedItems, this, true),
	            minus: $.proxy(toggleExpandedNestedItems, this, false)
	        })
	    },
	    _changeCheckBoxState: function($element) {
	        var checkboxInstance = this._getCheckBoxInstance($element),
	            currentState = checkboxInstance.option("value");
	        if (!checkboxInstance.option("disabled")) {
	            this._updateItemSelection(!currentState, $element.find("." + ITEM_CLASS).get(0), true, $element)
	        }
	    },
	    _toggleExpandedNestedItems: function(items, state) {
	        if (!items) {
	            return
	        }
	        for (var i = 0, len = items.length; i < len; i++) {
	            var item = items[i],
	                node = this._dataAdapter.getNodeByItem(item);
	            this._toggleExpandedState(node, state);
	            this._toggleExpandedNestedItems(item.items, state)
	        }
	    },
	    _getNodeElement: function(node) {
	        return this.element().find("[" + DATA_ITEM_ID + "='" + commonUtils.normalizeKey(node.internalFields.key) + "']")
	    },
	    _activeStateUnit: "." + ITEM_CLASS,
	    _widgetClass: function() {
	        return WIDGET_CLASS
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            animationEnabled: true,
	            dataStructure: "tree",
	            expandAllEnabled: false,
	            hasItemsExpr: "hasItems",
	            selectNodesRecursive: true,
	            expandNodesRecursive: true,
	            showCheckBoxesMode: "none",
	            selectAllText: messageLocalization.format("dxList-selectAll"),
	            onItemSelectionChanged: null,
	            onItemExpanded: null,
	            onItemCollapsed: null,
	            scrollDirection: "vertical",
	            virtualModeEnabled: false,
	            rootValue: 0,
	            searchValue: "",
	            focusStateEnabled: false,
	            selectionMode: "multiple",
	            expandEvent: "dblclick",
	            selectByClick: false,
	            createChildren: null
	        })
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            showCheckBoxes: {
	                since: "15.2",
	                message: "use 'showCheckBoxesMode' option instead"
	            },
	            selectAllEnabled: {
	                since: "15.2",
	                message: "use 'showCheckBoxesMode' option instead"
	            },
	            onItemSelected: {
	                since: "16.1",
	                alias: "onItemSelectionChanged"
	            }
	        })
	    },
	    _initSelectedItems: $.noop,
	    _syncSelectionOptions: $.noop,
	    _fireSelectionChanged: function() {
	        var selectionChangePromise = this._selectionChangePromise;
	        when(selectionChangePromise).done($.proxy(function() {
	            this._createActionByOption("onSelectionChanged", {
	                excludeValidators: ["disabled", "readOnly"]
	            })()
	        }, this))
	    },
	    _checkBoxModeChange: function(value, previousValue) {
	        if ("none" === previousValue || "none" === value) {
	            this.repaint();
	            return
	        }
	        var selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
	        switch (value) {
	            case "selectAll":
	                !selectAllExists && this._renderSelectAllItem();
	                break;
	            case "normal":
	                if (selectAllExists) {
	                    this._$selectAllItem.remove();
	                    delete this._$selectAllItem
	                }
	        }
	    },
	    _removeSelection: function() {
	        var that = this;
	        $.each(this._dataAdapter.getFullData(), function(_, node) {
	            if (!that._hasChildren(node)) {
	                return
	            }
	            that._dataAdapter.toggleSelection(node.internalFields.key, false, true)
	        })
	    },
	    _optionChanged: function(args) {
	        var name = args.name,
	            value = args.value,
	            previousValue = args.previousValue;
	        switch (name) {
	            case "showCheckBoxes":
	                this.option("showCheckBoxesMode", value ? "normal" : "none");
	                break;
	            case "selectAllEnabled":
	                this.option("showCheckBoxesMode", value ? "selectAll" : "normal");
	                break;
	            case "selectAllText":
	                if (this._$selectAllItem) {
	                    this._$selectAllItem.dxCheckBox("instance").option("text", value)
	                }
	                break;
	            case "showCheckBoxesMode":
	                this._checkBoxModeChange(value, previousValue);
	                break;
	            case "scrollDirection":
	                this._scrollableContainer.option("direction", value);
	                break;
	            case "items":
	                delete this._$selectAllItem;
	                this.callBase(args);
	                break;
	            case "dataSource":
	                this.callBase(args);
	                this._initDataAdapter();
	                this._filter = {};
	                break;
	            case "hasItemsExpr":
	                this._initAccessors();
	                this.repaint();
	                break;
	            case "expandEvent":
	                this._initExpandEvent();
	                break;
	            case "dataStructure":
	            case "rootValue":
	            case "searchValue":
	                if ((!value.length || value < previousValue) && "none" !== this.option("showCheckBoxesMode")) {
	                    this._removeSelection()
	                }
	                this._initDataAdapter();
	                this.repaint();
	                break;
	            case "createChildren":
	            case "expandNodesRecursive":
	            case "onItemSelectionChanged":
	            case "onItemExpanded":
	            case "onItemCollapsed":
	            case "expandAllEnabled":
	            case "animationEnabled":
	            case "virtualModeEnabled":
	            case "selectByClick":
	                break;
	            case "selectNodesRecursive":
	                this._dataAdapter.setOption("recursiveSelection", args.value);
	                this.repaint();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _initDataSource: function() {
	        if (this._useCustomChildrenLoader()) {
	            this._loadChildrenByCustomLoader(null).done(function(newItems) {
	                if (newItems && newItems.length) {
	                    this.option("items", newItems)
	                }
	            }.bind(this))
	        } else {
	            this.callBase();
	            this._isVirtualMode() && this._initVirtualMode()
	        }
	    },
	    _initVirtualMode: function() {
	        var that = this,
	            filter = that._filter;
	        if (!filter.custom) {
	            filter.custom = that._dataSource.filter()
	        }
	        if (!filter.internal) {
	            filter.internal = [that.option("parentIdExpr"), that.option("rootValue")]
	        }
	    },
	    _useCustomChildrenLoader: function() {
	        return commonUtils.isFunction(this.option("createChildren")) && this._isDataStructurePlain()
	    },
	    _loadChildrenByCustomLoader: function(parentNode) {
	        var invocationResult = this.option("createChildren").call(this, parentNode);
	        if (commonUtils.isArray(invocationResult)) {
	            return $.Deferred().resolve(invocationResult).promise()
	        }
	        if (invocationResult && $.isFunction(invocationResult.then)) {
	            return invocationResult
	        }
	        return $.Deferred().resolve([]).promise()
	    },
	    _combineFilter: function() {
	        if (!this._filter.custom || !this._filter.custom.length) {
	            return this._filter.internal
	        }
	        return [this._filter.custom, this._filter.internal]
	    },
	    _dataSourceLoadErrorHandler: function() {
	        this._renderEmptyMessage()
	    },
	    _init: function() {
	        this._filter = {};
	        this.callBase();
	        this._initStoreChangeHandlers();
	        this._initCheckBoxesMode()
	    },
	    _dataSourceChangedHandler: function(newItems) {
	        if (this._initialized && this._isVirtualMode() && this.option("items").length) {
	            return
	        }
	        this.option("items", newItems)
	    },
	    _removeTreeViewLoadIndicator: function() {
	        if (!this._treeViewLoadIndicator) {
	            return
	        }
	        this._treeViewLoadIndicator.remove();
	        this._treeViewLoadIndicator = null
	    },
	    _createTreeViewLoadIndicator: function() {
	        this._treeViewLoadIndicator = $("<div>", {
	            "class": LOAD_INDICATOR_CLASS
	        });
	        this._createComponent(this._treeViewLoadIndicator, LoadIndicator, {});
	        return this._treeViewLoadIndicator
	    },
	    _dataSourceLoadingChangedHandler: function(isLoading) {
	        var resultFilter = this._combineFilter();
	        this._dataSource.filter(resultFilter);
	        if (isLoading && !this._dataSource.isLoaded()) {
	            this.option("items", []);
	            var $wrapper = $("<div>", {
	                "class": LOAD_INDICATOR_WRAPPER_CLASS
	            });
	            this._createTreeViewLoadIndicator().appendTo($wrapper);
	            this.itemsContainer().append($wrapper);
	            this._dataSource.filter() !== resultFilter && this._dataSource.filter([])
	        } else {
	            this._removeTreeViewLoadIndicator()
	        }
	    },
	    _initStoreChangeHandlers: function() {
	        if ("plain" !== this.option("dataStructure")) {
	            return
	        }
	        var that = this;
	        this._dataSource && this._dataSource.store().on("inserted", function(newItem) {
	            that.option().items = that.option("items").concat(newItem);
	            that._dataAdapter.addItem(newItem);
	            if (!that._isFiltered(newItem)) {
	                return
	            }
	            that._updateLevel(that._parentIdGetter(newItem))
	        }).on("removed", function(removedKey) {
	            var node = that._dataAdapter.getNodeByKey(removedKey);
	            that.option("items")[that._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
	            that._markChildrenItemsToRemove(node);
	            that._removeItems();
	            that._dataAdapter.removeItem(removedKey);
	            that._updateLevel(that._parentIdGetter(node))
	        })
	    },
	    _markChildrenItemsToRemove: function(node) {
	        var that = this,
	            keys = node.internalFields.childrenKeys;
	        $.each(keys, function(_, key) {
	            that.option("items")[that._dataAdapter.getIndexByKey(key)] = 0;
	            that._markChildrenItemsToRemove(that._dataAdapter.getNodeByKey(key))
	        })
	    },
	    _removeItems: function() {
	        var that = this,
	            counter = 0,
	            items = $.extend(true, [], this.option("items"));
	        $.each(items, function(index, item) {
	            if (!item) {
	                that.option("items").splice(index - counter, 1);
	                counter++
	            }
	        })
	    },
	    _isFiltered: function(item) {
	        var value = this.option("searchValue"),
	            reg = new RegExp(value, "i");
	        return reg.test(this._displayGetter(item))
	    },
	    _updateLevel: function(parentId) {
	        var $container = this._getContainerByParentKey(parentId);
	        this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId))
	    },
	    _getOldContainer: function($itemElement) {
	        if ($itemElement.length) {
	            return $itemElement.find(" > ." + NODE_CONTAINER_CLASS)
	        }
	        if (this._scrollableContainer) {
	            return this._scrollableContainer.content().children()
	        }
	        return $()
	    },
	    _getContainerByParentKey: function(parentId) {
	        var $container, node = this._dataAdapter.getNodeByKey(parentId),
	            $itemElement = node ? this._getNodeElement(node) : [];
	        this._getOldContainer($itemElement).remove();
	        $container = this._renderNodeContainer($itemElement);
	        if (this._isRootLevel(parentId)) {
	            if (!this._scrollableContainer) {
	                this._renderScrollableContainer()
	            }
	            this._scrollableContainer.content().append($container)
	        }
	        return $container
	    },
	    _isRootLevel: function(parentId) {
	        return parentId === this.option("rootValue")
	    },
	    _getAccessors: function() {
	        return ["key", "display", "selected", "expanded", "items", "parentId", "disabled", "hasItems"]
	    },
	    _getDataAdapterOptions: function() {
	        return {
	            rootValue: this.option("rootValue"),
	            multipleSelection: !this._isSingleSelection(),
	            recursiveSelection: this._isRecursiveSelection(),
	            recursiveExpansion: this.option("expandNodesRecursive"),
	            searchValue: this.option("searchValue"),
	            dataType: this.option("dataStructure")
	        }
	    },
	    _render: function() {
	        this.callBase();
	        this.setAria("role", "tree")
	    },
	    _renderContentImpl: function() {
	        if (!this.option("items") || !this.option("items").length) {
	            return
	        }
	        var $nodeContainer = this._renderNodeContainer();
	        this._renderScrollableContainer();
	        this._scrollableContainer.content().append($nodeContainer);
	        this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
	        this._initExpandEvent();
	        if (this._selectAllEnabled()) {
	            this._renderSelectAllItem($nodeContainer)
	        }
	    },
	    _isVirtualMode: function() {
	        return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource")
	    },
	    _isDataStructurePlain: function() {
	        return "plain" === this.option("dataStructure")
	    },
	    _fireContentReadyAction: function() {
	        this.callBase();
	        if (this._scrollableContainer) {
	            this._scrollableContainer.update()
	        }
	    },
	    _renderScrollableContainer: function() {
	        this._scrollableContainer = this._createComponent($("<div>").appendTo(this.element()), Scrollable, {
	            direction: this.option("scrollDirection"),
	            useKeyboard: false
	        })
	    },
	    _renderNodeContainer: function($parent) {
	        var $container = $("<ul>").addClass(NODE_CONTAINER_CLASS);
	        this.setAria("role", "group", $container);
	        if ($parent && $parent.length) {
	            var itemData = this._getItemData($parent.find("> ." + ITEM_CLASS));
	            if (this._expandedGetter(itemData)) {
	                $container.addClass(OPENED_NODE_CONTAINER_CLASS)
	            }
	            $container.appendTo($parent)
	        }
	        return $container
	    },
	    _createDOMElement: function($nodeContainer, node) {
	        var $node = $("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, commonUtils.normalizeKey(node.internalFields.key)).prependTo($nodeContainer);
	        this.setAria({
	            role: "treeitem",
	            label: this._displayGetter(node.internalFields.item) || "",
	            expanded: node.internalFields.expanded || false,
	            level: this._getLevel($nodeContainer)
	        }, $node);
	        return $node
	    },
	    _getLevel: function($nodeContainer) {
	        var parent = $nodeContainer.parent();
	        return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1
	    },
	    _showCheckboxes: function() {
	        return "none" !== this.option("showCheckBoxesMode")
	    },
	    _selectAllEnabled: function() {
	        return "selectAll" === this.option("showCheckBoxesMode")
	    },
	    _initCheckBoxesMode: function() {
	        if (this._showCheckboxes()) {
	            return
	        }
	        this._suppressDeprecatedWarnings();
	        var showCheckboxes = this.option("showCheckBoxes"),
	            selectAllEnabled = this.option("selectAllEnabled");
	        this._resumeDeprecatedWarnings();
	        this.option("showCheckBoxesMode", showCheckboxes ? selectAllEnabled ? "selectAll" : "normal" : "none")
	    },
	    _renderItems: function($nodeContainer, nodes) {
	        var length = nodes.length - 1;
	        for (var i = length; i >= 0; i--) {
	            this._renderItem(nodes[i], $nodeContainer)
	        }
	        this._renderFocusTarget()
	    },
	    _renderItem: function(node, $nodeContainer) {
	        var $node = this._createDOMElement($nodeContainer, node),
	            nodeData = node.internalFields;
	        this._showCheckboxes() && this._renderCheckBox($node, node);
	        this.setAria("selected", nodeData.selected, $node);
	        this._toggleSelectedClass($node, nodeData.selected);
	        this.callBase(nodeData.key, nodeData.item, $node);
	        if (false !== nodeData.item.visible) {
	            this._renderChildren($node, node)
	        }
	    },
	    _renderChildren: function($node, node) {
	        if (!this._hasChildren(node)) {
	            this._addLeafClass($node);
	            return
	        }
	        this._renderToggleItemVisibilityIcon($node, node);
	        if (!node.internalFields.expanded) {
	            return
	        }
	        var that = this;
	        that._loadSublevel(node).done(function(childNodes) {
	            that._renderSublevel($node, that._getActualNode(node), childNodes)
	        })
	    },
	    _getActualNode: function(cachedNode) {
	        return this._dataAdapter.getNodeByKey(cachedNode.internalFields.key)
	    },
	    _hasChildren: function(node) {
	        if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
	            return false !== this._hasItemsGetter(node.internalFields.item)
	        }
	        return this.callBase(node)
	    },
	    _loadSublevel: function(node) {
	        var deferred = $.Deferred(),
	            that = this,
	            childrenNodes = that._getChildNodes(node);
	        if (childrenNodes.length) {
	            deferred.resolve(childrenNodes)
	        } else {
	            that._loadNestedItems(node).done(function(items) {
	                deferred.resolve(that._dataAdapter.getNodesByItems(items))
	            })
	        }
	        return deferred.promise()
	    },
	    _renderSublevel: function($node, node, childNodes) {
	        var $nestedNodeContainer = this._renderNodeContainer($node, node);
	        this._renderItems($nestedNodeContainer, childNodes);
	        if (childNodes.length && !node.internalFields.selected) {
	            var firstChild = childNodes[0];
	            this._updateParentsState(firstChild, this._getNodeElement(firstChild))
	        }
	        this._normalizeIconState($node, childNodes.length);
	        $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
	    },
	    _executeItemRenderAction: function(index, itemData, itemElement) {
	        var node = this._dataAdapter.getNodeByItem(itemData);
	        this._getItemRenderAction()({
	            itemElement: itemElement,
	            itemIndex: index,
	            itemData: itemData,
	            node: node
	        })
	    },
	    _addLeafClass: function($node) {
	        $node.addClass(IS_LEAF)
	    },
	    _initExpandEvent: function() {
	        var that = this,
	            expandedEventName = this._getEventNameByOption(this.option("expandEvent")),
	            $itemsContainer = this._itemContainer(),
	            itemSelector = this._itemSelector();
	        $itemsContainer.off("." + EXPAND_EVENT_NAMESPACE, itemSelector).on(expandedEventName, itemSelector, function(e) {
	            that._toggleExpandedState(e.currentTarget, void 0, e)
	        })
	    },
	    _getEventNameByOption: function(name) {
	        var event = "click" === name ? clickEvent : dblclickEvent;
	        return eventUtils.addNamespace(event.name, EXPAND_EVENT_NAMESPACE)
	    },
	    _getNodeByItemElement: function(itemElement) {
	        if (commonUtils.isPrimitive(itemElement)) {
	            return this._dataAdapter.getNodeByKey(itemElement)
	        }
	        itemElement = $(itemElement).get(0);
	        if (!itemElement) {
	            return null
	        }
	        if (itemElement.nodeType) {
	            return this._dataAdapter.getNodeByItem(this._getItemData(itemElement))
	        }
	        if (itemElement.internalFields) {
	            return itemElement
	        }
	        return this._dataAdapter.getNodeByItem(itemElement)
	    },
	    _toggleExpandedState: function(itemElement, state, e) {
	        var node = this._getNodeByItemElement(itemElement),
	            currentState = node.internalFields.expanded;
	        if (node.internalFields.disabled || currentState === state) {
	            return
	        }
	        if (this._isVirtualMode() && this._hasChildren(node) || this._useCustomChildrenLoader()) {
	            var $node = this._getNodeElement(node);
	            this._createLoadIndicator($node)
	        }
	        if (!commonUtils.isDefined(state)) {
	            state = !currentState
	        }
	        this._dataAdapter.toggleExpansion(node.internalFields.key, state);
	        node.internalFields.expanded = state;
	        if (this._isVirtualMode() && !this._hasChildren(node)) {
	            return
	        }
	        this._updateExpandedItemsUI(node, state, e)
	    },
	    _createLoadIndicator: function($node) {
	        var $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
	            $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
	        if ($icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) || $nodeContainer.not(":empty").length) {
	            return
	        }
	        this._createComponent($("<div>", {
	            "class": NODE_LOAD_INDICATOR_CLASS
	        }), LoadIndicator, {}).element().appendTo($node);
	        $icon.hide()
	    },
	    _renderToggleItemVisibilityIcon: function($node, node) {
	        var $icon = $("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
	        if (node.internalFields.expanded) {
	            $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
	            $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS)
	        }
	        if (node.internalFields.disabled) {
	            $icon.addClass(DISABLED_STATE_CLASS)
	        }
	        this._renderToggleItemVisibilityIconClick($icon, node)
	    },
	    _renderToggleItemVisibilityIconClick: function($icon, node) {
	        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME),
	            that = this;
	        $icon.off(eventName).on(eventName, function(e) {
	            that._toggleExpandedState(node, void 0, e)
	        })
	    },
	    _updateExpandedItemsUI: function(node, state, e) {
	        var $node = this._getNodeElement(node),
	            $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
	            $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
	        $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
	        var nodeContainerExists = $nodeContainer.length > 0;
	        if (!state || nodeContainerExists && !$nodeContainer.is(":empty")) {
	            this._updateExpandedItem(node, state, e);
	            return
	        }
	        if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
	            this._loadNestedItemsWithUpdate(node, state, e);
	            return
	        }
	        this._renderSublevel($node, node, this._getChildNodes(node));
	        this._fireContentReadyAction();
	        this._updateExpandedItem(node, state, e)
	    },
	    _loadNestedItemsWithUpdate: function(node, state, e) {
	        var that = this,
	            $node = this._getNodeElement(node);
	        that._loadNestedItems(node).done(function(items) {
	            var actualNodeData = that._getActualNode(node);
	            that._renderSublevel($node, actualNodeData, that._dataAdapter.getNodesByItems(items));
	            if (!items || !items.length) {
	                return
	            }
	            that._fireContentReadyAction();
	            that._updateExpandedItem(actualNodeData, state, e)
	        })
	    },
	    _loadNestedItems: function(node) {
	        var that = this;
	        if (that._useCustomChildrenLoader()) {
	            var publicNode = this._dataAdapter.getPublicNode(node);
	            return that._loadChildrenByCustomLoader(publicNode).done(function(newItems) {
	                that._appendItems(newItems)
	            })
	        }
	        if (!that._isVirtualMode()) {
	            return $.Deferred().resolve([]).promise()
	        }
	        that._filter.internal = [that.option("parentIdExpr"), node.internalFields.key];
	        that._dataSource.filter(that._combineFilter());
	        return that._dataSource.load().done(function(newItems) {
	            var areItemsAlreadyPresent = $.inArray(newItems[0], that.option("items")) + 1;
	            !areItemsAlreadyPresent && that._appendItems(newItems)
	        })
	    },
	    _appendItems: function(newItems) {
	        this.option().items = this.option("items").concat(newItems);
	        this._initDataAdapter()
	    },
	    _updateExpandedItem: function(node, state, e) {
	        var $node = this._getNodeElement(node),
	            $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
	        this._animateNodeContainer($nodeContainer, state);
	        this.setAria("expanded", state, $node);
	        this._fireExpandedStateUpdatedEvent(state, node, e)
	    },
	    _animateNodeContainer: function($nodeContainer, state) {
	        var nodeHeight = $nodeContainer.height();
	        fx.stop($nodeContainer, true);
	        fx.animate($nodeContainer, {
	            type: "custom",
	            duration: this.option("animationEnabled") ? 400 : 0,
	            from: {
	                "max-height": state ? 0 : nodeHeight
	            },
	            to: {
	                "max-height": state ? nodeHeight : 0
	            },
	            start: function() {
	                $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
	            },
	            complete: $.proxy(function() {
	                $nodeContainer.css("max-height", "none");
	                $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
	                this._scrollableContainer.update()
	            }, this)
	        })
	    },
	    _fireExpandedStateUpdatedEvent: function(isExpanded, node, e) {
	        var target, optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed";
	        if (!this.option(optionName) || !this._hasChildren(node)) {
	            return
	        }
	        if (commonUtils.isDefined(e)) {
	            this._itemJQueryEventHandler(e, optionName, {
	                node: this._dataAdapter.getPublicNode(node)
	            })
	        } else {
	            target = this._getNodeElement(node);
	            this._itemEventHandler(target, optionName, {
	                jQueryEvent: e,
	                node: this._dataAdapter.getPublicNode(node)
	            })
	        }
	    },
	    _normalizeIconState: function($node, hasNewItems) {
	        var $icon, $loadIndicator = $node.find(".dx-loadindicator");
	        $loadIndicator.length && LoadIndicator.getInstance($loadIndicator).option("visible", false);
	        if (hasNewItems) {
	            $icon = $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS);
	            $icon.show();
	            return
	        }
	        $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
	        $node.addClass(IS_LEAF)
	    },
	    _renderContent: function() {
	        this._renderEmptyMessage();
	        var items = this.option("items");
	        if (items && items.length) {
	            this._contentAlreadyRendered = true
	        }
	        this.callBase()
	    },
	    _renderSelectAllItem: function($container) {
	        $container = $container || this.element().find("." + NODE_CONTAINER_CLASS).first();
	        this._$selectAllItem = $("<div>").addClass(SELECT_ALL_ITEM_CLASS);
	        var value = this._dataAdapter.isAllSelected();
	        this._createComponent(this._$selectAllItem, CheckBox, {
	            value: value,
	            text: this.option("selectAllText"),
	            onValueChanged: $.proxy(this._toggleSelectAll, this)
	        });
	        this._toggleSelectedClass(this._$selectAllItem, value);
	        $container.before(this._$selectAllItem)
	    },
	    _toggleSelectAll: function(args) {
	        this._dataAdapter.toggleSelectAll(args.value);
	        this._updateItemsUI();
	        this._fireSelectionChanged()
	    },
	    _renderCheckBox: function($node, node) {
	        $node.addClass(ITEM_WITH_CHECKBOX_CLASS);
	        var $checkbox = $("<div>").appendTo($node);
	        this._createComponent($checkbox, CheckBox, {
	            value: node.internalFields.selected,
	            onValueChanged: $.proxy(this._changeCheckboxValue, this),
	            focusStateEnabled: false,
	            disabled: this._disabledGetter(node)
	        })
	    },
	    _toggleSelectedClass: function($node, value) {
	        $node.toggleClass(SELECTED_ITEM_CLASS, !!value)
	    },
	    _toggleNodeDisabledState: function(node, state) {
	        var $node = this._getNodeElement(node),
	            $item = $node.find("." + ITEM_CLASS).eq(0);
	        this._dataAdapter.toggleNodeDisabledState(node.internalFields.key, state);
	        $item.toggleClass(DISABLED_STATE_CLASS, !!state);
	        if (this._showCheckboxes()) {
	            var checkbox = this._getCheckBoxInstance($node);
	            checkbox.option("disabled", !!state)
	        }
	    },
	    _itemOptionChanged: function(item, property, value) {
	        var node = this._dataAdapter.getNodeByItem(item);
	        switch (property) {
	            case this.option("disabledExpr"):
	                this._toggleNodeDisabledState(node, value)
	        }
	    },
	    _changeCheckboxValue: function(e) {
	        var $node = e.element.parent("." + NODE_CLASS),
	            item = this._getItemData($node.find("> ." + ITEM_CLASS)),
	            node = this._dataAdapter.getNodeByItem(item),
	            value = e.value;
	        if (node.internalFields.selected === value) {
	            return
	        }
	        this._updateItemSelection(value, item, e.jQueryEvent)
	    },
	    _isSingleSelection: function() {
	        return "single" === this.option("selectionMode")
	    },
	    _isRecursiveSelection: function() {
	        return this.option("selectNodesRecursive") && "single" !== this.option("selectionMode")
	    },
	    _updateItemSelection: function(value, itemElement, jQueryEvent) {
	        var node = this._getNodeByItemElement(itemElement);
	        if (!node || node.internalFields.selected === value) {
	            return
	        }
	        if (this._isSingleSelection()) {
	            this._toggleSelectAll({
	                value: false
	            })
	        }
	        this._dataAdapter.toggleSelection(node.internalFields.key, value);
	        this._updateItemsUI();
	        var initiator = jQueryEvent || this._findItemElementByItem(node.internalFields.item),
	            handler = jQueryEvent ? this._itemJQueryEventHandler : this._itemEventHandler;
	        handler.call(this, initiator, "onItemSelectionChanged", {
	            node: this._dataAdapter.getPublicNode(node),
	            itemData: node.internalFields.item
	        });
	        this._fireSelectionChanged()
	    },
	    _getCheckBoxInstance: function($node) {
	        return $node.find("> .dx-checkbox").dxCheckBox("instance")
	    },
	    _updateItemsUI: function() {
	        var that = this;
	        $.each(this._dataAdapter.getData(), function(_, node) {
	            var $node = that._getNodeElement(node),
	                nodeSelection = node.internalFields.selected;
	            if (!$node.length) {
	                return
	            }
	            that._toggleSelectedClass($node, nodeSelection);
	            that.setAria("selected", nodeSelection, $node);
	            if (that._showCheckboxes()) {
	                var checkbox = that._getCheckBoxInstance($node);
	                checkbox.option("value", nodeSelection)
	            }
	        });
	        if (this._selectAllEnabled()) {
	            this._$selectAllItem.dxCheckBox("instance").option("value", this._dataAdapter.isAllSelected())
	        }
	    },
	    _updateParentsState: function(node, $node) {
	        var parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey);
	        if (!$node) {
	            return
	        }
	        var $parentNode = $($node.parents("." + NODE_CLASS)[0]);
	        if (this._showCheckboxes()) {
	            var parentValue = parentNode.internalFields.selected;
	            this._getCheckBoxInstance($parentNode).option("value", parentValue);
	            this._toggleSelectedClass($parentNode, parentValue)
	        }
	        if (parentNode.internalFields.parentKey !== this.option("rootValue")) {
	            this._updateParentsState(parentNode, $parentNode)
	        }
	    },
	    _itemEventHandlerImpl: function(initiator, action, actionArgs) {
	        var $itemElement = $(initiator).closest("." + NODE_CLASS).find("> ." + ITEM_CLASS);
	        return action($.extend(this._extendActionArgs($itemElement), actionArgs))
	    },
	    _itemContextMenuHandler: function(e) {
	        this._createEventHandler("onItemContextMenu", e)
	    },
	    _itemHoldHandler: function(e) {
	        this._createEventHandler("onItemHold", e)
	    },
	    _createEventHandler: function(eventName, e) {
	        var itemData = this._getItemData(e.currentTarget),
	            node = this._dataAdapter.getNodeByItem(itemData);
	        this._itemJQueryEventHandler(e, eventName, {
	            node: this._dataAdapter.getPublicNode(node)
	        })
	    },
	    _itemClass: function() {
	        return ITEM_CLASS
	    },
	    _nodeClass: function() {
	        return NODE_CLASS
	    },
	    _nodeSelector: function() {
	        return "." + this._nodeClass()
	    },
	    _itemDataKey: function() {
	        return ITEM_DATA_KEY
	    },
	    _selectionEnabled: function() {
	        return true
	    },
	    _attachClickEvent: function() {
	        var that = this,
	            nodeSelector = that._nodeSelector(),
	            eventName = eventUtils.addNamespace(clickEvent.name, that.NAME),
	            pointerDownEvent = eventUtils.addNamespace(pointerEvents.down, this.NAME);
	        that._itemContainer().off(eventName, nodeSelector).off(pointerDownEvent, nodeSelector).on(eventName, nodeSelector, function(e) {
	            that._itemClickHandler(e, $(this).find("> " + that._itemSelector()))
	        }).on(pointerDownEvent, nodeSelector, function(e) {
	            that._itemPointerDownHandler(e)
	        })
	    },
	    _itemClickHandler: function(e, $item) {
	        var itemData = this._getItemData($item),
	            node = this._dataAdapter.getNodeByItem(itemData);
	        this._itemJQueryEventHandler(e, "onItemClick", {
	            node: this._dataAdapter.getPublicNode(node)
	        });
	        if (this.option("selectByClick")) {
	            this._updateItemSelection(!node.internalFields.selected, itemData, e)
	        }
	    },
	    _updateSelectionToFirstItem: function($items, startIndex) {
	        var itemIndex = startIndex;
	        while (itemIndex >= 0) {
	            var $item = $($items[itemIndex]);
	            this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0));
	            itemIndex--
	        }
	    },
	    _updateSelectionToLastItem: function($items, startIndex) {
	        var itemIndex = startIndex,
	            length = $items.length;
	        while (itemIndex < length) {
	            var $item = $($items[itemIndex]);
	            this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0));
	            itemIndex++
	        }
	    },
	    _focusInHandler: function(e) {
	        var currentTarget = e.currentTarget,
	            focusTargets = this._focusTarget();
	        if ($.inArray(currentTarget, focusTargets) !== -1) {
	            this._toggleFocusClass(true, currentTarget)
	        }
	        var focusedElement = this.option("focusedElement");
	        if (focusedElement) {
	            this._setFocusedItem(focusedElement);
	            return
	        }
	        var $activeItem = this._getActiveItem();
	        this.option("focusedElement", $activeItem.closest("." + NODE_CLASS))
	    },
	    _setFocusedItem: function($target) {
	        if (!$target || !$target.length) {
	            return
	        }
	        if (!$target.children().hasClass(DISABLED_STATE_CLASS)) {
	            this.callBase($target)
	        }
	        this._scrollableContainer.scrollToElement($target.find("." + ITEM_CLASS).first())
	    },
	    _itemPointerDownHandler: function(e) {
	        if (!this.option("focusStateEnabled")) {
	            return
	        }
	        var $target = $(e.target).closest("." + NODE_CLASS);
	        if (!$target.hasClass(NODE_CLASS)) {
	            return
	        }
	        var itemElement = $target.hasClass(DISABLED_STATE_CLASS) ? null : $target;
	        this.option("focusedElement", itemElement)
	    },
	    _findNonDisabledNodes: function($nodes) {
	        return $nodes.not(function() {
	            return $(this).find(">." + ITEM_CLASS).hasClass(DISABLED_STATE_CLASS)
	        })
	    },
	    _moveFocus: function(location, e) {
	        var FOCUS_UP = "up",
	            FOCUS_DOWN = "down",
	            FOCUS_FIRST = "first",
	            FOCUS_LAST = "last",
	            FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
	            FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
	        this.element().find("." + NODE_CONTAINER_CLASS).each(function() {
	            fx.stop(this, true)
	        });
	        var $items = this._findNonDisabledNodes(this._nodeElements());
	        if (!$items || !$items.length) {
	            return
	        }
	        switch (location) {
	            case FOCUS_UP:
	                var $prevItem = this._prevItem($items);
	                this.option("focusedElement", $prevItem);
	                if (e.shiftKey && this._showCheckboxes()) {
	                    this._updateItemSelection(true, $prevItem.find("." + ITEM_CLASS).get(0))
	                }
	                break;
	            case FOCUS_DOWN:
	                var $nextItem = this._nextItem($items);
	                this.option("focusedElement", $nextItem);
	                if (e.shiftKey && this._showCheckboxes()) {
	                    this._updateItemSelection(true, $nextItem.find("." + ITEM_CLASS).get(0))
	                }
	                break;
	            case FOCUS_FIRST:
	                var $firstItem = $items.first();
	                if (e.shiftKey && this._showCheckboxes()) {
	                    this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)))
	                }
	                this.option("focusedElement", $firstItem);
	                break;
	            case FOCUS_LAST:
	                var $lastItem = $items.last();
	                if (e.shiftKey && this._showCheckboxes()) {
	                    this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)))
	                }
	                this.option("focusedElement", $lastItem);
	                break;
	            case FOCUS_RIGHT:
	                this._expandFocusedContainer();
	                break;
	            case FOCUS_LEFT:
	                this._collapseFocusedContainer();
	                break;
	            default:
	                this.callBase.apply(this, arguments);
	                return
	        }
	    },
	    _nodeElements: function() {
	        return this.element().find("." + NODE_CLASS).not(":hidden")
	    },
	    _expandFocusedContainer: function() {
	        var $focusedItem = this.option("focusedElement");
	        if (!$focusedItem || $focusedItem.hasClass(IS_LEAF)) {
	            return
	        }
	        var $node = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
	        if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
	            this.option("focusedElement", this._nextItem(this._findNonDisabledNodes(this._nodeElements())));
	            return
	        }
	        var node = this._getNodeByItemElement($focusedItem.find(">." + ITEM_CLASS));
	        this._toggleExpandedState(node, true)
	    },
	    _getClosestNonDisabledNode: function($node) {
	        do {
	            $node = $node.parent().closest("." + NODE_CLASS)
	        } while ($node.children(".dx-treeview-item.dx-state-disabled").length);
	        return $node
	    },
	    _collapseFocusedContainer: function() {
	        var $focusedItem = this.option("focusedElement");
	        if (!$focusedItem) {
	            return
	        }
	        var nodeElement = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
	        if (!$focusedItem.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
	            var node = this._getNodeByItemElement($focusedItem.find(">." + ITEM_CLASS));
	            this._toggleExpandedState(node, false)
	        } else {
	            var collapsedNode = this._getClosestNonDisabledNode($focusedItem);
	            collapsedNode.length && this.option("focusedElement", collapsedNode)
	        }
	    },
	    updateDimensions: function() {
	        var that = this,
	            deferred = $.Deferred();
	        if (that._scrollableContainer) {
	            that._scrollableContainer.update().done(function() {
	                deferred.resolveWith(that)
	            })
	        } else {
	            deferred.resolveWith(that)
	        }
	        return deferred.promise()
	    },
	    selectItem: function(itemElement) {
	        this._updateItemSelection(true, itemElement)
	    },
	    unselectItem: function(itemElement) {
	        this._updateItemSelection(false, itemElement)
	    },
	    expandItem: function(itemElement) {
	        this._toggleExpandedState(itemElement, true)
	    },
	    collapseItem: function(itemElement) {
	        this._toggleExpandedState(itemElement, false)
	    },
	    getNodes: function() {
	        return this._dataAdapter.getTreeNodes()
	    },
	    selectAll: function() {
	        if (this._selectAllEnabled()) {
	            this._$selectAllItem.dxCheckBox("instance").option("value", true)
	        } else {
	            this._toggleSelectAll({
	                value: true
	            })
	        }
	    },
	    unselectAll: function() {
	        if (this._selectAllEnabled()) {
	            this._$selectAllItem.dxCheckBox("instance").option("value", false)
	        } else {
	            this._toggleSelectAll({
	                value: false
	            })
	        }
	    },
	    collapseAll: function() {
	        var that = this;
	        $.each(this._dataAdapter.getExpandedNodesKeys(), function(_, key) {
	            that._toggleExpandedState(key, false)
	        })
	    }
	});
	registerComponent("dxTreeView", TreeView);
	module.exports = TreeView;
	module.exports.default = module.exports;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (events/dblclick.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    domUtils = __webpack_require__(43),
	    Class = __webpack_require__(18),
	    registerEvent = __webpack_require__(63),
	    clickEvent = __webpack_require__(65),
	    eventUtils = __webpack_require__(61);
	var DBLCLICK_EVENT_NAME = "dxdblclick",
	    DBLCLICK_NAMESPACE = "dxDblClick",
	    NAMESPACED_CLICK_EVENT = eventUtils.addNamespace(clickEvent.name, DBLCLICK_NAMESPACE),
	    DBLCLICK_TIMEOUT = 300;
	var DblClick = Class.inherit({
	    ctor: function() {
	        this._handlerCount = 0;
	        this._forgetLastClick()
	    },
	    _forgetLastClick: function() {
	        this._firstClickTarget = null;
	        this._lastClickTimeStamp = -DBLCLICK_TIMEOUT
	    },
	    add: function() {
	        if (this._handlerCount <= 0) {
	            $(document).on(NAMESPACED_CLICK_EVENT, $.proxy(this._clickHandler, this))
	        }
	        this._handlerCount++
	    },
	    _clickHandler: function(e) {
	        var timeStamp = e.timeStamp || $.now();
	        if (timeStamp - this._lastClickTimeStamp < DBLCLICK_TIMEOUT) {
	            eventUtils.fireEvent({
	                type: DBLCLICK_EVENT_NAME,
	                target: domUtils.closestCommonParent(this._firstClickTarget, e.target),
	                originalEvent: e
	            });
	            this._forgetLastClick()
	        } else {
	            this._firstClickTarget = e.target;
	            this._lastClickTimeStamp = timeStamp
	        }
	    },
	    remove: function() {
	        this._handlerCount--;
	        if (this._handlerCount <= 0) {
	            this._forgetLastClick();
	            $(document).off(NAMESPACED_CLICK_EVENT)
	        }
	    }
	});
	registerEvent(DBLCLICK_EVENT_NAME, new DblClick);
	exports.name = DBLCLICK_EVENT_NAME;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.grouping_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    ExpandedGroupingHelper = __webpack_require__(218).GroupingHelper,
	    CollapsedGroupingHelper = __webpack_require__(220).GroupingHelper,
	    messageLocalization = __webpack_require__(79),
	    dataSourceAdapter = __webpack_require__(153),
	    commonUtils = __webpack_require__(8),
	    devices = __webpack_require__(40),
	    when = __webpack_require__(10).when;
	var DATAGRID_GROUP_PANEL_CLASS = "dx-datagrid-group-panel",
	    DATAGRID_GROUP_PANEL_MESSAGE_CLASS = "dx-group-panel-message",
	    DATAGRID_GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item",
	    DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened",
	    DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed",
	    DATAGRID_EXPAND_CLASS = "dx-datagrid-expand",
	    DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled",
	    DATAGRID_GROUP_ROW_CLASS = "dx-group-row";
	var GroupingDataSourceAdapterExtender = function() {
	    return {
	        init: function() {
	            this.callBase.apply(this, arguments);
	            this._initGroupingHelper()
	        },
	        _initGroupingHelper: function(options) {
	            var grouping = this._grouping,
	                remoteOperations = options ? options.remoteOperations : this.remoteOperations();
	            if (remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging && !remoteOperations.grouping) {
	                if (!grouping || grouping instanceof CollapsedGroupingHelper) {
	                    this._grouping = new ExpandedGroupingHelper(this)
	                }
	            } else {
	                if (!grouping || grouping instanceof ExpandedGroupingHelper) {
	                    this._grouping = new CollapsedGroupingHelper(this)
	                }
	            }
	        },
	        totalItemsCount: function() {
	            var that = this,
	                totalCount = that.callBase();
	            return totalCount > 0 && that._dataSource.group() && that._dataSource.requireTotalCount() ? totalCount + that._grouping.totalCountCorrection() : totalCount
	        },
	        itemsCount: function() {
	            return this._dataSource.group() ? this._grouping.itemsCount() || 0 : this.callBase()
	        },
	        allowCollapseAll: function() {
	            return this._grouping.allowCollapseAll()
	        },
	        isRowExpanded: function(key) {
	            var groupInfo = this._grouping.findGroupInfo(key);
	            return groupInfo ? groupInfo.isExpanded : !this._grouping.allowCollapseAll()
	        },
	        collapseAll: function(groupIndex) {
	            return this._collapseExpandAll(groupIndex, false)
	        },
	        expandAll: function(groupIndex) {
	            return this._collapseExpandAll(groupIndex, true)
	        },
	        _collapseExpandAll: function(groupIndex, isExpand) {
	            var i, that = this,
	                dataSource = that._dataSource,
	                group = dataSource.group(),
	                groups = gridCore.normalizeSortingInfo(group || []);
	            if (groups.length) {
	                for (i = 0; i < groups.length; i++) {
	                    if (void 0 === groupIndex || groupIndex === i) {
	                        groups[i].isExpanded = isExpand
	                    } else {
	                        if (group && group[i]) {
	                            groups[i].isExpanded = group[i].isExpanded
	                        }
	                    }
	                }
	                dataSource.group(groups);
	                that._grouping.foreachGroups(function(groupInfo, parents) {
	                    if (void 0 === groupIndex || groupIndex === parents.length - 1) {
	                        groupInfo.isExpanded = isExpand
	                    }
	                }, false, true)
	            }
	            return true
	        },
	        refresh: function() {
	            this.callBase.apply(this, arguments);
	            return this._grouping.refresh.apply(this._grouping, arguments)
	        },
	        changeRowExpand: function(path) {
	            var that = this,
	                dataSource = that._dataSource;
	            if (dataSource.group()) {
	                dataSource._changeLoadingCount(1);
	                return that._changeRowExpandCore(path).always(function() {
	                    dataSource._changeLoadingCount(-1)
	                })
	            }
	        },
	        _changeRowExpandCore: function(path) {
	            return this._grouping.changeRowExpand(path)
	        },
	        _hasGroupLevelsExpandState: function(group, isExpanded) {
	            if (group && $.isArray(group)) {
	                for (var i = 0; i < group.length; i++) {
	                    if (group[i].isExpanded === isExpanded) {
	                        return true
	                    }
	                }
	            }
	        },
	        _customizeRemoteOperations: function(options) {
	            var remoteOperations = options.remoteOperations;
	            if (options.storeLoadOptions.group) {
	                if (remoteOperations.grouping && !options.isCustomLoading) {
	                    if (!remoteOperations.groupPaging || this._hasGroupLevelsExpandState(options.storeLoadOptions.group, true)) {
	                        remoteOperations.paging = false
	                    }
	                }
	                if (!remoteOperations.grouping && (!remoteOperations.sorting || !remoteOperations.filtering || options.isCustomLoading || this._hasGroupLevelsExpandState(options.storeLoadOptions.group, false))) {
	                    remoteOperations.paging = false
	                }
	            }
	            this.callBase.apply(this, arguments)
	        },
	        _handleDataLoading: function(options) {
	            this.callBase(options);
	            this._initGroupingHelper(options);
	            return this._grouping.handleDataLoading(options)
	        },
	        _handleDataLoaded: function(options) {
	            return this._grouping.handleDataLoaded(options, $.proxy(this.callBase, this))
	        },
	        _handleDataLoadedCore: function(options) {
	            return this._grouping.handleDataLoadedCore(options, $.proxy(this.callBase, this))
	        }
	    }
	}();
	dataSourceAdapter.extend(GroupingDataSourceAdapterExtender);
	var GroupingDataControllerExtender = function() {
	    return {
	        init: function() {
	            var that = this;
	            that.callBase();
	            that.createAction("onRowExpanding");
	            that.createAction("onRowExpanded");
	            that.createAction("onRowCollapsing");
	            that.createAction("onRowCollapsed")
	        },
	        _processItems: function(items, changeType) {
	            var groupColumns = this._columnsController.getGroupColumns();
	            if (items.length && groupColumns.length) {
	                items = this._processGroupItems(items, groupColumns.length)
	            }
	            return this.callBase(items, changeType)
	        },
	        _processItem: function(item, options) {
	            if (commonUtils.isDefined(item.groupIndex) && commonUtils.isString(item.rowType) && 0 === item.rowType.indexOf("group")) {
	                item = this._processGroupItem(item, options);
	                options.dataIndex = 0
	            } else {
	                item = this.callBase.apply(this, arguments)
	            }
	            return item
	        },
	        _processGroupItem: function(item) {
	            return item
	        },
	        _processGroupItems: function(items, groupsCount, options) {
	            var scrollingMode, i, item, resultItems, that = this,
	                groupedColumns = that._columnsController.getGroupColumns(),
	                column = groupedColumns[groupedColumns.length - groupsCount];
	            if (!options) {
	                scrollingMode = that.option("scrolling.mode");
	                options = {
	                    collectContinuationItems: "virtual" !== scrollingMode && "infinite" !== scrollingMode,
	                    resultItems: [],
	                    path: [],
	                    values: []
	                }
	            }
	            resultItems = options.resultItems;
	            if (options.data) {
	                if (options.collectContinuationItems || !options.data.isContinuation) {
	                    resultItems.push({
	                        rowType: "group",
	                        data: options.data,
	                        groupIndex: options.path.length - 1,
	                        isExpanded: !!options.data.items,
	                        key: options.path.slice(0),
	                        values: options.values.slice(0)
	                    })
	                }
	            }
	            if (items) {
	                if (0 === groupsCount) {
	                    resultItems.push.apply(resultItems, items)
	                } else {
	                    for (i = 0; i < items.length; i++) {
	                        item = items[i];
	                        if (item && "items" in item) {
	                            options.data = item;
	                            options.path.push(item.key);
	                            options.values.push(column && column.deserializeValue ? column.deserializeValue(item.key) : item.key);
	                            that._processGroupItems(item.items, groupsCount - 1, options);
	                            options.data = void 0;
	                            options.path.pop();
	                            options.values.pop()
	                        } else {
	                            resultItems.push(item)
	                        }
	                    }
	                }
	            }
	            return resultItems
	        },
	        publicMethods: function() {
	            return this.callBase().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"])
	        },
	        collapseAll: function(groupIndex) {
	            var dataSource = this._dataSource;
	            if (dataSource && dataSource.collapseAll(groupIndex)) {
	                dataSource.pageIndex(0);
	                dataSource.reload()
	            }
	        },
	        expandAll: function(groupIndex) {
	            var dataSource = this._dataSource;
	            if (dataSource && dataSource.expandAll(groupIndex)) {
	                dataSource.pageIndex(0);
	                dataSource.reload()
	            }
	        },
	        changeRowExpand: function(key) {
	            var that = this,
	                expanded = that.isRowExpanded(key),
	                args = {
	                    key: key,
	                    expanded: expanded
	                };
	            that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
	            if (!args.cancel) {
	                return when(that._changeRowExpandCore(key)).done(function() {
	                    args.expanded = !expanded;
	                    that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args)
	                })
	            }
	        },
	        _changeRowExpandCore: function(key) {
	            var d, that = this,
	                dataSource = this._dataSource;
	            if (!dataSource) {
	                return
	            }
	            d = $.Deferred();
	            when(dataSource.changeRowExpand(key)).done(function() {
	                that.load().done(d.resolve).fail(d.reject)
	            }).fail(d.reject);
	            return d
	        },
	        isRowExpanded: function(key) {
	            var dataSource = this._dataSource;
	            return dataSource && dataSource.isRowExpanded(key)
	        },
	        expandRow: function(key) {
	            if (!this.isRowExpanded(key)) {
	                return this.changeRowExpand(key)
	            }
	            return $.Deferred().resolve()
	        },
	        collapseRow: function(key) {
	            if (this.isRowExpanded(key)) {
	                return this.changeRowExpand(key)
	            }
	            return $.Deferred().resolve()
	        },
	        optionChanged: function(args) {
	            if ("grouping" === args.name) {
	                args.name = "dataSource"
	            }
	            this.callBase(args)
	        }
	    }
	}();
	var onGroupingMenuItemClick = function(column, params) {
	    var columnsController = this._columnsController;
	    switch (params.itemData.value) {
	        case "group":
	            var groups = columnsController._dataSource.group() || [];
	            columnsController.columnOption(column.dataField, "groupIndex", groups.length);
	            break;
	        case "ungroup":
	            columnsController.columnOption(column.dataField, "groupIndex", -1);
	            break;
	        case "ungroupAll":
	            this.component.clearGrouping()
	    }
	};
	var GroupingHeaderPanelExtender = function() {
	    return {
	        _getToolbarItems: function() {
	            var items = this.callBase();
	            return this._appendGroupingItem(items)
	        },
	        _appendGroupingItem: function(items) {
	            var that = this;
	            if (that._isGroupPanelVisible()) {
	                var toolbarItem = {
	                    template: function(data, index, $container) {
	                        var $groupPanel = $("<div />").addClass(DATAGRID_GROUP_PANEL_CLASS).appendTo($container);
	                        that._updateGroupPanelContent($groupPanel)
	                    },
	                    name: "groupPanel",
	                    location: "before",
	                    locateInMenu: "never"
	                };
	                items.push(toolbarItem)
	            }
	            return items
	        },
	        _updateGroupPanelContent: function($groupPanel) {
	            var that = this,
	                groupColumns = that.getController("columns").getGroupColumns(),
	                groupPanelOptions = that.option("groupPanel");
	            that._renderGroupPanelItems($groupPanel, groupColumns);
	            if (groupPanelOptions.allowColumnDragging && !groupColumns.length) {
	                $("<div />").addClass(DATAGRID_GROUP_PANEL_MESSAGE_CLASS).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel)
	            }
	        },
	        _isGroupPanelVisible: function() {
	            var isVisible, groupPanelOptions = this.option("groupPanel");
	            if (groupPanelOptions) {
	                isVisible = groupPanelOptions.visible;
	                if ("auto" === isVisible) {
	                    isVisible = "desktop" === devices.current().deviceType ? true : false
	                }
	            }
	            return isVisible
	        },
	        _renderGroupPanelItems: function($groupPanel, groupColumns) {
	            var that = this;
	            $groupPanel.empty();
	            $.each(groupColumns, function(index, groupColumn) {
	                that._createGroupPanelItem($groupPanel, groupColumn)
	            })
	        },
	        _createGroupPanelItem: function($rootElement, groupColumn) {
	            return $("<div />").addClass(groupColumn.cssClass).addClass(DATAGRID_GROUP_PANEL_ITEM_CLASS).data("columnData", groupColumn).appendTo($rootElement).text(groupColumn.caption)
	        },
	        _renderCore: function() {
	            if (this._toolbar) {
	                var $groupPanel = this.element().find("." + DATAGRID_GROUP_PANEL_CLASS);
	                if ($groupPanel.length) {
	                    this._updateGroupPanelContent($groupPanel)
	                }
	            }
	            this.callBase()
	        },
	        allowDragging: function(column) {
	            var groupPanelOptions = this.option("groupPanel");
	            return this._isGroupPanelVisible() && groupPanelOptions.allowColumnDragging && column && column.allowGrouping
	        },
	        getColumnElements: function() {
	            var $element = this.element();
	            return $element && $element.find("." + DATAGRID_GROUP_PANEL_ITEM_CLASS)
	        },
	        getColumns: function() {
	            return this.getController("columns").getGroupColumns()
	        },
	        getBoundingRect: function() {
	            var offset, that = this,
	                $element = that.element();
	            if ($element && $element.find("." + DATAGRID_GROUP_PANEL_CLASS).length) {
	                offset = $element.offset();
	                return {
	                    top: offset.top,
	                    bottom: offset.top + $element.height()
	                }
	            }
	            return null
	        },
	        getName: function() {
	            return "group"
	        },
	        getContextMenuItems: function(options) {
	            var items, that = this,
	                contextMenuEnabled = that.option("grouping.contextMenuEnabled"),
	                $groupedColumnElement = options.targetElement.closest("." + DATAGRID_GROUP_PANEL_ITEM_CLASS);
	            if ($groupedColumnElement.length) {
	                options.column = $groupedColumnElement.data("columnData")
	            }
	            if (contextMenuEnabled && options.column) {
	                var column = options.column,
	                    isGroupingAllowed = commonUtils.isDefined(column.allowGrouping) ? column.allowGrouping : true;
	                if (isGroupingAllowed) {
	                    var isColumnGrouped = commonUtils.isDefined(column.groupIndex) && column.groupIndex > -1,
	                        groupingTexts = that.option("grouping.texts"),
	                        onItemClick = $.proxy(onGroupingMenuItemClick, that, column);
	                    items = [{
	                        text: groupingTexts.ungroup,
	                        value: "ungroup",
	                        disabled: !isColumnGrouped,
	                        onItemClick: onItemClick
	                    }, {
	                        text: groupingTexts.ungroupAll,
	                        value: "ungroupAll",
	                        onItemClick: onItemClick
	                    }]
	                }
	            }
	            return items
	        },
	        isVisible: function() {
	            return this.callBase() || this._isGroupPanelVisible()
	        },
	        optionChanged: function(args) {
	            if ("groupPanel" === args.name) {
	                this.updateToolbar();
	                args.handled = true
	            } else {
	                this.callBase(args)
	            }
	        }
	    }
	}();
	exports.GroupingHeaderPanelExtender = GroupingHeaderPanelExtender;
	var GroupingRowsViewExtender = function() {
	    return {
	        getContextMenuItems: function(options) {
	            var items, that = this,
	                contextMenuEnabled = that.option("grouping.contextMenuEnabled");
	            if (contextMenuEnabled && options.row && "group" === options.row.rowType) {
	                var columnsController = that._columnsController,
	                    column = columnsController.columnOption("groupIndex:" + options.row.groupIndex);
	                if (column && column.allowGrouping) {
	                    var groupingTexts = that.option("grouping.texts"),
	                        onItemClick = $.proxy(onGroupingMenuItemClick, that, column);
	                    items = [];
	                    items.push({
	                        text: groupingTexts.ungroup,
	                        value: "ungroup",
	                        onItemClick: onItemClick
	                    }, {
	                        text: groupingTexts.ungroupAll,
	                        value: "ungroupAll",
	                        onItemClick: onItemClick
	                    })
	                }
	            }
	            return items
	        },
	        _rowClick: function(e) {
	            var that = this,
	                expandMode = that.option("grouping.expandMode"),
	                isGroupRowStateChanged = "rowClick" === expandMode && $(e.jQueryEvent.target).closest("." + DATAGRID_GROUP_ROW_CLASS).length,
	                isExpandButtonClicked = $(e.jQueryEvent.target).closest("." + DATAGRID_EXPAND_CLASS).length;
	            if (isGroupRowStateChanged || isExpandButtonClicked) {
	                that._changeGroupRowState(e)
	            }
	            that.callBase(e)
	        },
	        _changeGroupRowState: function(e) {
	            var dataController = this.getController("data"),
	                row = dataController.items()[e.rowIndex];
	            if ("detail" !== row.rowType) {
	                dataController.changeRowExpand(row.key);
	                e.jQueryEvent.preventDefault();
	                e.handled = true
	            }
	        },
	        _getCellTemplate: function(options) {
	            var that = this;
	            if ("expand" === options.column.command) {
	                return {
	                    allowRenderToDetachedContainer: true,
	                    render: function(container, options) {
	                        if (commonUtils.isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.inserted) {
	                            container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
	                            $("<div>").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo(container);
	                            that.setAria("label", options.value ? that.localize("dxDataGrid-ariaCollapse") : that.localize("dxDataGrid-ariaExpand"), container)
	                        }
	                    }
	                }
	            }
	            return that.callBase(options)
	        }
	    }
	}();
	var columnHeadersViewExtender = function() {
	    return {
	        getContextMenuItems: function(options) {
	            var that = this,
	                contextMenuEnabled = that.option("grouping.contextMenuEnabled"),
	                items = that.callBase(options);
	            if (contextMenuEnabled && options.row && "header" === options.row.rowType) {
	                var column = options.column;
	                if (!column.command && (!commonUtils.isDefined(column.allowGrouping) || column.allowGrouping)) {
	                    var groupingTexts = that.option("grouping.texts"),
	                        isColumnGrouped = commonUtils.isDefined(column.groupIndex) && column.groupIndex > -1,
	                        onItemClick = $.proxy(onGroupingMenuItemClick, that, column);
	                    items = items || [];
	                    items.push({
	                        text: groupingTexts.groupByThisColumn,
	                        value: "group",
	                        beginGroup: true,
	                        disabled: isColumnGrouped,
	                        onItemClick: onItemClick
	                    });
	                    if (column.showWhenGrouped) {
	                        items.push({
	                            text: groupingTexts.ungroup,
	                            value: "ungroup",
	                            disabled: !isColumnGrouped,
	                            onItemClick: onItemClick
	                        })
	                    }
	                    items.push({
	                        text: groupingTexts.ungroupAll,
	                        value: "ungroupAll",
	                        onItemClick: onItemClick
	                    })
	                }
	            }
	            return items
	        }
	    }
	}();
	gridCore.registerModule("grouping", {
	    defaultOptions: function() {
	        return {
	            grouping: {
	                autoExpandAll: true,
	                allowCollapsing: true,
	                contextMenuEnabled: false,
	                expandMode: "buttonClick",
	                texts: {
	                    groupContinuesMessage: messageLocalization.format("dxDataGrid-groupContinuesMessage"),
	                    groupContinuedMessage: messageLocalization.format("dxDataGrid-groupContinuedMessage"),
	                    groupByThisColumn: messageLocalization.format("dxDataGrid-groupHeaderText"),
	                    ungroup: messageLocalization.format("dxDataGrid-ungroupHeaderText"),
	                    ungroupAll: messageLocalization.format("dxDataGrid-ungroupAllText")
	                }
	            },
	            groupPanel: {
	                visible: false,
	                emptyPanelText: messageLocalization.format("dxDataGrid-groupPanelEmptyText"),
	                allowColumnDragging: true
	            }
	        }
	    },
	    extenders: {
	        controllers: {
	            data: GroupingDataControllerExtender
	        },
	        views: {
	            headerPanel: GroupingHeaderPanelExtender,
	            rowsView: GroupingRowsViewExtender,
	            columnHeadersView: columnHeadersViewExtender
	        }
	    }
	});


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.grouping.server.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    toComparable = __webpack_require__(35).toComparable,
	    dataUtils = __webpack_require__(122),
	    Store = __webpack_require__(123),
	    gridCore = __webpack_require__(144),
	    normalizeSortingInfo = gridCore.normalizeSortingInfo,
	    groupingCore = __webpack_require__(219),
	    createGroupFilter = groupingCore.createGroupFilter,
	    createOffsetFilter = groupingCore.createOffsetFilter,
	    dataQuery = __webpack_require__(125),
	    when = __webpack_require__(10).when;
	var loadTotalCount = function(dataSource, options) {
	    var d = $.Deferred(),
	        loadOptions = $.extend({
	            skip: 0,
	            take: 1,
	            requireTotalCount: true
	        }, options);
	    dataSource.load(loadOptions).done(function(data, extra) {
	        d.resolve(extra && extra.totalCount)
	    }).fail($.proxy(d.reject, d));
	    return d
	};
	exports.GroupingHelper = groupingCore.GroupingHelper.inherit(function() {
	    var foreachCollapsedGroups = function(that, callback, updateOffsets) {
	        return that.foreachGroups(function(groupInfo) {
	            if (!groupInfo.isExpanded) {
	                return callback(groupInfo)
	            }
	        }, false, false, updateOffsets, true)
	    };
	    var correctSkipLoadOption = function(that, skip) {
	        var skipCorrection = 0,
	            resultSkip = skip || 0;
	        if (skip) {
	            foreachCollapsedGroups(that, function(groupInfo) {
	                if (groupInfo.offset - skipCorrection >= skip) {
	                    return false
	                }
	                skipCorrection += groupInfo.count - 1
	            });
	            resultSkip += skipCorrection
	        }
	        return resultSkip
	    };
	    var processGroupItems = function(that, items, path, offset, skipFirstItem, take) {
	        var i, item, offsetInfo, removeLastItemsCount = 0,
	            needRemoveFirstItem = false;
	        for (i = 0; i < items.length; i++) {
	            item = items[i];
	            if (void 0 !== item.items) {
	                path.push(item.key);
	                var groupInfo = that.findGroupInfo(path);
	                if (groupInfo && !groupInfo.isExpanded) {
	                    item.collapsedItems = item.items;
	                    item.items = null;
	                    offset += groupInfo.count;
	                    take--;
	                    if (take < 0) {
	                        removeLastItemsCount++
	                    }
	                    if (skipFirstItem) {
	                        needRemoveFirstItem = true
	                    }
	                } else {
	                    if (item.items) {
	                        offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);
	                        if (skipFirstItem) {
	                            if (offsetInfo.offset - offset > 1) {
	                                item.isContinuation = true
	                            } else {
	                                needRemoveFirstItem = true
	                            }
	                        }
	                        offset = offsetInfo.offset;
	                        take = offsetInfo.take;
	                        if (take < 0) {
	                            if (item.items.length) {
	                                item.isContinuationOnNextPage = true
	                            } else {
	                                removeLastItemsCount++
	                            }
	                        }
	                    }
	                }
	                path.pop()
	            } else {
	                if (skipFirstItem) {
	                    needRemoveFirstItem = true
	                }
	                offset++;
	                take--;
	                if (take < 0) {
	                    removeLastItemsCount++
	                }
	            }
	            skipFirstItem = false
	        }
	        if (needRemoveFirstItem) {
	            items.splice(0, 1)
	        }
	        if (removeLastItemsCount) {
	            items.splice(-removeLastItemsCount, removeLastItemsCount)
	        }
	        return {
	            offset: offset,
	            take: take
	        }
	    };
	    var pathEquals = function(path1, path2) {
	        var i;
	        if (path1.length !== path2.length) {
	            return false
	        }
	        for (i = 0; i < path1.length; i++) {
	            if (!dataUtils.keysEqual(null, path1[i], path2[i])) {
	                return false
	            }
	        }
	        return true
	    };
	    var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
	        var i, item;
	        if (!items) {
	            return
	        }
	        for (i = 0; i < items.length; i++) {
	            item = items[i];
	            if ("key" in item && void 0 !== item.items) {
	                path.push(item.key);
	                if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {
	                    additionalGroupInfo.offset = offset
	                }
	                var groupInfo = that.findGroupInfo(path);
	                if (groupInfo && !item.isContinuation) {
	                    groupInfo.offset = offset
	                }
	                if (groupInfo && !groupInfo.isExpanded) {
	                    offset += groupInfo.count
	                } else {
	                    offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo)
	                }
	                path.pop()
	            } else {
	                offset++
	            }
	        }
	        return offset
	    };
	    var removeGroupLoadOption = function(storeLoadOptions, loadOptions) {
	        var groups, sorts;
	        if (loadOptions.group) {
	            groups = normalizeSortingInfo(loadOptions.group);
	            sorts = normalizeSortingInfo(storeLoadOptions.sort);
	            storeLoadOptions.sort = Store.arrangeSortingInfo(groups, sorts);
	            delete loadOptions.group
	        }
	    };
	    var createNotGroupFilter = function(path, storeLoadOptions, group) {
	        var i, j, filterElement, groups = normalizeSortingInfo(group || storeLoadOptions.group),
	            filter = [];
	        for (i = 0; i < path.length; i++) {
	            filterElement = [];
	            for (j = 0; j <= i; j++) {
	                filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]])
	            }
	            filter.push(gridCore.combineFilters(filterElement))
	        }
	        filter = gridCore.combineFilters(filter, "or");
	        return gridCore.combineFilters([filter, storeLoadOptions.filter])
	    };
	    var getGroupCount = function(item, groupCount) {
	        var i, count = item.count || item.items.length;
	        if (!item.count && groupCount > 1) {
	            count = 0;
	            for (i = 0; i < item.items.length; i++) {
	                count += getGroupCount(item.items[i], groupCount - 1)
	            }
	        }
	        return count
	    };
	    return {
	        handleDataLoading: function(options) {
	            var loadOptions, take, that = this,
	                storeLoadOptions = options.storeLoadOptions,
	                collapsedGroups = [],
	                collapsedItemsCount = 0,
	                skipFirstItem = false,
	                group = options.loadOptions.group,
	                skipCorrection = 0;
	            removeGroupLoadOption(storeLoadOptions, options.loadOptions);
	            options.group = options.group || group;
	            if (options.isCustomLoading) {
	                return
	            }
	            loadOptions = $.extend({}, storeLoadOptions);
	            loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);
	            if (loadOptions.skip && loadOptions.take && group) {
	                loadOptions.skip--;
	                loadOptions.take++;
	                skipFirstItem = true
	            }
	            if (loadOptions.take && group) {
	                take = loadOptions.take;
	                loadOptions.take++
	            }
	            foreachCollapsedGroups(that, function(groupInfo) {
	                if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {
	                    return false
	                } else {
	                    if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
	                        skipCorrection += groupInfo.count - 1;
	                        collapsedGroups.push(groupInfo);
	                        collapsedItemsCount += groupInfo.count
	                    }
	                }
	            });
	            $.each(collapsedGroups, function() {
	                loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group)
	            });
	            options.storeLoadOptions = loadOptions;
	            options.collapsedGroups = collapsedGroups;
	            options.collapsedItemsCount = collapsedItemsCount;
	            options.skip = loadOptions.skip || 0;
	            options.skipFirstItem = skipFirstItem;
	            options.take = take
	        },
	        handleDataLoaded: function(options, callBase) {
	            var pathIndex, query, that = this,
	                data = options.data,
	                collapsedGroups = options.collapsedGroups,
	                groups = normalizeSortingInfo(options.group),
	                groupCount = groups.length;

	            function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {
	                if (!data || !path.length || !groups.length) {
	                    return
	                }
	                var i, keyValue, pathValue = toComparable(path[0], true);
	                for (i = 0; i < data.length; i++) {
	                    keyValue = toComparable(data[i].key, true);
	                    if (offset >= collapsedGroup.offset || pathValue === keyValue) {
	                        break
	                    } else {
	                        offset += getGroupCount(data[i], groups.length)
	                    }
	                }
	                if (!data.length || pathValue !== keyValue) {
	                    data.splice(i, 0, {
	                        key: path[0],
	                        items: [],
	                        count: 1 === path.length ? collapsedGroup.count : void 0
	                    })
	                }
	                appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset)
	            }
	            callBase(options);
	            if (groupCount) {
	                query = dataQuery(data);
	                Store.multiLevelGroup(query, groups).enumerate().done(function(groupedData) {
	                    data = groupedData
	                });
	                if (collapsedGroups) {
	                    for (pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {
	                        appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip)
	                    }
	                }
	                if (!options.isCustomLoading) {
	                    processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);
	                    that.updateItemsCount(data, groupCount)
	                }
	                options.data = data;
	                if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {
	                    options.extra.totalCount += options.collapsedItemsCount
	                }
	            }
	        },
	        updateTotalItemsCount: function() {
	            var itemsCountCorrection = 0;
	            foreachCollapsedGroups(this, function(groupInfo) {
	                if (groupInfo.count) {
	                    itemsCountCorrection -= groupInfo.count - 1
	                }
	            });
	            this.callBase(itemsCountCorrection)
	        },
	        changeRowExpand: function(path) {
	            var groupCountQuery, that = this,
	                dataSource = that._dataSource,
	                beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex(),
	                dataSourceItems = dataSource.items(),
	                offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize()),
	                groupInfo = that.findGroupInfo(path);
	            if (groupInfo && !groupInfo.isExpanded) {
	                groupCountQuery = $.Deferred().resolve(groupInfo.count)
	            } else {
	                groupCountQuery = loadTotalCount(dataSource, {
	                    filter: createGroupFilter(path, {
	                        filter: dataSource.filter(),
	                        group: dataSource.group()
	                    })
	                })
	            }
	            return when(groupCountQuery).done(function(count) {
	                count = parseInt(count.length ? count[0] : count);
	                if (groupInfo) {
	                    updateGroupOffsets(that, dataSourceItems, [], offset);
	                    groupInfo.isExpanded = !groupInfo.isExpanded;
	                    groupInfo.count = count
	                } else {
	                    groupInfo = {
	                        offset: -1,
	                        count: count,
	                        path: path,
	                        isExpanded: false
	                    };
	                    updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
	                    if (groupInfo.offset >= 0) {
	                        that.addGroupInfo(groupInfo)
	                    }
	                }
	                that.updateTotalItemsCount()
	            }).fail(function() {
	                dataSource.fireEvent("loadError", arguments)
	            })
	        },
	        allowCollapseAll: function() {
	            return false
	        },
	        refresh: function(options, isReload, operationTypes) {
	            var that = this,
	                storeLoadOptions = options.storeLoadOptions,
	                dataSource = that._dataSource;
	            this.callBase.apply(this, arguments);
	            if (isReload || operationTypes.reload) {
	                return foreachCollapsedGroups(that, function(groupInfo) {
	                    var groupCountQuery = loadTotalCount(dataSource, {
	                            filter: createGroupFilter(groupInfo.path, storeLoadOptions)
	                        }),
	                        groupOffsetQuery = loadTotalCount(dataSource, {
	                            filter: createOffsetFilter(groupInfo.path, storeLoadOptions)
	                        });
	                    return when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
	                        offset = parseInt(offset.length ? offset[0] : offset);
	                        count = parseInt(count.length ? count[0] : count);
	                        groupInfo.offset = offset;
	                        if (groupInfo.count !== count) {
	                            groupInfo.count = count;
	                            that.updateTotalItemsCount()
	                        }
	                    })
	                }, true)
	            }
	        }
	    }
	}());


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.grouping.core.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    gridCore = __webpack_require__(144),
	    normalizeSortingInfo = __webpack_require__(122).normalizeSortingInfo,
	    when = __webpack_require__(10).when;
	exports.createGroupFilter = function(path, storeLoadOptions) {
	    var i, groups = normalizeSortingInfo(storeLoadOptions.group),
	        filter = [];
	    for (i = 0; i < path.length; i++) {
	        filter.push([groups[i].selector, "=", path[i]])
	    }
	    if (storeLoadOptions.filter) {
	        filter.push(storeLoadOptions.filter)
	    }
	    return gridCore.combineFilters(filter)
	};
	exports.createOffsetFilter = function(path, storeLoadOptions) {
	    var i, j, filterElement, groups = normalizeSortingInfo(storeLoadOptions.group),
	        filter = [];
	    for (i = 0; i < path.length; i++) {
	        filterElement = [];
	        for (j = 0; j <= i; j++) {
	            filterElement.push([groups[j].selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]])
	        }
	        filter.push(gridCore.combineFilters(filterElement))
	    }
	    filter = gridCore.combineFilters(filter, "or");
	    return gridCore.combineFilters([filter, storeLoadOptions.filter])
	};
	exports.GroupingHelper = Class.inherit(function() {
	    var findGroupInfoByKey = function(groupsInfo, key) {
	        var hash = groupsInfo.hash;
	        return hash && hash[key]
	    };
	    var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
	        var index, leftIndex = 0,
	            rightIndex = groupsInfo.length - 1;
	        if (!groupsInfo.length) {
	            return 0
	        }
	        do {
	            var middleIndex = rightIndex + leftIndex >> 1;
	            if (groupsInfo[middleIndex].offset > offset) {
	                rightIndex = middleIndex
	            } else {
	                leftIndex = middleIndex
	            }
	        } while (rightIndex - leftIndex > 1);
	        for (index = leftIndex; index <= rightIndex; index++) {
	            if (groupsInfo[index].offset > offset) {
	                break
	            }
	        }
	        return index
	    };
	    var updateGroupInfoOffsets = function(groupsInfo, parents) {
	        var groupInfo, index;
	        parents = parents || [];
	        for (index = 0; index < groupsInfo.length; index++) {
	            groupInfo = groupsInfo[index];
	            if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
	                groupInfo.offset = groupInfo.data.offset;
	                for (var parentIndex = 0; parentIndex < parents.length; parentIndex++) {
	                    parents[parentIndex].offset = groupInfo.offset
	                }
	            }
	        }
	        groupsInfo.sort(function(a, b) {
	            return a.offset - b.offset
	        })
	    };
	    var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
	        var i;
	        for (i = 0; i < groupsInfo.length; i++) {
	            if (groupIndex + 1 >= groupsCount) {
	                groupsInfo[i].children = []
	            } else {
	                cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)
	            }
	        }
	    };
	    return {
	        ctor: function(dataSourceAdapter) {
	            this._dataSource = dataSourceAdapter;
	            this.reset()
	        },
	        reset: function() {
	            this._groupsInfo = [];
	            this._totalCountCorrection = 0;
	            this._itemsCount = 0
	        },
	        totalCountCorrection: function() {
	            return this._totalCountCorrection
	        },
	        updateTotalItemsCount: function(totalCountCorrection) {
	            this._totalCountCorrection = totalCountCorrection || 0
	        },
	        _isGroupItemCountable: function(item) {
	            return !this._isVirtualPaging() || !item.isContinuation
	        },
	        _isVirtualPaging: function() {
	            var scrollingMode = this._dataSource.option("scrolling.mode");
	            return "virtual" === scrollingMode || "infinite" === scrollingMode
	        },
	        itemsCount: function() {
	            return this._itemsCount
	        },
	        updateItemsCount: function(data, groupsCount) {
	            function calculateItemsCount(that, items, groupsCount) {
	                var i, result = 0;
	                if (items) {
	                    if (!groupsCount) {
	                        result = items.length
	                    } else {
	                        for (i = 0; i < items.length; i++) {
	                            if (that._isGroupItemCountable(items[i])) {
	                                result++
	                            }
	                            result += calculateItemsCount(that, items[i].items, groupsCount - 1)
	                        }
	                    }
	                }
	                return result
	            }
	            this._itemsCount = calculateItemsCount(this, data, groupsCount)
	        },
	        foreachGroups: function(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets, updateParentOffsets) {
	            var that = this;

	            function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {
	                var i, callbackResult, callbackResults = [];

	                function executeCallback(callback, data, parents, callbackResults) {
	                    var callbackResult = data && callback(data, parents);
	                    callbackResult && callbackResults.push(callbackResult);
	                    return callbackResult
	                }
	                for (i = 0; i < groupsInfo.length; i++) {
	                    parents.push(groupsInfo[i].data);
	                    if (!childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {
	                        return false
	                    }
	                    if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {
	                        callbackResult = foreachGroupsCore(groupsInfo[i].children, callback, childrenAtFirst, parents);
	                        callbackResult && callbackResults.push(callbackResult);
	                        if (false === callbackResult) {
	                            return false
	                        }
	                    }
	                    if (childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {
	                        return false
	                    }
	                    if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {
	                        updateOffsets = true
	                    }
	                    parents.pop()
	                }
	                var currentParents = updateParentOffsets && parents.slice(0);
	                return updateOffsets && when.apply($, callbackResults).always(function() {
	                    updateGroupInfoOffsets(groupsInfo, currentParents)
	                })
	            }
	            return foreachGroupsCore(that._groupsInfo, callback, childrenAtFirst, [])
	        },
	        findGroupInfo: function(path) {
	            var pathIndex, groupInfo, that = this,
	                groupsInfo = that._groupsInfo;
	            for (pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
	                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
	                groupsInfo = groupInfo && groupInfo.children
	            }
	            return groupInfo && groupInfo.data
	        },
	        addGroupInfo: function(groupInfoData) {
	            var index, groupInfo, pathIndex, that = this,
	                path = groupInfoData.path,
	                groupsInfo = that._groupsInfo;
	            for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
	                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
	                if (!groupInfo) {
	                    groupInfo = {
	                        key: path[pathIndex],
	                        offset: groupInfoData.offset,
	                        data: {
	                            offset: groupInfoData.offset,
	                            isExpanded: true,
	                            path: path.slice(0, pathIndex + 1)
	                        },
	                        children: []
	                    };
	                    index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
	                    groupsInfo.splice(index, 0, groupInfo);
	                    groupsInfo.hash = groupsInfo.hash || {};
	                    groupsInfo.hash[groupInfo.key] = groupInfo
	                }
	                if (pathIndex === path.length - 1) {
	                    groupInfo.data = groupInfoData;
	                    if (groupInfo.offset !== groupInfoData.offset) {
	                        updateGroupInfoOffsets(groupsInfo)
	                    }
	                }
	                groupsInfo = groupInfo.children
	            }
	        },
	        allowCollapseAll: function() {
	            return true
	        },
	        refresh: function(options) {
	            var groupIndex, that = this,
	                storeLoadOptions = options.storeLoadOptions,
	                oldGroups = normalizeSortingInfo(that._group || []),
	                groups = normalizeSortingInfo(storeLoadOptions.group || []),
	                groupsCount = Math.min(oldGroups.length, groups.length);
	            that._group = storeLoadOptions.group;
	            for (groupIndex = 0; groupIndex < groupsCount; groupIndex++) {
	                if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {
	                    groupsCount = groupIndex;
	                    break
	                }
	            }
	            if (!groupsCount) {
	                that.reset()
	            } else {
	                cleanGroupsInfo(that._groupsInfo, 0, groupsCount)
	            }
	        },
	        handleDataLoading: function() {},
	        handleDataLoaded: function(options, callBase) {
	            callBase(options)
	        },
	        handleDataLoadedCore: function(options, callBase) {
	            callBase(options)
	        }
	    }
	}());


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.grouping.client.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    normalizeSortingInfo = gridCore.normalizeSortingInfo,
	    groupingCore = __webpack_require__(219),
	    createGroupFilter = groupingCore.createGroupFilter,
	    createOffsetFilter = groupingCore.createOffsetFilter,
	    dataQuery = __webpack_require__(125),
	    errors = __webpack_require__(15),
	    when = __webpack_require__(10).when;
	exports.GroupingHelper = groupingCore.GroupingHelper.inherit(function() {
	    var foreachExpandedGroups = function(that, callback) {
	        return that.foreachGroups(function(groupInfo, parents) {
	            if (groupInfo.isExpanded) {
	                return callback(groupInfo, parents)
	            }
	        }, true)
	    };
	    var processGroupItems = function(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {
	        var i, item, groupInfo, isExpanded;
	        expandedInfo.items = expandedInfo.items || [];
	        expandedInfo.paths = expandedInfo.paths || [];
	        expandedInfo.count = expandedInfo.count || 0;
	        expandedInfo.lastCount = expandedInfo.lastCount || 0;
	        if (!groupsCount) {
	            return
	        }
	        for (i = 0; i < items.length; i++) {
	            item = items[i];
	            if (void 0 !== item.items) {
	                path.push(item.key);
	                if (isCustomLoading) {
	                    isExpanded = true
	                } else {
	                    groupInfo = that.findGroupInfo(path);
	                    isExpanded = groupInfo && groupInfo.isExpanded
	                }
	                if (!isExpanded) {
	                    item.collapsedItems = item.items;
	                    item.items = null
	                } else {
	                    if (item.items) {
	                        processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded)
	                    } else {
	                        if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {
	                            expandedInfo.items.push(item);
	                            expandedInfo.paths.push(path.slice(0));
	                            expandedInfo.count += expandedInfo.lastCount;
	                            expandedInfo.lastCount = item.count
	                        }
	                    }
	                }
	                path.pop()
	            }
	        }
	    };
	    var updateGroupInfoItem = function(that, item, isLastGroupLevel, path, offset) {
	        var count, groupInfo = that.findGroupInfo(path);
	        if (!groupInfo) {
	            if (isLastGroupLevel) {
	                count = item.count > 0 ? item.count : item.items.length
	            }
	            that.addGroupInfo({
	                isExpanded: that._isGroupExpanded(path.length - 1),
	                path: path.slice(0),
	                offset: offset,
	                count: count || 0
	            })
	        } else {
	            if (isLastGroupLevel) {
	                groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0
	            } else {
	                item.count = groupInfo.count
	            }
	            groupInfo.offset = offset
	        }
	    };
	    var updateGroupInfos = function(that, options, items, loadedGroupCount, groupIndex, path) {
	        var item, count, i, groupCount = options.group ? options.group.length : 0,
	            isLastGroupLevel = groupCount === loadedGroupCount,
	            remotePaging = options.remoteOperations.paging,
	            validateItemsCount = !remotePaging,
	            offset = 0,
	            totalCount = 0;
	        groupIndex = groupIndex || 0;
	        path = path || [];
	        if (remotePaging) {
	            offset = 0 === groupIndex ? options.skip || 0 : options.skips[groupIndex - 1] || 0
	        }
	        if (groupIndex >= loadedGroupCount) {
	            return items.length
	        }
	        for (i = 0; i < items.length; i++) {
	            item = items[i];
	            if (item) {
	                path.push(item.key);
	                if (validateItemsCount && !item.count && !item.items || void 0 === item.items) {
	                    return -1
	                }
	                updateGroupInfoItem(that, item, isLastGroupLevel, path, offset + i);
	                count = item.items ? updateGroupInfos(that, options, item.items, loadedGroupCount, groupIndex + 1, path) : item.count || -1;
	                if (validateItemsCount && count < 0) {
	                    return -1
	                }
	                totalCount += count;
	                path.pop()
	            }
	        }
	        return totalCount
	    };
	    var isGroupExpanded = function(groups, groupIndex) {
	        return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded
	    };
	    var getTotalOffset = function(groupInfos, pageSize, offset) {
	        var groupIndex, groupSize, totalOffset = offset;
	        for (groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
	            groupSize = groupInfos[groupIndex].offset + 1;
	            if (groupIndex > 0) {
	                groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
	                if (pageSize) {
	                    groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex
	                }
	            }
	            totalOffset += groupSize
	        }
	        return totalOffset
	    };
	    var getContinuationGroupCount = function(groupOffset, pageSize, groupSize, groupIndex) {
	        groupIndex = groupIndex || 0;
	        if (pageSize > 1 && groupSize > 0) {
	            var pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
	            pageOffset += groupSize - groupIndex - 2;
	            if (pageOffset < 0) {
	                pageOffset += pageSize
	            }
	            return Math.floor(pageOffset / (pageSize - groupIndex - 1))
	        }
	        return 0
	    };

	    function applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex) {
	        var item = expandedInfo.items[expandedItemIndex],
	            skip = options.skips && options.skips[groupLevel],
	            take = options.takes && options.takes[groupLevel],
	            isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1,
	            isFirstExpandedItem = 0 === expandedItemIndex,
	            lastExpandedItemSkip = isFirstExpandedItem && skip || 0,
	            isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;
	        if (isFirstExpandedItem && void 0 !== skip) {
	            item.isContinuation = true
	        }
	        if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {
	            item.isContinuationOnNextPage = true
	        }
	    }

	    function fillSkipTakeInExpandedInfo(options, expandedInfo, currentGroupCount) {
	        var currentGroupIndex = currentGroupCount - 1,
	            groupCount = options.group ? options.group.length : 0;
	        expandedInfo.skip = options.skips && options.skips[currentGroupIndex];
	        if (options.takes && void 0 !== options.takes[currentGroupIndex]) {
	            if (groupCount === currentGroupCount) {
	                expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0
	            } else {
	                expandedInfo.take = 0
	            }
	            expandedInfo.take += options.takes[currentGroupIndex]
	        }
	    }

	    function isDataDeferred(data) {
	        return !Array.isArray(data)
	    }

	    function makeDataDeferred(options) {
	        if (!isDataDeferred(options.data)) {
	            options.data = $.Deferred()
	        }
	    }

	    function loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel, data) {
	        if (!options.isCustomLoading) {
	            expandedInfo = {};
	            var currentGroupCount = loadedGroupCount + groupLevel;
	            processGroupItems(that, data, currentGroupCount, expandedInfo, []);
	            fillSkipTakeInExpandedInfo(options, expandedInfo, currentGroupCount)
	        }
	        var groupCount = options.group ? options.group.length : 0;
	        if (expandedInfo.paths.length && groupCount - loadedGroupCount - groupLevel > 0) {
	            makeDataDeferred(options);
	            loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data)
	        } else {
	            if (expandedInfo.paths.length && options.storeLoadOptions.group) {
	                makeDataDeferred(options);
	                loadLastLevelGroupItems(that, options, expandedInfo, data)
	            } else {
	                if (isDataDeferred(options.data)) {
	                    options.data.resolve(data)
	                }
	            }
	        }
	    }

	    function loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data) {
	        var groups = options.group || [],
	            currentGroup = groups[groupLevel + 1],
	            deferreds = [];
	        $.each(expandedInfo.paths, function(expandedItemIndex) {
	            var loadOptions = {
	                requireTotalCount: false,
	                requireGroupCount: true,
	                group: [currentGroup],
	                groupSummary: options.storeLoadOptions.groupSummary,
	                filter: createGroupFilter(expandedInfo.paths[expandedItemIndex], {
	                    filter: options.storeLoadOptions.filter,
	                    group: groups
	                })
	            };
	            if (0 === expandedItemIndex) {
	                loadOptions.skip = expandedInfo.skip || 0
	            }
	            if (expandedItemIndex === expandedInfo.paths.length - 1) {
	                loadOptions.take = expandedInfo.take
	            }
	            var loadResult = 0 === loadOptions.take ? [] : that._dataSource.store().load(loadOptions);
	            when(loadResult).done(function(data) {
	                var item = expandedInfo.items[expandedItemIndex];
	                applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex);
	                item.items = data
	            });
	            deferreds.push(loadResult)
	        });
	        when.apply(null, deferreds).done(function() {
	            updateGroupInfos(that, options, data, groups.length);
	            loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel + 1, data)
	        })
	    }

	    function loadLastLevelGroupItems(that, options, expandedInfo, data) {
	        var expandedFilters = [],
	            groups = options.group || [];
	        $.each(expandedInfo.paths, function(_, expandedPath) {
	            expandedFilters.push(createGroupFilter(expandedPath, {
	                group: options.isCustomLoading ? options.storeLoadOptions.group : groups
	            }))
	        });
	        var filter = options.storeLoadOptions.filter;
	        if (!options.storeLoadOptions.isLoadingAll) {
	            filter = gridCore.combineFilters([filter, gridCore.combineFilters(expandedFilters, "or")])
	        }
	        var loadOptions = $.extend({}, options.storeLoadOptions, {
	            requireTotalCount: false,
	            requireGroupCount: false,
	            group: null,
	            sort: groups.concat(normalizeSortingInfo(options.storeLoadOptions.sort || [])),
	            filter: filter
	        });
	        loadOptions.skip = expandedInfo.skip;
	        loadOptions.take = expandedInfo.take;
	        when(0 === expandedInfo.take ? [] : that._dataSource.store().load(loadOptions)).done(function(items, extra) {
	            $.each(expandedInfo.items, function(index, item) {
	                dataQuery(items).filter(expandedFilters[index]).enumerate().done(function(expandedItems) {
	                    applyContinuationToGroupItem(options, expandedInfo, groups.length - 1, index);
	                    item.items = expandedItems
	                })
	            });
	            options.data.resolve(data)
	        }).fail(options.data.reject)
	    }
	    var loadGroupTotalCount = function(dataSource, options) {
	        var d = $.Deferred(),
	            loadOptions = $.extend({
	                skip: 0,
	                take: 1,
	                requireGroupCount: true,
	                requireTotalCount: false
	            }, options);
	        dataSource.load(loadOptions).done(function(data, extra) {
	            d.resolve(extra && extra.groupCount)
	        }).fail($.proxy(d.reject, d));
	        return d
	    };
	    return {
	        updateTotalItemsCount: function(options) {
	            var totalItemsCount = 0,
	                totalCount = options.extra && options.extra.totalCount || 0,
	                groupCount = options.extra && options.extra.groupCount || 0,
	                pageSize = this._dataSource.pageSize(),
	                isVirtualPaging = this._isVirtualPaging();
	            foreachExpandedGroups(this, function(groupInfo) {
	                groupInfo.childrenTotalCount = 0
	            });
	            foreachExpandedGroups(this, function(groupInfo, parents) {
	                var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount),
	                    count = groupInfo.count + groupInfo.childrenTotalCount;
	                if (!isVirtualPaging) {
	                    count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1)
	                }
	                if (parents[parents.length - 2]) {
	                    parents[parents.length - 2].childrenTotalCount += count
	                } else {
	                    totalItemsCount += count
	                }
	            });
	            this.callBase(totalItemsCount - totalCount + groupCount)
	        },
	        _isGroupExpanded: function(groupIndex) {
	            var groups = this._dataSource.group();
	            return isGroupExpanded(groups, groupIndex)
	        },
	        _updatePagingOptions: function(options) {
	            var that = this,
	                isVirtualPaging = that._isVirtualPaging(),
	                pageSize = that._dataSource.pageSize(),
	                skips = [],
	                takes = [],
	                skipChildrenTotalCount = 0,
	                childrenTotalCount = 0;
	            if (options.take) {
	                foreachExpandedGroups(this, function(groupInfo) {
	                    groupInfo.childrenTotalCount = 0;
	                    groupInfo.skipChildrenTotalCount = 0
	                });
	                foreachExpandedGroups(that, function(groupInfo, parents) {
	                    var skip, take, takeCorrection = 0,
	                        parentTakeCorrection = 0,
	                        totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount),
	                        continuationGroupCount = 0,
	                        skipContinuationGroupCount = 0,
	                        groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount,
	                        childrenGroupInfoCount = groupInfoCount;
	                    skip = options.skip - totalOffset;
	                    if (totalOffset <= options.skip + options.take && groupInfoCount) {
	                        take = options.take;
	                        if (!isVirtualPaging) {
	                            continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
	                            groupInfoCount += continuationGroupCount * parents.length;
	                            childrenGroupInfoCount += continuationGroupCount;
	                            if (pageSize && skip >= 0) {
	                                takeCorrection = parents.length;
	                                parentTakeCorrection = parents.length - 1;
	                                skipContinuationGroupCount = Math.floor(skip / pageSize)
	                            }
	                        }
	                        if (skip >= 0) {
	                            if (totalOffset + groupInfoCount > options.skip) {
	                                skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount)
	                            }
	                            if (totalOffset + groupInfoCount >= options.skip + take) {
	                                takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount)
	                            }
	                        } else {
	                            if (totalOffset + groupInfoCount >= options.skip + take) {
	                                takes.unshift(take + skip - groupInfo.childrenTotalCount)
	                            }
	                        }
	                    }
	                    if (totalOffset <= options.skip) {
	                        if (parents[parents.length - 2]) {
	                            parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection)
	                        } else {
	                            skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1)
	                        }
	                    }
	                    if (totalOffset <= options.skip + take) {
	                        groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
	                        if (parents[parents.length - 2]) {
	                            parents[parents.length - 2].childrenTotalCount += groupInfoCount
	                        } else {
	                            childrenTotalCount += groupInfoCount
	                        }
	                    }
	                });
	                options.skip -= skipChildrenTotalCount;
	                options.take -= childrenTotalCount - skipChildrenTotalCount
	            }
	            options.skips = skips;
	            options.takes = takes
	        },
	        changeRowExpand: function(path) {
	            var that = this,
	                groupInfo = that.findGroupInfo(path),
	                dataSource = that._dataSource,
	                remoteGroupPaging = dataSource.remoteOperations().groupPaging,
	                groups = normalizeSortingInfo(dataSource.group());
	            if (groupInfo) {
	                groupInfo.isExpanded = !groupInfo.isExpanded;
	                if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {
	                    return loadGroupTotalCount(dataSource, {
	                        filter: createGroupFilter(path, {
	                            filter: dataSource.filter(),
	                            group: dataSource.group()
	                        }),
	                        group: groups.slice(path.length)
	                    }).done(function(groupCount) {
	                        groupInfo.count = groupCount
	                    })
	                }
	                return $.Deferred().resolve()
	            }
	            return $.Deferred().reject()
	        },
	        handleDataLoading: function(options) {
	            var groups = normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group);
	            var that = this;
	            if (options.isCustomLoading || !groups.length) {
	                return
	            }
	            options.group = options.group || groups;
	            if (options.remoteOperations.paging) {
	                options.skip = options.storeLoadOptions.skip;
	                options.take = options.storeLoadOptions.take;
	                options.storeLoadOptions.requireGroupCount = true;
	                options.storeLoadOptions.group = groups.slice(0, 1);
	                that._updatePagingOptions(options);
	                options.storeLoadOptions.skip = options.skip;
	                options.storeLoadOptions.take = options.take
	            } else {
	                that.foreachGroups(function(groupInfo) {
	                    groupInfo.count = 0
	                })
	            }
	        },
	        handleDataLoadedCore: function(options, callBase) {
	            var totalCount, that = this,
	                loadedGroupCount = normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group).length,
	                groupCount = options.group ? options.group.length : 0,
	                expandedInfo = {};
	            if (options.isCustomLoading) {
	                callBase(options);
	                processGroupItems(that, options.data, loadedGroupCount, expandedInfo, [], options.isCustomLoading, options.storeLoadOptions.isLoadingAll)
	            } else {
	                totalCount = updateGroupInfos(that, options, options.data, loadedGroupCount);
	                if (totalCount < 0) {
	                    options.data = $.Deferred().reject(errors.Error("E1037"));
	                    return
	                }
	                if (!options.remoteOperations.paging) {
	                    if (loadedGroupCount && options.extra && options.loadOptions.requireTotalCount) {
	                        options.extra.totalCount = totalCount;
	                        options.extra.groupCount = options.data.length
	                    }
	                }
	                that.updateTotalItemsCount(options);
	                if (!options.remoteOperations.paging) {
	                    that._updatePagingOptions(options)
	                }
	                callBase(options);
	                if (!options.remoteOperations.paging) {
	                    that._processPaging(options, loadedGroupCount)
	                }
	            }
	            loadGroupItems(that, options, loadedGroupCount, expandedInfo, 0, options.data);
	            if (!options.isCustomLoading) {
	                when(options.data).done(function(data) {
	                    that.updateItemsCount(data, groupCount)
	                })
	            }
	        },
	        _processSkips: function(items, skips, groupCount) {
	            if (!groupCount) {
	                return
	            }
	            var firstItem = items[0],
	                skip = skips[0],
	                children = firstItem && firstItem.items;
	            if (void 0 !== skip) {
	                firstItem.isContinuation = true;
	                if (children) {
	                    firstItem.items = children.slice(skip);
	                    this._processSkips(firstItem.items, skips.slice(1), groupCount - 1)
	                }
	            }
	        },
	        _processTakes: function(items, skips, takes, groupCount) {
	            if (!groupCount || !items) {
	                return
	            }
	            var lastItem = items[items.length - 1],
	                children = lastItem && lastItem.items,
	                take = takes[0],
	                skip = skips[0];
	            if (lastItem) {
	                var maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;
	                if (void 0 !== take && maxTakeCount > take) {
	                    lastItem.isContinuationOnNextPage = true;
	                    if (children) {
	                        children = children.slice(0, take);
	                        lastItem.items = children
	                    }
	                }
	                this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1)
	            }
	        },
	        _processPaging: function(options, groupCount) {
	            this._processSkips(options.data, options.skips, groupCount);
	            this._processTakes(options.data, options.skips, options.takes, groupCount)
	        },
	        refresh: function(options, isReload, operationTypes) {
	            var isExpanded, groupIndex, that = this,
	                dataSource = that._dataSource,
	                storeLoadOptions = options.storeLoadOptions,
	                group = options.group || options.storeLoadOptions.group,
	                oldGroups = normalizeSortingInfo(that._group);

	            function handleGroup(groupInfo, parents) {
	                if (parents.length === groupIndex + 1) {
	                    groupInfo.isExpanded = isExpanded
	                }
	            }
	            for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
	                isExpanded = isGroupExpanded(group, groupIndex);
	                if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {
	                    that.foreachGroups(handleGroup)
	                }
	            }
	            that.callBase.apply(this, arguments);
	            if (group && options.remoteOperations.paging && (isReload || operationTypes.reload)) {
	                return foreachExpandedGroups(that, function(groupInfo) {
	                    var groupCountQuery = loadGroupTotalCount(dataSource, {
	                            filter: createGroupFilter(groupInfo.path, {
	                                filter: storeLoadOptions.filter,
	                                group: group
	                            }),
	                            group: group.slice(groupInfo.path.length)
	                        }),
	                        groupOffsetQuery = loadGroupTotalCount(dataSource, {
	                            filter: createOffsetFilter(groupInfo.path, {
	                                filter: storeLoadOptions.filter,
	                                group: group
	                            }),
	                            group: group.slice(groupInfo.path.length)
	                        });
	                    return when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
	                        offset = parseInt(offset.length ? offset[0] : offset);
	                        count = parseInt(count.length ? count[0] : count);
	                        groupInfo.offset = offset;
	                        if (groupInfo.count !== count) {
	                            groupInfo.count = count;
	                            that.updateTotalItemsCount(options)
	                        }
	                    })
	                })
	            }
	        }
	    }
	}());


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.master_detail_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    gridCoreUtils = __webpack_require__(148),
	    commonUtils = __webpack_require__(8);
	var DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
	    DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
	    DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
	    DATAGRID_ROW_LINES_CLASS = "dx-row-lines";
	gridCore.registerModule("masterDetail", {
	    defaultOptions: function() {
	        return {
	            masterDetail: {
	                enabled: false,
	                autoExpandAll: false,
	                template: null
	            }
	        }
	    },
	    extenders: {
	        controllers: {
	            columns: {
	                _getExpandColumnsCore: function() {
	                    var expandColumns = this.callBase();
	                    if (this.option("masterDetail.enabled")) {
	                        expandColumns.push({})
	                    }
	                    return expandColumns
	                }
	            },
	            data: function() {
	                var initMasterDetail = function(that) {
	                    that._expandedItems = [];
	                    that._isExpandAll = that.option("masterDetail.autoExpandAll")
	                };
	                return {
	                    init: function() {
	                        var that = this;
	                        initMasterDetail(that);
	                        that.callBase()
	                    },
	                    expandAll: function(groupIndex) {
	                        var that = this;
	                        if (groupIndex < 0) {
	                            that._isExpandAll = true;
	                            that._expandedItems = [];
	                            that.updateItems()
	                        } else {
	                            that.callBase.apply(that, arguments)
	                        }
	                    },
	                    collapseAll: function(groupIndex) {
	                        var that = this;
	                        if (groupIndex < 0) {
	                            that._isExpandAll = false;
	                            that._expandedItems = [];
	                            that.updateItems()
	                        } else {
	                            that.callBase.apply(that, arguments)
	                        }
	                    },
	                    isRowExpanded: function(key) {
	                        var that = this,
	                            expandIndex = gridCoreUtils.getIndexByKey(key, that._expandedItems);
	                        if (commonUtils.isArray(key)) {
	                            return that.callBase.apply(that, arguments)
	                        } else {
	                            return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible))
	                        }
	                    },
	                    _changeRowExpandCore: function(key) {
	                        var expandIndex, rowIndex, that = this;
	                        if (commonUtils.isArray(key)) {
	                            return that.callBase.apply(that, arguments)
	                        } else {
	                            expandIndex = gridCoreUtils.getIndexByKey(key, that._expandedItems);
	                            if (expandIndex >= 0) {
	                                var visible = that._expandedItems[expandIndex].visible;
	                                that._expandedItems[expandIndex].visible = !visible
	                            } else {
	                                that._expandedItems.push({
	                                    key: key,
	                                    visible: true
	                                })
	                            }
	                            rowIndex = that.getRowIndexByKey(key);
	                            that.updateItems({
	                                changeType: "update",
	                                rowIndices: [rowIndex, rowIndex + 1, rowIndex + 2]
	                            })
	                        }
	                    },
	                    _processDataItem: function(data, options) {
	                        var that = this,
	                            dataItem = that.callBase.apply(that, arguments);
	                        dataItem.isExpanded = that.isRowExpanded(dataItem.key);
	                        if (void 0 === options.detailColumnIndex) {
	                            options.detailColumnIndex = -1;
	                            $.each(options.visibleColumns, function(index, column) {
	                                if ("expand" === column.command && !commonUtils.isDefined(column.groupIndex)) {
	                                    options.detailColumnIndex = index;
	                                    return false
	                                }
	                            })
	                        }
	                        if (options.detailColumnIndex >= 0) {
	                            dataItem.values[options.detailColumnIndex] = dataItem.isExpanded
	                        }
	                        return dataItem
	                    },
	                    _processItems: function(items, changeType) {
	                        var expandIndex, that = this,
	                            result = [];
	                        items = that.callBase.apply(that, arguments);
	                        if ("loadingAll" === changeType) {
	                            return items
	                        }
	                        if ("refresh" === changeType) {
	                            that._expandedItems = $.grep(that._expandedItems, function(item) {
	                                return item.visible
	                            })
	                        }
	                        $.each(items, function(index, item) {
	                            result.push(item);
	                            expandIndex = gridCoreUtils.getIndexByKey(item.key, that._expandedItems);
	                            if ("data" === item.rowType && (item.isExpanded || expandIndex >= 0) && !item.inserted) {
	                                result.push({
	                                    visible: item.isExpanded,
	                                    rowType: "detail",
	                                    key: item.key,
	                                    data: item.data,
	                                    values: []
	                                })
	                            }
	                        });
	                        return result
	                    },
	                    optionChanged: function(args) {
	                        var value, previousValue, isEnabledChanged, isAutoExpandAllChanged, that = this;
	                        if ("masterDetail" === args.name) {
	                            args.name = "dataSource";
	                            switch (args.fullName) {
	                                case "masterDetail":
	                                    value = args.value || {};
	                                    previousValue = args.previousValue || {};
	                                    isEnabledChanged = value.enabled !== previousValue.enabled;
	                                    isAutoExpandAllChanged = value.autoExpandAll !== previousValue.autoExpandAll;
	                                    break;
	                                case "masterDetail.enabled":
	                                    isEnabledChanged = true;
	                                    break;
	                                case "masterDetail.autoExpandAll":
	                                    isAutoExpandAllChanged = true
	                            }
	                            if (isEnabledChanged || isAutoExpandAllChanged) {
	                                initMasterDetail(that)
	                            }
	                        }
	                        that.callBase(args)
	                    }
	                }
	            }()
	        },
	        views: {
	            rowsView: function() {
	                return {
	                    _getCellTemplate: function(options) {
	                        var template, that = this,
	                            column = options.column,
	                            editingController = that.getController("editing"),
	                            isEditRow = editingController && editingController.isEditRow(options.rowIndex);
	                        if ("detail" === column.command && !isEditRow) {
	                            template = that.option("masterDetail.template") || that._getDefaultTemplate(column)
	                        } else {
	                            template = that.callBase.apply(that, arguments)
	                        }
	                        return template
	                    },
	                    _isDetailRow: function(row) {
	                        return row && row.rowType && 0 === row.rowType.indexOf("detail")
	                    },
	                    _createRow: function(row) {
	                        var $row = this.callBase(row);
	                        if (row && this._isDetailRow(row)) {
	                            this.option("showRowLines") && $row.addClass(DATAGRID_ROW_LINES_CLASS);
	                            $row.addClass(DATAGRID_MASTER_DETAIL_ROW_CLASS);
	                            if (commonUtils.isDefined(row.visible)) {
	                                $row.toggle(row.visible)
	                            }
	                        }
	                        return $row
	                    },
	                    _getGroupCellOptions: function(options) {
	                        var row = options.row,
	                            groupColumns = this._columnsController.getGroupColumns(),
	                            columnIndex = groupColumns.length + options.columnsCountBeforeGroups,
	                            emptyCellsCount = columnIndex + Number(this.option("masterDetail.enabled"));
	                        if (row && this._isDetailRow(row)) {
	                            return {
	                                columnIndex: columnIndex,
	                                emptyCellsCount: emptyCellsCount,
	                                colspan: options.columns.length - emptyCellsCount
	                            }
	                        }
	                        return this.callBase(options)
	                    },
	                    _renderCells: function($row, options) {
	                        var $detailCell, groupCellOptions, i, row = options.row;
	                        if (row.rowType && this._isDetailRow(row)) {
	                            groupCellOptions = this._getGroupCellOptions(options);
	                            for (i = 0; i < groupCellOptions.emptyCellsCount; i++) {
	                                this._renderCell($row, {
	                                    value: null,
	                                    row: row,
	                                    rowIndex: row.rowIndex,
	                                    column: options.columns[i]
	                                })
	                            }
	                            $detailCell = this._renderCell($row, {
	                                value: null,
	                                row: row,
	                                rowIndex: row.rowIndex,
	                                column: {
	                                    command: "detail"
	                                },
	                                columnIndex: groupCellOptions.columnIndex
	                            });
	                            $detailCell.addClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS).addClass(DATAGRID_MASTER_DETAIL_CELL_CLASS).attr("colspan", groupCellOptions.colspan)
	                        } else {
	                            this.callBase.apply(this, arguments)
	                        }
	                    }
	                }
	            }()
	        }
	    }
	});


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.editing.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    commonUtils = __webpack_require__(8),
	    objectUtils = __webpack_require__(36),
	    gridCore = __webpack_require__(144),
	    clickEvent = __webpack_require__(65),
	    gridCoreUtils = __webpack_require__(148),
	    getIndexByKey = gridCoreUtils.getIndexByKey,
	    eventUtils = __webpack_require__(61),
	    addNamespace = eventUtils.addNamespace,
	    dialog = __webpack_require__(111),
	    messageLocalization = __webpack_require__(79),
	    Button = __webpack_require__(114),
	    errors = __webpack_require__(15),
	    devices = __webpack_require__(40),
	    Form = __webpack_require__(223),
	    holdEvent = __webpack_require__(132),
	    when = __webpack_require__(10).when;
	__webpack_require__(264);
	var DATAGRID_LINK_CLASS = "dx-link",
	    DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
	    DATAGRID_ROW_SELECTED = "dx-selection",
	    DATAGRID_EDIT_ROW = "dx-edit-row",
	    DATAGRID_EDIT_FORM_CLASS = "dx-datagrid-edit-form",
	    DATAGRID_EDIT_FORM_ITEM_CLASS = "dx-datagrid-edit-form-item",
	    DATAGRID_EDIT_BUTTON_CLASS = "dx-edit-button",
	    DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
	    DATAGRID_ROW_CLASS = "dx-row",
	    DATAGRID_ROW_REMOVED = "dx-row-removed",
	    DATAGRID_ROW_INSERTED = "dx-row-inserted",
	    DATAGRID_ROW_MODIFIED = "dx-row-modified",
	    DATAGRID_CELL_MODIFIED = "dx-cell-modified",
	    DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
	    DATAGRID_EDITING_NAMESPACE = "dxDataGridEditing",
	    DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
	    DATAGRID_READONLY_CLASS = "dx-datagrid-readonly",
	    DATAGRID_DATA_ROW_CLASS = "dx-data-row",
	    DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
	    DATAGRID_EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])",
	    DATAGRID_EDIT_MODE_BATCH = "batch",
	    DATAGRID_EDIT_MODE_ROW = "row",
	    DATAGRID_EDIT_MODE_CELL = "cell",
	    DATAGRID_EDIT_MODE_FORM = "form",
	    DATA_EDIT_DATA_INSERT_TYPE = "insert",
	    DATA_EDIT_DATA_UPDATE_TYPE = "update",
	    DATA_EDIT_DATA_REMOVE_TYPE = "remove",
	    DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
	    DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target";
	var getEditMode = function(that) {
	    var editMode = that.option("editing.mode");
	    if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL || editMode === DATAGRID_EDIT_MODE_FORM) {
	        return editMode
	    }
	    return DATAGRID_EDIT_MODE_ROW
	};
	var isRowEditMode = function(that) {
	    var editMode = getEditMode(that);
	    return editMode === DATAGRID_EDIT_MODE_ROW || editMode === DATAGRID_EDIT_MODE_FORM
	};
	exports.EditingController = gridCore.ViewController.inherit(function() {
	    var getDefaultEditorTemplate = function(that) {
	        return function(container, options) {
	            var $editor = $("<div/>").appendTo(container);
	            that.getController("editorFactory").createEditor($editor, $.extend({}, options.column, {
	                value: options.value,
	                setValue: options.setValue,
	                row: options.row,
	                parentType: "dataRow",
	                width: null,
	                readOnly: !options.setValue,
	                id: options.id
	            }))
	        }
	    };
	    return {
	        init: function() {
	            var that = this;
	            that._insertIndex = 1;
	            that._editRowIndex = -1;
	            that._editData = [];
	            that._editColumnIndex = -1;
	            that._columnsController = that.getController("columns");
	            that._dataController = that.getController("data");
	            that._rowsView = that.getView("rowsView");
	            if (!that._dataChangedHandler) {
	                that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
	                that._dataController.changed.add(that._dataChangedHandler)
	            }
	            if (!that._saveEditorHandler) {
	                that.createAction("onInitNewRow", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that.createAction("onRowInserting", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that.createAction("onRowInserted", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that.createAction("onEditingStart", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that.createAction("onRowUpdating", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that.createAction("onRowUpdated", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that.createAction("onRowRemoving", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that.createAction("onRowRemoved", {
	                    excludeValidators: ["disabled", "readOnly"]
	                });
	                that._saveEditorHandler = that.createAction(function(e) {
	                    var isEditorPopup, isDomElement, isFocusOverlay, isAddRowButton, isCellEditMode, $target, event = e.jQueryEvent;
	                    if (!isRowEditMode(that) && !that._editCellInProgress) {
	                        $target = $(event.target);
	                        isEditorPopup = $target.closest(".dx-dropdowneditor-overlay").length;
	                        isDomElement = $target.closest(document).length;
	                        isAddRowButton = $target.closest(".dx-datagrid-addrow-button").length;
	                        isFocusOverlay = $target.hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
	                        isCellEditMode = getEditMode(that) === DATAGRID_EDIT_MODE_CELL;
	                        if (!isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && that.isEditing()) && isDomElement) {
	                            $.proxy(that._closeEditItem, that)($target)
	                        }
	                    }
	                });
	                $(document).on(clickEvent.name, that._saveEditorHandler)
	            }
	            that._updateEditColumn();
	            that._updateEditButtons()
	        },
	        _closeEditItem: function($targetElement) {
	            var isDataRow = $targetElement.closest("." + DATAGRID_DATA_ROW_CLASS).length,
	                $targetCell = $targetElement.closest("." + DATAGRID_ROW_CLASS + "> td"),
	                columnIndex = $targetCell[0] && $targetCell[0].cellIndex,
	                rowIndex = this.getView("rowsView").getRowIndex($targetCell.parent()),
	                visibleColumns = this._columnsController.getVisibleColumns(),
	                allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;
	            if (this.isEditing() && (!isDataRow || isDataRow && !allowEditing && !this.isEditCell(rowIndex, columnIndex))) {
	                this.closeEditCell()
	            }
	        },
	        _handleDataChanged: function(args) {
	            if ("standard" === this.option("scrolling.mode")) {
	                this.resetRowAndPageIndices()
	            }
	            if ("prepend" === args.changeType) {
	                $.each(this._editData, function(_, editData) {
	                    editData.rowIndex += args.items.length;
	                    if (editData.type === DATA_EDIT_DATA_INSERT_TYPE) {
	                        editData.key.rowIndex += args.items.length
	                    }
	                })
	            }
	        },
	        getEditMode: function() {
	            return getEditMode(this)
	        },
	        getFirstEditableColumnIndex: function() {
	            var columnIndex, columnsController = this.getController("columns"),
	                visibleColumns = columnsController.getVisibleColumns();
	            $.each(visibleColumns, function(index, column) {
	                if (column.allowEditing) {
	                    columnIndex = index;
	                    return false
	                }
	            });
	            return columnIndex
	        },
	        getFirstEditableCellInRow: function(rowIndex) {
	            return this.getView("rowsView").getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex())
	        },
	        getFocusedCellInRow: function(rowIndex) {
	            return this.getFirstEditableCellInRow(rowIndex)
	        },
	        getIndexByKey: function(key, items) {
	            return getIndexByKey(key, items)
	        },
	        hasChanges: function() {
	            var that = this,
	                result = false;
	            for (var i = 0; i < that._editData.length; i++) {
	                if (that._editData[i].type) {
	                    result = true;
	                    break
	                }
	            }
	            return result
	        },
	        dispose: function() {
	            this.callBase();
	            $(document).off(clickEvent.name, this._saveEditorHandler)
	        },
	        optionChanged: function(args) {
	            if ("editing" === args.name) {
	                this.init();
	                args.handled = true
	            } else {
	                this.callBase(args)
	            }
	        },
	        publicMethods: function() {
	            return ["insertRow", "addRow", "removeRow", "deleteRow", "undeleteRow", "editRow", "editCell", "closeEditCell", "saveEditData", "cancelEditData", "hasEditData"]
	        },
	        refresh: function() {
	            if (getEditMode(this) !== DATAGRID_EDIT_MODE_BATCH) {
	                this.init()
	            } else {
	                this._editRowIndex = -1;
	                this._editColumnIndex = -1
	            }
	        },
	        isEditing: function() {
	            return this._editRowIndex > -1
	        },
	        isEditRow: function(rowIndex) {
	            var editMode = getEditMode(this);
	            return this._editRowIndex === rowIndex && (editMode === DATAGRID_EDIT_MODE_ROW || editMode === DATAGRID_EDIT_MODE_FORM)
	        },
	        getEditRowKey: function() {
	            var items = this._dataController.items(),
	                item = items[this._editRowIndex];
	            return item && item.key
	        },
	        getEditFormRowIndex: function() {
	            return getEditMode(this) === DATAGRID_EDIT_MODE_FORM ? this._editRowIndex : -1
	        },
	        isEditCell: function(rowIndex, columnIndex) {
	            return this._editRowIndex === rowIndex && this._editColumnIndex === columnIndex
	        },
	        _needInsertItem: function(editData, changeType) {
	            var that = this,
	                dataSource = that._dataController.dataSource(),
	                scrollingMode = that.option("scrolling.mode"),
	                pageIndex = dataSource.pageIndex(),
	                beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex,
	                endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;
	            if ("standard" !== scrollingMode) {
	                switch (changeType) {
	                    case "append":
	                        return editData.key.pageIndex === endPageIndex;
	                    case "prepend":
	                        return editData.key.pageIndex === beginPageIndex;
	                    case "refresh":
	                        editData.key.rowIndex = 0;
	                        editData.key.pageIndex = 0;
	                        break;
	                    default:
	                        return editData.key.pageIndex >= beginPageIndex && editData.key.pageIndex <= endPageIndex
	                }
	            }
	            return editData.key.pageIndex === pageIndex
	        },
	        processItems: function(items, changeType) {
	            var i, key, data, that = this,
	                editData = that._editData;
	            that.update(changeType);
	            for (i = 0; i < editData.length; i++) {
	                key = editData[i].key;
	                data = {
	                    key: key
	                };
	                if (editData[i].type === DATA_EDIT_DATA_INSERT_TYPE && that._needInsertItem(editData[i], changeType)) {
	                    data[DATAGRID_INSERT_INDEX] = key[DATAGRID_INSERT_INDEX];
	                    items.splice(key.rowIndex, 0, data)
	                }
	            }
	            return items
	        },
	        processDataItem: function(item, options, generateDataValues) {
	            var data, editData, editIndex, editMode, that = this,
	                columns = options.visibleColumns,
	                key = item.data[DATAGRID_INSERT_INDEX] ? item.data.key : item.key;
	            editIndex = getIndexByKey(key, that._editData);
	            if (editIndex >= 0) {
	                editMode = getEditMode(that);
	                editData = that._editData[editIndex];
	                data = editData.data;
	                item.isEditing = options.dataIndex === that._editRowIndex;
	                switch (editData.type) {
	                    case DATA_EDIT_DATA_INSERT_TYPE:
	                        item.inserted = true;
	                        item.key = key;
	                        item.data = data;
	                        break;
	                    case DATA_EDIT_DATA_UPDATE_TYPE:
	                        item.modified = true;
	                        item.oldData = item.data;
	                        item.data = $.extend(true, {}, item.data, data);
	                        item.modifiedValues = generateDataValues(data, columns);
	                        break;
	                    case DATA_EDIT_DATA_REMOVE_TYPE:
	                        if (editMode === DATAGRID_EDIT_MODE_BATCH) {
	                            item.data = $.extend(true, {}, item.data, data)
	                        }
	                        item.removed = true
	                }
	            }
	        },
	        insertRow: function() {
	            errors.log("W0002", "dxDataGrid", "insertRow", "15.2", "Use the 'addRow' method instead");
	            return this.addRow()
	        },
	        addRow: function() {
	            var $firstCell, that = this,
	                dataController = that._dataController,
	                store = dataController.store(),
	                key = store && store.key(),
	                rowsView = that.getView("rowsView"),
	                param = {
	                    data: {}
	                },
	                insertKey = {
	                    pageIndex: dataController.pageIndex(),
	                    rowIndex: rowsView ? rowsView.getTopVisibleItemIndex() : 0
	                },
	                oldEditRowIndex = that._editRowIndex,
	                editMode = getEditMode(that);
	            if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges()) {
	                that.saveEditData()
	            }
	            that.refresh();
	            if (editMode !== DATAGRID_EDIT_MODE_BATCH && that._insertIndex > 1) {
	                return
	            }
	            if (!key) {
	                param.data.__KEY__ = String(new Guid)
	            }
	            that.executeAction("onInitNewRow", param);
	            if (editMode !== DATAGRID_EDIT_MODE_BATCH) {
	                that._editRowIndex = insertKey.rowIndex
	            }
	            insertKey[DATAGRID_INSERT_INDEX] = that._insertIndex++;
	            that._addEditData({
	                key: insertKey,
	                data: param.data,
	                type: DATA_EDIT_DATA_INSERT_TYPE
	            });
	            dataController.updateItems({
	                changeType: "update",
	                rowIndices: [oldEditRowIndex, insertKey.rowIndex]
	            });
	            $firstCell = that.getFirstEditableCellInRow(insertKey.rowIndex);
	            that._delayedInputFocus($firstCell, function() {
	                var $cell = that.getFirstEditableCellInRow(insertKey.rowIndex);
	                $cell && $cell.trigger(clickEvent.name)
	            });
	            that._afterInsertRow({
	                key: insertKey,
	                data: param.data
	            })
	        },
	        _isEditingStart: function(options) {
	            this.executeAction("onEditingStart", options);
	            return options.cancel
	        },
	        _beforeEditCell: function(rowIndex, columnIndex, item) {
	            if (getEditMode(this) === DATAGRID_EDIT_MODE_CELL && !item.inserted && this.hasChanges()) {
	                this.saveEditData();
	                if (this.hasChanges()) {
	                    return true
	                }
	            }
	        },
	        _beforeUpdateItems: function() {},
	        editRow: function(rowIndex) {
	            var $editingCell, that = this,
	                dataController = that._dataController,
	                items = dataController.items(),
	                item = items[rowIndex],
	                params = {
	                    data: item.data,
	                    cancel: false
	                },
	                oldEditRowIndex = that._editRowIndex;
	            if (rowIndex === oldEditRowIndex) {
	                return true
	            }
	            if (!item.inserted) {
	                params.key = item.key
	            }
	            if (that._isEditingStart(params)) {
	                return
	            }
	            that.init();
	            that._pageIndex = dataController.pageIndex();
	            that._editRowIndex = items[0].inserted ? rowIndex - 1 : rowIndex;
	            that._addEditData({
	                data: {},
	                key: item.key,
	                oldData: item.data
	            });
	            var rowIndices = [oldEditRowIndex, rowIndex];
	            that._beforeUpdateItems(rowIndices, rowIndex, oldEditRowIndex);
	            dataController.updateItems({
	                changeType: "update",
	                rowIndices: rowIndices
	            });
	            if (getEditMode(that) === DATAGRID_EDIT_MODE_ROW || getEditMode(that) === DATAGRID_EDIT_MODE_FORM) {
	                $editingCell = that.getFocusedCellInRow(that._editRowIndex);
	                that._delayedInputFocus($editingCell, function() {
	                    $editingCell && that.component.focus($editingCell)
	                })
	            }
	        },
	        editCell: function(rowIndex, columnIndex) {
	            var $cell, showEditorAlways, that = this,
	                columnsController = that._columnsController,
	                dataController = that._dataController,
	                items = dataController.items(),
	                item = items[rowIndex],
	                params = {
	                    data: item && item.data,
	                    cancel: false
	                },
	                oldEditRowIndex = that._editRowIndex,
	                oldEditColumnIndex = that._editColumnIndex,
	                columns = columnsController.getVisibleColumns();
	            if (commonUtils.isString(columnIndex)) {
	                columnIndex = columnsController.columnOption(columnIndex, "index");
	                columnIndex = columnsController.getVisibleIndex(columnIndex)
	            }
	            params.column = columnsController.getVisibleColumns()[columnIndex];
	            showEditorAlways = params.column && params.column.showEditorAlways;
	            if (params.column && item && ("data" === item.rowType || "detailAdaptive" === item.rowType) && !item.removed && !isRowEditMode(that)) {
	                if (this.isEditCell(rowIndex, columnIndex)) {
	                    return true
	                }
	                if (that._beforeEditCell(rowIndex, columnIndex, item)) {
	                    return true
	                }
	                if (!item.inserted) {
	                    params.key = item.key
	                }
	                if (that._isEditingStart(params)) {
	                    return true
	                }
	                that._editRowIndex = rowIndex;
	                that._editColumnIndex = columnIndex;
	                that._pageIndex = dataController.pageIndex();
	                that._addEditData({
	                    data: {},
	                    key: item.key,
	                    oldData: item.data
	                });
	                if (!showEditorAlways || columns[oldEditColumnIndex] && !columns[oldEditColumnIndex].showEditorAlways) {
	                    that._editCellInProgress = true;
	                    that.getController("editorFactory").loseFocus();
	                    dataController.updateItems({
	                        changeType: "update",
	                        rowIndices: [oldEditRowIndex, that._editRowIndex]
	                    })
	                }
	                $cell = that.getView("rowsView").getCellElement(that._editRowIndex, that._editColumnIndex);
	                if ($cell && !$cell.find(":focus").length) {
	                    that._focusEditingCell(function() {
	                        that._editCellInProgress = false
	                    }, $cell)
	                } else {
	                    that._editCellInProgress = false
	                }
	                return true
	            }
	            return false
	        },
	        _delayedInputFocus: function($cell, beforeFocusCallback) {
	            function inputFocus() {
	                if (beforeFocusCallback) {
	                    beforeFocusCallback()
	                }
	                $cell && $cell.find("[tabindex], " + DATAGRID_EDITORS_INPUT_SELECTOR).first().focus()
	            }
	            if (devices.real().ios || devices.real().android) {
	                inputFocus()
	            } else {
	                setTimeout(inputFocus)
	            }
	        },
	        _focusEditingCell: function(beforeFocusCallback, $editCell) {
	            var that = this;
	            $editCell = $editCell || that.getView("rowsView").getCellElement(that._editRowIndex, that._editColumnIndex);
	            that._delayedInputFocus($editCell, beforeFocusCallback)
	        },
	        removeRow: function(rowIndex) {
	            errors.log("W0002", "dxDataGrid", "removeRow", "15.2", "Use the 'deleteRow' method instead");
	            return this.deleteRow(rowIndex)
	        },
	        deleteRow: function(rowIndex) {
	            var removeByKey, showDialogTitle, that = this,
	                editingOptions = that.option("editing"),
	                editingTexts = editingOptions && editingOptions.texts,
	                confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle,
	                isBatchMode = editingOptions && editingOptions.mode === DATAGRID_EDIT_MODE_BATCH,
	                confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage,
	                dataController = that._dataController,
	                oldEditRowIndex = that._editRowIndex,
	                item = dataController.items()[rowIndex],
	                key = item && item.key;
	            if (item) {
	                removeByKey = function(key) {
	                    that.refresh();
	                    var editIndex = getIndexByKey(key, that._editData);
	                    if (editIndex >= 0) {
	                        if (that._editData[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {
	                            that._editData.splice(editIndex, 1)
	                        } else {
	                            that._editData[editIndex].type = DATA_EDIT_DATA_REMOVE_TYPE
	                        }
	                    } else {
	                        that._addEditData({
	                            key: key,
	                            oldData: item.data,
	                            type: DATA_EDIT_DATA_REMOVE_TYPE
	                        })
	                    }
	                    if (isBatchMode) {
	                        dataController.updateItems({
	                            changeType: "update",
	                            rowIndices: [oldEditRowIndex, rowIndex]
	                        })
	                    } else {
	                        that.saveEditData()
	                    }
	                };
	                if (isBatchMode || !confirmDeleteMessage) {
	                    removeByKey(key)
	                } else {
	                    showDialogTitle = commonUtils.isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
	                    dialog.confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(function(confirmResult) {
	                        if (confirmResult) {
	                            removeByKey(key)
	                        }
	                    })
	                }
	            }
	        },
	        undeleteRow: function(rowIndex) {
	            var that = this,
	                dataController = that._dataController,
	                item = dataController.items()[rowIndex],
	                oldEditRowIndex = that._editRowIndex,
	                key = item && item.key;
	            if (item) {
	                var editData, editIndex = getIndexByKey(key, that._editData);
	                if (editIndex >= 0) {
	                    editData = that._editData[editIndex];
	                    if ($.isEmptyObject(editData.data)) {
	                        that._editData.splice(editIndex, 1)
	                    } else {
	                        editData.type = DATA_EDIT_DATA_UPDATE_TYPE
	                    }
	                    dataController.updateItems({
	                        changeType: "update",
	                        rowIndices: [oldEditRowIndex, rowIndex]
	                    })
	                }
	            }
	        },
	        _saveEditDataCore: function(deferreds, processedKeys) {
	            var that = this,
	                store = that._dataController.store(),
	                hasCanceledData = false;

	            function executeEditingAction(actionName, params, func) {
	                var deferred = $.Deferred();
	                that.executeAction(actionName, params);

	                function createFailureHandler(deferred) {
	                    return function(arg) {
	                        var error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
	                        deferred.reject(error)
	                    }
	                }
	                when(params.cancel).done(function(cancel) {
	                    if (cancel) {
	                        deferred.resolve("cancel")
	                    } else {
	                        func(params).done(deferred.resolve).fail(createFailureHandler(deferred))
	                    }
	                }).fail(createFailureHandler(deferred));
	                return deferred
	            }
	            $.each(that._editData, function(index, editData) {
	                var deferred, doneDeferred, params, data = editData.data,
	                    oldData = editData.oldData,
	                    key = editData.key,
	                    type = editData.type;
	                if (that._beforeSaveEditData(editData, index)) {
	                    return
	                }
	                switch (type) {
	                    case DATA_EDIT_DATA_REMOVE_TYPE:
	                        params = {
	                            data: oldData,
	                            key: key,
	                            cancel: false
	                        };
	                        deferred = executeEditingAction("onRowRemoving", params, function() {
	                            return store.remove(key)
	                        });
	                        break;
	                    case DATA_EDIT_DATA_INSERT_TYPE:
	                        params = {
	                            data: data,
	                            cancel: false
	                        };
	                        deferred = executeEditingAction("onRowInserting", params, function() {
	                            return store.insert(params.data)
	                        });
	                        break;
	                    case DATA_EDIT_DATA_UPDATE_TYPE:
	                        params = {
	                            newData: data,
	                            oldData: oldData,
	                            key: key,
	                            cancel: false
	                        };
	                        deferred = executeEditingAction("onRowUpdating", params, function() {
	                            return store.update(key, params.newData)
	                        })
	                }
	                if (deferred) {
	                    doneDeferred = $.Deferred();
	                    deferred.always(function() {
	                        processedKeys.push(key)
	                    }).always(doneDeferred.resolve);
	                    deferreds.push(doneDeferred.promise())
	                }
	            });
	            return hasCanceledData
	        },
	        _processSaveEditDataResult: function(results, processedKeys) {
	            var i, arg, editIndex, isError, that = this,
	                dataController = that._dataController,
	                hasSavedData = false,
	                editMode = getEditMode(that);
	            for (i = 0; i < results.length; i++) {
	                arg = results[i];
	                editIndex = getIndexByKey(processedKeys[i], that._editData);
	                if (that._editData[editIndex]) {
	                    isError = arg && arg instanceof Error;
	                    if (isError) {
	                        that._editData[editIndex].error = arg;
	                        dataController.dataErrorOccurred.fire(arg);
	                        if (editMode !== DATAGRID_EDIT_MODE_BATCH) {
	                            break
	                        }
	                    } else {
	                        if ("cancel" !== arg) {
	                            that._editData.splice(editIndex, 1);
	                            hasSavedData = true
	                        }
	                    }
	                }
	            }
	            return hasSavedData
	        },
	        _fireSaveEditDataEvents: function(editData) {
	            var that = this;
	            $.each(editData, function(_, itemData) {
	                var data = itemData.data,
	                    key = itemData.key,
	                    type = itemData.type,
	                    params = {
	                        key: key,
	                        data: data
	                    };
	                if (itemData.error) {
	                    params.error = itemData.error
	                }
	                switch (type) {
	                    case DATA_EDIT_DATA_REMOVE_TYPE:
	                        that.executeAction("onRowRemoved", $.extend({}, params, {
	                            data: itemData.oldData
	                        }));
	                        break;
	                    case DATA_EDIT_DATA_INSERT_TYPE:
	                        that.executeAction("onRowInserted", params);
	                        break;
	                    case DATA_EDIT_DATA_UPDATE_TYPE:
	                        that.executeAction("onRowUpdated", params)
	                }
	            })
	        },
	        saveEditData: function() {
	            var that = this,
	                processedKeys = [],
	                deferreds = [],
	                dataController = that._dataController,
	                editData = $.extend({}, that._editData),
	                editMode = getEditMode(that),
	                result = $.Deferred();
	            var resetEditIndices = function(that) {
	                that._editColumnIndex = -1;
	                that._editRowIndex = -1
	            };
	            if (that._beforeSaveEditData() || that._saving) {
	                that._afterSaveEditData();
	                return result.resolve().promise()
	            }
	            that._saveEditDataCore(deferreds, processedKeys);
	            if (deferreds.length) {
	                that._saving = true;
	                when.apply($, deferreds).done(function() {
	                    if (that._processSaveEditDataResult(arguments, processedKeys)) {
	                        resetEditIndices(that);
	                        when(dataController.refresh()).always(function() {
	                            that._fireSaveEditDataEvents(editData);
	                            that._afterSaveEditData();
	                            result.resolve()
	                        })
	                    } else {
	                        result.resolve()
	                    }
	                }).fail(result.resolve);
	                return result.always(function() {
	                    that._saving = false
	                }).promise()
	            }
	            if (isRowEditMode(that)) {
	                if (!that.hasChanges()) {
	                    that.cancelEditData()
	                }
	            } else {
	                if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL) {
	                    resetEditIndices(that);
	                    dataController.updateItems()
	                } else {
	                    that._focusEditingCell()
	                }
	            }
	            that._afterSaveEditData();
	            return result.resolve().promise()
	        },
	        _updateEditColumn: function() {
	            var that = this,
	                editing = that.option("editing"),
	                editMode = getEditMode(that),
	                isEditColumnVisible = editing && ((editing.allowUpdating || editing.allowAdding) && editMode === DATAGRID_EDIT_MODE_ROW || editing.allowUpdating && editMode === DATAGRID_EDIT_MODE_FORM || editing.allowDeleting);
	            that._columnsController.addCommandColumn({
	                command: "edit",
	                visible: isEditColumnVisible,
	                cssClass: "dx-command-edit",
	                width: "auto"
	            });
	            that._columnsController.columnOption("command:edit", "visible", isEditColumnVisible)
	        },
	        _updateEditButtons: function() {
	            var that = this,
	                headerPanel = that.getView("headerPanel"),
	                hasChanges = that.hasChanges();
	            if (headerPanel) {
	                headerPanel.updateToolbarItemOption("saveButton", "disabled", !hasChanges);
	                headerPanel.updateToolbarItemOption("revertButton", "disabled", !hasChanges)
	            }
	        },
	        _applyModified: function($element) {
	            $element && $element.addClass(DATAGRID_CELL_MODIFIED)
	        },
	        _beforeCloseEditCellInBatchMode: function() {},
	        cancelEditData: function() {
	            var that = this,
	                dataController = that._dataController;
	            that._beforeCancelEditData();
	            that.init();
	            dataController.updateItems()
	        },
	        hasEditData: function() {
	            return this.hasChanges()
	        },
	        closeEditCell: function() {
	            var that = this,
	                editMode = getEditMode(that),
	                oldEditRowIndex = that._editRowIndex,
	                dataController = that._dataController;
	            if (!isRowEditMode(that)) {
	                setTimeout(function() {
	                    if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges()) {
	                        that.saveEditData()
	                    } else {
	                        if (oldEditRowIndex >= 0) {
	                            var rowIndices = [oldEditRowIndex];
	                            that._editRowIndex = -1;
	                            that._editColumnIndex = -1;
	                            that._beforeCloseEditCellInBatchMode(rowIndices);
	                            dataController.updateItems({
	                                changeType: "update",
	                                rowIndices: rowIndices
	                            })
	                        }
	                    }
	                })
	            }
	        },
	        update: function(changeType) {
	            var that = this,
	                dataController = that._dataController;
	            if (dataController && that._pageIndex !== dataController.pageIndex()) {
	                if ("refresh" === changeType) {
	                    that.refresh()
	                }
	                that._pageIndex = dataController.pageIndex()
	            }
	            that._updateEditButtons()
	        },
	        updateFieldValue: function(options, value, text, forceUpdateRow) {
	            var params, that = this,
	                data = {},
	                rowKey = options.key,
	                $cellElement = options.cellElement,
	                editMode = getEditMode(that);
	            if (void 0 !== rowKey && options.column.setCellValue) {
	                if (editMode === DATAGRID_EDIT_MODE_BATCH) {
	                    that._applyModified($cellElement, options)
	                }
	                options.value = value;
	                options.column.setCellValue(data, value, text);
	                if (text && options.column.displayValueMap) {
	                    options.column.displayValueMap[value] = text
	                }
	                params = {
	                    data: data,
	                    key: rowKey,
	                    oldData: options.data,
	                    type: DATA_EDIT_DATA_UPDATE_TYPE
	                };
	                that._addEditData(params);
	                that._updateEditButtons();
	                if (options.column.showEditorAlways && getEditMode(that) === DATAGRID_EDIT_MODE_CELL && options.row && !options.row.inserted) {
	                    that.saveEditData().always(function() {
	                        that._editColumnIndex = options.columnIndex;
	                        that._editRowIndex = options.row.rowIndex;
	                        that._focusEditingCell()
	                    })
	                } else {
	                    if (options.row && (forceUpdateRow || options.column.setCellValue !== options.column.defaultSetCellValue)) {
	                        that._dataController.updateItems({
	                            changeType: "update",
	                            rowIndices: [options.row.rowIndex]
	                        })
	                    }
	                }
	            }
	        },
	        _addEditData: function(options) {
	            var that = this,
	                editDataIndex = getIndexByKey(options.key, that._editData);
	            if (editDataIndex < 0) {
	                editDataIndex = that._editData.length;
	                that._editData.push(options)
	            }
	            if (that._editData[editDataIndex]) {
	                options.type = that._editData[editDataIndex].type || options.type;
	                objectUtils.deepExtendArraySafe(that._editData[editDataIndex], {
	                    data: options.data,
	                    type: options.type
	                })
	            }
	            return editDataIndex
	        },
	        _getFormEditItemTemplate: function(cellOptions, column) {
	            return column.editCellTemplate || getDefaultEditorTemplate(this)
	        },
	        renderFormEditTemplate: function(detailCellOptions, item, form, $container, isReadOnly) {
	            var that = this,
	                column = item.column,
	                cellOptions = $.extend({}, detailCellOptions, {
	                    cellElement: null,
	                    item: item,
	                    value: column.calculateCellValue(detailCellOptions.data),
	                    column: $.extend({}, column, {
	                        editorOptions: item.editorOptions
	                    }),
	                    id: form.getItemID(item.name || item.dataField),
	                    columnIndex: column.index,
	                    setValue: !isReadOnly && column.allowEditing && function(value) {
	                        that.updateFieldValue(cellOptions, value)
	                    }
	                }),
	                template = $.proxy(that._getFormEditItemTemplate, that)(cellOptions, column);
	            if (that._rowsView.renderTemplate($container, template, cellOptions, !!$container.closest(document).length)) {
	                that._rowsView._updateCell($container, cellOptions)
	            }
	        },
	        getFormEditorTemplate: function(cellOptions, item) {
	            var that = this;
	            return function(options, $container) {
	                $.proxy(that.renderFormEditTemplate, that)(cellOptions, item, options.component, $container)
	            }
	        },
	        getEditFormTemplate: function() {
	            var that = this;
	            return function($container, detailOptions) {
	                var editFormOptions = that.option("editing.form"),
	                    items = that.option("editing.form.items"),
	                    userCustomizeItem = that.option("editing.form.customizeItem");
	                if (!items) {
	                    var columns = that.getController("columns").getColumns();
	                    items = [];
	                    $.each(columns, function(_, column) {
	                        if (!column.isBand) {
	                            items.push({
	                                column: column,
	                                name: column.name,
	                                dataField: column.dataField
	                            })
	                        }
	                    })
	                }
	                that._createComponent($("<div>").appendTo($container), Form, $.extend({}, editFormOptions, {
	                    items: items,
	                    formID: new Guid,
	                    customizeItem: function(item) {
	                        var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
	                        if (column) {
	                            item.label = item.label || {};
	                            item.label.text = item.label.text || column.caption;
	                            item.template = item.template || that.getFormEditorTemplate(detailOptions, item);
	                            item.column = column;
	                            if (column.formItem) {
	                                $.extend(item, column.formItem)
	                            }
	                        }
	                        userCustomizeItem && userCustomizeItem.call(this, item);
	                        item.cssClass = commonUtils.isString(item.cssClass) ? item.cssClass + " " + DATAGRID_EDIT_FORM_ITEM_CLASS : DATAGRID_EDIT_FORM_ITEM_CLASS
	                    }
	                }));
	                var $buttonsContainer = $("<div>").addClass("dx-datagrid-form-buttons-container").appendTo($container);
	                that._createComponent($("<div>").appendTo($buttonsContainer), Button, {
	                    text: that.option("editing.texts.saveRowChanges"),
	                    onClick: $.proxy(that.saveEditData, that)
	                });
	                that._createComponent($("<div>").appendTo($buttonsContainer), Button, {
	                    text: that.option("editing.texts.cancelRowChanges"),
	                    onClick: $.proxy(that.cancelEditData, that)
	                })
	            }
	        },
	        getColumnTemplate: function(options) {
	            var template, editingOptions, editingTexts, allowUpdating, editingStartOptions, that = this,
	                column = options.column,
	                rowIndex = options.row && options.row.rowIndex,
	                isRowMode = isRowEditMode(that),
	                isRowEditing = that.isEditRow(rowIndex),
	                isCellEditing = that.isEditCell(rowIndex, options.columnIndex);
	            if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && ("data" === options.rowType || "detailAdaptive" === options.rowType) && !column.command) {
	                allowUpdating = that.option("editing.allowUpdating");
	                if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode)) {
	                    if (column.showEditorAlways && !isRowMode) {
	                        editingStartOptions = {
	                            cancel: false,
	                            key: options.row.key,
	                            data: options.row.data,
	                            column: column
	                        };
	                        that._isEditingStart(editingStartOptions)
	                    }
	                    if (!editingStartOptions || !editingStartOptions.cancel) {
	                        options.setValue = function(value, text) {
	                            that.updateFieldValue(options, value, text)
	                        }
	                    }
	                }
	                template = column.editCellTemplate || getDefaultEditorTemplate(that)
	            } else {
	                if ("edit" === column.command && "data" === options.rowType) {
	                    template = function(container, options) {
	                        var createLink = function(container, text, methodName, options, linkClass) {
	                            var $link = $("<a />").addClass(DATAGRID_LINK_CLASS).addClass(linkClass).text(text).on(addNamespace(clickEvent.name, DATAGRID_EDITING_NAMESPACE), that.createAction(function(params) {
	                                var e = params.jQueryEvent;
	                                e.stopPropagation();
	                                setTimeout(function() {
	                                    options.row && that[methodName](options.row.rowIndex)
	                                })
	                            }));
	                            options.rtlEnabled ? container.prepend($link, "&nbsp;") : container.append($link, "&nbsp;")
	                        };
	                        container.css("text-align", "center");
	                        options.rtlEnabled = that.option("rtlEnabled");
	                        editingOptions = that.option("editing") || {};
	                        editingTexts = editingOptions.texts || {};
	                        if (options.row && options.row.rowIndex === that._editRowIndex && isRowMode) {
	                            createLink(container, editingTexts.saveRowChanges, "saveEditData", options, "dx-link-save");
	                            createLink(container, editingTexts.cancelRowChanges, "cancelEditData", options, "dx-link-cancel")
	                        } else {
	                            if (editingOptions.allowUpdating && isRowMode) {
	                                createLink(container, editingTexts.editRow, "editRow", options, "dx-link-edit")
	                            }
	                            if (editingOptions.allowDeleting) {
	                                if (options.row.removed) {
	                                    createLink(container, editingTexts.undeleteRow, "undeleteRow", options, "dx-link-undelete")
	                                } else {
	                                    createLink(container, editingTexts.deleteRow, "deleteRow", options, "dx-link-delete")
	                                }
	                            }
	                        }
	                    }
	                } else {
	                    if ("detail" === column.command && "detail" === options.rowType && isRowEditing) {
	                        template = that.getEditFormTemplate(options)
	                    }
	                }
	            }
	            return template
	        },
	        prepareEditButtons: function(headerPanel) {
	            var that = this,
	                editingOptions = that.option("editing") || {},
	                editingTexts = that.option("editing.texts") || {},
	                titleButtonTextByClassNames = {
	                    revert: editingTexts.cancelAllChanges,
	                    save: editingTexts.saveAllChanges,
	                    addRow: editingTexts.addRow
	                },
	                classNameButtonByNames = {
	                    revert: "cancel",
	                    save: "save",
	                    addRow: "addrow"
	                },
	                buttonItems = [];
	            var prepareButtonItem = function(name, methodName) {
	                var className = classNameButtonByNames[name],
	                    onInitialized = function(e) {
	                        e.element.addClass(headerPanel._getToolbarButtonClass(DATAGRID_EDIT_BUTTON_CLASS + " dx-datagrid-" + className + "-button"))
	                    },
	                    hintText = titleButtonTextByClassNames[name],
	                    isButtonDisabled = ("save" === className || "cancel" === className) && !that.hasChanges();
	                return {
	                    widget: "dxButton",
	                    options: {
	                        onInitialized: onInitialized,
	                        icon: "edit-button-" + className,
	                        disabled: isButtonDisabled,
	                        onClick: function() {
	                            that[methodName]()
	                        },
	                        text: hintText,
	                        hint: hintText
	                    },
	                    showText: "inMenu",
	                    name: name + "Button",
	                    disabled: isButtonDisabled,
	                    location: "after",
	                    locateInMenu: "auto"
	                }
	            };
	            if (editingOptions.allowAdding) {
	                buttonItems.push(prepareButtonItem("addRow", "addRow"))
	            }
	            if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && getEditMode(that) === DATAGRID_EDIT_MODE_BATCH) {
	                buttonItems.push(prepareButtonItem("save", "saveEditData"));
	                buttonItems.push(prepareButtonItem("revert", "cancelEditData"))
	            }
	            return buttonItems
	        },
	        showHighlighting: function($cell) {
	            var $highlight = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE);
	            if ("TD" === $cell.get(0).tagName && !$highlight.length) {
	                $cell.wrapInner($("<div>").addClass(DATAGRID_CELL_HIGHLIGHT_OUTLINE + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS))
	            }
	        },
	        resetRowAndPageIndices: function(alwaysRest) {
	            var that = this;
	            $.each(that._editData, function(_, editData) {
	                if (editData.pageIndex !== that._pageIndex || alwaysRest) {
	                    delete editData.pageIndex;
	                    delete editData.rowIndex
	                }
	            })
	        },
	        _afterInsertRow: function() {},
	        _beforeSaveEditData: function() {},
	        _afterSaveEditData: function() {},
	        _beforeCancelEditData: function() {}
	    }
	}());
	gridCore.registerModule("editing", {
	    defaultOptions: function() {
	        return {
	            editing: {
	                mode: "row",
	                allowAdding: false,
	                allowUpdating: false,
	                allowDeleting: false,
	                texts: {
	                    editRow: messageLocalization.format("dxDataGrid-editingEditRow"),
	                    saveAllChanges: messageLocalization.format("dxDataGrid-editingSaveAllChanges"),
	                    saveRowChanges: messageLocalization.format("dxDataGrid-editingSaveRowChanges"),
	                    cancelAllChanges: messageLocalization.format("dxDataGrid-editingCancelAllChanges"),
	                    cancelRowChanges: messageLocalization.format("dxDataGrid-editingCancelRowChanges"),
	                    addRow: messageLocalization.format("dxDataGrid-editingAddRow"),
	                    deleteRow: messageLocalization.format("dxDataGrid-editingDeleteRow"),
	                    undeleteRow: messageLocalization.format("dxDataGrid-editingUndeleteRow"),
	                    confirmDeleteMessage: messageLocalization.format("dxDataGrid-editingConfirmDeleteMessage"),
	                    confirmDeleteTitle: ""
	                },
	                form: {
	                    colCount: 2
	                }
	            }
	        }
	    },
	    controllers: {
	        editing: exports.EditingController
	    },
	    extenders: {
	        controllers: {
	            data: {
	                init: function() {
	                    this._editingController = this.getController("editing");
	                    this.callBase()
	                },
	                reload: function(full) {
	                    var d, editingController = this.getController("editing");
	                    this._editingController.refresh();
	                    d = this.callBase(full);
	                    return d && d.done(function() {
	                        editingController.resetRowAndPageIndices(true)
	                    })
	                },
	                _updateItemsCore: function(change) {
	                    this.callBase(change);
	                    var editFormItem = this.items()[this.getController("editing").getEditFormRowIndex()];
	                    if (editFormItem) {
	                        editFormItem.rowType = "detail"
	                    }
	                },
	                _processItems: function(items, changeType) {
	                    items = this._editingController.processItems(items, changeType);
	                    return this.callBase(items, changeType)
	                },
	                _processDataItem: function(dataItem, options) {
	                    this._editingController.processDataItem(dataItem, options, this.generateDataValues);
	                    return this.callBase(dataItem, options)
	                },
	                _processItem: function(item, options) {
	                    item = this.callBase(item, options);
	                    if (item.inserted) {
	                        options.dataIndex--;
	                        delete item.dataIndex;
	                    }
	                    return item
	                }
	            }
	        },
	        views: {
	            rowsView: {
	                init: function() {
	                    this.callBase();
	                    this._editingController = this.getController("editing")
	                },
	                getCellElements: function(rowIndex) {
	                    var $cellElements = this.callBase(rowIndex),
	                        editFormRowIndex = this._editingController.getEditFormRowIndex();
	                    if (editFormRowIndex === rowIndex && $cellElements) {
	                        return $cellElements.find("." + DATAGRID_EDIT_FORM_ITEM_CLASS)
	                    }
	                    return $cellElements
	                },
	                _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
	                    var item, visibleIndex = this.callBase($cells, rowIndex, columnIdentifier),
	                        editFormRowIndex = this._editingController.getEditFormRowIndex();
	                    if (editFormRowIndex === rowIndex) {
	                        $.each($cells, function(index, cellElement) {
	                            item = $(cellElement).find(".dx-field-item-content").data("dx-form-item");
	                            if (item && item.column && item.column.visibleIndex === visibleIndex) {
	                                visibleIndex = index;
	                                return false
	                            }
	                        })
	                    }
	                    return visibleIndex
	                },
	                publicMethods: function() {
	                    return this.callBase().concat(["cellValue"])
	                },
	                _getCellTemplate: function(options) {
	                    var that = this,
	                        template = that._editingController.getColumnTemplate(options);
	                    return template || that.callBase(options)
	                },
	                _isNativeClick: function() {
	                    return (devices.real().ios || devices.real().android) && this.option("editing.allowUpdating")
	                },
	                _createTable: function() {
	                    var that = this,
	                        $table = that.callBase.apply(that, arguments);
	                    if (!isRowEditMode(that) && that.option("editing.allowUpdating")) {
	                        $table.on(addNamespace(holdEvent.name, "dxDataGridRowsView"), "td:not(." + DATAGRID_EDITOR_CELL_CLASS + ")", that.createAction(function() {
	                            var editingController = that._editingController;
	                            if (editingController.isEditing()) {
	                                editingController.closeEditCell()
	                            }
	                        }))
	                    }
	                    return $table
	                },
	                _createRow: function(row) {
	                    var editingController, isEditRow, isRowRemoved, isRowInserted, isRowModified, $row = this.callBase(row);
	                    if (row) {
	                        editingController = this._editingController;
	                        isEditRow = editingController.isEditRow(row.rowIndex);
	                        isRowRemoved = !!row.removed;
	                        isRowInserted = !!row.inserted;
	                        isRowModified = !!row.modified;
	                        if (getEditMode(this) === DATAGRID_EDIT_MODE_BATCH) {
	                            isRowRemoved && $row.addClass(DATAGRID_ROW_REMOVED)
	                        } else {
	                            isEditRow && $row.addClass(DATAGRID_EDIT_ROW)
	                        }
	                        isRowInserted && $row.addClass(DATAGRID_ROW_INSERTED);
	                        isRowModified && $row.addClass(DATAGRID_ROW_MODIFIED);
	                        if (isEditRow || isRowInserted || isRowRemoved) {
	                            $row.removeClass(DATAGRID_ROW_SELECTED)
	                        }
	                        if (isEditRow && "detail" === row.rowType) {
	                            $row.addClass(DATAGRID_EDIT_FORM_CLASS)
	                        }
	                    }
	                    return $row
	                },
	                _getColumnIndexByElement: function($element) {
	                    var $targetElement = $element.closest("." + DATAGRID_ROW_CLASS + "> td:not(.dx-master-detail-cell)");
	                    return this.getCellIndex($targetElement)
	                },
	                _rowClick: function(e) {
	                    var that = this,
	                        editingController = that._editingController,
	                        $targetElement = $(e.jQueryEvent.target),
	                        columnIndex = that._getColumnIndexByElement($targetElement),
	                        allowUpdating = that.option("editing.allowUpdating"),
	                        column = that._columnsController.getVisibleColumns()[columnIndex],
	                        allowEditing = column && (column.allowEditing || editingController.isEditCell(e.rowIndex, columnIndex));
	                    if ($targetElement.closest("." + DATAGRID_ROW_CLASS + "> td").hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS)) {
	                        return
	                    }
	                    if (!(allowUpdating && allowEditing && editingController.editCell(e.rowIndex, columnIndex)) && !editingController.isEditRow(e.rowIndex)) {
	                        that.callBase(e)
	                    }
	                },
	                _cellPrepared: function($cell, parameters) {
	                    var columnIndex = parameters.columnIndex,
	                        editingController = this._editingController,
	                        isCommandCell = !!parameters.column.command,
	                        isEditableCell = parameters.setValue,
	                        isEditing = parameters.isEditing || editingController.isEditRow(parameters.rowIndex) && parameters.column.allowEditing;
	                    if ("data" === parameters.rowType && !parameters.column.command && (isEditing || parameters.column.showEditorAlways)) {
	                        var alignment = parameters.column.alignment;
	                        $cell.addClass(DATAGRID_EDITOR_CELL_CLASS).toggleClass(DATAGRID_READONLY_CLASS, !isEditableCell).toggleClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS, !isEditableCell);
	                        if (alignment) {
	                            $cell.find(DATAGRID_EDITORS_INPUT_SELECTOR).first().css("text-align", alignment)
	                        }
	                    }
	                    var modifiedValues = parameters.row && (parameters.row.inserted ? parameters.row.values : parameters.row.modifiedValues);
	                    if (modifiedValues && void 0 !== modifiedValues[columnIndex] && parameters.column && !isCommandCell && parameters.column.setCellValue) {
	                        editingController.showHighlighting($cell);
	                        $cell.addClass(DATAGRID_CELL_MODIFIED)
	                    } else {
	                        if (isEditableCell) {
	                            editingController.showHighlighting($cell, true)
	                        }
	                    }
	                    this.callBase.apply(this, arguments)
	                },
	                _formItemPrepared: function() {},
	                _updateCell: function($cell, parameters) {
	                    if ("detail" === parameters.rowType || "detailAdaptive" === parameters.rowType && parameters.item) {
	                        this._formItemPrepared(parameters, $cell)
	                    } else {
	                        this.callBase($cell, parameters)
	                    }
	                },
	                _update: function(change) {
	                    this.callBase(change);
	                    if ("updateSelection" === change.changeType) {
	                        this.getTableElements().children("tbody").children("." + DATAGRID_EDIT_ROW).removeClass(DATAGRID_ROW_SELECTED)
	                    }
	                },
	                _getCellOptions: function(options) {
	                    var cellOptions = this.callBase(options);
	                    cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);
	                    return cellOptions
	                },
	                cellValue: function(rowIndex, columnIdentifier, value, text) {
	                    var cellOptions = this.getCellOptions(rowIndex, columnIdentifier);
	                    if (cellOptions) {
	                        if (void 0 === value) {
	                            return cellOptions.value
	                        } else {
	                            this._editingController.updateFieldValue(cellOptions, value, text, true)
	                        }
	                    }
	                }
	            },
	            headerPanel: {
	                _getToolbarItems: function() {
	                    var items = this.callBase(),
	                        editButtonItems = this.getController("editing").prepareEditButtons(this);
	                    return editButtonItems.concat(items)
	                },
	                optionChanged: function(args) {
	                    switch (args.name) {
	                        case "editing":
	                            this.updateToolbar();
	                            this.callBase(args);
	                            break;
	                        default:
	                            this.callBase(args)
	                    }
	                },
	                isVisible: function() {
	                    var that = this,
	                        editingOptions = that.getController("editing").option("editing");
	                    return that.callBase() || editingOptions && (editingOptions.allowAdding || (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === DATAGRID_EDIT_MODE_BATCH)
	                }
	            }
	        }
	    }
	});


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/form.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(224);
	module.exports.default = module.exports;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/form/ui.form.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    Guid = __webpack_require__(119),
	    utils = __webpack_require__(8),
	    stringUtils = __webpack_require__(7),
	    errors = __webpack_require__(15),
	    domUtils = __webpack_require__(43),
	    messageLocalization = __webpack_require__(79),
	    Widget = __webpack_require__(84),
	    windowUtils = __webpack_require__(29),
	    ValidationEngine = __webpack_require__(106),
	    LayoutManager = __webpack_require__(225),
	    TabPanel = __webpack_require__(258),
	    Scrollable = __webpack_require__(157).default;
	__webpack_require__(262);
	__webpack_require__(263);
	var FORM_CLASS = "dx-form",
	    FIELD_ITEM_CLASS = "dx-field-item",
	    FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text",
	    FORM_GROUP_CLASS = "dx-form-group",
	    FORM_GROUP_CONTENT_CLASS = "dx-form-group-content",
	    FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption",
	    FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption",
	    HIDDEN_LABEL_CLASS = "dx-layout-manager-hidden-label",
	    FIELD_ITEM_LABEL_CLASS = "dx-field-item-label",
	    FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content",
	    FIELD_ITEM_TAB_CLASS = "dx-field-item-tab",
	    FORM_FIELD_ITEM_COL_CLASS = "dx-col-",
	    GROUP_COL_COUNT_CLASS = "dx-group-colcount-",
	    FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content",
	    FORM_VALIDATION_SUMMARY = "dx-form-validation-summary",
	    WIDGET_CLASS = "dx-widget";
	var Form = Widget.inherit({
	    _init: function() {
	        this.callBase();
	        this._cachedColCountOptions = [];
	        this._groupsColCount = []
	    },
	    _initOptions: function(options) {
	        if (!("screenByWidth" in options)) {
	            options.screenByWidth = windowUtils.defaultScreenFactorFunc
	        }
	        this.callBase(options)
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            formID: new Guid,
	            formData: {},
	            colCount: 1,
	            screenByWidth: null,
	            colCountByScreen: void 0,
	            labelLocation: "left",
	            readOnly: false,
	            onFieldDataChanged: null,
	            customizeItem: null,
	            onEditorEnterKey: null,
	            minColWidth: 200,
	            alignItemLabels: true,
	            alignItemLabelsInAllGroups: true,
	            showColonAfterLabel: true,
	            showRequiredMark: true,
	            showOptionalMark: false,
	            requiredMark: "*",
	            optionalMark: messageLocalization.format("dxForm-optionalMark"),
	            requiredMessage: messageLocalization.getFormatter("dxForm-requiredMessage"),
	            showValidationSummary: false,
	            items: void 0,
	            scrollingEnabled: false,
	            validationGroup: void 0
	        })
	    },
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            formData: true
	        })
	    },
	    _getColCount: function($element) {
	        var $cols, index = 0,
	            isFinding = true;
	        while (isFinding) {
	            $cols = $element.find("." + FORM_FIELD_ITEM_COL_CLASS + index);
	            if (!$cols.length) {
	                isFinding = false
	            } else {
	                index++
	            }
	        }
	        return index
	    },
	    _createHiddenElement: function(rootLayoutManager) {
	        this._$hiddenElement = $("<div/>").addClass(WIDGET_CLASS).addClass(HIDDEN_LABEL_CLASS).appendTo(document.body);
	        var $hiddenLabel = rootLayoutManager._renderLabel({
	            text: " ",
	            location: this.option("labelLocation")
	        }).appendTo(this._$hiddenElement);
	        this._hiddenLabelText = $hiddenLabel.find("." + FIELD_ITEM_LABEL_TEXT_CLASS)[0]
	    },
	    _removeHiddenElement: function() {
	        this._$hiddenElement.remove();
	        this._hiddenLabelText = null
	    },
	    _getLabelWidthByText: function(text) {
	        this._hiddenLabelText.innerHTML = text;
	        return this._hiddenLabelText.offsetWidth
	    },
	    _getLabelsSelectorByCol: function(index, options) {
	        options = options || {};
	        var cssExcludeTabbedSelector = options.excludeTabbed ? ":not(." + FIELD_ITEM_TAB_CLASS + ")" : "";
	        return "." + (options.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index) + cssExcludeTabbedSelector + "> ." + FIELD_ITEM_LABEL_CLASS + " > ." + FIELD_ITEM_LABEL_CONTENT_CLASS
	    },
	    _getLabelText: function(labelText) {
	        var child, i, length = labelText.children.length,
	            result = "";
	        for (i = 0; i < length; i++) {
	            child = labelText.children[i];
	            result += !stringUtils.isEmpty(child.innerText) ? child.innerText : child.innerHTML
	        }
	        return result
	    },
	    _applyLabelsWidthByCol: function($container, index, options) {
	        var labelWidth, i, $labelTexts = $container.find(this._getLabelsSelectorByCol(index, options)),
	            $labelTextsLength = $labelTexts.length,
	            maxWidth = 0;
	        for (i = 0; i < $labelTextsLength; i++) {
	            labelWidth = this._getLabelWidthByText(this._getLabelText($labelTexts[i]));
	            if (labelWidth > maxWidth) {
	                maxWidth = labelWidth
	            }
	        }
	        for (i = 0; i < $labelTextsLength; i++) {
	            $labelTexts[i].style.width = maxWidth + "px"
	        }
	    },
	    _applyLabelsWidth: function($container, excludeTabbed, inOneColumn) {
	        var i, colCount = inOneColumn ? 1 : this._getColCount($container),
	            applyLabelsOptions = {
	                excludeTabbed: excludeTabbed,
	                inOneColumn: inOneColumn
	            };
	        for (i = 0; i < colCount; i++) {
	            this._applyLabelsWidthByCol($container, i, applyLabelsOptions)
	        }
	    },
	    _getGroupElementsInColumn: function($container, columnIndex, colCount) {
	        var cssColCountSelector = utils.isDefined(colCount) ? "." + GROUP_COL_COUNT_CLASS + colCount : "";
	        return $container.find("." + FORM_FIELD_ITEM_COL_CLASS + columnIndex + " > ." + FIELD_ITEM_CONTENT_CLASS + " > ." + FORM_GROUP_CLASS + cssColCountSelector)
	    },
	    _applyLabelsWidthWithGroups: function($container, colCount, excludeTabbed) {
	        var i, j, $groups, groupColCount, $groupsByCol, alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups"),
	            applyLabelsOptions = {
	                excludeTabbed: excludeTabbed
	            };
	        if (alignItemLabelsInAllGroups) {
	            for (i = 0; i < colCount; i++) {
	                $groupsByCol = this._getGroupElementsInColumn($container, i);
	                this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions);
	                for (j = 0; j < this._groupsColCount.length; j++) {
	                    $groupsByCol = this._getGroupElementsInColumn($container, i, this._groupsColCount[j]);
	                    groupColCount = this._getColCount($groupsByCol);
	                    for (var k = 1; k < groupColCount; k++) {
	                        this._applyLabelsWidthByCol($groupsByCol, k, applyLabelsOptions)
	                    }
	                }
	            }
	        } else {
	            $groups = this.element().find("." + FORM_GROUP_CLASS);
	            for (i = 0; i < $groups.length; i++) {
	                this._applyLabelsWidth($groups.eq(i), excludeTabbed)
	            }
	        }
	    },
	    _alignLabelsInColumn: function(options) {
	        this._createHiddenElement(options.layoutManager);
	        if (options.inOneColumn) {
	            this._applyLabelsWidth(options.$container, options.excludeTabbed, true)
	        } else {
	            if (this._checkGrouping(options.items)) {
	                this._applyLabelsWidthWithGroups(options.$container, options.layoutManager._getColCount(), options.excludeTabbed)
	            } else {
	                this._applyLabelsWidth(options.$container, options.excludeTabbed)
	            }
	        }
	        this._removeHiddenElement()
	    },
	    _render: function() {
	        this._clearEditorInstances();
	        this.callBase();
	        this.element().addClass(FORM_CLASS);
	        this._cachedScreenFactor = windowUtils.getCurrentScreenFactor(this.option("screenByWidth"))
	    },
	    _clearEditorInstances: function() {
	        this._editorInstancesByField = {}
	    },
	    _alignLabels: function(layoutManager, inOneColumn) {
	        this._alignLabelsInColumn({
	            $container: this.element(),
	            layoutManager: layoutManager,
	            excludeTabbed: true,
	            items: this.option("items"),
	            inOneColumn: inOneColumn
	        })
	    },
	    _clean: function() {
	        this.callBase();
	        this._groupsColCount = [];
	        this._cachedColCountOptions = [];
	        delete this._cachedScreenFactor
	    },
	    _renderContentImpl: function() {
	        this.callBase();
	        this.setAria("role", "form", this.element());
	        if (this.option("scrollingEnabled")) {
	            this._renderScrollable()
	        }
	        this._renderLayout();
	        this._renderValidationSummary()
	    },
	    _renderScrollable: function() {
	        var useNativeScrolling = this.option("useNativeScrolling");
	        this._scrollable = new Scrollable(this.element(), {
	            useNative: !!useNativeScrolling,
	            useSimulatedScrollbar: !useNativeScrolling,
	            useKeyboard: false,
	            direction: "both",
	            bounceEnabled: false
	        })
	    },
	    _getContent: function() {
	        return this.option("scrollingEnabled") ? this._scrollable.content() : this.element()
	    },
	    _renderValidationSummary: function() {
	        var $validationSummary = this.element().find("." + FORM_VALIDATION_SUMMARY);
	        if ($validationSummary.length > 0) {
	            $validationSummary.remove()
	        }
	        if (this.option("showValidationSummary")) {
	            $("<div/>").addClass(FORM_VALIDATION_SUMMARY).dxValidationSummary({
	                validationGroup: this._getValidationGroup()
	            }).appendTo(this._getContent())
	        }
	    },
	    _prepareItems: function(items, isTabbed) {
	        if (items) {
	            var i, item, clonedItem, that = this,
	                extendedItems = [];
	            for (i = 0; i < items.length; i++) {
	                item = items[i];
	                clonedItem = utils.isObject(item) ? $.extend({}, item) : item;
	                that._prepareGroupItem(clonedItem);
	                that._prepareTabbedItem(clonedItem);
	                that._prepareItemTemplate(clonedItem);
	                if (utils.isObject(clonedItem)) {
	                    if (isTabbed) {
	                        clonedItem.cssItemClass = FIELD_ITEM_TAB_CLASS
	                    }
	                    clonedItem.items = this._prepareItems(clonedItem.items, isTabbed)
	                }
	                extendedItems.push(clonedItem)
	            }
	            return extendedItems
	        }
	    },
	    _prepareGroupItem: function(item) {
	        if ("group" === item.itemType) {
	            item.alignItemLabels = utils.ensureDefined(item.alignItemLabels, true);
	            if (item.template) {
	                item.groupContentTemplate = this._getTemplate(item.template)
	            }
	            item.template = $.proxy(this._itemGroupTemplate, this, item)
	        }
	    },
	    _prepareTabbedItem: function(item) {
	        if ("tabbed" === item.itemType) {
	            item.template = $.proxy(this._itemTabbedTemplate, this, item);
	            item.tabs = this._prepareItems(item.tabs, true)
	        }
	    },
	    _prepareItemTemplate: function(item) {
	        if (item.template) {
	            item.template = this._getTemplate(item.template)
	        }
	    },
	    _checkGrouping: function(items) {
	        if (items) {
	            for (var i = 0; i < items.length; i++) {
	                var item = items[i];
	                if ("group" === item.itemType) {
	                    return true
	                }
	            }
	        }
	    },
	    _renderLayout: function() {
	        var that = this,
	            items = that.option("items"),
	            $content = that._getContent();
	        items = that._prepareItems(items);
	        that._rootLayoutManager = that._renderLayoutManager(items, $content, {
	            colCount: that.option("colCount"),
	            width: this.option("width"),
	            alignItemLabels: that.option("alignItemLabels"),
	            screenByWidth: this.option("screenByWidth"),
	            colCountByScreen: this.option("colCountByScreen"),
	            onLayoutChanged: function(inOneColumn) {
	                $.proxy(that._alignLabels, that)(that._rootLayoutManager, inOneColumn)
	            },
	            onContentReady: function(e) {
	                that._alignLabels(e.component, e.component.isLayoutChanged())
	            }
	        })
	    },
	    _itemTabbedTemplate: function(item, e, $container) {
	        var that = this,
	            $tabPanel = $("<div/>").appendTo($container),
	            tabPanelOptions = $.extend({}, item.tabPanelOptions, {
	                dataSource: item.tabs,
	                onItemRendered: function(args) {
	                    domUtils.triggerShownEvent(args.itemElement)
	                },
	                itemTemplate: function(itemData, e, $container) {
	                    var layoutManager, alignItemLabels = utils.ensureDefined(itemData.alignItemLabels, true);
	                    layoutManager = that._renderLayoutManager(itemData.items, $container, {
	                        colCount: itemData.colCount,
	                        alignItemLabels: alignItemLabels,
	                        screenByWidth: this.option("screenByWidth"),
	                        colCountByScreen: itemData.colCountByScreen,
	                        cssItemClass: itemData.cssItemClass,
	                        onLayoutChanged: function(inOneColumn) {
	                            $.proxy(that._alignLabelsInColumn, that)({
	                                $container: $container,
	                                layoutManager: layoutManager,
	                                items: itemData.items,
	                                inOneColumn: inOneColumn
	                            })
	                        }
	                    });
	                    if (alignItemLabels) {
	                        $.proxy(that._alignLabelsInColumn, that)({
	                            $container: $container,
	                            layoutManager: layoutManager,
	                            items: itemData.items,
	                            inOneColumn: layoutManager.isLayoutChanged()
	                        })
	                    }
	                }
	            });
	        that._createComponent($tabPanel, TabPanel, tabPanelOptions)
	    },
	    _itemGroupTemplate: function(item, e, $container) {
	        var $groupContent, colCount, layoutManager, $group = $("<div/>").appendTo($container).toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, utils.isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS);
	        if (item.caption) {
	            $("<span/>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).appendTo($group)
	        }
	        $groupContent = $("<div/>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
	        if (item.groupContentTemplate) {
	            var data = {
	                formData: this.option("formData"),
	                component: this
	            };
	            item.groupContentTemplate.render({
	                model: data,
	                container: $groupContent
	            })
	        } else {
	            layoutManager = this._renderLayoutManager(item.items, $groupContent, {
	                colCount: item.colCount,
	                colCountByScreen: item.colCountByScreen,
	                alignItemLabels: item.alignItemLabels,
	                cssItemClass: item.cssItemClass
	            });
	            colCount = layoutManager._getColCount();
	            if ($.inArray(colCount, this._groupsColCount) === -1) {
	                this._groupsColCount.push(colCount)
	            }
	            $group.addClass(GROUP_COL_COUNT_CLASS + colCount)
	        }
	    },
	    _renderLayoutManager: function(items, $rootElement, options) {
	        var instance, $element = $("<div />"),
	            that = this,
	            config = $.extend(that._getLayoutManagerDefaultConfig(), {
	                items: items,
	                onContentReady: function(args) {
	                    that._updateEditorInstancesFromLayoutManager(args.component._editorInstancesByField);
	                    options.onContentReady && options.onContentReady(args)
	                },
	                colCount: options.colCount,
	                alignItemLabels: options.alignItemLabels,
	                cssItemClass: options.cssItemClass,
	                colCountByScreen: options.colCountByScreen,
	                onLayoutChanged: options.onLayoutChanged,
	                width: options.width
	            });
	        that._cachedColCountOptions.push({
	            colCount: options.colCount,
	            colCountByScreen: options.colCountByScreen
	        });
	        $element.appendTo($rootElement);
	        instance = that._createComponent($element, "dxLayoutManager", config);
	        that._attachSyncSubscriptions(instance);
	        return instance
	    },
	    _getValidationGroup: function() {
	        return this.option("validationGroup") || this
	    },
	    _getLayoutManagerDefaultConfig: function() {
	        var that = this;
	        return {
	            form: that,
	            validationGroup: that._getValidationGroup(),
	            showRequiredMark: that.option("showRequiredMark"),
	            showOptionalMark: that.option("showOptionalMark"),
	            requiredMark: that.option("requiredMark"),
	            optionalMark: that.option("optionalMark"),
	            requiredMessage: that.option("requiredMessage"),
	            screenByWidth: that.option("screenByWidth"),
	            layoutData: that.option("formData"),
	            labelLocation: that.option("labelLocation"),
	            customizeItem: that.option("customizeItem"),
	            minColWidth: that.option("minColWidth"),
	            showColonAfterLabel: that.option("showColonAfterLabel"),
	            onEditorEnterKey: that.option("onEditorEnterKey"),
	            onFieldDataChanged: function(args) {
	                that._triggerOnFieldDataChanged(args)
	            },
	            validationBoundary: that.option("scrollingEnabled") ? that.element() : void 0
	        }
	    },
	    _updateEditorInstancesFromLayoutManager: function(instancesByDataFields) {
	        $.extend(this._editorInstancesByField, instancesByDataFields)
	    },
	    _createComponent: function($element, type, config) {
	        var that = this;
	        config = config || {};
	        that._extendConfig(config, {
	            readOnly: that.option("readOnly")
	        });
	        return that.callBase($element, type, config)
	    },
	    _attachSyncSubscriptions: function(instance) {
	        var that = this;
	        that.on("optionChanged", function(args) {
	            if (utils.isDefined(that.option("items")) && "formData" === args.fullName) {
	                instance.updateData(args.value)
	            }
	            if ("readOnly" === args.name) {
	                instance.option(args.fullName, args.value)
	            }
	        })
	    },
	    _optionChanged: function(args) {
	        var rootNameOfComplexOption = this._getRootLevelOfExpectedComplexOption(args.fullName, ["formData", "items"]);
	        if (rootNameOfComplexOption) {
	            this._customHandlerOfComplexOption(args, rootNameOfComplexOption);
	            return
	        }
	        switch (args.name) {
	            case "formData":
	                if (!utils.isDefined(this._options.items)) {
	                    this._invalidate();
	                    this._triggerOnFieldDataChangedByDataSet(args.value)
	                } else {
	                    if ($.isEmptyObject(args.value)) {
	                        this._resetValues()
	                    }
	                }
	                break;
	            case "items":
	            case "colCount":
	            case "onFieldDataChanged":
	            case "onEditorEnterKey":
	            case "labelLocation":
	            case "alignItemLabels":
	            case "showColonAfterLabel":
	            case "customizeItem":
	            case "alignItemLabelsInAllGroups":
	            case "showRequiredMark":
	            case "showOptionalMark":
	            case "requiredMark":
	            case "optionalMark":
	            case "requiredMessage":
	            case "scrollingEnabled":
	            case "formID":
	            case "colCountByScreen":
	            case "screenByWidth":
	                this._invalidate();
	                break;
	            case "showValidationSummary":
	                this._renderValidationSummary();
	                break;
	            case "minColWidth":
	                if ("auto" === this.option("colCount")) {
	                    this._invalidate()
	                }
	                break;
	            case "readOnly":
	                break;
	            case "width":
	                this.callBase(args);
	                this._rootLayoutManager.option(args.name, args.value);
	                this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isLayoutChanged());
	                break;
	            case "visible":
	                this.callBase(args);
	                if (args.value) {
	                    domUtils.triggerShownEvent(this.element())
	                }
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _getRootLevelOfExpectedComplexOption: function(fullOptionName, expectedRootNames) {
	        var result, splitFullName = fullOptionName.split(".");
	        if (splitFullName.length > 1) {
	            var i, rootOptionName = splitFullName[0];
	            for (i = 0; i < expectedRootNames.length; i++) {
	                if (rootOptionName.search(expectedRootNames[i]) !== -1) {
	                    result = expectedRootNames[i]
	                }
	            }
	        }
	        return result
	    },
	    _customHandlerOfComplexOption: function(args, rootOptionName) {
	        var nameParts = args.fullName.split(".");
	        switch (rootOptionName) {
	            case "items":
	                var instance, items, name, itemPath = this._getItemPath(nameParts),
	                    item = this.option(itemPath);
	                if (args.fullName.search("editorOptions") !== -1) {
	                    instance = this.getEditor(item.dataField);
	                    instance && instance.option(item.editorOptions)
	                } else {
	                    if (item) {
	                        name = args.fullName.replace(itemPath + ".", "");
	                        this._changeItemOption(item, name, args.value);
	                        items = this._generateItemsFromData(this.option("items"));
	                        this.option("items", items)
	                    }
	                }
	                break;
	            case "formData":
	                var dataField = nameParts.slice(1).join(".");
	                this._triggerOnFieldDataChanged({
	                    dataField: dataField,
	                    value: args.value
	                })
	        }
	    },
	    _getItemPath: function(nameParts) {
	        var i, itemPath = nameParts[0];
	        for (i = 1; i < nameParts.length; i++) {
	            if (nameParts[i].search("items|tabs") !== -1) {
	                itemPath += "." + nameParts[i]
	            } else {
	                break
	            }
	        }
	        return itemPath
	    },
	    _triggerOnFieldDataChanged: function(args) {
	        this._createActionByOption("onFieldDataChanged")(args)
	    },
	    _triggerOnFieldDataChangedByDataSet: function(data) {
	        var that = this;
	        if (data && utils.isObject(data)) {
	            $.each(data, function(dataField, value) {
	                that._triggerOnFieldDataChanged({
	                    dataField: dataField,
	                    value: value
	                })
	            })
	        }
	    },
	    _updateFieldValue: function(dataField, value) {
	        if (utils.isDefined(this.option("formData"))) {
	            var editor = this.getEditor(dataField);
	            this.option("formData." + dataField, value);
	            if (editor) {
	                var editorValue = editor.option("value");
	                if (editorValue !== value) {
	                    editor.option("value", value)
	                }
	            }
	        }
	    },
	    _generateItemsFromData: function(items) {
	        var formData = this.option("formData"),
	            result = [];
	        if (!items && utils.isDefined(formData)) {
	            $.each(formData, function(dataField) {
	                result.push({
	                    dataField: dataField
	                })
	            })
	        }
	        if (items) {
	            $.each(items, function(index, item) {
	                if (utils.isObject(item)) {
	                    result.push(item)
	                } else {
	                    result.push({
	                        dataField: item
	                    })
	                }
	            })
	        }
	        return result
	    },
	    _getItemByField: function(field, items) {
	        var resultItem, that = this,
	            fieldParts = utils.isObject(field) ? field : that._getFieldParts(field),
	            fieldName = fieldParts.fieldName,
	            fieldPath = fieldParts.fieldPath;
	        if (items.length) {
	            $.each(items, function(index, item) {
	                var itemType = item.itemType;
	                if (fieldPath.length) {
	                    var path = fieldPath.slice();
	                    item = that._getItemByFieldPath(path, fieldName, item)
	                } else {
	                    if ("group" === itemType && !item.caption || "tabbed" === itemType) {
	                        var subItemsField = that._getSubItemField(itemType);
	                        item.items = that._generateItemsFromData(item.items);
	                        item = that._getItemByField({
	                            fieldName: fieldName,
	                            fieldPath: fieldPath
	                        }, item[subItemsField])
	                    }
	                }
	                if (item && (item.dataField === fieldName || item.name === fieldName || that._getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && that._getTextWithoutSpaces(item.caption) === fieldName)) {
	                    resultItem = item;
	                    return false
	                }
	            })
	        }
	        return resultItem
	    },
	    _getFieldParts: function(field) {
	        var fieldSeparator = ".",
	            fieldName = field,
	            separatorIndex = fieldName.indexOf(fieldSeparator),
	            resultPath = [];
	        while (separatorIndex !== -1) {
	            resultPath.push(fieldName.substr(0, separatorIndex));
	            fieldName = fieldName.substr(separatorIndex + 1);
	            separatorIndex = fieldName.indexOf(fieldSeparator)
	        }
	        return {
	            fieldName: fieldName,
	            fieldPath: resultPath.reverse()
	        }
	    },
	    _getItemByFieldPath: function(path, fieldName, item) {
	        var result, that = this,
	            itemType = item.itemType,
	            subItemsField = that._getSubItemField(itemType),
	            isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
	        do {
	            if (isItemWithSubItems) {
	                var pathNode, isGroupWithCaption = utils.isDefined(item.caption || item.title),
	                    captionWithoutSpaces = that._getTextWithoutSpaces(item.caption || item.title);
	                item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
	                if (isGroupWithCaption) {
	                    pathNode = path.pop()
	                }
	                if (!path.length) {
	                    result = that._getItemByField(fieldName, item[subItemsField]);
	                    if (result) {
	                        break
	                    }
	                }
	                if (!isGroupWithCaption || isGroupWithCaption && captionWithoutSpaces === pathNode) {
	                    if (path.length) {
	                        result = that._searchItemInEverySubItem(path, fieldName, item[subItemsField])
	                    }
	                }
	            } else {
	                break
	            }
	        } while (path.length && false !== result);
	        return result
	    },
	    _getSubItemField: function(itemType) {
	        return "tabbed" === itemType ? "tabs" : "items"
	    },
	    _searchItemInEverySubItem: function(path, fieldName, items) {
	        var result, that = this;
	        $.each(items, function(index, groupItem) {
	            result = that._getItemByFieldPath(path, fieldName, groupItem);
	            if (result) {
	                return false
	            }
	        });
	        if (!result) {
	            result = false
	        }
	        return result
	    },
	    _getTextWithoutSpaces: function(text) {
	        return text ? text.replace(" ", "") : void 0
	    },
	    _changeItemOption: function(item, option, value) {
	        if (utils.isObject(item)) {
	            item[option] = value
	        }
	    },
	    _dimensionChanged: function() {
	        var currentScreenFactor = windowUtils.getCurrentScreenFactor(this.option("screenByWidth"));
	        if (this._cachedScreenFactor !== currentScreenFactor) {
	            if (this._isColCountChanged(this._cachedScreenFactor, currentScreenFactor)) {
	                this._refresh()
	            }
	            this._cachedScreenFactor = currentScreenFactor;
	            return
	        }
	        if ("auto" === this.option("colCount")) {
	            this._refresh()
	        }
	    },
	    _isColCountChanged: function(oldScreenSize, newScreenSize) {
	        var isChanged = false;
	        $.each(this._cachedColCountOptions, function(index, item) {
	            if (1 !== item.colCount || item.colCountByScreen && item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
	                isChanged = true;
	                return false
	            }
	        });
	        return isChanged
	    },
	    _refresh: function() {
	        this.element().find(".dx-state-focused input, .dx-state-focused textarea").trigger("change");
	        this.callBase()
	    },
	    _resetValues: function() {
	        var validationGroup = ValidationEngine.getGroupConfig(this);
	        validationGroup && validationGroup.reset();
	        $.each(this._editorInstancesByField, function(dataField, editor) {
	            editor.reset();
	            editor.option("isValid", true)
	        })
	    },
	    _updateData: function(data, value, isComplexData) {
	        var that = this,
	            _data = isComplexData ? value : data;
	        if (utils.isObject(_data)) {
	            $.each(_data, function(dataField, fieldValue) {
	                that._updateData(isComplexData ? data + "." + dataField : dataField, fieldValue, utils.isObject(fieldValue))
	            })
	        } else {
	            if (utils.isString(data)) {
	                that._updateFieldValue(data, value)
	            }
	        }
	    },
	    registerKeyHandler: function(key, handler) {
	        this.callBase(key, handler);
	        $.each(this._editorInstancesByField, function(dataField, editor) {
	            editor.registerKeyHandler(key, handler)
	        })
	    },
	    _focusTarget: function() {
	        return this.element().find(".dx-field-item-content [tabindex]").first()
	    },
	    resetValues: function() {
	        this._resetValues()
	    },
	    updateData: function(data, value) {
	        this._updateData(data, value)
	    },
	    getEditor: function(field) {
	        return this._editorInstancesByField[field]
	    },
	    updateDimensions: function() {
	        var that = this,
	            deferred = $.Deferred();
	        if (that._scrollable) {
	            that._scrollable.update().done(function() {
	                deferred.resolveWith(that)
	            })
	        } else {
	            deferred.resolveWith(that)
	        }
	        return deferred.promise()
	    },
	    itemOption: function(field, option, value) {
	        var that = this,
	            argsCount = arguments.length,
	            items = that._generateItemsFromData(that.option("items")),
	            item = that._getItemByField(field, items);
	        if (1 === argsCount) {
	            return item
	        } else {
	            if (3 === argsCount) {
	                that._changeItemOption(item, option, value)
	            } else {
	                if (utils.isObject(option)) {
	                    $.each(option, function(optionName, optionValue) {
	                        that._changeItemOption(item, optionName, optionValue)
	                    })
	                }
	            }
	            this.option("items", items)
	        }
	    },
	    validate: function() {
	        try {
	            return ValidationEngine.validateGroup(this._getValidationGroup())
	        } catch (e) {
	            errors.log("E1036", e.message)
	        }
	    },
	    getItemID: function(name) {
	        return "dx_" + this.option("formID") + "_" + (name || new Guid)
	    }
	});
	registerComponent("dxForm", Form);
	module.exports = Form;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/form/ui.form.layout_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    registerComponent = __webpack_require__(44),
	    utils = __webpack_require__(8),
	    isWrapped = __webpack_require__(37).isWrapped,
	    isWritableWrapped = __webpack_require__(37).isWritableWrapped,
	    windowUtils = __webpack_require__(29),
	    stringUtils = __webpack_require__(7),
	    removeEvent = __webpack_require__(32),
	    clickEvent = __webpack_require__(65),
	    normalizeIndexes = __webpack_require__(99).normalizeIndexes,
	    errors = __webpack_require__(15),
	    messageLocalization = __webpack_require__(79),
	    support = __webpack_require__(48),
	    inflector = __webpack_require__(49),
	    Widget = __webpack_require__(84),
	    Validator = __webpack_require__(226),
	    ResponsiveBox = __webpack_require__(228);
	__webpack_require__(230);
	__webpack_require__(237);
	__webpack_require__(204);
	__webpack_require__(240);
	var FORM_EDITOR_BY_DEFAULT = "dxTextBox",
	    FIELD_ITEM_CLASS = "dx-field-item",
	    FIELD_EMPTY_ITEM_CLASS = "dx-field-empty-item",
	    FIELD_ITEM_REQUIRED_CLASS = "dx-field-item-required",
	    FIELD_ITEM_OPTIONAL_CLASS = "dx-field-item-optional",
	    FIELD_ITEM_REQUIRED_MARK_CLASS = "dx-field-item-required-mark",
	    FIELD_ITEM_OPTIONAL_MARK_CLASS = "dx-field-item-optional-mark",
	    FIELD_ITEM_LABEL_CLASS = "dx-field-item-label",
	    FIELD_ITEM_LABEL_ALIGN_CLASS = "dx-field-item-label-align",
	    FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content",
	    FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text",
	    FIELD_ITEM_LABEL_LOCATION_CLASS = "dx-field-item-label-location-",
	    FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content",
	    FIELD_ITEM_CONTENT_LOCATION_CLASS = "dx-field-item-content-location-",
	    FIELD_ITEM_CONTENT_WRAPPER_CLASS = "dx-field-item-content-wrapper",
	    FIELD_ITEM_HELP_TEXT_CLASS = "dx-field-item-help-text",
	    LABEL_HORIZONTAL_ALIGNMENT_CLASS = "dx-label-h-align",
	    LABEL_VERTICAL_ALIGNMENT_CLASS = "dx-label-v-align",
	    FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager",
	    LAYOUT_MANAGER_FIRST_ROW_CLASS = "dx-first-row",
	    LAYOUT_MANAGER_FIRST_COL_CLASS = "dx-first-col",
	    LAYOUT_MANAGER_LAST_COL_CLASS = "dx-last-col",
	    LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col",
	    FLEX_LAYOUT_CLASS = "dx-flex-layout",
	    LAYOUT_STRATEGY_FLEX = "flex",
	    LAYOUT_STRATEGY_FALLBACK = "fallback",
	    DATA_OPTIONS = ["dataSource", "items"];
	var LayoutManager = Widget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            layoutData: {},
	            readOnly: false,
	            colCount: 1,
	            colCountByScreen: void 0,
	            labelLocation: "left",
	            onFieldDataChanged: null,
	            onEditorEnterKey: null,
	            customizeItem: null,
	            alignItemLabels: true,
	            minColWidth: 200,
	            showRequiredMark: true,
	            screenByWidth: null,
	            showOptionalMark: false,
	            requiredMark: "*",
	            optionalMark: messageLocalization.format("dxForm-optionalMark"),
	            requiredMessage: messageLocalization.getFormatter("dxForm-requiredMessage")
	        })
	    },
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            layoutData: true
	        })
	    },
	    _init: function() {
	        this.callBase();
	        this._syncDataWithItems();
	        this._updateItems(this.option("layoutData"))
	    },
	    _syncDataWithItems: function() {
	        var that = this,
	            userItems = that.option("items");
	        if (utils.isDefined(userItems)) {
	            $.each(userItems, function(index, item) {
	                var value;
	                if (item.dataField && void 0 === that._getDataByField(item.dataField)) {
	                    if (item.editorOptions) {
	                        value = item.editorOptions.value
	                    }
	                    that._updateFieldValue(item.dataField, value)
	                }
	            })
	        }
	    },
	    _getDataByField: function(dataField) {
	        return dataField ? this.option("layoutData." + dataField) : null
	    },
	    _updateFieldValue: function(dataField, value) {
	        var layoutData = this.option("layoutData"),
	            newValue = value;
	        if (!isWrapped(layoutData[dataField]) && utils.isDefined(dataField)) {
	            this.option("layoutData." + dataField, newValue)
	        } else {
	            if (isWritableWrapped(layoutData[dataField])) {
	                newValue = utils.isFunction(newValue) ? newValue() : newValue;
	                layoutData[dataField](newValue)
	            }
	        }
	        this._triggerOnFieldDataChanged({
	            dataField: dataField,
	            value: newValue
	        })
	    },
	    _triggerOnFieldDataChanged: function(args) {
	        this._createActionByOption("onFieldDataChanged")(args)
	    },
	    _updateItems: function(layoutData) {
	        var items, processedItems, that = this,
	            userItems = this.option("items"),
	            customizeItem = that.option("customizeItem");
	        items = utils.isDefined(userItems) ? userItems : this._generateItemsByData(layoutData);
	        if (utils.isDefined(items)) {
	            processedItems = [];
	            $.each(items, function(index, item) {
	                if (that._isAcceptableItem(item)) {
	                    item = that._processItem(item);
	                    customizeItem && customizeItem(item);
	                    if (utils.isObject(item)) {
	                        processedItems.push(item)
	                    }
	                }
	            });
	            this._items = processedItems;
	            this._sortItems()
	        }
	    },
	    _generateItemsByData: function(layoutData) {
	        var result = [];
	        if (utils.isDefined(layoutData)) {
	            $.each(layoutData, function(dataField) {
	                result.push({
	                    dataField: dataField
	                })
	            })
	        }
	        return result
	    },
	    _isAcceptableItem: function(item) {
	        var itemField = item.dataField || item,
	            itemData = this.option("layoutData." + itemField);
	        return !(utils.isFunction(itemData) && !isWrapped(itemData))
	    },
	    _processItem: function(item) {
	        if ("string" === typeof item) {
	            item = {
	                dataField: item
	            }
	        }
	        if ("object" === typeof item && !item.itemType) {
	            item.itemType = "simple"
	        }
	        if (!utils.isDefined(item.editorType) && utils.isDefined(item.dataField)) {
	            var value = this._getDataByField(item.dataField);
	            item.editorType = utils.isDefined(value) ? this._getEditorTypeByDataType($.type(value)) : FORM_EDITOR_BY_DEFAULT
	        }
	        return item
	    },
	    _getEditorTypeByDataType: function(dataType) {
	        switch (dataType) {
	            case "number":
	                return "dxNumberBox";
	            case "date":
	                return "dxDateBox";
	            case "boolean":
	                return "dxCheckBox";
	            default:
	                return "dxTextBox"
	        }
	    },
	    _sortItems: function() {
	        normalizeIndexes(this._items, "visibleIndex");
	        this._sortIndexes()
	    },
	    _sortIndexes: function() {
	        this._items.sort(function(itemA, itemB) {
	            var result, indexA = itemA.visibleIndex,
	                indexB = itemB.visibleIndex;
	            if (indexA > indexB) {
	                result = 1
	            } else {
	                if (indexA < indexB) {
	                    result = -1
	                } else {
	                    result = 0
	                }
	            }
	            return result
	        })
	    },
	    _render: function() {
	        this._clearEditorInstances();
	        this.element().addClass(FORM_LAYOUT_MANAGER_CLASS);
	        this.callBase()
	    },
	    _clearEditorInstances: function() {
	        this._editorInstancesByField = {}
	    },
	    _hasBrowserFlex: function() {
	        return support.styleProp(LAYOUT_STRATEGY_FLEX) === LAYOUT_STRATEGY_FLEX
	    },
	    _renderContentImpl: function() {
	        this.callBase();
	        this._renderResponsiveBox()
	    },
	    _renderResponsiveBox: function() {
	        var that = this;
	        if (that._items && that._items.length) {
	            var layoutItems, colCount = that._getColCount(),
	                $container = $("<div />").appendTo(that.element());
	            that._prepareItemsWithMerging(colCount);
	            layoutItems = that._generateLayoutItems();
	            that._extendItemsWithDefaultTemplateOptions(layoutItems, that._items);
	            that._responsiveBox = that._createComponent($container, ResponsiveBox, that._getResponsiveBoxConfig(layoutItems, colCount))
	        }
	    },
	    _extendItemsWithDefaultTemplateOptions: function(targetItems, sourceItems) {
	        sourceItems.forEach(function(item, index) {
	            if (utils.isDefined(item.disabled)) {
	                targetItems[index].disabled = item.disabled
	            }
	            if (utils.isDefined(item.visible)) {
	                targetItems[index].visible = item.visible
	            }
	        })
	    },
	    _getResponsiveBoxConfig: function(layoutItems, colCount) {
	        var that = this,
	            colCountByScreen = that.option("colCountByScreen"),
	            xsColCount = colCountByScreen && colCountByScreen.xs;
	        return {
	            _layoutStrategy: that._hasBrowserFlex() ? LAYOUT_STRATEGY_FLEX : LAYOUT_STRATEGY_FALLBACK,
	            onLayoutChanged: function() {
	                var onLayoutChanged = that.option("onLayoutChanged"),
	                    isLayoutChanged = that.isLayoutChanged();
	                if (onLayoutChanged) {
	                    that.element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isLayoutChanged);
	                    onLayoutChanged(isLayoutChanged)
	                }
	            },
	            onContentReady: function(e) {
	                if (that.option("onLayoutChanged")) {
	                    that.element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isLayoutChanged(e.component))
	                }
	                that._fireContentReadyAction()
	            },
	            itemTemplate: function(e, itemData, $itemElement) {
	                if (!e.location) {
	                    return
	                }
	                var itemRenderedCountInPreviousRows = e.location.row * colCount,
	                    item = that._items[e.location.col + itemRenderedCountInPreviousRows],
	                    $fieldItem = $("<div/>").addClass(item.cssClass).appendTo($itemElement);
	                if (0 === e.location.row) {
	                    $fieldItem.addClass(LAYOUT_MANAGER_FIRST_ROW_CLASS)
	                }
	                if (0 === e.location.col) {
	                    $fieldItem.addClass(LAYOUT_MANAGER_FIRST_COL_CLASS)
	                }
	                if (e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount) {
	                    $fieldItem.addClass(LAYOUT_MANAGER_LAST_COL_CLASS)
	                }
	                "empty" === item.itemType ? that._renderEmptyItem($fieldItem) : that._renderFieldItem(item, $fieldItem)
	            },
	            cols: that._generateRatio(colCount),
	            rows: that._generateRatio(that._getRowsCount(), true),
	            dataSource: layoutItems,
	            screenByWidth: that.option("screenByWidth"),
	            singleColumnScreen: xsColCount ? false : "xs"
	        }
	    },
	    _getColCount: function() {
	        var colCount = this.option("colCount"),
	            colCountByScreen = this.option("colCountByScreen");
	        if (colCountByScreen) {
	            var currentColCount = colCountByScreen[windowUtils.getCurrentScreenFactor(this.option("screenByWidth"))];
	            colCount = currentColCount || colCount
	        }
	        if ("auto" === colCount) {
	            if (!!this._cashedColCount) {
	                return this._cashedColCount
	            }
	            var minColWidth = this.option("minColWidth"),
	                width = this.element().width(),
	                itemsCount = this._items.length,
	                maxColCount = Math.floor(width / minColWidth) || 1;
	            this._cashedColCount = colCount = itemsCount < maxColCount ? itemsCount : maxColCount
	        }
	        return colCount < 1 ? 1 : colCount
	    },
	    _prepareItemsWithMerging: function(colCount) {
	        var item, itemsMergedByCol, j, i, items = this._items.slice(0),
	            result = [];
	        for (i = 0; i < items.length; i++) {
	            item = items[i];
	            result.push(item);
	            if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
	                item.col = this._getColByIndex(result.length - 1, colCount)
	            }
	            if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
	                itemsMergedByCol = [];
	                for (j = 0; j < item.colSpan - 1; j++) {
	                    itemsMergedByCol.push({
	                        merged: true
	                    })
	                }
	                result = result.concat(itemsMergedByCol)
	            } else {
	                delete item.colSpan
	            }
	        }
	        this._items = result
	    },
	    _getColByIndex: function(index, colCount) {
	        return index % colCount
	    },
	    _generateLayoutItems: function() {
	        var item, i, items = this._items,
	            colCount = this._getColCount(),
	            result = [];
	        for (i = 0; i < items.length; i++) {
	            item = items[i];
	            if (!item.merged) {
	                var generatedItem = {
	                    location: {
	                        row: parseInt(i / colCount),
	                        col: this._getColByIndex(i, colCount)
	                    }
	                };
	                if (utils.isDefined(item.colSpan)) {
	                    generatedItem.location.colspan = item.colSpan
	                }
	                if (utils.isDefined(item.rowSpan)) {
	                    generatedItem.location.rowspan = item.rowSpan
	                }
	                result.push(generatedItem)
	            }
	        }
	        return result
	    },
	    _renderEmptyItem: function($container) {
	        return $container.addClass(FIELD_EMPTY_ITEM_CLASS).html("&nbsp;")
	    },
	    _renderFieldItem: function(item, $container) {
	        var $label, that = this,
	            name = that._getName(item),
	            id = that.getItemID(name),
	            isRequired = utils.isDefined(item.isRequired) ? item.isRequired : !!that._hasRequiredRuleInSet(item.validationRules),
	            labelOptions = that._getLabelOptions(item, id, isRequired),
	            $editor = $("<div/>"),
	            helpID = item.helpText ? new Guid : null;
	        $container.addClass(FIELD_ITEM_CLASS).addClass(isRequired ? FIELD_ITEM_REQUIRED_CLASS : FIELD_ITEM_OPTIONAL_CLASS).addClass(that.option("cssItemClass")).addClass(utils.isDefined(item.col) ? "dx-col-" + item.col : "");
	        if (labelOptions.visible && labelOptions.text) {
	            $label = that._renderLabel(labelOptions).appendTo($container)
	        }
	        if (item.helpText) {
	            helpID = new Guid
	        }
	        if ("simple" === item.itemType) {
	            if (that._isLabelNeedBaselineAlign(item) && "top" !== labelOptions.location) {
	                $container.addClass(FIELD_ITEM_LABEL_ALIGN_CLASS)
	            }
	            that._hasBrowserFlex() && $container.addClass(FLEX_LAYOUT_CLASS)
	        }
	        $editor.data("dx-form-item", item);
	        that._appendEditorToField({
	            $fieldItem: $container,
	            $label: $label,
	            $editor: $editor,
	            labelOptions: labelOptions
	        });
	        that._renderEditor({
	            $container: $editor,
	            dataField: name,
	            editorType: item.editorType,
	            editorOptions: item.editorOptions,
	            template: that._getTemplateByFieldItem(item),
	            isRequired: isRequired,
	            helpID: helpID,
	            id: id,
	            validationBoundary: that.option("validationBoundary")
	        });
	        var $validationTarget = $editor.children().first();
	        if ($validationTarget && $validationTarget.data("dx-validation-target")) {
	            that._renderValidator($validationTarget, item)
	        }
	        that._renderHelpText(item, $editor, helpID);
	        that._attachClickHandler($label, $editor, item.editorType)
	    },
	    _hasRequiredRuleInSet: function(rules) {
	        var hasRequiredRule;
	        if (rules && rules.length) {
	            $.each(rules, function(index, rule) {
	                if ("required" === rule.type) {
	                    hasRequiredRule = true;
	                    return false
	                }
	            })
	        }
	        return hasRequiredRule
	    },
	    _getName: function(item) {
	        return item.dataField || item.name
	    },
	    _isLabelNeedBaselineAlign: function(item) {
	        var largeEditors = ["dxTextArea", "dxRadioGroup", "dxCalendar"];
	        return !!item.helpText && !this._hasBrowserFlex() || $.inArray(item.editorType, largeEditors) !== -1
	    },
	    _getLabelOptions: function(item, id, isRequired) {
	        var labelOptions = $.extend({
	            showColon: this.option("showColonAfterLabel"),
	            location: this.option("labelLocation"),
	            id: id,
	            visible: true,
	            isRequired: isRequired
	        }, item ? item.label : {});
	        if (!labelOptions.text && item.dataField) {
	            labelOptions.text = inflector.captionize(item.dataField)
	        }
	        if (labelOptions.text) {
	            labelOptions.text += labelOptions.showColon ? ":" : ""
	        }
	        return labelOptions
	    },
	    _renderLabel: function(options) {
	        if (utils.isDefined(options.text) && options.text.length > 0) {
	            var labelClasses = FIELD_ITEM_LABEL_CLASS + " " + FIELD_ITEM_LABEL_LOCATION_CLASS + options.location,
	                $label = $("<label />").addClass(labelClasses).attr("for", options.id),
	                $labelContent = $("<span/>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS).appendTo($label);
	            $("<span />").addClass(FIELD_ITEM_LABEL_TEXT_CLASS).text(options.text).appendTo($labelContent);
	            if (options.alignment) {
	                $label.css("text-align", options.alignment)
	            }
	            $labelContent.append(this._renderLabelMark(options.isRequired));
	            return $label
	        }
	    },
	    _renderLabelMark: function(isRequired) {
	        var $mark, requiredMarksConfig = this._getRequiredMarksConfig(),
	            isRequiredMark = requiredMarksConfig.showRequiredMark && isRequired,
	            isOptionalMark = requiredMarksConfig.showOptionalMark && !isRequired;
	        if (isRequiredMark || isOptionalMark) {
	            var markClass = isRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS,
	                markText = isRequiredMark ? requiredMarksConfig.requiredMark : requiredMarksConfig.optionalMark;
	            $mark = $("<span />").addClass(markClass).html("&nbsp" + markText)
	        }
	        return $mark
	    },
	    _getRequiredMarksConfig: function() {
	        if (!this._cashedRequiredConfig) {
	            this._cashedRequiredConfig = {
	                showRequiredMark: this.option("showRequiredMark"),
	                showOptionalMark: this.option("showOptionalMark"),
	                requiredMark: this.option("requiredMark"),
	                optionalMark: this.option("optionalMark")
	            }
	        }
	        return this._cashedRequiredConfig
	    },
	    _renderEditor: function(options) {
	        var editorOptions, dataValue = this._getDataByField(options.dataField),
	            defaultEditorOptions = {
	                value: dataValue
	            },
	            isDeepExtend = true;
	        if ("dxTagBox" === options.editorType) {
	            defaultEditorOptions.value = defaultEditorOptions.value || []
	        }
	        editorOptions = $.extend(isDeepExtend, defaultEditorOptions, options.editorOptions, {
	            inputAttr: {
	                id: options.id
	            },
	            validationBoundary: options.validationBoundary
	        });
	        this._replaceDataOptions(options.editorOptions, editorOptions);
	        this._createEditor(options.$container, {
	            editorType: options.editorType,
	            dataField: options.dataField,
	            template: options.template,
	            name: options.name,
	            helpID: options.helpID,
	            isRequired: options.isRequired
	        }, editorOptions)
	    },
	    _replaceDataOptions: function(originalOptions, resultOptions) {
	        if (originalOptions) {
	            DATA_OPTIONS.forEach(function(item) {
	                if (resultOptions[item]) {
	                    resultOptions[item] = originalOptions[item]
	                }
	            })
	        }
	    },
	    _renderValidator: function($editor, item) {
	        var fieldName = this._getFieldLabelName(item),
	            validationRules = this._prepareValidationRules(item.validationRules, item.isRequired, item.itemType, fieldName);
	        if (utils.isArray(validationRules)) {
	            this._createComponent($editor, Validator, {
	                validationRules: validationRules,
	                validationGroup: this.option("validationGroup")
	            })
	        }
	    },
	    _getFieldLabelName: function(item) {
	        var isItemHaveCustomLabel = item.label && item.label.text,
	            itemName = isItemHaveCustomLabel ? null : this._getName(item);
	        return isItemHaveCustomLabel ? item.label.text : itemName && inflector.captionize(itemName)
	    },
	    _prepareValidationRules: function(userValidationRules, isItemRequired, itemType, itemName) {
	        var validationRules, isSimpleItem = "simple" === itemType;
	        if (isSimpleItem) {
	            if (userValidationRules) {
	                validationRules = userValidationRules
	            } else {
	                var requiredMessage = stringUtils.format(this.option("requiredMessage"), itemName || "");
	                validationRules = isItemRequired ? [{
	                    type: "required",
	                    message: requiredMessage
	                }] : null
	            }
	        }
	        return validationRules
	    },
	    _createEditor: function($container, renderOptions, editorOptions) {
	        var editorInstance, that = this,
	            template = renderOptions.template;
	        if (renderOptions.dataField && !editorOptions.name) {
	            editorOptions.name = renderOptions.dataField
	        }
	        that._addItemContentClasses($container);
	        if (template) {
	            var data = {
	                dataField: renderOptions.dataField,
	                editorType: renderOptions.editorType,
	                editorOptions: editorOptions,
	                component: that.option("form") || that
	            };
	            template.render({
	                model: data,
	                container: $container
	            })
	        } else {
	            var $editor = $("<div/>").appendTo($container);
	            try {
	                editorInstance = that._createComponent($editor, renderOptions.editorType, editorOptions);
	                editorInstance.setAria("describedby", renderOptions.helpID);
	                editorInstance.setAria("required", renderOptions.isRequired);
	                if (renderOptions.dataField) {
	                    var componentOwner = that.option("form") || that;
	                    editorInstance.on("enterKey", function(args) {
	                        componentOwner._createActionByOption("onEditorEnterKey")($.extend(args, {
	                            dataField: renderOptions.dataField
	                        }))
	                    });
	                    that._registerEditorInstance(editorInstance, renderOptions.dataField);
	                    that._createWatcher(editorInstance, $container, renderOptions);
	                    that.linkEditorToDataField(editorInstance, renderOptions.dataField, renderOptions.editorType)
	                }
	            } catch (e) {
	                errors.log("E1035", e.message)
	            }
	        }
	    },
	    _createWatcher: function(editorInstance, $container, renderOptions) {
	        var that = this,
	            watch = that._getWatch();
	        if (!$.isFunction(watch)) {
	            return
	        }
	        var dispose = watch(function() {
	            return that._getDataByField(renderOptions.dataField)
	        }, function() {
	            editorInstance.option("value", that._getDataByField(renderOptions.dataField))
	        }, {
	            deep: true,
	            skipImmediate: true
	        });
	        $container.on(removeEvent, dispose)
	    },
	    _getWatch: function() {
	        if (!utils.isDefined(this._watch)) {
	            var formInstance = this.option("form");
	            this._watch = formInstance && formInstance.option("integrationOptions.watchMethod")
	        }
	        return this._watch
	    },
	    _addItemContentClasses: function($itemContent) {
	        var locationSpecificClass = this._getItemContentLocationSpecificClass();
	        $itemContent.addClass([FIELD_ITEM_CONTENT_CLASS, locationSpecificClass].join(" "))
	    },
	    _getItemContentLocationSpecificClass: function() {
	        var labelLocation = this.option("labelLocation"),
	            oppositeClasses = {
	                right: "left",
	                left: "right",
	                top: "bottom"
	            };
	        return FIELD_ITEM_CONTENT_LOCATION_CLASS + oppositeClasses[labelLocation]
	    },
	    _registerEditorInstance: function(instance, dataField) {
	        this._editorInstancesByField[dataField] = instance
	    },
	    _createComponent: function($editor, type, editorOptions) {
	        var instance, that = this,
	            readOnlyState = this.option("readOnly");
	        instance = that.callBase($editor, type, editorOptions);
	        readOnlyState && instance.option("readOnly", readOnlyState);
	        that.on("optionChanged", function(args) {
	            if ("readOnly" === args.name) {
	                instance.option(args.name, args.value)
	            }
	        });
	        return instance
	    },
	    _getTemplateByFieldItem: function(fieldItem) {
	        return fieldItem.template ? this._getTemplate(fieldItem.template) : null
	    },
	    _appendEditorToField: function(params) {
	        if (params.$label) {
	            var location = params.labelOptions.location;
	            if ("top" === location || "left" === location) {
	                params.$fieldItem.append(params.$editor)
	            }
	            if ("right" === location) {
	                params.$fieldItem.prepend(params.$editor)
	            }
	            this._addInnerItemAlignmentClass(params.$fieldItem, location)
	        } else {
	            params.$fieldItem.append(params.$editor)
	        }
	    },
	    _addInnerItemAlignmentClass: function($fieldItem, location) {
	        if ("top" === location) {
	            $fieldItem.addClass(LABEL_VERTICAL_ALIGNMENT_CLASS)
	        } else {
	            $fieldItem.addClass(LABEL_HORIZONTAL_ALIGNMENT_CLASS)
	        }
	    },
	    _renderHelpText: function(fieldItem, $editor, helpID) {
	        var helpText = fieldItem.helpText;
	        if (helpText) {
	            var $editorWrapper = $("<div>").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS);
	            $editor.wrap($editorWrapper);
	            $("<div>").addClass(FIELD_ITEM_HELP_TEXT_CLASS).attr("id", helpID).text(helpText).appendTo($editor.parent())
	        }
	    },
	    _attachClickHandler: function($label, $editor, editorType) {
	        var isBooleanEditors = "dxCheckBox" === editorType || "dxSwitch" === editorType;
	        if ($label && isBooleanEditors) {
	            $label.on(clickEvent.name, function() {
	                $editor.children().trigger(clickEvent.name)
	            })
	        }
	    },
	    _generateRatio: function(count, isAutoSize) {
	        var ratio, i, result = [];
	        for (i = 0; i < count; i++) {
	            ratio = {
	                ratio: 1
	            };
	            if (isAutoSize) {
	                ratio.baseSize = "auto"
	            }
	            result.push(ratio)
	        }
	        return result
	    },
	    _getRowsCount: function() {
	        return Math.ceil(this._items.length / this._getColCount())
	    },
	    _optionChanged: function(args) {
	        if (0 === args.fullName.search("layoutData.")) {
	            return
	        }
	        switch (args.name) {
	            case "showRequiredMark":
	            case "showOptionalMark":
	            case "requiredMark":
	            case "optionalMark":
	                this._cashedRequiredConfig = null;
	                this._invalidate();
	                break;
	            case "layoutData":
	            case "items":
	                this._syncDataWithItems();
	                this._updateItems(args.value);
	                this._invalidate();
	                break;
	            case "alignItemLabels":
	            case "labelLocation":
	            case "requiredMessage":
	                this._invalidate();
	                break;
	            case "customizeItem":
	                this._updateItems(this.option("layoutData"));
	                this._invalidate();
	                break;
	            case "colCount":
	                this._resetColCount();
	                break;
	            case "minColWidth":
	                if ("auto" === this.option("colCount")) {
	                    this._resetColCount()
	                }
	                break;
	            case "readOnly":
	                break;
	            case "width":
	                this.callBase(args);
	                if ("auto" === this.option("colCount")) {
	                    this._resetColCount()
	                }
	                break;
	            case "onFieldDataChanged":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _resetColCount: function() {
	        this._cashedColCount = null;
	        this._invalidate()
	    },
	    linkEditorToDataField: function(editorInstance, dataField, editorType) {
	        var fullFieldName = "layoutData." + dataField,
	            that = this;
	        that.on("optionChanged", function(args) {
	            if (args.fullName === fullFieldName) {
	                if ("object" === typeof args.value) {
	                    that._managedUpdateEditorOption(editorInstance, "value", args.value)
	                } else {
	                    editorInstance.option("value", args.value)
	                }
	            }
	        });
	        editorInstance.on("valueChanged", function(args) {
	            if ("object" === typeof args.value) {
	                that._managedUpdateFieldValue(dataField, args.value)
	            } else {
	                that._updateFieldValue(dataField, args.value)
	            }
	        })
	    },
	    _managedUpdateEditorOption: function(editorInstance, optionName, value) {
	        if (!this._isValueChangedCalled) {
	            this._isFieldValueChanged = true;
	            editorInstance.option(optionName, value);
	            this._isFieldValueChanged = false
	        }
	    },
	    _managedUpdateFieldValue: function(dataField, value) {
	        this._isValueChangedCalled = true;
	        if (!this._isFieldValueChanged) {
	            this._updateFieldValue(dataField, value)
	        }
	        this._isValueChangedCalled = false
	    },
	    getItemID: function(name) {
	        var formInstance = this.option("form");
	        return formInstance && formInstance.getItemID(name)
	    },
	    updateData: function(data, value) {
	        var that = this;
	        if (utils.isObject(data)) {
	            $.each(data, function(dataField, fieldValue) {
	                that._updateFieldValue(dataField, fieldValue)
	            })
	        } else {
	            if ("string" === typeof data) {
	                that._updateFieldValue(data, value)
	            }
	        }
	    },
	    getEditor: function(field) {
	        return this._editorInstancesByField[field]
	    },
	    isLayoutChanged: function(component) {
	        var responsiveBox = this._responsiveBox || component;
	        if (responsiveBox) {
	            return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen")
	        }
	    }
	});
	registerComponent("dxLayoutManager", LayoutManager);
	module.exports = LayoutManager;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/validator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(15),
	    DOMComponent = __webpack_require__(28),
	    ValidationMixin = __webpack_require__(96),
	    ValidationEngine = __webpack_require__(106),
	    DefaultAdapter = __webpack_require__(227),
	    registerComponent = __webpack_require__(44);
	var VALIDATOR_CLASS = "dx-validator";
	var Validator = DOMComponent.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            validationRules: []
	        })
	    },
	    _init: function() {
	        this.callBase();
	        this._initGroupRegistration();
	        this.focused = $.Callbacks();
	        this._initAdapter()
	    },
	    _initGroupRegistration: function() {
	        var group = this._findGroup();
	        if (!this._groupWasInit) {
	            this.on("disposing", function(args) {
	                ValidationEngine.removeRegisteredValidator(args.component._validationGroup, args.component)
	            })
	        }
	        if (!this._groupWasInit || this._validationGroup !== group) {
	            ValidationEngine.removeRegisteredValidator(this._validationGroup, this);
	            this._groupWasInit = true;
	            this._validationGroup = group;
	            ValidationEngine.registerValidatorInGroup(group, this)
	        }
	    },
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            validationGroup: true
	        })
	    },
	    _initAdapter: function() {
	        var that = this,
	            element = that.element()[0],
	            dxStandardEditor = $.data(element, "dx-validation-target"),
	            adapter = that.option("adapter");
	        if (!adapter) {
	            if (dxStandardEditor) {
	                adapter = new DefaultAdapter(dxStandardEditor, this);
	                adapter.validationRequestsCallbacks.add(function() {
	                    that.validate()
	                });
	                this.option("adapter", adapter);
	                return
	            }
	            throw errors.Error("E0120")
	        }
	        if (adapter.validationRequestsCallbacks) {
	            adapter.validationRequestsCallbacks.add(function() {
	                that.validate()
	            })
	        }
	    },
	    _render: function() {
	        this.element().addClass(VALIDATOR_CLASS);
	        this.callBase()
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._initGroupRegistration()
	        }
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "validationGroup":
	                this._initGroupRegistration();
	                return;
	            case "validationRules":
	                void 0 !== this.option("isValid") && this.validate();
	                return;
	            case "adapter":
	                this._initAdapter();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    validate: function() {
	        var result, that = this,
	            adapter = that.option("adapter"),
	            name = that.option("name"),
	            bypass = adapter.bypass && adapter.bypass(),
	            value = adapter.getValue(),
	            currentError = adapter.getCurrentValidationError && adapter.getCurrentValidationError(),
	            rules = $.map(that.option("validationRules"), function(rule) {
	                rule.validator = that;
	                return rule
	            });
	        if (bypass) {
	            result = {
	                isValid: true
	            }
	        } else {
	            if (currentError && currentError.editorSpecific) {
	                currentError.validator = this;
	                result = {
	                    isValid: false,
	                    brokenRule: currentError
	                }
	            } else {
	                result = ValidationEngine.validate(value, rules, name)
	            }
	        }
	        this._applyValidationResult(result, adapter);
	        return result
	    },
	    reset: function() {
	        var that = this,
	            adapter = that.option("adapter"),
	            result = {
	                isValid: true,
	                brokenRule: null
	            };
	        adapter.reset();
	        this._applyValidationResult(result, adapter)
	    },
	    _applyValidationResult: function(result, adapter) {
	        var validatedAction = this._createActionByOption("onValidated");
	        result.validator = this;
	        adapter.applyValidationResults && adapter.applyValidationResults(result);
	        this.option({
	            isValid: result.isValid
	        });
	        validatedAction(result)
	    },
	    focus: function() {
	        var adapter = this.option("adapter");
	        adapter && adapter.focus && adapter.focus()
	    }
	}).include(ValidationMixin);
	registerComponent("dxValidator", Validator);
	module.exports = Validator;
	module.exports.default = module.exports;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/validation/default_adapter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18);
	var DefaultAdapter = Class.inherit({
	    ctor: function(editor, validator) {
	        var that = this;
	        that.editor = editor;
	        that.validator = validator;
	        that.validationRequestsCallbacks = $.Callbacks();
	        var handler = function() {
	            that.validationRequestsCallbacks.fire()
	        };
	        editor.validationRequest.add(handler);
	        editor.on("disposing", function() {
	            editor.validationRequest.remove(handler)
	        })
	    },
	    getValue: function() {
	        return this.editor.option("value")
	    },
	    getCurrentValidationError: function() {
	        return this.editor.option("validationError")
	    },
	    bypass: function() {
	        return this.editor.option("disabled")
	    },
	    applyValidationResults: function(params) {
	        this.editor.option({
	            isValid: params.isValid,
	            validationError: params.brokenRule
	        })
	    },
	    reset: function() {
	        this.editor.reset()
	    },
	    focus: function() {
	        this.editor.focus()
	    }
	});
	module.exports = DefaultAdapter;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/responsive_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(15),
	    windowUtils = __webpack_require__(29),
	    registerComponent = __webpack_require__(44),
	    Box = __webpack_require__(229),
	    CollectionWidget = __webpack_require__(117);
	var RESPONSIVE_BOX_CLASS = "dx-responsivebox",
	    SCREEN_SIZE_CLASS_PREFIX = RESPONSIVE_BOX_CLASS + "-screen-",
	    BOX_ITEM_CLASS = "dx-box-item",
	    BOX_ITEM_DATA_KEY = "dxBoxItemData";
	var ResponsiveBox = CollectionWidget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            rows: [],
	            cols: [],
	            screenByWidth: null,
	            singleColumnScreen: "",
	            height: "100%",
	            width: "100%",
	            activeStateEnabled: false,
	            focusStateEnabled: false,
	            onLayoutChanged: null,
	            currentScreenFactor: void 0,
	            _layoutStrategy: void 0
	        })
	    },
	    _init: function() {
	        if (!this.option("screenByWidth")) {
	            this._options.screenByWidth = windowUtils.defaultScreenFactorFunc
	        }
	        this.callBase();
	        this._initLayoutChangedAction()
	    },
	    _initLayoutChangedAction: function() {
	        this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
	            excludeValidators: ["disabled", "readonly"]
	        })
	    },
	    _itemClass: function() {
	        return BOX_ITEM_CLASS
	    },
	    _itemDataKey: function() {
	        return BOX_ITEM_DATA_KEY
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(RESPONSIVE_BOX_CLASS);
	        this._updateRootBox()
	    },
	    _updateRootBox: function() {
	        clearTimeout(this._updateTimer);
	        this._updateTimer = setTimeout($.proxy(function() {
	            if (this._$root) {
	                this._$root.triggerHandler("dxupdate")
	            }
	        }, this))
	    },
	    _renderItems: function() {
	        this._setScreenSize();
	        this._screenItems = this._itemsByScreen();
	        this._prepareGrid();
	        this._spreadItems();
	        this._layoutItems();
	        this._linkNodeToItem()
	    },
	    _setScreenSize: function() {
	        var currentScreen = this._getCurrentScreen();
	        this._removeScreenSizeClass();
	        this.element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
	        this.option("currentScreenFactor", currentScreen)
	    },
	    _removeScreenSizeClass: function() {
	        var currentScreenFactor = this.option("currentScreenFactor");
	        currentScreenFactor && this.element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor)
	    },
	    _prepareGrid: function() {
	        var grid = this._grid = [];
	        this._prepareRowsAndCols();
	        $.each(this._rows, $.proxy(function() {
	            var row = [];
	            grid.push(row);
	            $.each(this._cols, $.proxy(function() {
	                row.push(this._createEmptyCell())
	            }, this))
	        }, this))
	    },
	    _prepareRowsAndCols: function() {
	        if (this._isSingleColumnScreen()) {
	            this._prepareSingleColumnScreenItems();
	            this._rows = this._defaultSizeConfig(this._screenItems.length);
	            this._cols = this._defaultSizeConfig(1)
	        } else {
	            this._rows = this._sizesByScreen(this.option("rows"));
	            this._cols = this._sizesByScreen(this.option("cols"))
	        }
	    },
	    _isSingleColumnScreen: function() {
	        return this._screenRegExp().test(this.option("singleColumnScreen")) || !this.option("rows").length || !this.option("cols").length
	    },
	    _prepareSingleColumnScreenItems: function() {
	        this._screenItems.sort(function(item1, item2) {
	            return item1.location.row - item2.location.row || item1.location.col - item2.location.col
	        });
	        $.each(this._screenItems, function(index, item) {
	            $.extend(item.location, {
	                row: index,
	                col: 0,
	                rowspan: 1,
	                colspan: 1
	            })
	        })
	    },
	    _sizesByScreen: function(sizeConfigs) {
	        return $.map(this._filterByScreen(sizeConfigs), $.proxy(function(sizeConfig) {
	            return $.extend(this._defaultSizeConfig(), sizeConfig)
	        }, this))
	    },
	    _defaultSizeConfig: function(size) {
	        var defaultSizeConfig = {
	            ratio: 1,
	            baseSize: 0,
	            minSize: 0,
	            maxSize: 0
	        };
	        if (!arguments.length) {
	            return defaultSizeConfig
	        }
	        var result = [];
	        for (var i = 0; i < size; i++) {
	            result.push(defaultSizeConfig)
	        }
	        return result
	    },
	    _filterByScreen: function(items) {
	        var screenRegExp = this._screenRegExp();
	        return $.grep(items, function(item) {
	            return !item.screen || screenRegExp.test(item.screen)
	        })
	    },
	    _screenRegExp: function() {
	        var screen = this._getCurrentScreen();
	        return new RegExp("(^|\\s)" + screen + "($|\\s)", "i")
	    },
	    _getCurrentScreen: function() {
	        var width = this._screenWidth();
	        return this.option("screenByWidth")(width)
	    },
	    _screenWidth: function() {
	        return $(window).width()
	    },
	    _createEmptyCell: function() {
	        return {
	            item: {},
	            location: {
	                colspan: 1,
	                rowspan: 1
	            }
	        }
	    },
	    _spreadItems: function() {
	        $.each(this._screenItems, $.proxy(function(_, itemInfo) {
	            var location = itemInfo.location || {};
	            var itemCol = location.col;
	            var itemRow = location.row;
	            var row = this._grid[itemRow];
	            var itemCell = row && row[itemCol];
	            this._occupyCells(itemCell, itemInfo)
	        }, this))
	    },
	    _itemsByScreen: function() {
	        return $.map(this.option("items"), $.proxy(function(item) {
	            var locations = item.location || {};
	            locations = $.isPlainObject(locations) ? [locations] : locations;
	            return $.map(this._filterByScreen(locations), function(location) {
	                return {
	                    item: item,
	                    location: $.extend({
	                        rowspan: 1,
	                        colspan: 1
	                    }, location)
	                }
	            })
	        }, this))
	    },
	    _occupyCells: function(itemCell, itemInfo) {
	        if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
	            return
	        }
	        $.extend(itemCell, itemInfo);
	        this._markSpanningCell(itemCell)
	    },
	    _isItemCellOccupied: function(itemCell, itemInfo) {
	        if (!$.isEmptyObject(itemCell.item)) {
	            return true
	        }
	        var result = false;
	        this._loopOverSpanning(itemInfo.location, function(cell) {
	            result = result || !$.isEmptyObject(cell.item)
	        });
	        return result
	    },
	    _loopOverSpanning: function(location, callback) {
	        var rowEnd = location.row + location.rowspan - 1;
	        var colEnd = location.col + location.colspan - 1;
	        var boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
	        var boundColEnd = Math.min(colEnd, this._cols.length - 1);
	        location.rowspan -= rowEnd - boundRowEnd;
	        location.colspan -= colEnd - boundColEnd;
	        for (var rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
	            for (var colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
	                if (rowIndex !== location.row || colIndex !== location.col) {
	                    callback(this._grid[rowIndex][colIndex])
	                }
	            }
	        }
	    },
	    _markSpanningCell: function(itemCell) {
	        this._loopOverSpanning(itemCell.location, function(cell) {
	            $.extend(cell, {
	                item: itemCell.item,
	                spanningCell: itemCell
	            })
	        })
	    },
	    _linkNodeToItem: function() {
	        $.each(this._itemElements(), function(_, itemNode) {
	            var $item = $(itemNode),
	                item = $item.data(BOX_ITEM_DATA_KEY);
	            if (!item.box) {
	                item.node = $item.children()
	            }
	        })
	    },
	    _layoutItems: function() {
	        var rowsCount = this._grid.length;
	        var colsCount = rowsCount && this._grid[0].length;
	        if (!rowsCount && !colsCount) {
	            return
	        }
	        var result = this._layoutBlock({
	            direction: "col",
	            row: {
	                start: 0,
	                end: rowsCount - 1
	            },
	            col: {
	                start: 0,
	                end: colsCount - 1
	            }
	        });
	        var rootBox = this._prepareBoxConfig(result.box || {
	            direction: "row",
	            items: [$.extend(result, {
	                ratio: 1
	            })]
	        });
	        $.extend(rootBox, this._rootBoxConfig());
	        this._$root = $("<div>").appendTo(this._itemContainer());
	        this._createComponent(this._$root, Box, rootBox)
	    },
	    _rootBoxConfig: function() {
	        return $.extend({
	            width: "100%",
	            height: "100%",
	            itemTemplate: this.option("itemTemplate"),
	            itemHoldTimeout: this.option("itemHoldTimeout"),
	            onItemHold: this._createActionByOption("onItemHold"),
	            onItemClick: this._createActionByOption("onItemClick"),
	            onItemContextMenu: this._createActionByOption("onItemContextMenu"),
	            onItemRendered: this._createActionByOption("onItemRendered")
	        }, {
	            _layoutStrategy: this.option("_layoutStrategy")
	        })
	    },
	    _prepareBoxConfig: function(config) {
	        return $.extend(config || {}, {
	            crossAlign: "stretch"
	        })
	    },
	    _layoutBlock: function(options) {
	        if (this._isSingleItem(options)) {
	            return this._itemByCell(options.row.start, options.col.start)
	        }
	        return this._layoutDirection(options)
	    },
	    _isSingleItem: function(options) {
	        var firstCellLocation = this._grid[options.row.start][options.col.start].location;
	        var isItemRowSpanned = options.row.end - options.row.start === firstCellLocation.rowspan - 1;
	        var isItemColSpanned = options.col.end - options.col.start === firstCellLocation.colspan - 1;
	        return isItemRowSpanned && isItemColSpanned
	    },
	    _itemByCell: function(rowIndex, colIndex) {
	        var itemCell = this._grid[rowIndex][colIndex];
	        return itemCell.spanningCell ? null : itemCell.item
	    },
	    _layoutDirection: function(options) {
	        var items = [];
	        var direction = options.direction;
	        var crossDirection = this._crossDirection(direction);
	        var block;
	        while (block = this._nextBlock(options)) {
	            if (this._isBlockIndivisible(options.prevBlockOptions, block)) {
	                throw errors.Error("E1025")
	            }
	            var item = this._layoutBlock({
	                direction: crossDirection,
	                row: block.row,
	                col: block.col,
	                prevBlockOptions: options
	            });
	            if (item) {
	                $.extend(item, this._blockSize(block, crossDirection));
	                items.push(item)
	            }
	            options[crossDirection].start = block[crossDirection].end + 1
	        }
	        return {
	            box: this._prepareBoxConfig({
	                direction: direction,
	                items: items
	            })
	        }
	    },
	    _isBlockIndivisible: function(options, block) {
	        return options && options.col.start === block.col.start && options.col.end === block.col.end && options.row.start === block.row.start && options.row.end === block.row.end
	    },
	    _crossDirection: function(direction) {
	        return "col" === direction ? "row" : "col"
	    },
	    _nextBlock: function(options) {
	        var direction = options.direction;
	        var crossDirection = this._crossDirection(direction);
	        var startIndex = options[direction].start;
	        var endIndex = options[direction].end;
	        var crossStartIndex = options[crossDirection].start;
	        if (crossStartIndex > options[crossDirection].end) {
	            return null
	        }
	        var crossSpan = 1;
	        for (var crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
	            var lineCrossSpan = 1;
	            for (var index = startIndex; index <= endIndex; index++) {
	                var cell = this._cellByDirection(direction, index, crossIndex);
	                lineCrossSpan = Math.max(lineCrossSpan, cell.location[crossDirection + "span"])
	            }
	            var lineCrossEndIndex = crossIndex + lineCrossSpan;
	            var crossEndIndex = crossStartIndex + crossSpan;
	            if (lineCrossEndIndex > crossEndIndex) {
	                crossSpan += lineCrossEndIndex - crossEndIndex
	            }
	        }
	        var result = {};
	        result[direction] = {
	            start: startIndex,
	            end: endIndex
	        };
	        result[crossDirection] = {
	            start: crossStartIndex,
	            end: crossStartIndex + crossSpan - 1
	        };
	        return result
	    },
	    _cellByDirection: function(direction, index, crossIndex) {
	        return "col" === direction ? this._grid[crossIndex][index] : this._grid[index][crossIndex]
	    },
	    _blockSize: function(block, direction) {
	        var sizeConfigs = "row" === direction ? this._rows : this._cols;
	        var result = {
	            ratio: 0,
	            baseSize: 0,
	            minSize: 0,
	            maxSize: 0
	        };
	        for (var index = block[direction].start; index <= block[direction].end; index++) {
	            var sizeConfig = sizeConfigs[index];
	            result.ratio += sizeConfig.ratio;
	            result.baseSize += sizeConfig.baseSize;
	            result.minSize += sizeConfig.minSize;
	            result.maxSize += sizeConfig.maxSize
	        }
	        result.minSize = result.minSize ? result.minSize : "auto";
	        result.maxSize = result.maxSize ? result.maxSize : "auto";
	        this._isSingleColumnScreen() && (result.baseSize = "auto");
	        return result
	    },
	    _update: function() {
	        var $existingRoot = this._$root;
	        this._renderItems();
	        $existingRoot && $existingRoot.detach();
	        this._saveAssistantRoot($existingRoot);
	        this._layoutChangedAction();
	        this._updateRootBox()
	    },
	    _saveAssistantRoot: function($root) {
	        this._assistantRoots = this._assistantRoots || [];
	        this._assistantRoots.push($root)
	    },
	    _dispose: function() {
	        clearTimeout(this._updateTimer);
	        this._cleanUnusedRoots();
	        this.callBase.apply(this, arguments)
	    },
	    _cleanUnusedRoots: function() {
	        if (!this._assistantRoots) {
	            return
	        }
	        $.each(this._assistantRoots, function() {
	            $(this).remove()
	        })
	    },
	    _clearItemNodeTemplates: function() {
	        $.each(this.option("items"), function() {
	            delete this.node
	        })
	    },
	    _toggleVisibility: function(visible) {
	        this.callBase(visible);
	        if (visible) {
	            this._updateRootBox()
	        }
	    },
	    _attachClickEvent: $.noop,
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "rows":
	            case "cols":
	            case "screenByWidth":
	            case "_layoutStrategy":
	            case "singleColumnScreen":
	                this._clearItemNodeTemplates();
	                this._invalidate();
	                break;
	            case "width":
	            case "height":
	                this.callBase(args);
	                this._update();
	                break;
	            case "onLayoutChanged":
	                this._initLayoutChangedAction();
	                break;
	            case "itemTemplate":
	                this._clearItemNodeTemplates();
	                this.callBase(args);
	                break;
	            case "currentScreenFactor":
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _dimensionChanged: function() {
	        if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
	            this._update()
	        }
	    },
	    repaint: function() {
	        this._update()
	    }
	});
	registerComponent("dxResponsiveBox", ResponsiveBox);
	module.exports = ResponsiveBox;
	module.exports.default = module.exports;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    support = __webpack_require__(48),
	    browser = __webpack_require__(16),
	    devices = __webpack_require__(40),
	    CollectionWidget = __webpack_require__(117);
	var BOX_CLASS = "dx-box",
	    BOX_SELECTOR = ".dx-box",
	    BOX_ITEM_CLASS = "dx-box-item",
	    BOX_ITEM_DATA_KEY = "dxBoxItemData";
	var flexGrowProp = support.styleProp("flexGrow");
	var flexShrinkProp = support.styleProp("flexShrink");
	var flexPropPrefix = support.stylePropPrefix("flexDirection");
	var MINSIZE_MAP = {
	    row: "minWidth",
	    col: "minHeight"
	};
	var MAXSIZE_MAP = {
	    row: "maxWidth",
	    col: "maxHeight"
	};
	var SHRINK = 1;
	var FLEX_JUSTIFY_CONTENT_MAP = {
	    start: "flex-start",
	    end: "flex-end",
	    center: "center",
	    "space-between": "space-between",
	    "space-around": "space-around"
	};
	var FLEX_ALIGN_ITEMS_MAP = {
	    start: "flex-start",
	    end: "flex-end",
	    center: "center",
	    stretch: "stretch"
	};
	var FLEX_DIRECTION_MAP = {
	    row: "row",
	    col: "column"
	};
	var FlexLayoutStrategy = Class.inherit({
	    ctor: function($element, option) {
	        this._$element = $element;
	        this._option = option
	    },
	    renderBox: function() {
	        this._$element.css({
	            display: support.stylePropPrefix("flexDirection") + "flex",
	            flexDirection: FLEX_DIRECTION_MAP[this._option("direction")]
	        })
	    },
	    renderAlign: function() {
	        this._$element.css({
	            justifyContent: this._normalizedAlign()
	        })
	    },
	    _normalizedAlign: function() {
	        var align = this._option("align");
	        return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align
	    },
	    renderCrossAlign: function() {
	        this._$element.css({
	            alignItems: this._normalizedCrossAlign()
	        })
	    },
	    _normalizedCrossAlign: function() {
	        var crossAlign = this._option("crossAlign");
	        return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign
	    },
	    renderItems: function($items) {
	        var direction = this._option("direction");
	        $.each($items, function() {
	            var $item = $(this);
	            var item = $item.data(BOX_ITEM_DATA_KEY);
	            $item.css({
	                display: flexPropPrefix + "flex",
	                flexBasis: item.baseSize || 0
	            }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
	            var itemStyle = $item.get(0).style;
	            itemStyle[flexGrowProp] = item.ratio;
	            itemStyle[flexShrinkProp] = commonUtils.isDefined(item.shrink) ? item.shrink : SHRINK;
	            $item.children().each(function(_, itemContent) {
	                $(itemContent).css({
	                    width: "auto",
	                    height: "auto",
	                    display: support.stylePropPrefix("flexDirection") + "flex",
	                    flexDirection: $item.children().css("flexDirection") || "column"
	                });
	                itemContent.style[flexGrowProp] = 1
	            })
	        })
	    },
	    initSize: $.noop,
	    update: $.noop
	});
	var BOX_EVENTNAMESPACE = "dxBox",
	    UPDATE_EVENT = "dxupdate." + BOX_EVENTNAMESPACE,
	    FALLBACK_BOX_ITEM = "dx-box-fallback-item";
	var FALLBACK_WRAP_MAP = {
	    row: "nowrap",
	    col: "normal"
	};
	var FALLBACK_MAIN_SIZE_MAP = {
	    row: "width",
	    col: "height"
	};
	var FALLBACK_CROSS_SIZE_MAP = {
	    row: "height",
	    col: "width"
	};
	var FALLBACK_PRE_MARGIN_MAP = {
	    row: "marginLeft",
	    col: "marginTop"
	};
	var FALLBACK_POST_MARGIN_MAP = {
	    row: "marginRight",
	    col: "marginBottom"
	};
	var FALLBACK_CROSS_PRE_MARGIN_MAP = {
	    row: "marginTop",
	    col: "marginLeft"
	};
	var FALLBACK_CROSS_POST_MARGIN_MAP = {
	    row: "marginBottom",
	    col: "marginRight"
	};
	var MARGINS_RTL_FLIP_MAP = {
	    marginLeft: "marginRight",
	    marginRight: "marginLeft"
	};
	var FallbackLayoutStrategy = Class.inherit({
	    ctor: function($element, option) {
	        this._$element = $element;
	        this._option = option
	    },
	    renderBox: function() {
	        this._$element.css({
	            fontSize: 0,
	            whiteSpace: FALLBACK_WRAP_MAP[this._option("direction")],
	            verticalAlign: "top"
	        });
	        this._$element.off(UPDATE_EVENT).on(UPDATE_EVENT, $.proxy(this.update, this))
	    },
	    renderAlign: function() {
	        var $items = this._$items;
	        if (!$items) {
	            return
	        }
	        var align = this._option("align"),
	            shift = 0,
	            totalItemSize = this.totalItemSize,
	            direction = this._option("direction"),
	            boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]](),
	            freeSpace = boxSize - totalItemSize;
	        this._setItemsMargins($items, direction, 0);
	        switch (align) {
	            case "start":
	                break;
	            case "end":
	                shift = freeSpace;
	                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
	                break;
	            case "center":
	                shift = .5 * freeSpace;
	                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
	                $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);
	                break;
	            case "space-between":
	                shift = .5 * freeSpace / ($items.length - 1);
	                this._setItemsMargins($items, direction, shift);
	                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), 0);
	                $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), 0);
	                break;
	            case "space-around":
	                shift = .5 * freeSpace / $items.length;
	                this._setItemsMargins($items, direction, shift)
	        }
	    },
	    _setItemsMargins: function($items, direction, shift) {
	        $items.css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift).css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift)
	    },
	    renderCrossAlign: function() {
	        var $items = this._$items;
	        if (!$items) {
	            return
	        }
	        var crossAlign = this._option("crossAlign"),
	            direction = this._option("direction"),
	            size = this._$element[FALLBACK_CROSS_SIZE_MAP[direction]]();
	        var that = this;
	        switch (crossAlign) {
	            case "start":
	                break;
	            case "end":
	                $.each($items, function() {
	                    var $item = $(this),
	                        itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
	                        shift = size - itemSize;
	                    $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift)
	                });
	                break;
	            case "center":
	                $.each($items, function() {
	                    var $item = $(this),
	                        itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
	                        shift = .5 * (size - itemSize);
	                    $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), shift)
	                });
	                break;
	            case "stretch":
	                $items.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), 0).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), 0).css(FALLBACK_CROSS_SIZE_MAP[direction], "100%")
	        }
	    },
	    _chooseMarginSide: function(value) {
	        if (!this._option("rtlEnabled")) {
	            return value
	        }
	        return MARGINS_RTL_FLIP_MAP[value] || value
	    },
	    renderItems: function($items) {
	        this._$items = $items;
	        var direction = this._option("direction"),
	            totalRatio = 0,
	            totalWeightedShrink = 0,
	            totalBaseSize = 0;
	        $.each($items, $.proxy(function(_, item) {
	            var $item = $(item);
	            $item.css({
	                display: "inline-block",
	                verticalAlign: "top"
	            });
	            $item[FALLBACK_MAIN_SIZE_MAP[direction]]("auto");
	            $item.removeClass(FALLBACK_BOX_ITEM);
	            var itemData = $item.data(BOX_ITEM_DATA_KEY),
	                ratio = itemData.ratio || 0,
	                size = this._baseSize($item),
	                shrink = commonUtils.isDefined(itemData.shrink) ? itemData.shrink : SHRINK;
	            totalRatio += ratio;
	            totalWeightedShrink += shrink * size;
	            totalBaseSize += size
	        }, this));
	        var freeSpaceSize = this._boxSize() - totalBaseSize;
	        var itemSize = $.proxy(function($item) {
	            var itemData = $item.data(BOX_ITEM_DATA_KEY),
	                size = this._baseSize($item),
	                factor = freeSpaceSize >= 0 ? itemData.ratio || 0 : (commonUtils.isDefined(itemData.shrink) ? itemData.shrink : SHRINK) * size,
	                totalFactor = freeSpaceSize >= 0 ? totalRatio : totalWeightedShrink,
	                shift = totalFactor ? Math.round(freeSpaceSize * factor / totalFactor) : 0;
	            return size + shift
	        }, this);
	        var totalItemSize = 0;
	        $.each($items, function(_, item) {
	            var $item = $(item),
	                itemData = $(item).data(BOX_ITEM_DATA_KEY),
	                size = itemSize($item);
	            totalItemSize += size;
	            $item.css(MAXSIZE_MAP[direction], itemData.maxSize || "none").css(MINSIZE_MAP[direction], itemData.minSize || "0").css(FALLBACK_MAIN_SIZE_MAP[direction], size);
	            $item.addClass(FALLBACK_BOX_ITEM)
	        });
	        this.totalItemSize = totalItemSize
	    },
	    _baseSize: function(item) {
	        var itemData = $(item).data(BOX_ITEM_DATA_KEY);
	        return null == itemData.baseSize ? 0 : "auto" === itemData.baseSize ? this._contentSize(item) : this._parseSize(itemData.baseSize)
	    },
	    _contentSize: function(item) {
	        return $(item)[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]()
	    },
	    _parseSize: function(size) {
	        return String(size).match(/.+%$/) ? .01 * parseFloat(size) * this._boxSizeValue : size
	    },
	    _boxSize: function(value) {
	        if (!arguments.length) {
	            this._boxSizeValue = this._boxSizeValue || this._totalBaseSize();
	            return this._boxSizeValue
	        }
	        this._boxSizeValue = value
	    },
	    _totalBaseSize: function() {
	        var result = 0;
	        $.each(this._$items, $.proxy(function(_, item) {
	            result += this._baseSize(item)
	        }, this));
	        return result
	    },
	    initSize: function() {
	        this._boxSize(this._$element[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]())
	    },
	    update: function() {
	        if (!this._$items || this._$element.is(":hidden")) {
	            return
	        }
	        this._$items.detach();
	        this.initSize();
	        this._$element.append(this._$items);
	        this.renderItems(this._$items);
	        this.renderAlign();
	        this.renderCrossAlign();
	        var element = this._$element.get(0);
	        this._$items.find(BOX_SELECTOR).each(function() {
	            if (element === $(this).parent().closest(BOX_SELECTOR).get(0)) {
	                $(this).triggerHandler(UPDATE_EVENT)
	            }
	        })
	    }
	});
	var Box = CollectionWidget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            direction: "row",
	            align: "start",
	            crossAlign: "stretch",
	            activeStateEnabled: false,
	            focusStateEnabled: false,
	            _layoutStrategy: "flex",
	            _queue: void 0
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                var device = devices.real();
	                var isOldAndroid = "android" === device.platform && (device.version[0] < 4 || 4 === device.version[0] && device.version[1] < 4),
	                    isOldIos = "ios" === device.platform && device.version[0] < 7;
	                return "win" === device.platform || browser.msie || isOldAndroid || isOldIos
	            },
	            options: {
	                _layoutStrategy: "fallback"
	            }
	        }])
	    },
	    _itemClass: function() {
	        return BOX_ITEM_CLASS
	    },
	    _itemDataKey: function() {
	        return BOX_ITEM_DATA_KEY
	    },
	    _itemElements: function() {
	        return this._itemContainer().children(this._itemSelector())
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(BOX_CLASS + "-" + this.option("_layoutStrategy"));
	        this._initLayout();
	        this._initBoxQueue()
	    },
	    _initLayout: function() {
	        this._layout = "fallback" === this.option("_layoutStrategy") ? new FallbackLayoutStrategy(this.element(), $.proxy(this.option, this)) : new FlexLayoutStrategy(this.element(), $.proxy(this.option, this))
	    },
	    _initBoxQueue: function() {
	        this._queue = this.option("_queue") || []
	    },
	    _queueIsNotEmpty: function() {
	        return this.option("_queue") ? false : !!this._queue.length
	    },
	    _pushItemToQueue: function($item, config) {
	        this._queue.push({
	            $item: $item,
	            config: config
	        })
	    },
	    _shiftItemFromQueue: function() {
	        return this._queue.shift()
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(BOX_CLASS);
	        this._renderBox()
	    },
	    _renderBox: function() {
	        this._layout.renderBox();
	        this._layout.renderAlign();
	        this._layout.renderCrossAlign()
	    },
	    _renderItems: function(items) {
	        this._layout.initSize();
	        this.callBase(items);
	        while (this._queueIsNotEmpty()) {
	            var item = this._shiftItemFromQueue();
	            this._createComponent(item.$item, Box, $.extend({
	                _layoutStrategy: this.option("_layoutStrategy"),
	                itemTemplate: this.option("itemTemplate"),
	                itemHoldTimeout: this.option("itemHoldTimeout"),
	                onItemHold: this.option("onItemHold"),
	                onItemClick: this.option("onItemClick"),
	                onItemContextMenu: this.option("onItemContextMenu"),
	                onItemRendered: this.option("onItemRendered"),
	                _queue: this._queue
	            }, item.config))
	        }
	        this._layout.renderItems(this._itemElements());
	        clearTimeout(this._updateTimer);
	        this._updateTimer = setTimeout($.proxy(function() {
	            if (!this._isUpdated) {
	                this._layout.update()
	            }
	            this._isUpdated = false;
	            this._updateTimer = null
	        }, this))
	    },
	    _renderItemContent: function(args) {
	        var $itemNode = args.itemData && args.itemData.node;
	        if ($itemNode) {
	            return this._renderItemContentByNode(args, $itemNode)
	        }
	        return this.callBase(args)
	    },
	    _postprocessRenderItem: function(args) {
	        var boxConfig = args.itemData.box;
	        if (!boxConfig) {
	            return
	        }
	        this._pushItemToQueue(args.itemContent, boxConfig)
	    },
	    _createItemByTemplate: function(itemTemplate, args) {
	        if (args.itemData.box) {
	            return itemTemplate.source ? itemTemplate.source() : $()
	        }
	        return this.callBase(itemTemplate, args)
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._dimensionChanged()
	        }
	    },
	    _dimensionChanged: function() {
	        if (this._updateTimer) {
	            return
	        }
	        this._isUpdated = true;
	        this._layout.update()
	    },
	    _dispose: function() {
	        clearTimeout(this._updateTimer);
	        this.callBase.apply(this, arguments)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "_layoutStrategy":
	            case "_queue":
	            case "direction":
	                this._invalidate();
	                break;
	            case "align":
	                this._layout.renderAlign();
	                break;
	            case "crossAlign":
	                this._layout.renderCrossAlign();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    repaint: function() {
	        this._dimensionChanged()
	    }
	});
	registerComponent("dxBox", Box);
	module.exports = Box;
	module.exports.default = module.exports;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/text_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(231);
	module.exports.default = module.exports;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/text_box/text_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    TextEditor = __webpack_require__(232),
	    eventUtils = __webpack_require__(61);
	var ua = window.navigator.userAgent,
	    ignoreCode = [8, 9, 13, 33, 34, 35, 36, 37, 38, 39, 40, 46],
	    TEXTBOX_CLASS = "dx-textbox",
	    SEARCHBOX_CLASS = "dx-searchbox",
	    ICON_CLASS = "dx-icon",
	    SEARCH_ICON_CLASS = "dx-icon-search";
	var TextBox = TextEditor.inherit({
	    ctor: function(element, options) {
	        if (options) {
	            this._showClearButton = options.showClearButton
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            mode: "text",
	            maxLength: null
	        })
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(TEXTBOX_CLASS);
	        this.setAria("role", "textbox");
	        this._renderMaxLengthHandlers()
	    },
	    _renderInputType: function() {
	        this.callBase();
	        this._renderSearchMode()
	    },
	    _renderMaxLengthHandlers: function() {
	        if (this._isAndroid()) {
	            this._input().on(eventUtils.addNamespace("keydown", this.NAME), $.proxy(this._onKeyDownAndroidHandler, this)).on(eventUtils.addNamespace("change", this.NAME), $.proxy(this._onChangeAndroidHandler, this))
	        }
	    },
	    _renderProps: function() {
	        this.callBase();
	        this._toggleMaxLengthProp()
	    },
	    _toggleMaxLengthProp: function() {
	        if (this._isAndroid()) {
	            return
	        }
	        var maxLength = this.option("maxLength");
	        if (maxLength > 0) {
	            this._input().attr("maxLength", maxLength)
	        } else {
	            this._input().removeAttr("maxLength")
	        }
	    },
	    _renderSearchMode: function() {
	        var $element = this._$element;
	        if ("search" === this.option("mode")) {
	            $element.addClass(SEARCHBOX_CLASS);
	            this._renderSearchIcon();
	            if (void 0 === this._showClearButton) {
	                this._showClearButton = this.option("showClearButton");
	                this.option("showClearButton", true)
	            }
	        } else {
	            $element.removeClass(SEARCHBOX_CLASS);
	            this._$searchIcon && this._$searchIcon.remove();
	            this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
	            delete this._showClearButton
	        }
	    },
	    _renderSearchIcon: function() {
	        var $searchIcon = $("<div>").addClass(ICON_CLASS).addClass(SEARCH_ICON_CLASS);
	        $searchIcon.prependTo(this._input().parent());
	        this._$searchIcon = $searchIcon
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "maxLength":
	                this._toggleMaxLengthProp();
	                this._renderMaxLengthHandlers();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _onKeyDownAndroidHandler: function(e) {
	        var maxLength = this.option("maxLength");
	        if (maxLength) {
	            var $input = $(e.target),
	                code = e.keyCode;
	            this._cutOffExtraChar($input);
	            return $input.val().length < maxLength || $.inArray(code, ignoreCode) !== -1 || "" !== window.getSelection().toString()
	        } else {
	            return true
	        }
	    },
	    _onChangeAndroidHandler: function(e) {
	        var $input = $(e.target);
	        if (this.option("maxLength")) {
	            this._cutOffExtraChar($input)
	        }
	    },
	    _cutOffExtraChar: function($input) {
	        var maxLength = this.option("maxLength"),
	            textInput = $input.val();
	        if (textInput.length > maxLength) {
	            $input.val(textInput.substr(0, maxLength))
	        }
	    },
	    _isAndroid: function() {
	        var realDevice = devices.real();
	        var version = realDevice.version.join(".");
	        return "android" === realDevice.platform && version && /^(2\.|4\.1)/.test(version) && !/chrome/i.test(ua)
	    }
	});
	registerComponent("dxTextBox", TextBox);
	module.exports = TextBox;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/text_box/ui.text_editor.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var registerComponent = __webpack_require__(44),
	    TextEditorMask = __webpack_require__(233);
	registerComponent("dxTextEditor", TextEditorMask);
	module.exports = TextEditorMask;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/text_box/ui.text_editor.mask.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    caret = __webpack_require__(234),
	    domUtils = __webpack_require__(43),
	    commonUtils = __webpack_require__(8),
	    messageLocalization = __webpack_require__(79),
	    TextEditorBase = __webpack_require__(235),
	    MaskRules = __webpack_require__(236),
	    eventUtils = __webpack_require__(61);
	var stubCaret = function() {
	    return {}
	};
	var EMPTY_CHAR = " ";
	var EMPTY_CHAR_CODE = 32;
	var ESCAPED_CHAR = "\\";
	var TEXTEDITOR_MASKED_CLASS = "dx-texteditor-masked";
	var MASK_EVENT_NAMESPACE = "dxMask";
	var FORWARD_DIRECTION = "forward";
	var BACKWARD_DIRECTION = "backward";
	var buildInMaskRules = {
	    0: /[0-9]/,
	    9: /[0-9\s]/,
	    "#": /[-+0-9\s]/,
	    L: function(char) {
	        return isLiteralChar(char)
	    },
	    l: function(char) {
	        return isLiteralChar(char) || isSpaceChar(char)
	    },
	    C: /\S/,
	    c: /./,
	    A: function(char) {
	        return isLiteralChar(char) || isNumericChar(char)
	    },
	    a: function(char) {
	        return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
	    }
	};
	var isNumericChar = function(char) {
	    return /[0-9]/.test(char)
	};
	var isLiteralChar = function(char) {
	    var code = char.charCodeAt();
	    return 64 < code && code < 91 || 96 < code && code < 123 || code > 127
	};
	var isSpaceChar = function(char) {
	    return " " === char
	};
	var TextEditorMask = TextEditorBase.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            mask: "",
	            maskChar: "_",
	            maskRules: {},
	            maskInvalidMessage: messageLocalization.format("validation-mask"),
	            useMaskedValue: false
	        })
	    },
	    _supportedKeys: function() {
	        var that = this;
	        var keyHandlerMap = {
	            backspace: that._maskBackspaceHandler,
	            del: that._maskDelHandler,
	            enter: that._changeHandler
	        };
	        var result = that.callBase();
	        $.each(keyHandlerMap, function(key, callback) {
	            var parentHandler = result[key];
	            result[key] = function(e) {
	                that.option("mask") && callback.call(that, e);
	                parentHandler && parentHandler(e)
	            }
	        });
	        return result
	    },
	    _render: function() {
	        this.callBase();
	        this._renderMask()
	    },
	    _renderMask: function() {
	        this.element().removeClass(TEXTEDITOR_MASKED_CLASS);
	        this._maskRulesChain = null;
	        this._detachMaskEventHandlers();
	        if (!this.option("mask")) {
	            return
	        }
	        this.element().addClass(TEXTEDITOR_MASKED_CLASS);
	        this._attachMaskEventHandlers();
	        this._parseMask();
	        this._renderMaskedValue();
	        this._changedValue = this._input().val()
	    },
	    _attachMaskEventHandlers: function() {
	        this._input().on(eventUtils.addNamespace("focus", MASK_EVENT_NAMESPACE), $.proxy(this._maskFocusHandler, this)).on(eventUtils.addNamespace("keydown", MASK_EVENT_NAMESPACE), $.proxy(this._maskKeyDownHandler, this)).on(eventUtils.addNamespace("keypress", MASK_EVENT_NAMESPACE), $.proxy(this._maskKeyPressHandler, this)).on(eventUtils.addNamespace("input", MASK_EVENT_NAMESPACE), $.proxy(this._maskInputHandler, this)).on(eventUtils.addNamespace("paste", MASK_EVENT_NAMESPACE), $.proxy(this._maskPasteHandler, this)).on(eventUtils.addNamespace("cut", MASK_EVENT_NAMESPACE), $.proxy(this._maskCutHandler, this)).on(eventUtils.addNamespace("drop", MASK_EVENT_NAMESPACE), $.proxy(this._maskDragHandler, this));
	        this._attachChangeEventHandlers()
	    },
	    _detachMaskEventHandlers: function() {
	        this._input().off("." + MASK_EVENT_NAMESPACE)
	    },
	    _attachChangeEventHandlers: function() {
	        if ($.inArray("change", this.option("valueChangeEvent").split(" ")) === -1) {
	            return
	        }
	        this._input().on(eventUtils.addNamespace("blur", MASK_EVENT_NAMESPACE), $.proxy(function(e) {
	            this._suppressCaretChanging(this._changeHandler, [e]);
	            this._changeHandler(e)
	        }, this))
	    },
	    _suppressCaretChanging: function(callback, args) {
	        var originalCaret = caret;
	        caret = stubCaret;
	        try {
	            callback.apply(this, args)
	        } finally {
	            caret = originalCaret
	        }
	    },
	    _changeHandler: function(e) {
	        var $input = this._input(),
	            inputValue = $input.val();
	        if (inputValue === this._changedValue) {
	            return
	        }
	        this._changedValue = inputValue;
	        var changeEvent = eventUtils.createEvent(e, {
	            type: "change"
	        });
	        $input.trigger(changeEvent)
	    },
	    _parseMask: function() {
	        this._maskRules = $.extend({}, buildInMaskRules, this.option("maskRules"));
	        this._maskRulesChain = this._parseMaskRule(0)
	    },
	    _parseMaskRule: function(index) {
	        var mask = this.option("mask");
	        if (index >= mask.length) {
	            return new MaskRules.EmptyMaskRule
	        }
	        var currentMaskChar = mask[index];
	        var isEscapedChar = currentMaskChar === ESCAPED_CHAR;
	        var result = isEscapedChar ? new MaskRules.StubMaskRule({
	            maskChar: mask[index + 1]
	        }) : this._getMaskRule(currentMaskChar);
	        result.next(this._parseMaskRule(index + 1 + isEscapedChar));
	        return result
	    },
	    _getMaskRule: function(pattern) {
	        var ruleConfig;
	        $.each(this._maskRules, function(rulePattern, allowedChars) {
	            if (rulePattern === pattern) {
	                ruleConfig = {
	                    pattern: rulePattern,
	                    allowedChars: allowedChars
	                };
	                return false
	            }
	        });
	        return commonUtils.isDefined(ruleConfig) ? new MaskRules.MaskRule($.extend({
	            maskChar: this.option("maskChar")
	        }, ruleConfig)) : new MaskRules.StubMaskRule({
	            maskChar: pattern
	        })
	    },
	    _renderMaskedValue: function() {
	        if (!this._maskRulesChain) {
	            return
	        }
	        var value = this.option("value") || "";
	        this._maskRulesChain.clear(this._normalizeChainArguments());
	        var chainArgs = {
	            length: value.length
	        };
	        chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value;
	        this._handleChain(chainArgs);
	        this._displayMask()
	    },
	    _isMaskedValueMode: function() {
	        return this.option("useMaskedValue")
	    },
	    _displayMask: function(caret) {
	        caret = caret || this._caret();
	        this._renderValue();
	        this._caret(caret)
	    },
	    _renderValue: function() {
	        if (this._maskRulesChain) {
	            this.option("text", this._maskRulesChain.text())
	        }
	        this.callBase()
	    },
	    _valueChangeEventHandler: function(e) {
	        if (!this._maskRulesChain) {
	            this.callBase.apply(this, arguments);
	            return
	        }
	        this._saveValueChangeEvent(e);
	        var value = this._isMaskedValueMode() ? (this._textValue || "").replace(new RegExp("[" + this.option("maskChar") + "]", "g"), " ").replace(/\s+$/, "") : (this._value || "").replace(/\s+$/, "");
	        this.option("value", value)
	    },
	    _maskFocusHandler: function() {
	        this._direction(FORWARD_DIRECTION);
	        this._adjustCaret()
	    },
	    _maskKeyDownHandler: function() {
	        this._keyPressHandled = false
	    },
	    _maskKeyPressHandler: function(e) {
	        if (this._keyPressHandled) {
	            return
	        }
	        this._keyPressHandled = true;
	        if (this._isControlKeyFired(e)) {
	            return
	        }
	        this._maskKeyHandler(e, function() {
	            this._handleKey(e.which);
	            return true
	        })
	    },
	    _maskInputHandler: function(e) {
	        if (this._keyPressHandled) {
	            return
	        }
	        this._keyPressHandled = true;
	        var inputValue = this._input().val();
	        var caret = this._caret();
	        caret.start = caret.end - 1;
	        var oldValue = inputValue.substring(0, caret.start) + inputValue.substring(caret.end);
	        var char = inputValue[caret.start];
	        this._input().val(oldValue);
	        this._inputHandlerTimer = setTimeout($.proxy(function() {
	            this._caret({
	                start: caret.start,
	                end: caret.start
	            });
	            this._maskKeyHandler(e, function() {
	                this._handleKey(char.charCodeAt());
	                return true
	            })
	        }, this))
	    },
	    _isControlKeyFired: function(e) {
	        return this._isControlKey(e.keyCode) && !e.which || e.metaKey
	    },
	    _maskBackspaceHandler: function(e) {
	        var that = this;
	        that._keyPressHandled = true;
	        var afterBackspaceHandler = function(needAdjustCaret, callBack) {
	            if (needAdjustCaret) {
	                that._direction(FORWARD_DIRECTION);
	                that._adjustCaret()
	            }
	            var currentCaret = that._caret();
	            clearTimeout(that._backspaceHandlerTimeout);
	            that._backspaceHandlerTimeout = setTimeout(function() {
	                callBack(currentCaret)
	            })
	        };
	        that._maskKeyHandler(e, function() {
	            if (that._hasSelection()) {
	                afterBackspaceHandler(true, function(currentCaret) {
	                    that._displayMask(currentCaret);
	                    that._maskRulesChain.reset()
	                });
	                return
	            }
	            if (that._tryMoveCaretBackward()) {
	                afterBackspaceHandler(false, function(currentCaret) {
	                    that._caret(currentCaret)
	                });
	                return
	            }
	            that._handleKey(EMPTY_CHAR_CODE, BACKWARD_DIRECTION);
	            afterBackspaceHandler(true, function(currentCaret) {
	                that._displayMask(currentCaret);
	                that._maskRulesChain.reset()
	            })
	        })
	    },
	    _maskDelHandler: function(e) {
	        this._keyPressHandled = true;
	        this._maskKeyHandler(e, function() {
	            !this._hasSelection() && this._handleKey(EMPTY_CHAR_CODE);
	            return true
	        })
	    },
	    _maskPasteHandler: function(e) {
	        this._keyPressHandled = true;
	        var caret = this._caret();
	        this._maskKeyHandler(e, function() {
	            var pastingText = domUtils.clipboardText(e);
	            var restText = this._maskRulesChain.text().substring(caret.end);
	            var accepted = this._handleChain({
	                text: pastingText,
	                start: caret.start,
	                length: pastingText.length
	            });
	            var newCaret = caret.start + accepted;
	            this._handleChain({
	                text: restText,
	                start: newCaret,
	                length: restText.length
	            });
	            this._caret({
	                start: newCaret,
	                end: newCaret
	            });
	            return true
	        })
	    },
	    _handleChain: function(args) {
	        var handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
	        this._value = this._maskRulesChain.value();
	        this._textValue = this._maskRulesChain.text();
	        return handledCount
	    },
	    _normalizeChainArguments: function(args) {
	        args = args || {};
	        args.index = 0;
	        args.fullText = this._maskRulesChain.text();
	        return args
	    },
	    _maskCutHandler: function(e) {
	        var caret = this._caret();
	        var selectedText = this._input().val().substring(caret.start, caret.end);
	        this._maskKeyHandler(e, function() {
	            domUtils.clipboardText(e, selectedText);
	            return true
	        })
	    },
	    _maskDragHandler: function() {
	        this._clearDragTimer();
	        this._dragTimer = setTimeout($.proxy(function() {
	            this.option("value", this._convertToValue(this._input().val()))
	        }, this))
	    },
	    _convertToValue: function(text) {
	        return text.replace(new RegExp(this.option("maskChar"), "g"), EMPTY_CHAR)
	    },
	    _maskKeyHandler: function(e, tryHandleKeyCallback) {
	        if (this.option("readOnly")) {
	            return
	        }
	        this._direction(FORWARD_DIRECTION);
	        e.preventDefault();
	        this._handleSelection();
	        if (!tryHandleKeyCallback.call(this)) {
	            return
	        }
	        this._direction(FORWARD_DIRECTION);
	        this._adjustCaret();
	        this._displayMask();
	        this._maskRulesChain.reset()
	    },
	    _handleKey: function(keyCode, direction) {
	        var char = String.fromCharCode(keyCode);
	        this._direction(direction || FORWARD_DIRECTION);
	        this._adjustCaret(char);
	        this._handleKeyChain(char);
	        this._moveCaret()
	    },
	    _handleSelection: function() {
	        if (!this._hasSelection()) {
	            return
	        }
	        var caret = this._caret();
	        var emptyChars = new Array(caret.end - caret.start + 1).join(EMPTY_CHAR);
	        this._handleKeyChain(emptyChars)
	    },
	    _handleKeyChain: function(chars) {
	        var caret = this._caret();
	        var start = this._isForwardDirection() ? caret.start : caret.start - 1;
	        var end = this._isForwardDirection() ? caret.end : caret.end - 1;
	        var length = start === end ? 1 : end - start;
	        this._handleChain({
	            text: chars,
	            start: start,
	            length: length
	        })
	    },
	    _tryMoveCaretBackward: function() {
	        this._direction(BACKWARD_DIRECTION);
	        var currentCaret = this._caret().start;
	        this._adjustCaret();
	        return !currentCaret || currentCaret !== this._caret().start
	    },
	    _adjustCaret: function(char) {
	        var caret = this._maskRulesChain.adjustedCaret(this._caret().start, this._isForwardDirection(), char);
	        this._caret({
	            start: caret,
	            end: caret
	        })
	    },
	    _moveCaret: function() {
	        var currentCaret = this._caret().start;
	        var maskRuleIndex = currentCaret + (this._isForwardDirection() ? 0 : -1);
	        var caret = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this._isForwardDirection() ? 1 : -1) : currentCaret;
	        this._caret({
	            start: caret,
	            end: caret
	        })
	    },
	    _caret: function(position) {
	        if (!arguments.length) {
	            return caret(this._input())
	        }
	        caret(this._input(), position)
	    },
	    _hasSelection: function() {
	        var caret = this._caret();
	        return caret.start !== caret.end
	    },
	    _direction: function(direction) {
	        if (!arguments.length) {
	            return this._typingDirection
	        }
	        this._typingDirection = direction
	    },
	    _isForwardDirection: function() {
	        return this._direction() === FORWARD_DIRECTION
	    },
	    _clearDragTimer: function() {
	        clearTimeout(this._dragTimer)
	    },
	    _clean: function() {
	        this._clearDragTimer();
	        this.callBase()
	    },
	    _validateMask: function() {
	        if (!this._maskRulesChain) {
	            return
	        }
	        var isValid = this._maskRulesChain.isValid(this._normalizeChainArguments());
	        this.option({
	            isValid: isValid,
	            validationError: isValid ? null : {
	                editorSpecific: true,
	                message: this.option("maskInvalidMessage")
	            }
	        })
	    },
	    _dispose: function() {
	        clearTimeout(this._inputHandlerTimer);
	        clearTimeout(this._backspaceHandlerTimeout);
	        this.callBase()
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "mask":
	            case "maskChar":
	            case "maskRules":
	            case "useMaskedValue":
	                this._renderMask();
	                this._validateMask();
	                break;
	            case "value":
	                this._renderMaskedValue();
	                this._validateMask();
	                this.callBase(args);
	                break;
	            case "maskInvalidMessage":
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	module.exports = TextEditorMask;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/text_box/utils.caret.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    browser = __webpack_require__(16);
	var isIE = browser.msie && parseInt(browser.version) <= 11;
	var getCaret = function(input) {
	    if (isObsoleteBrowser(input)) {
	        return getCaretForObsoleteBrowser(input)
	    }
	    return {
	        start: input.selectionStart,
	        end: input.selectionEnd
	    }
	};
	var setCaret = function(input, position) {
	    if (isObsoleteBrowser(input)) {
	        setCaretForObsoleteBrowser(input, position);
	        return
	    }
	    if (!$.contains(document, input)) {
	        return
	    }
	    input.selectionStart = position.start;
	    input.selectionEnd = position.end
	};
	var isObsoleteBrowser = function(input) {
	    return !input.setSelectionRange
	};
	var getCaretForObsoleteBrowser = function(input) {
	    var range = document.selection.createRange();
	    var rangeCopy = range.duplicate();
	    range.move("character", -input.value.length);
	    range.setEndPoint("EndToStart", rangeCopy);
	    return {
	        start: range.text.length,
	        end: range.text.length + rangeCopy.text.length
	    }
	};
	var setCaretForObsoleteBrowser = function(input, position) {
	    if (!$.contains(document, input)) {
	        return
	    }
	    var range = input.createTextRange();
	    range.collapse(true);
	    range.moveStart("character", position.start);
	    range.moveEnd("character", position.end - position.start);
	    range.select()
	};
	var caret = function(input, position) {
	    input = $(input).get(0);
	    if (!commonUtils.isDefined(position)) {
	        return getCaret(input)
	    }
	    if (isIE && document.activeElement !== input) {
	        return
	    }
	    setCaret(input, position)
	};
	module.exports = caret;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/text_box/ui.text_editor.base.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    domUtils = __webpack_require__(43),
	    commonUtils = __webpack_require__(8),
	    themes = __webpack_require__(112),
	    Editor = __webpack_require__(95),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    clickEvent = __webpack_require__(65);
	var TEXTEDITOR_CLASS = "dx-texteditor",
	    TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input",
	    TEXTEDITOR_INPUT_SELECTOR = "." + TEXTEDITOR_INPUT_CLASS,
	    TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container",
	    TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container",
	    TEXTEDITOR_PLACEHOLDER_CLASS = "dx-placeholder",
	    TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS = "dx-show-clear-button",
	    TEXTEDITOR_ICON_CLASS = "dx-icon",
	    TEXTEDITOR_CLEAR_ICON_CLASS = "dx-icon-clear",
	    TEXTEDITOR_CLEAR_BUTTON_CLASS = "dx-clear-button-area",
	    TEXTEDITOR_EMPTY_INPUT_CLASS = "dx-texteditor-empty";
	var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
	var CONTROL_KEYS = {
	    9: "tab",
	    13: "enter",
	    16: "shift",
	    17: "ctrl",
	    18: "alt",
	    27: "escape",
	    33: "pageUp",
	    34: "pageDown",
	    35: "end",
	    36: "home",
	    37: "leftArrow",
	    38: "upArrow",
	    39: "rightArrow",
	    40: "downArrow"
	};
	var TextEditorBase = Editor.inherit({
	    _supportedKeys: function() {
	        var stop = function(e) {
	            e.stopPropagation()
	        };
	        return {
	            space: stop,
	            enter: stop,
	            leftArrow: stop,
	            rightArrow: stop
	        }
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            attr: {
	                since: "16.2",
	                alias: "inputAttr"
	            }
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            value: "",
	            spellcheck: false,
	            showClearButton: false,
	            valueChangeEvent: "change",
	            placeholder: "",
	            inputAttr: {},
	            onFocusIn: null,
	            onFocusOut: null,
	            onKeyDown: null,
	            onKeyPress: null,
	            onKeyUp: null,
	            onChange: null,
	            onInput: null,
	            onCut: null,
	            onCopy: null,
	            onPaste: null,
	            onEnterKey: null,
	            mode: "text",
	            hoverStateEnabled: true,
	            focusStateEnabled: true,
	            text: void 0,
	            valueFormat: function(value) {
	                return value
	            }
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                var currentTheme = (themes.current() || "").split(".")[0];
	                return "android5" === currentTheme
	            },
	            options: {
	                validationMessageOffset: {
	                    v: -8
	                }
	            }
	        }])
	    },
	    _input: function() {
	        return this.element().find(TEXTEDITOR_INPUT_SELECTOR).first()
	    },
	    _inputWrapper: function() {
	        return this.element()
	    },
	    _buttonsContainer: function() {
	        return this._inputWrapper().find("." + TEXTEDITOR_BUTTONS_CONTAINER_CLASS)
	    },
	    _isControlKey: function(keyCode) {
	        return !!CONTROL_KEYS[keyCode]
	    },
	    _render: function() {
	        this.element().addClass(TEXTEDITOR_CLASS);
	        this._renderInput();
	        this._renderInputType();
	        this._renderValue();
	        this._renderProps();
	        this._renderPlaceholder();
	        this.callBase();
	        this._refreshValueChangeEvent();
	        this._renderEvents();
	        this._renderEnterKeyAction();
	        this._renderEmptinessEvent()
	    },
	    _renderInput: function() {
	        $("<div>").addClass(TEXTEDITOR_CONTAINER_CLASS).append(this._createInput()).append($("<div>").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS)).appendTo(this.element())
	    },
	    _createInput: function() {
	        return $("<input>").addClass(TEXTEDITOR_INPUT_CLASS).css("min-height", this.option("height") ? "0" : "").attr("autocomplete", "off").attr(this.option("inputAttr"))
	    },
	    _renderValue: function() {
	        this._renderInputValue();
	        this._renderInputAddons()
	    },
	    _renderInputValue: function(value) {
	        value = value || this.option("value");
	        var text = this.option("text"),
	            displayValue = this.option("displayValue"),
	            valueFormat = this.option("valueFormat");
	        if (void 0 !== displayValue && null !== value) {
	            text = valueFormat(displayValue)
	        } else {
	            if (!commonUtils.isDefined(text)) {
	                text = valueFormat(value)
	            }
	        }
	        this.option("text", text);
	        if (this._input().val() !== (commonUtils.isDefined(text) ? text : "")) {
	            this._renderDisplayText(text)
	        } else {
	            this._toggleEmptinessEventHandler()
	        }
	    },
	    _renderDisplayText: function(text) {
	        this._input().val(text);
	        this._toggleEmptinessEventHandler()
	    },
	    _isValueValid: function() {
	        if (this._input().length) {
	            var validity = this._input().get(0).validity;
	            if (validity) {
	                return validity.valid
	            }
	        }
	        return true
	    },
	    _toggleEmptiness: function(isEmpty) {
	        this.element().toggleClass(TEXTEDITOR_EMPTY_INPUT_CLASS, isEmpty);
	        this._togglePlaceholder(isEmpty)
	    },
	    _togglePlaceholder: function(isEmpty) {
	        if (!this._$placeholder) {
	            return
	        }
	        this._$placeholder.toggleClass("dx-state-invisible", !isEmpty)
	    },
	    _renderProps: function() {
	        this._toggleDisabledState(this.option("disabled"));
	        this._toggleReadOnlyState();
	        this._toggleSpellcheckState()
	    },
	    _toggleDisabledState: function(value) {
	        this.callBase.apply(this, arguments);
	        var $input = this._input();
	        if (value) {
	            $input.attr("disabled", true).attr("tabindex", -1)
	        } else {
	            $input.removeAttr("disabled").removeAttr("tabindex")
	        }
	    },
	    _toggleReadOnlyState: function() {
	        this._input().prop("readOnly", this._readOnlyPropValue());
	        this.callBase()
	    },
	    _readOnlyPropValue: function() {
	        return this.option("readOnly")
	    },
	    _toggleSpellcheckState: function() {
	        this._input().prop("spellcheck", this.option("spellcheck"))
	    },
	    _renderPlaceholder: function() {
	        if (this._$placeholder) {
	            this._$placeholder.remove();
	            this._$placeholder = null
	        }
	        var that = this,
	            $input = that._input(),
	            placeholderText = that.option("placeholder"),
	            $placeholder = this._$placeholder = $("<div>").attr("data-dx_placeholder", placeholderText),
	            startEvent = eventUtils.addNamespace(pointerEvents.up, this.NAME);
	        $placeholder.on(startEvent, function() {
	            $input.focus()
	        });
	        $placeholder.insertAfter($input);
	        $placeholder.addClass(TEXTEDITOR_PLACEHOLDER_CLASS);
	        this._toggleEmptinessEventHandler()
	    },
	    _placeholder: function() {
	        return this._$placeholder || $()
	    },
	    _renderInputAddons: function() {
	        this._renderClearButton()
	    },
	    _renderClearButton: function() {
	        var clearButtonVisibility = this._clearButtonVisibility();
	        this.element().toggleClass(TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, clearButtonVisibility);
	        if (clearButtonVisibility) {
	            if (!this._$clearButton || this._$clearButton && !this._$clearButton.closest(this.element()).length) {
	                this._$clearButton = this._createClearButton()
	            }
	            this._$clearButton.prependTo(this._buttonsContainer())
	        }
	        if (this._$clearButton) {
	            this._$clearButton.toggleClass("dx-state-invisible", !clearButtonVisibility)
	        }
	    },
	    _clearButtonVisibility: function() {
	        return this.option("showClearButton") && !this.option("readOnly")
	    },
	    _createClearButton: function() {
	        return $("<span>").addClass(TEXTEDITOR_CLEAR_BUTTON_CLASS).append($("<span>").addClass(TEXTEDITOR_ICON_CLASS).addClass(TEXTEDITOR_CLEAR_ICON_CLASS)).on(eventUtils.addNamespace(pointerEvents.down, this.NAME), function(e) {
	            if ("mouse" === e.pointerType) {
	                e.preventDefault()
	            }
	        }).on(eventUtils.addNamespace(clickEvent.name, this.NAME), $.proxy(this._clearValueHandler, this))
	    },
	    _clearValueHandler: function(e) {
	        var $input = this._input();
	        e.stopPropagation();
	        this._valueChangeEventHandler(e);
	        this.reset();
	        !$input.is(":focus") && $input.focus()
	    },
	    _renderEvents: function() {
	        var that = this,
	            $input = that._input();
	        $.each(EVENTS_LIST, function(_, event) {
	            if (that.hasActionSubscription("on" + event)) {
	                var action = that._createActionByOption("on" + event, {
	                    excludeValidators: ["readOnly"]
	                });
	                $input.on(eventUtils.addNamespace(event.toLowerCase(), that.NAME), function(e) {
	                    if (that._disposed) {
	                        return
	                    }
	                    action({
	                        jQueryEvent: e
	                    })
	                })
	            }
	        })
	    },
	    _refreshEvents: function() {
	        var that = this,
	            $input = this._input();
	        $.each(EVENTS_LIST, function(_, event) {
	            $input.off(eventUtils.addNamespace(event.toLowerCase(), that.NAME))
	        });
	        this._renderEvents()
	    },
	    _keyPressHandler: function() {
	        this.option("text", this._input().val())
	    },
	    _renderValueChangeEvent: function() {
	        var keyPressEvent = eventUtils.addNamespace(this._renderValueEventName(), this.NAME + "TextChange"),
	            valueChangeEvent = eventUtils.addNamespace(this.option("valueChangeEvent"), this.NAME + "ValueChange");
	        this._input().on(keyPressEvent, $.proxy(this._keyPressHandler, this)).on(valueChangeEvent, $.proxy(this._valueChangeEventHandler, this))
	    },
	    _cleanValueChangeEvent: function() {
	        var eventNamespace = this.NAME + "ValueChange",
	            keyPressEvent = eventUtils.addNamespace(this._renderValueEventName(), this.NAME + "TextChange");
	        this._input().off("." + eventNamespace).off(keyPressEvent)
	    },
	    _refreshValueChangeEvent: function() {
	        this._cleanValueChangeEvent();
	        this._renderValueChangeEvent()
	    },
	    _renderValueEventName: function() {
	        return "input change keypress"
	    },
	    _focusTarget: function() {
	        return this._input()
	    },
	    _focusClassTarget: function() {
	        return this.element()
	    },
	    _toggleFocusClass: function(isFocused, $element) {
	        this.callBase(isFocused, this._focusClassTarget($element))
	    },
	    _hasFocusClass: function(element) {
	        return this.callBase($(element || this.element()))
	    },
	    _renderEmptinessEvent: function() {
	        var $input = this._input();
	        $input.on("input blur", $.proxy(this._toggleEmptinessEventHandler, this))
	    },
	    _toggleEmptinessEventHandler: function() {
	        var text = this._input().val(),
	            isEmpty = ("" === text || null === text) && this._isValueValid();
	        this._toggleEmptiness(isEmpty)
	    },
	    _valueChangeEventHandler: function(e, formattedValue) {
	        this._saveValueChangeEvent(e);
	        this.option("value", arguments.length > 1 ? formattedValue : this._input().val())
	    },
	    _renderEnterKeyAction: function() {
	        this._enterKeyAction = this._createActionByOption("onEnterKey", {
	            excludeValidators: ["readOnly"]
	        });
	        this._input().off("keyup.onEnterKey.dxTextEditor").on("keyup.onEnterKey.dxTextEditor", $.proxy(this._enterKeyHandlerUp, this))
	    },
	    _enterKeyHandlerUp: function(e) {
	        if (this._disposed) {
	            return
	        }
	        if (13 === e.which) {
	            this._enterKeyAction({
	                jQueryEvent: e
	            })
	        }
	    },
	    _updateValue: function() {
	        this.option("text", void 0);
	        this._renderValue()
	    },
	    _dispose: function() {
	        this._enterKeyAction = void 0;
	        this.callBase()
	    },
	    _getSubmitElement: function() {
	        return this._input()
	    },
	    _optionChanged: function(args) {
	        var name = args.name;
	        if ($.inArray(name.replace("on", ""), EVENTS_LIST) > -1) {
	            this._refreshEvents();
	            return
	        }
	        switch (name) {
	            case "valueChangeEvent":
	                this._refreshValueChangeEvent();
	                this._refreshFocusEvent();
	                this._refreshEvents();
	                break;
	            case "onValueChanged":
	                this._createValueChangeAction();
	                break;
	            case "readOnly":
	                this.callBase(args);
	                this._renderInputAddons();
	                break;
	            case "spellcheck":
	                this._toggleSpellcheckState();
	                break;
	            case "mode":
	                this._renderInputType();
	                break;
	            case "onEnterKey":
	                this._renderEnterKeyAction();
	                break;
	            case "placeholder":
	                this._renderPlaceholder();
	                break;
	            case "showClearButton":
	                this._renderInputAddons();
	                break;
	            case "text":
	                break;
	            case "value":
	                this._updateValue();
	                this.callBase(args);
	                break;
	            case "inputAttr":
	                this._input().attr(args.value);
	                break;
	            case "valueFormat":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _renderInputType: function() {
	        this._setInputType(this.option("mode"))
	    },
	    _setInputType: function(type) {
	        var input = this._input();
	        if ("search" === type) {
	            type = "text"
	        }
	        try {
	            input.prop("type", type)
	        } catch (e) {
	            input.prop("type", "text")
	        }
	    },
	    focus: function() {
	        this._input().focus()
	    },
	    blur: function() {
	        if (this._input().is(document.activeElement)) {
	            domUtils.resetActiveElement()
	        }
	    },
	    reset: function() {
	        this.option("value", "")
	    }
	});
	var originalOnMethod = TextEditorBase.prototype.on;
	TextEditorBase.prototype.on = function(eventName, eventHandler) {
	    originalOnMethod.call(this, eventName, eventHandler);
	    var event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
	    if (EVENTS_LIST.indexOf(event) >= 0) {
	        this._refreshEvents()
	    }
	};
	module.exports = TextEditorBase;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/text_box/ui.text_editor.mask.rule.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8);
	var EMPTY_CHAR = " ";
	var BaseMaskRule = Class.inherit({
	    ctor: function(config) {
	        this._value = EMPTY_CHAR;
	        $.extend(this, config)
	    },
	    next: function(rule) {
	        if (!arguments.length) {
	            return this._next
	        }
	        this._next = rule
	    },
	    text: $.noop,
	    value: $.noop,
	    rawValue: $.noop,
	    handle: $.noop,
	    _prepareHandlingArgs: function(args, config) {
	        config = config || {};
	        var handlingProperty = args.hasOwnProperty("value") ? "value" : "text";
	        args[handlingProperty] = commonUtils.isDefined(config.str) ? config.str : args[handlingProperty];
	        args.start = commonUtils.isDefined(config.start) ? config.start : args.start;
	        args.length = commonUtils.isDefined(config.length) ? config.length : args.length;
	        args.index = args.index + 1;
	        return args
	    },
	    reset: $.noop,
	    clear: $.noop,
	    isAccepted: function() {
	        return false
	    },
	    adjustedCaret: function(caret, isForwardDirection, char) {
	        return isForwardDirection ? this._adjustedForward(caret, 0, char) : this._adjustedBackward(caret, 0, char)
	    },
	    _adjustedForward: $.noop,
	    _adjustedBackward: $.noop,
	    isValid: $.noop
	});
	var EmptyMaskRule = BaseMaskRule.inherit({
	    next: $.noop,
	    handle: function() {
	        return 0
	    },
	    text: function() {
	        return ""
	    },
	    value: function() {
	        return ""
	    },
	    rawValue: function() {
	        return ""
	    },
	    adjustedCaret: function() {
	        return 0
	    },
	    isValid: function() {
	        return true
	    }
	});
	var MaskRule = BaseMaskRule.inherit({
	    text: function() {
	        return (this._value !== EMPTY_CHAR ? this._value : this.maskChar) + this.next().text()
	    },
	    value: function() {
	        return this._value + this.next().value()
	    },
	    rawValue: function() {
	        return this._value + this.next().rawValue()
	    },
	    handle: function(args) {
	        var str = args.hasOwnProperty("value") ? args.value : args.text;
	        if (!str || !str.length || !args.length) {
	            return 0
	        }
	        if (args.start) {
	            return this.next().handle(this._prepareHandlingArgs(args, {
	                start: args.start - 1
	            }))
	        }
	        var char = str[0];
	        var rest = str.substring(1);
	        this._tryAcceptChar(char, args);
	        return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
	            str: rest,
	            length: args.length - 1
	        })) + 1 : this.handle(this._prepareHandlingArgs(args, {
	            str: rest,
	            length: args.length - 1
	        }))
	    },
	    clear: function(args) {
	        this._tryAcceptChar(EMPTY_CHAR, args);
	        this.next().clear(this._prepareHandlingArgs(args))
	    },
	    reset: function() {
	        this._accepted(false);
	        this.next().reset()
	    },
	    _tryAcceptChar: function(char, args) {
	        this._accepted(false);
	        if (!this._isAllowed(char, args)) {
	            return
	        }
	        var acceptedChar = char === EMPTY_CHAR ? this.maskChar : char;
	        args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
	        this._accepted(true);
	        this._value = char
	    },
	    _accepted: function(value) {
	        if (!arguments.length) {
	            return !!this._isAccepted
	        }
	        this._isAccepted = !!value
	    },
	    _isAllowed: function(char, args) {
	        if (char === EMPTY_CHAR) {
	            return true
	        }
	        return this._isValid(char, args)
	    },
	    _isValid: function(char, args) {
	        var allowedChars = this.allowedChars;
	        if (allowedChars instanceof RegExp) {
	            return allowedChars.test(char)
	        }
	        if ($.isFunction(allowedChars)) {
	            return allowedChars(char, args.index, args.fullText)
	        }
	        if ($.isArray(allowedChars)) {
	            return $.inArray(char, allowedChars) > -1
	        }
	        return allowedChars === char
	    },
	    isAccepted: function(caret) {
	        return 0 === caret ? this._accepted() : this.next().isAccepted(caret - 1)
	    },
	    _adjustedForward: function(caret, index, char) {
	        if (index >= caret) {
	            return index
	        }
	        return this.next()._adjustedForward(caret, index + 1, char) || index + 1
	    },
	    _adjustedBackward: function(caret, index) {
	        if (index >= caret - 1) {
	            return caret
	        }
	        return this.next()._adjustedBackward(caret, index + 1) || index + 1
	    },
	    isValid: function(args) {
	        return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args))
	    }
	});
	var StubMaskRule = MaskRule.inherit({
	    value: function() {
	        return this.next().value()
	    },
	    handle: function(args) {
	        var hasValueProperty = args.hasOwnProperty("value");
	        var str = hasValueProperty ? args.value : args.text;
	        if (!str.length || !args.length) {
	            return 0
	        }
	        if (args.start || hasValueProperty) {
	            return this.next().handle(this._prepareHandlingArgs(args, {
	                start: args.start && args.start - 1
	            }))
	        }
	        var char = str[0];
	        var rest = str.substring(1);
	        this._tryAcceptChar(char);
	        var nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
	            str: rest,
	            length: args.length - 1
	        }) : args;
	        return this.next().handle(nextArgs) + 1
	    },
	    clear: function(args) {
	        this._accepted(false);
	        this.next().clear(this._prepareHandlingArgs(args))
	    },
	    _tryAcceptChar: function(char) {
	        this._accepted(this._isValid(char))
	    },
	    _isValid: function(char) {
	        return char === this.maskChar
	    },
	    _adjustedForward: function(caret, index, char) {
	        if (index >= caret && char === this.maskChar) {
	            return index
	        }
	        if (caret === index + 1 && this._accepted()) {
	            return caret
	        }
	        return this.next()._adjustedForward(caret, index + 1, char)
	    },
	    _adjustedBackward: function(caret, index) {
	        if (index >= caret - 1) {
	            return 0
	        }
	        return this.next()._adjustedBackward(caret, index + 1)
	    },
	    isValid: function(args) {
	        return this.next().isValid(this._prepareHandlingArgs(args))
	    }
	});
	module.exports.MaskRule = MaskRule;
	module.exports.StubMaskRule = StubMaskRule;
	module.exports.EmptyMaskRule = EmptyMaskRule;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/number_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(238);
	module.exports.default = module.exports;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/number_box/number_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    TextEditor = __webpack_require__(232),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    wheelEvent = __webpack_require__(75),
	    SpinButton = __webpack_require__(239),
	    messageLocalization = __webpack_require__(79);
	var math = Math;
	var WIDGET_CLASS = "dx-numberbox",
	    SPIN_CLASS = "dx-numberbox-spin",
	    SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container",
	    SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
	var FIREFOX_CONTROL_KEYS = ["Tab", "Del", "Delete", "Backspace", "Left", "ArrowLeft", "Right", "ArrowRight", "Home", "End", "Enter"];
	var NumberBox = TextEditor.inherit({
	    _supportedKeys: function() {
	        return $.extend(this.callBase(), {
	            upArrow: function(e) {
	                e.preventDefault();
	                e.stopPropagation();
	                this._spinUpChangeHandler(e)
	            },
	            downArrow: function(e) {
	                e.preventDefault();
	                e.stopPropagation();
	                this._spinDownChangeHandler(e)
	            },
	            enter: function() {}
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            value: 0,
	            min: void 0,
	            max: void 0,
	            step: 1,
	            showSpinButtons: false,
	            useTouchSpinButtons: true,
	            mode: "text",
	            invalidValueMessage: messageLocalization.format("dxNumberBox-invalidValueMessage")
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return devices.real().generic && !devices.isSimulator()
	            },
	            options: {
	                useTouchSpinButtons: false
	            }
	        }, {
	            device: function() {
	                return "generic" !== devices.real().platform
	            },
	            options: {
	                mode: "number"
	            }
	        }])
	    },
	    _render: function() {
	        this._renderSubmitElement();
	        this._setSubmitValue(this.option("value"));
	        this.callBase();
	        this.option("isValid") && this._validateValue(this.option("value"));
	        this.element().addClass(WIDGET_CLASS);
	        this.setAria("role", "spinbutton");
	        this._renderMouseWheelHandler()
	    },
	    _renderSubmitElement: function() {
	        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
	    },
	    _setSubmitValue: function(value) {
	        this._$submitElement.val(commonUtils.applyServerDecimalSeparator(value))
	    },
	    _getSubmitElement: function() {
	        return this._$submitElement
	    },
	    _keyPressHandler: function(e) {
	        this.callBase(e);
	        var ch = String.fromCharCode(e.which),
	            validCharRegExp = /[\d.,eE\-+]/,
	            isInputCharValid = validCharRegExp.test(ch);
	        if (!isInputCharValid) {
	            if (e.metaKey || e.ctrlKey || e.key && $.inArray(e.key, FIREFOX_CONTROL_KEYS) >= 0) {
	                return
	            }
	            e.preventDefault();
	            return false
	        }
	        this._keyPressed = true
	    },
	    _renderMouseWheelHandler: function() {
	        var eventName = eventUtils.addNamespace(wheelEvent.name, this.NAME);
	        var mouseWheelAction = this._createAction($.proxy(function(e) {
	            this._mouseWheelHandler(e.jQueryEvent)
	        }, this));
	        this._input().off(eventName).on(eventName, function(e) {
	            mouseWheelAction({
	                jQueryEvent: e
	            })
	        })
	    },
	    _mouseWheelHandler: function(jQueryEvent) {
	        if (!this._input().is(":focus")) {
	            return
	        }
	        jQueryEvent.delta > 0 ? this._spinValueChange(1, jQueryEvent) : this._spinValueChange(-1, jQueryEvent);
	        jQueryEvent.preventDefault();
	        jQueryEvent.stopPropagation()
	    },
	    _renderValue: function() {
	        var inputValue = this._input().val();
	        if (!inputValue.length || Number(inputValue) !== this.option("value")) {
	            this._forceValueRender();
	            this._toggleEmptinessEventHandler()
	        }
	        var value = this.option("value");
	        this._renderInputAddons();
	        this.setAria("valuenow", value)
	    },
	    _renderValueEventName: function() {
	        return this.callBase() + " keypress"
	    },
	    _toggleDisabledState: function(value) {
	        if (this._$spinUp) {
	            SpinButton.getInstance(this._$spinUp).option("disabled", value)
	        }
	        if (this._$spinDown) {
	            SpinButton.getInstance(this._$spinDown).option("disabled", value)
	        }
	        this.callBase.apply(this, arguments)
	    },
	    _forceValueRender: function() {
	        var value = this.option("value"),
	            number = Number(value),
	            valueFormat = this.option("valueFormat"),
	            formattedValue = isNaN(number) ? "" : valueFormat(value);
	        this._renderDisplayText(formattedValue)
	    },
	    _renderProps: function() {
	        this.callBase();
	        this._input().prop({
	            min: this.option("min"),
	            max: this.option("max"),
	            step: this.option("step")
	        });
	        this.setAria({
	            valuemin: this.option("min") || "undefined",
	            valuemax: this.option("max") || "undefined"
	        })
	    },
	    _renderInputAddons: function() {
	        this.callBase();
	        this._renderSpinButtons()
	    },
	    _renderSpinButtons: function() {
	        var spinButtonsVisible = this.option("showSpinButtons");
	        this.element().toggleClass(SPIN_CLASS, spinButtonsVisible);
	        this._toggleTouchFriendlyClass();
	        if (!spinButtonsVisible) {
	            this._$spinContainer && this._$spinContainer.remove();
	            this._$spinContainer = null;
	            return
	        }
	        if (!this._$spinContainer) {
	            this._$spinContainer = this._createSpinButtons()
	        }
	        this._$spinContainer.prependTo(this._buttonsContainer())
	    },
	    _toggleTouchFriendlyClass: function() {
	        this.element().toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, this.option("showSpinButtons") && this.option("useTouchSpinButtons"))
	    },
	    _createSpinButtons: function() {
	        var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
	        var pointerDownAction = this._createAction($.proxy(this._spinButtonsPointerDownHandler, this));
	        var $spinContainer = $("<div>").addClass(SPIN_CONTAINER_CLASS).off(eventName).on(eventName, function(e) {
	            pointerDownAction({
	                jQueryEvent: e
	            })
	        });
	        this._$spinUp = $("<div>").appendTo($spinContainer);
	        this._createComponent(this._$spinUp, SpinButton, {
	            direction: "up",
	            onChange: $.proxy(this._spinUpChangeHandler, this)
	        });
	        this._$spinDown = $("<div>").appendTo($spinContainer);
	        this._createComponent(this._$spinDown, SpinButton, {
	            direction: "down",
	            onChange: $.proxy(this._spinDownChangeHandler, this)
	        });
	        return $spinContainer
	    },
	    _spinButtonsPointerDownHandler: function() {
	        var $input = this._input();
	        if (!this.option("useTouchSpinButtons") && document.activeElement !== $input[0]) {
	            $input.trigger("focus")
	        }
	    },
	    _spinUpChangeHandler: function(e) {
	        if (!this.option("readOnly")) {
	            this._spinValueChange(1, e.jQueryEvent || e)
	        }
	    },
	    _spinDownChangeHandler: function(e) {
	        if (!this.option("readOnly")) {
	            this._spinValueChange(-1, e.jQueryEvent || e)
	        }
	    },
	    _spinValueChange: function(sign, jQueryEvent) {
	        var value = parseFloat(this._normalizeInputValue()) || 0,
	            step = parseFloat(this.option("step"));
	        value = this._correctRounding(value, step * sign);
	        var min = this.option("min"),
	            max = this.option("max");
	        if (void 0 !== min) {
	            value = Math.max(min, value)
	        }
	        if (void 0 !== max) {
	            value = Math.min(max, value)
	        }
	        this._saveValueChangeEvent(jQueryEvent);
	        this.option("value", value)
	    },
	    _correctRounding: function(value, step) {
	        var regex = /[,.](.*)/;
	        var isFloatValue = regex.test(value),
	            isFloatStep = regex.test(step);
	        if (isFloatValue || isFloatStep) {
	            var valueAccuracy = isFloatValue ? regex.exec(value)[0].length : 0,
	                stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0,
	                accuracy = math.max(valueAccuracy, stepAccuracy);
	            value = this._round(value + step, accuracy);
	            return value
	        }
	        return value + step
	    },
	    _round: function(value, precision) {
	        precision = precision || 0;
	        var multiplier = Math.pow(10, precision);
	        value *= multiplier;
	        value = Math.round(value) / multiplier;
	        return value
	    },
	    _renderValueChangeEvent: function() {
	        this.callBase();
	        this._input().focusout($.proxy(this._forceRefreshInputValue, this))
	    },
	    _forceRefreshInputValue: function() {
	        if ("number" === this.option("mode")) {
	            return
	        }
	        var $input = this._input(),
	            valueFormat = this.option("valueFormat");
	        $input.val(null);
	        $input.val(valueFormat(this.option("value")))
	    },
	    _valueChangeEventHandler: function(e) {
	        var $input = this._input(),
	            inputValue = $input.val(),
	            value = this._normalizeInputValue(),
	            valueFormat = this.option("valueFormat");
	        if (this._shouldBeValidated() && !this._validateValue(value)) {
	            $input.val(valueFormat(this.option("value")));
	            return
	        }
	        if ("number" === this.option("mode")) {
	            this.callBase(e, isNaN(value) ? null : value);
	            return
	        }
	        if ("." === inputValue || "-" === inputValue) {
	            return
	        }
	        this.callBase(e, value);
	        if (this._isValueIncomplete(inputValue)) {
	            return
	        }
	        if (commonUtils.isString(inputValue)) {
	            inputValue = this._replaceCommaWithPoint(inputValue)
	        }
	        if (Number(inputValue) !== value) {
	            $input.val(valueFormat(value))
	        }
	    },
	    _replaceCommaWithPoint: function(value) {
	        return value.replace(",", ".")
	    },
	    _inputIsInvalid: function() {
	        var isNumberMode = "number" === this.option("mode");
	        var validityState = this._input().get(0).validity;
	        return isNumberMode && validityState && validityState.badInput
	    },
	    _renderDisplayText: function(text) {
	        if (this._inputIsInvalid()) {
	            return
	        }
	        this.callBase(text)
	    },
	    _isValueIncomplete: function(value) {
	        var incompleteRegex = /^(([+-])|([+-]?(0|[1-9]\d*)?[.,])|([+-]?(0|[1-9]\d*)?([.,]\d+)[eE][+-]?)|([+-]?(0|[1-9]\d*)[eE][+-]?))$/;
	        return incompleteRegex.test(value)
	    },
	    _shouldBeValidated: function() {
	        var inputValue = this._normalizeText();
	        return !!inputValue && !isNaN(Number(inputValue)) && this._isValueValid()
	    },
	    _validateValue: function(value) {
	        var inputValue = this._normalizeText(),
	            isValueValid = this._isValueValid(),
	            isValid = true,
	            isNumber = /^([-+]?[0-9]*[.,]?[0-9]+([eE][-+]?[0-9]+)?)$/.test(inputValue);
	        if (isNaN(Number(value))) {
	            isValid = false
	        }
	        if (!value && isValueValid) {
	            isValid = true
	        } else {
	            if (!isNumber && !isValueValid) {
	                isValid = false
	            }
	        }
	        this.option({
	            isValid: isValid,
	            validationError: isValid ? null : {
	                editorSpecific: true,
	                message: this.option("invalidValueMessage")
	            }
	        });
	        return isValid
	    },
	    _normalizeInputValue: function() {
	        return this._normalizeValue()
	    },
	    _normalizeValue: function(value) {
	        return this._parseValue(this._normalizeText(value))
	    },
	    _normalizeText: function(value) {
	        value = $.trim(commonUtils.isDefined(value) ? value : this._input().val());
	        return this._replaceCommaWithPoint(value)
	    },
	    _parseValue: function(value) {
	        if ("" === value) {
	            return null
	        }
	        var number = parseFloat(value);
	        if (isNaN(number)) {
	            return null
	        }
	        if (void 0 !== this.option("min")) {
	            number = math.max(number, this.option("min"))
	        }
	        if (void 0 !== this.option("max")) {
	            number = math.min(number, this.option("max"))
	        }
	        return number
	    },
	    _clean: function() {
	        delete this._$spinContainer;
	        delete this._$spinUp;
	        delete this._$spinDown;
	        this.callBase()
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "value":
	                this._validateValue(args.value);
	                this._setSubmitValue(args.value);
	                this.callBase(args);
	                this._resumeValueChangeAction();
	                break;
	            case "step":
	            case "min":
	            case "max":
	                this._renderProps();
	                break;
	            case "showSpinButtons":
	                this._renderInputAddons();
	                break;
	            case "useTouchSpinButtons":
	                this._toggleTouchFriendlyClass();
	                break;
	            case "invalidValueMessage":
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxNumberBox", NumberBox);
	module.exports = NumberBox;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/number_box/number_box.spin.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Widget = __webpack_require__(84),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    feedbackEvents = __webpack_require__(93),
	    holdEvent = __webpack_require__(132);
	var SPIN_CLASS = "dx-numberbox-spin",
	    SPIN_BUTTON_CLASS = "dx-numberbox-spin-button",
	    SPIN_HOLD_DELAY = 100,
	    NUMBER_BOX = "dxNumberBox",
	    POINTERUP_EVENT_NAME = eventUtils.addNamespace(pointerEvents.up, NUMBER_BOX),
	    POINTERCANCEL_EVENT_NAME = eventUtils.addNamespace(pointerEvents.cancel, NUMBER_BOX);
	var SpinButton = Widget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            direction: "up",
	            onChange: null,
	            activeStateEnabled: true,
	            hoverStateEnabled: true
	        })
	    },
	    _render: function() {
	        this.callBase();
	        var $element = this.element(),
	            direction = SPIN_CLASS + "-" + this.option("direction");
	        var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
	        $element.addClass(SPIN_BUTTON_CLASS).addClass(direction).off(eventName).on(eventName, $.proxy(this._spinDownHandler, this));
	        this._spinIcon = $("<div>").addClass(direction + "-icon").appendTo(this.element());
	        this._spinChangeHandler = this._createActionByOption("onChange")
	    },
	    _spinDownHandler: function(e) {
	        e.preventDefault();
	        this._clearTimer();
	        $(document).on(holdEvent.name, $.proxy(function() {
	            this._feedBackDeferred = $.Deferred();
	            feedbackEvents.lock(this._feedBackDeferred);
	            this._spinChangeHandler({
	                jQueryEvent: e
	            });
	            this._holdTimer = setInterval(this._spinChangeHandler, SPIN_HOLD_DELAY, {
	                jQueryEvent: e
	            })
	        }, this)).on(POINTERUP_EVENT_NAME, $.proxy(this._clearTimer, this)).on(POINTERCANCEL_EVENT_NAME, $.proxy(this._clearTimer, this));
	        this._spinChangeHandler({
	            jQueryEvent: e
	        })
	    },
	    _dispose: function() {
	        this._clearTimer();
	        this.callBase()
	    },
	    _clearTimer: function() {
	        $(document).off(POINTERUP_EVENT_NAME).off(POINTERCANCEL_EVENT_NAME).off(holdEvent.name);
	        if (this._feedBackDeferred) {
	            this._feedBackDeferred.resolve()
	        }
	        if (this._holdTimer) {
	            clearInterval(this._holdTimer)
	        }
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "onChange":
	            case "direction":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	module.exports = SpinButton;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(241);
	module.exports.default = module.exports;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    compareVersions = __webpack_require__(11).compare,
	    support = __webpack_require__(48),
	    devices = __webpack_require__(40),
	    dateUtils = __webpack_require__(51),
	    uiDateUtils = __webpack_require__(242),
	    DropDownEditor = __webpack_require__(243),
	    dateLocalization = __webpack_require__(55),
	    messageLocalization = __webpack_require__(79),
	    DATEBOX_CLASS = "dx-datebox",
	    DATEBOX_WRAPPER_CLASS = "dx-datebox-wrapper";
	var PICKER_TYPE = {
	    calendar: "calendar",
	    rollers: "rollers",
	    list: "list",
	    "native": "native"
	};
	var TYPE = {
	    date: "date",
	    datetime: "datetime",
	    time: "time"
	};
	var STRATEGY_NAME = {
	    calendar: "Calendar",
	    dateView: "DateView",
	    "native": "Native",
	    calendarWithTime: "CalendarWithTime",
	    list: "List"
	};
	var STRATEGY_CLASSES = {
	    Calendar: __webpack_require__(244),
	    DateView: __webpack_require__(251),
	    Native: __webpack_require__(254),
	    CalendarWithTime: __webpack_require__(255),
	    List: __webpack_require__(257)
	};
	var isRealWidthSet = function($element) {
	    var explicitWidth = $element[0].style.width;
	    if (explicitWidth && "auto" !== explicitWidth && "inherit" !== explicitWidth) {
	        return true
	    }
	    return false
	};
	var calculateWidth = function(value, $input, $element) {
	    var IE_ROUNDING_ERROR = 10;
	    var NATIVE_BUTTONS_WIDTH = 48;
	    var $longestValueElement = $("<div>").text(value).css({
	        "font-style": $input.css("font-style"),
	        "font-variant": $input.css("font-variant"),
	        "font-weight": $input.css("font-weight"),
	        "font-size": $input.css("font-size"),
	        "font-family": $input.css("font-family"),
	        "letter-spacing": $input.css("letter-spacing"),
	        "padding-left": $input.css("padding-left"),
	        "padding-right": $input.css("padding-right"),
	        border: $input.css("border"),
	        visibility: "hidden",
	        "white-space": "nowrap",
	        position: "absolute",
	        "float": "left"
	    });
	    $longestValueElement.appendTo($element);
	    var width = $longestValueElement.outerWidth() + IE_ROUNDING_ERROR + ("text" !== $input.prop("type") ? NATIVE_BUTTONS_WIDTH : 0);
	    $longestValueElement.remove();
	    return width
	};
	var DateBox = DropDownEditor.inherit({
	    _supportedKeys: function() {
	        return $.extend(this.callBase(), this._strategy.supportedKeys())
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            format: {
	                since: "16.1",
	                alias: "type"
	            },
	            formatString: {
	                since: "16.1",
	                alias: "displayFormat"
	            },
	            useNative: {
	                since: "15.1",
	                message: "'useNative' option is deprecated in 15.1. Use the 'pickerType' option instead"
	            },
	            useCalendar: {
	                since: "15.1",
	                message: "'useCalendar' option is deprecated in 15.1. Use the 'pickerType' option instead"
	            }
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            type: "date",
	            value: null,
	            min: void 0,
	            max: void 0,
	            useCalendar: false,
	            displayFormat: null,
	            interval: 30,
	            maxZoomLevel: "month",
	            minZoomLevel: "century",
	            useNative: true,
	            pickerType: PICKER_TYPE.native,
	            invalidDateMessage: messageLocalization.format("dxDateBox-validation-datetime"),
	            dateOutOfRangeMessage: messageLocalization.format("validation-range"),
	            applyButtonText: messageLocalization.format("Done"),
	            adaptivityEnabled: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: {
	                platform: "ios"
	            },
	            options: {
	                showPopupTitle: true
	            }
	        }, {
	            device: function(device) {
	                return "android" === device.platform
	            },
	            options: {
	                buttonsLocation: "bottom after"
	            }
	        }, {
	            device: function(device) {
	                return "win" === device.platform && device.version && 8 === device.version[0]
	            },
	            options: {
	                buttonsLocation: "bottom after"
	            }
	        }, {
	            device: function(device) {
	                return "win" === device.platform && device.version && 10 === device.version[0]
	            },
	            options: {
	                buttonsLocation: "bottom center"
	            }
	        }, {
	            device: function() {
	                var realDevice = devices.real(),
	                    platform = realDevice.platform,
	                    version = realDevice.version;
	                return "generic" === platform || "win" === platform || "android" === platform && compareVersions(version, [4, 4]) < 0
	            },
	            options: {
	                pickerType: PICKER_TYPE.rollers
	            }
	        }, {
	            device: {
	                platform: "generic",
	                deviceType: "desktop"
	            },
	            options: {
	                pickerType: PICKER_TYPE.calendar,
	                buttonsLocation: "bottom after"
	            }
	        }, {
	            device: function() {
	                var realDevice = devices.real(),
	                    platform = realDevice.platform,
	                    isPhone = realDevice.phone;
	                return "win" === platform && !isPhone
	            },
	            options: {
	                pickerType: PICKER_TYPE.calendar
	            }
	        }])
	    },
	    _initOptions: function(options) {
	        this._userOptions = $.extend({}, options);
	        this.callBase(options);
	        this._updatePickerOptions(this._userOptions)
	    },
	    _updatePickerOptions: function(userOptions) {
	        var pickerType = this._getPickerTypeByDeprecatedOptions(userOptions);
	        var type = this.option("type");
	        if (pickerType === PICKER_TYPE.list && (type === TYPE.datetime || type === TYPE.date)) {
	            pickerType = PICKER_TYPE.calendar
	        }
	        if (type === TYPE.time && pickerType === PICKER_TYPE.calendar) {
	            pickerType = PICKER_TYPE.list
	        }
	        this.option("showDropButton", "generic" !== devices.real().platform || pickerType !== PICKER_TYPE.native);
	        this._pickerType = pickerType
	    },
	    _getPickerTypeByDeprecatedOptions: function(userOptions) {
	        return userOptions.pickerType ? userOptions.pickerType : commonUtils.isDefined(userOptions.useCalendar) || commonUtils.isDefined(userOptions.useNative) ? this._getPickerType() : this._pickerType || this.option("pickerType")
	    },
	    _getPickerType: function() {
	        if (this.option().useCalendar) {
	            return this.option("type") === TYPE.time ? PICKER_TYPE.list : PICKER_TYPE.calendar
	        }
	        if (this.option().useNative) {
	            return PICKER_TYPE.native
	        }
	        return PICKER_TYPE.rollers
	    },
	    _init: function() {
	        this._initStrategy();
	        this.option($.extend({}, this._strategy.getDefaultOptions(), this._userOptions));
	        delete this._userOptions;
	        this.callBase()
	    },
	    _toLowerCaseFirstLetter: function(string) {
	        return string.charAt(0).toLowerCase() + string.substr(1)
	    },
	    _initStrategy: function() {
	        var strategyName = this._getStrategyName(this._getFormatType()),
	            strategy = STRATEGY_CLASSES[strategyName];
	        if (!(this._strategy && this._strategy.NAME === strategyName)) {
	            this._strategy = new strategy(this)
	        }
	    },
	    _getFormatType: function() {
	        var currentType = this.option("type");
	        var isTime = /h|m|s/g.test(currentType),
	            isDate = /d|M|Y/g.test(currentType);
	        var type = "";
	        if (isDate) {
	            type += TYPE.date
	        }
	        if (isTime) {
	            type += TYPE.time
	        }
	        return type
	    },
	    _getStrategyName: function(type) {
	        var pickerType = this._pickerType;
	        if (pickerType === PICKER_TYPE.rollers) {
	            return this.option().useCalendar ? STRATEGY_NAME.calendar : STRATEGY_NAME.dateView
	        }
	        if (pickerType === PICKER_TYPE.native) {
	            return STRATEGY_NAME.native
	        }
	        if (type === TYPE.date) {
	            return STRATEGY_NAME.calendar
	        }
	        if (type === TYPE.datetime) {
	            return STRATEGY_NAME.calendarWithTime
	        }
	        return STRATEGY_NAME.list
	    },
	    _render: function() {
	        this.element().addClass(DATEBOX_CLASS);
	        this._refreshFormatClass();
	        this._refreshPickerTypeClass();
	        this._renderSubmitElement();
	        this.callBase();
	        this._updateSize();
	        this._strategy.renderInputMinMax(this._input())
	    },
	    _refreshFormatClass: function() {
	        var $element = this.element();
	        $.each(TYPE, $.proxy(function(_, item) {
	            $element.removeClass(DATEBOX_CLASS + "-" + item)
	        }, null));
	        $element.addClass(DATEBOX_CLASS + "-" + this.option("type"))
	    },
	    _refreshPickerTypeClass: function() {
	        var $element = this.element();
	        $.each(PICKER_TYPE, $.proxy(function(_, item) {
	            $element.removeClass(DATEBOX_CLASS + "-" + item)
	        }, null));
	        $element.addClass(DATEBOX_CLASS + "-" + this._pickerType)
	    },
	    _renderSubmitElement: function() {
	        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
	    },
	    _getSubmitElement: function() {
	        return this._$submitElement
	    },
	    _updateSize: function() {
	        var $element = this.element(),
	            widthOption = this.option("width"),
	            isWidthSet = commonUtils.isDefined(widthOption) || isRealWidthSet($element) && !this._isSizeUpdatable,
	            isElementVisible = $element.is(":visible"),
	            pickerType = this._pickerType,
	            shouldCalculateWidth = pickerType !== PICKER_TYPE.rollers && "generic" === devices.current().platform;
	        if (isWidthSet || !(shouldCalculateWidth && isElementVisible)) {
	            return
	        }
	        var $input = this._input(),
	            format = this._strategy.getDisplayFormat(this.option("displayFormat")),
	            longestValue = dateLocalization.format(uiDateUtils.getLongestDate(format, dateLocalization.getMonthNames(), dateLocalization.getDayNames()), format);
	        $element.width(calculateWidth(longestValue, $input, this.element()));
	        this._isSizeUpdatable = true
	    },
	    _attachChildKeyboardEvents: function() {
	        this._strategy.attachKeyboardEvents(this._keyboardProcessor)
	    },
	    _renderPopup: function() {
	        this.callBase();
	        this._popup._wrapper().addClass(DATEBOX_WRAPPER_CLASS);
	        this._renderPopupWrapper()
	    },
	    _popupConfig: function() {
	        var popupConfig = this.callBase();
	        return $.extend(this._strategy.popupConfig(popupConfig), {
	            title: this._getPopupTitle(),
	            dragEnabled: false
	        })
	    },
	    _renderPopupWrapper: function() {
	        if (!this._popup) {
	            return
	        }
	        var $element = this.element();
	        var classPostfixes = $.extend({}, TYPE, PICKER_TYPE);
	        $.each(classPostfixes, $.proxy(function(_, item) {
	            $element.removeClass(DATEBOX_WRAPPER_CLASS + "-" + item)
	        }, this));
	        this._popup._wrapper().addClass(DATEBOX_WRAPPER_CLASS + "-" + this.option("type")).addClass(DATEBOX_WRAPPER_CLASS + "-" + this._pickerType)
	    },
	    _renderPopupContent: function() {
	        this.callBase();
	        this._strategy.renderPopupContent()
	    },
	    _getFirstPopupElement: function() {
	        return this._strategy.getFirstPopupElement() || this.callBase()
	    },
	    _getLastPopupElement: function() {
	        return this._strategy.getLastPopupElement() || this.callBase()
	    },
	    _popupShowingHandler: function() {
	        this.callBase();
	        this._strategy.popupShowingHandler()
	    },
	    _popupHiddenHandler: function() {
	        this.callBase();
	        this._strategy.popupHiddenHandler()
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._updateSize()
	        }
	    },
	    _readOnlyPropValue: function() {
	        return this.callBase() || this._pickerType === PICKER_TYPE.rollers
	    },
	    _clearButtonVisibility: function() {
	        return this.callBase() && !this._isNativeType()
	    },
	    _renderValue: function() {
	        var value = this.dateOption("value");
	        this.option("text", this._getDisplayedText(value));
	        var submitFormat = uiDateUtils.SUBMIT_FORMATS_MAP[this.option("type")];
	        this._$submitElement.val(uiDateUtils.toStandardDateFormat(value, submitFormat));
	        this._strategy.renderValue();
	        this.callBase()
	    },
	    _getDisplayedText: function(value) {
	        var displayedText, mode = this.option("mode");
	        if ("text" !== mode) {
	            var format = this._getFormatByMode(mode);
	            displayedText = uiDateUtils.toStandardDateFormat(value, mode, format)
	        } else {
	            var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
	            displayedText = dateLocalization.format(value, displayFormat)
	        }
	        return displayedText
	    },
	    _getFormatByMode: function(mode) {
	        return !support.inputType(mode) ? uiDateUtils.FORMATS_MAP[mode] : null
	    },
	    _valueChangeEventHandler: function() {
	        var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat")),
	            text = this.option("text"),
	            date = this._strategy.getParsedText(text, displayFormat),
	            value = this.dateOption("value"),
	            modelValue = new Date(value && value.valueOf()),
	            type = this.option("type"),
	            newValue = uiDateUtils.mergeDates(modelValue, date, type) || null;
	        if (this._validateValue(date)) {
	            var displayedText = this._getDisplayedText(newValue);
	            if (value && newValue && value.getTime() === newValue.getTime() && displayedText !== text) {
	                this._renderValue()
	            } else {
	                this.dateOption("value", newValue)
	            }
	        }
	        this.validationRequest.fire({
	            value: newValue,
	            editor: this
	        })
	    },
	    _validateValue: function(value) {
	        var text = this.option("text"),
	            hasText = !!text && null !== value,
	            isDate = !!value && !isNaN(value.getTime()),
	            isDateInRange = isDate && dateUtils.dateInRange(value, this.dateOption("min"), this.dateOption("max"), this.option("type")),
	            isValid = !hasText || !hasText && !value || isDateInRange,
	            validationMessage = "";
	        if (!isDate) {
	            validationMessage = this.option("invalidDateMessage")
	        } else {
	            if (!isDateInRange) {
	                validationMessage = this.option("dateOutOfRangeMessage")
	            }
	        }
	        this.option({
	            isValid: isValid,
	            validationError: isValid ? null : {
	                editorSpecific: true,
	                message: validationMessage
	            }
	        });
	        return isValid
	    },
	    _renderProps: function() {
	        this.callBase();
	        this._input().attr("autocomplete", "off")
	    },
	    _renderOpenedState: function() {
	        if (!this._isNativeType()) {
	            this.callBase()
	        }
	        if (this._strategy.isAdaptivityChanged()) {
	            this._refreshStrategy()
	        }
	        this._strategy.renderOpenedState()
	    },
	    _getPopupTitle: function() {
	        var placeholder = this.option("placeholder");
	        if (placeholder) {
	            return placeholder
	        }
	        var type = this.option("type");
	        if (type === TYPE.time) {
	            return messageLocalization.format("dxDateBox-simulatedDataPickerTitleTime")
	        }
	        if (type === TYPE.date || type === TYPE.datetime) {
	            return messageLocalization.format("dxDateBox-simulatedDataPickerTitleDate")
	        }
	        return ""
	    },
	    _renderPlaceholder: function() {
	        this._popup && this._popup.option("title", this._getPopupTitle());
	        this.callBase()
	    },
	    _refreshStrategy: function() {
	        this._strategy.dispose();
	        this._initStrategy();
	        this.option(this._strategy.getDefaultOptions());
	        this._refresh()
	    },
	    _applyButtonHandler: function() {
	        this.dateOption("value", this._strategy.getValue());
	        this.callBase()
	    },
	    _dispose: function() {
	        this._strategy && this._strategy.dispose();
	        this.callBase()
	    },
	    _isNativeType: function() {
	        return this._pickerType === PICKER_TYPE.native
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "useCalendar":
	                this._updatePickerOptions({
	                    useCalendar: args.value
	                });
	                this._refreshStrategy();
	                break;
	            case "useNative":
	                this._updatePickerOptions({
	                    useNative: args.value
	                });
	                this._refreshStrategy();
	                break;
	            case "showClearButton":
	                this.callBase.apply(this, arguments);
	                this._updateSize();
	                break;
	            case "pickerType":
	                this._updatePickerOptions({
	                    pickerType: args.value
	                });
	                this._refreshStrategy();
	                this._refreshPickerTypeClass();
	                this._invalidate();
	                break;
	            case "type":
	                this._updatePickerOptions({
	                    format: args.value
	                });
	                this._refreshStrategy();
	                this._refreshFormatClass();
	                this._renderPopupWrapper();
	                this._updateSize();
	                break;
	            case "placeholder":
	                this._renderPlaceholder();
	                break;
	            case "readOnly":
	            case "min":
	            case "max":
	            case "interval":
	            case "minZoomLevel":
	            case "maxZoomLevel":
	                this._invalidate();
	                break;
	            case "displayFormat":
	                this._updateValue();
	                break;
	            case "formatWidthCalculator":
	                break;
	            case "closeOnValueChange":
	                var applyValueMode = args.value ? "instantly" : "useButtons";
	                this.option("applyValueMode", applyValueMode);
	                break;
	            case "applyValueMode":
	                this._suppressDeprecatedWarnings();
	                this.option("closeOnValueChange", "instantly" === args.value);
	                this._resumeDeprecatedWarnings();
	                this.callBase.apply(this, arguments);
	                break;
	            case "text":
	                this._strategy.textChangedHandler(args.value);
	                this.callBase.apply(this, arguments);
	                break;
	            case "isValid":
	                this.callBase.apply(this, arguments);
	                this._updateSize();
	                break;
	            case "value":
	                this._validateValue(dateUtils.deserializeDate(this.option("value"), this._getSerializationFormat(this.option("value"))));
	                this.callBase.apply(this, arguments);
	                break;
	            case "showDropButton":
	            case "invalidDateMessage":
	            case "dateOutOfRangeMessage":
	            case "adaptivityEnabled":
	                break;
	            default:
	                this.callBase.apply(this, arguments)
	        }
	    },
	    _getSerializationFormat: function() {
	        var value = this.option("value");
	        if (commonUtils.isNumber(value)) {
	            return "number"
	        }
	        if (!commonUtils.isString(value)) {
	            return
	        }
	        return "date" === this.option("type") ? "yyyy'/'MM'/'dd" : "yyyy'/'MM'/'dd HH:mm:ss"
	    },
	    dateOption: function(optionName, value) {
	        var serializationFormat = this._getSerializationFormat();
	        if (1 === arguments.length) {
	            return dateUtils.deserializeDate(this.option(optionName), serializationFormat, $.proxy(dateLocalization.parse, dateLocalization))
	        }
	        this.option(optionName, dateUtils.serializeDate(value, serializationFormat, $.proxy(dateLocalization.format, dateLocalization)))
	    },
	    reset: function() {
	        this.callBase();
	        this._updateValue()
	    }
	});
	registerComponent("dxDateBox", DateBox);
	module.exports = DateBox;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_utils.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    dateLocalization = __webpack_require__(55);
	var dateComponents = function() {
	    return ["year", "day", "month", "day"]
	};
	var ONE_MINUTE = 6e4;
	var ONE_DAY = 60 * ONE_MINUTE * 24;
	var ONE_YEAR = 365 * ONE_DAY;
	var getStringFormat = function(format) {
	    var formatType = typeof format;
	    if ("string" === formatType) {
	        return "format"
	    }
	    if ("object" === formatType && void 0 !== format.type) {
	        return format.type
	    }
	    return null
	};
	var dateUtils = {
	    SUPPORTED_FORMATS: ["date", "time", "datetime"],
	    DEFAULT_FORMATTER: function(value) {
	        return value
	    },
	    DATE_COMPONENT_TEXT_FORMATTER: function(value, name) {
	        var $container = $("<div>").addClass("dx-dateview-formatter-container");
	        $("<span>").text(value).addClass("dx-dateview-value-formatter").appendTo($container);
	        $("<span>").text(name).addClass("dx-dateview-name-formatter").appendTo($container);
	        return $container
	    },
	    ONE_MINUTE: ONE_MINUTE,
	    ONE_DAY: ONE_DAY,
	    ONE_YEAR: ONE_YEAR,
	    MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
	    MAX_DATEVIEW_DEFAULT_DATE: function() {
	        var newDate = new Date;
	        return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59)
	    }(),
	    FORMATS_INFO: {
	        date: {
	            getStandardPattern: function() {
	                return "yyyy-MM-dd"
	            },
	            components: dateComponents()
	        },
	        time: {
	            getStandardPattern: function() {
	                return "HH':'mm"
	            },
	            components: ["hours", "minutes"]
	        },
	        datetime: {
	            getStandardPattern: function() {
	                var standardPattern;
	                ! function() {
	                    var androidFormatPattern = "yyyy-MM-ddTHH':'mm'Z'";
	                    var $input = $("<input>").attr("type", "datetime");
	                    $input.val(dateUtils.toStandardDateFormat(new Date, "datetime", androidFormatPattern));
	                    if ($input.val()) {
	                        standardPattern = androidFormatPattern
	                    }
	                }();
	                if (!standardPattern) {
	                    standardPattern = "yyyy-MM-ddTHH':'mm':'ss'Z'"
	                }
	                dateUtils.FORMATS_INFO.datetime.getStandardPattern = function() {
	                    return standardPattern
	                };
	                return standardPattern
	            },
	            components: dateComponents().concat(["hours", "minutes", "seconds", "milliseconds"])
	        },
	        "datetime-local": {
	            getStandardPattern: function() {
	                return "yyyy-MM-ddTHH':'mm':'ss"
	            },
	            components: dateComponents().concat(["hours", "minutes", "seconds"])
	        }
	    },
	    FORMATS_MAP: {
	        date: "shortdate",
	        time: "shorttime",
	        datetime: "shortdateshorttime",
	        "datetime-local": "datetime-local"
	    },
	    SUBMIT_FORMATS_MAP: {
	        date: "date",
	        time: "time",
	        datetime: "datetime-local"
	    },
	    toStandardDateFormat: function(date, mode, pattern) {
	        pattern = pattern || dateUtils.FORMATS_INFO[mode].getStandardPattern();
	        return dateLocalization.format(date, pattern)
	    },
	    fromStandardDateFormat: function(date) {
	        return dateLocalization.parse(date, dateUtils.FORMATS_INFO.datetime.getStandardPattern()) || dateLocalization.parse(date, dateUtils.FORMATS_INFO["datetime-local"].getStandardPattern()) || dateLocalization.parse(date, dateUtils.FORMATS_INFO.time.getStandardPattern()) || dateLocalization.parse(date, dateUtils.FORMATS_INFO.date.getStandardPattern()) || Date.parse && Date.parse(date) && new Date(Date.parse(date))
	    },
	    getMaxMonthDay: function(year, month) {
	        return new Date(year, month + 1, 0).getDate()
	    },
	    mergeDates: function(target, source, format) {
	        if (!source) {
	            return
	        }
	        if (isNaN(target.getTime())) {
	            target = new Date(0, 0, 0, 0, 0, 0)
	        }
	        var formatInfo = dateUtils.FORMATS_INFO[format];
	        $.each(formatInfo.components, function() {
	            var componentInfo = dateUtils.DATE_COMPONENTS_INFO[this];
	            target[componentInfo.setter](source[componentInfo.getter]())
	        });
	        return target
	    },
	    getLongestCaptionIndex: function(captionArray) {
	        var i, longestIndex = 0,
	            longestCaptionLength = 0;
	        for (i = 0; i < captionArray.length; ++i) {
	            if (captionArray[i].length > longestCaptionLength) {
	                longestIndex = i;
	                longestCaptionLength = captionArray[i].length
	            }
	        }
	        return longestIndex
	    },
	    formatUsesMonthName: function(format) {
	        return dateLocalization.formatUsesMonthName(format)
	    },
	    formatUsesDayName: function(format) {
	        return dateLocalization.formatUsesDayName(format)
	    },
	    getLongestDate: function(format, monthNames, dayNames) {
	        var stringFormat = getStringFormat(format),
	            month = 9;
	        if (!stringFormat || dateUtils.formatUsesMonthName(stringFormat)) {
	            month = dateUtils.getLongestCaptionIndex(monthNames)
	        }
	        var longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
	        if (!stringFormat || dateUtils.formatUsesDayName(stringFormat)) {
	            var date = longestDate.getDate() - longestDate.getDay() + dateUtils.getLongestCaptionIndex(dayNames);
	            longestDate.setDate(date)
	        }
	        return longestDate
	    }
	};
	dateUtils.DATE_COMPONENTS_INFO = {
	    year: {
	        getter: "getFullYear",
	        setter: "setFullYear",
	        formatter: dateUtils.DEFAULT_FORMATTER,
	        startValue: void 0,
	        endValue: void 0
	    },
	    day: {
	        getter: "getDate",
	        setter: "setDate",
	        formatter: function(value, showNames, date) {
	            if (!showNames) {
	                return value
	            }
	            var formatDate = new Date(date.getTime());
	            formatDate.setDate(value);
	            return dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value, dateLocalization.getDayNames()[formatDate.getDay()])
	        },
	        startValue: 1,
	        endValue: void 0
	    },
	    month: {
	        getter: "getMonth",
	        setter: "setMonth",
	        formatter: function(value, showNames) {
	            var monthName = dateLocalization.getMonthNames()[value];
	            return showNames ? dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value + 1, monthName) : monthName
	        },
	        startValue: 0,
	        endValue: 11
	    },
	    hours: {
	        getter: "getHours",
	        setter: "setHours",
	        formatter: function(value) {
	            return dateLocalization.format(new Date(0, 0, 0, value), "hour")
	        },
	        startValue: 0,
	        endValue: 23
	    },
	    minutes: {
	        getter: "getMinutes",
	        setter: "setMinutes",
	        formatter: function(value) {
	            return dateLocalization.format(new Date(0, 0, 0, 0, value), "minute")
	        },
	        startValue: 0,
	        endValue: 59
	    },
	    seconds: {
	        getter: "getSeconds",
	        setter: "setSeconds",
	        formatter: function(value) {
	            return dateLocalization.format(new Date(0, 0, 0, 0, 0, value), "second")
	        },
	        startValue: 0,
	        endValue: 59
	    },
	    milliseconds: {
	        getter: "getMilliseconds",
	        setter: "setMilliseconds",
	        formatter: function(value) {
	            return dateLocalization.format(new Date(0, 0, 0, 0, 0, 0, value), "millisecond")
	        },
	        startValue: 0,
	        endValue: 999
	    }
	};
	module.exports = dateUtils;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/drop_down_editor/ui.drop_down_editor.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    errors = __webpack_require__(15),
	    positionUtils = __webpack_require__(60),
	    messageLocalization = __webpack_require__(79),
	    Button = __webpack_require__(114),
	    eventUtils = __webpack_require__(61),
	    TextBox = __webpack_require__(230),
	    clickEvent = __webpack_require__(65),
	    Popup = __webpack_require__(113);
	var DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor",
	    DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS = "dx-dropdowneditor-input-wrapper",
	    DROP_DOWN_EDITOR_BUTTON_CLASS = "dx-dropdowneditor-button",
	    DROP_DOWN_EDITOR_BUTTON_ICON = "dx-dropdowneditor-icon",
	    DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay",
	    DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped",
	    DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active",
	    DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible",
	    DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
	var DropDownEditor = TextBox.inherit({
	    _supportedKeys: function() {
	        return $.extend({}, this.callBase(), {
	            tab: function(e) {
	                if (!this.option("opened")) {
	                    return
	                }
	                if ("instantly" === this.option("applyValueMode")) {
	                    this.close();
	                    return
	                }
	                var $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
	                $focusableElement && $focusableElement.focus();
	                e.preventDefault()
	            },
	            escape: function(e) {
	                if (this.option("opened")) {
	                    e.preventDefault()
	                }
	                this.close()
	            },
	            upArrow: function(e) {
	                e.preventDefault();
	                e.stopPropagation();
	                if (e.altKey) {
	                    this.close();
	                    return false
	                }
	                return true
	            },
	            downArrow: function(e) {
	                e.preventDefault();
	                e.stopPropagation();
	                if (e.altKey) {
	                    this._validatedOpening();
	                    return false
	                }
	                return true
	            },
	            enter: function(e) {
	                if (this.option("opened")) {
	                    e.preventDefault();
	                    this._valueChangeEventHandler(e)
	                }
	                return true
	            }
	        })
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            fieldEditEnabled: {
	                since: "16.1",
	                alias: "acceptCustomValue"
	            }
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            value: null,
	            onOpened: null,
	            onClosed: null,
	            opened: false,
	            acceptCustomValue: true,
	            applyValueMode: "instantly",
	            deferRendering: true,
	            activeStateEnabled: true,
	            fieldTemplate: null,
	            contentTemplate: null,
	            openOnFieldClick: false,
	            showDropButton: true,
	            popupPosition: this._getDefaultPopupPosition(),
	            onPopupInitialized: null,
	            applyButtonText: messageLocalization.format("OK"),
	            cancelButtonText: messageLocalization.format("Cancel"),
	            buttonsLocation: "default",
	            showPopupTitle: false
	        })
	    },
	    _getDefaultPopupPosition: function() {
	        var position = commonUtils.getDefaultAlignment(this.option("rtlEnabled"));
	        return {
	            offset: {
	                h: 0,
	                v: -1
	            },
	            my: position + " top",
	            at: position + " bottom",
	            collision: "flip flip"
	        }
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function(device) {
	                var isGeneric = "generic" === device.platform,
	                    isWin10 = "win" === device.platform && device.version && 10 === device.version[0];
	                return isGeneric || isWin10
	            },
	            options: {
	                popupPosition: {
	                    offset: {
	                        v: 0
	                    }
	                }
	            }
	        }])
	    },
	    _inputWrapper: function() {
	        return this.element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS)
	    },
	    _init: function() {
	        this.callBase();
	        this._initVisibilityActions();
	        this._initPopupInitializedAction()
	    },
	    _initVisibilityActions: function() {
	        this._openAction = this._createActionByOption("onOpened", {
	            excludeValidators: ["disabled", "readOnly"]
	        });
	        this._closeAction = this._createActionByOption("onClosed", {
	            excludeValidators: ["disabled", "readOnly"]
	        })
	    },
	    _initPopupInitializedAction: function() {
	        this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
	            excludeValidators: ["disabled", "readOnly", "designMode"]
	        })
	    },
	    _render: function() {
	        this.callBase();
	        this._renderOpenHandler();
	        this.element().addClass(DROP_DOWN_EDITOR_CLASS);
	        this._renderOpenedState();
	        this.setAria("role", "combobox")
	    },
	    _renderContentImpl: function() {
	        if (!this.option("deferRendering")) {
	            this._createPopup()
	        }
	    },
	    _renderInput: function() {
	        this.callBase();
	        this.element().wrapInner($("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS));
	        this._$container = this.element().children().eq(0);
	        this.setAria({
	            haspopup: "true",
	            autocomplete: "list"
	        })
	    },
	    _readOnlyPropValue: function() {
	        return !this.option("acceptCustomValue") || this.callBase()
	    },
	    _cleanFocusState: function() {
	        this.callBase();
	        if (this.option("fieldTemplate")) {
	            this._input().off("focusin focusout beforeactivate")
	        }
	    },
	    _renderField: function() {
	        var fieldTemplate = this._getTemplateByOption("fieldTemplate");
	        if (!(fieldTemplate && this.option("fieldTemplate"))) {
	            return
	        }
	        this._renderTemplatedField(fieldTemplate, this._fieldRenderData())
	    },
	    _renderTemplatedField: function(fieldTemplate, data) {
	        var isFocused = this._input().is(":focus");
	        this._resetFocus(isFocused);
	        var $container = this._$container;
	        $container.empty();
	        this._$dropButton = null;
	        this._$clearButton = null;
	        fieldTemplate.render({
	            model: data,
	            container: $container
	        });
	        if (!this._input().length) {
	            throw errors.Error("E1010")
	        }
	        this._refreshEvents();
	        this._refreshValueChangeEvent();
	        isFocused && this._input().focus();
	        this._renderFocusState()
	    },
	    _resetFocus: function(isFocused) {
	        this._cleanFocusState();
	        isFocused && this._input().focusout()
	    },
	    _fieldRenderData: function() {
	        return this.option("value")
	    },
	    _renderInputAddons: function() {
	        this._renderField();
	        this.callBase();
	        this._renderDropButton()
	    },
	    _renderDropButton: function() {
	        var dropButtonVisible = this.option("showDropButton");
	        this.element().toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, dropButtonVisible);
	        if (!dropButtonVisible) {
	            this._$dropButton && this._$dropButton.remove();
	            this._$dropButton = null;
	            return
	        }
	        if (!this._$dropButton) {
	            this._$dropButton = this._createDropButton().addClass(DROP_DOWN_EDITOR_BUTTON_CLASS)
	        }
	        this._attachDropButtonClickHandler();
	        this._$dropButton.prependTo(this._buttonsContainer())
	    },
	    _attachDropButtonClickHandler: function() {
	        if (this.option("showDropButton") && !this.option("openOnFieldClick")) {
	            this._$dropButton.dxButton("option", "onClick", $.proxy(this._openHandler, this))
	        }
	    },
	    _createDropButton: function() {
	        var $button = $("<div>");
	        this._createComponent($button, Button, {
	            focusStateEnabled: false,
	            disabled: this.option("readOnly"),
	            integrationOptions: {},
	            useInkRipple: false
	        });
	        var $buttonIcon = $("<div>").addClass(DROP_DOWN_EDITOR_BUTTON_ICON);
	        $button.append($buttonIcon).removeClass("dx-button").on("mousedown", function(e) {
	            e.preventDefault()
	        });
	        $button.find(".dx-button-content").remove();
	        return $button
	    },
	    _renderOpenHandler: function() {
	        var $inputWrapper = this.element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS);
	        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
	        $inputWrapper.off(eventName);
	        var openOnFieldClick = this.option("openOnFieldClick");
	        this.element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
	        if (openOnFieldClick) {
	            $inputWrapper.on(eventName, $.proxy(this._openHandler, this));
	            return
	        }
	    },
	    _openHandler: function() {
	        this._toggleOpenState()
	    },
	    _keyboardEventBindingTarget: function() {
	        return this._input()
	    },
	    _toggleOpenState: function(isVisible) {
	        if (this.option("disabled")) {
	            return
	        }
	        this._input().focus();
	        if (!this.option("readOnly")) {
	            isVisible = arguments.length ? isVisible : !this.option("opened");
	            this.option("opened", isVisible)
	        }
	    },
	    _renderOpenedState: function() {
	        var opened = this.option("opened");
	        if (opened) {
	            this._createPopup()
	        }
	        this.element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
	        this._setPopupOption("visible", opened);
	        this.setAria({
	            expanded: opened,
	            owns: (opened || void 0) && this._popupContentId
	        })
	    },
	    _createPopup: function() {
	        if (this._$popup) {
	            return
	        }
	        this._$popup = $("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).addClass(this.option("customOverlayCssClass")).appendTo(this.element());
	        this._renderPopup();
	        this._renderPopupContent()
	    },
	    _renderPopup: function() {
	        this._popup = this._createComponent(this._$popup, Popup, this._popupConfig());
	        this._popup.on({
	            showing: $.proxy(this._popupShowingHandler, this),
	            shown: $.proxy(this._popupShownHandler, this),
	            hiding: $.proxy(this._popupHidingHandler, this),
	            hidden: $.proxy(this._popupHiddenHandler, this)
	        });
	        this._popup.option("onContentReady", $.proxy(this._contentReadyHandler, this));
	        this._contentReadyHandler();
	        this._popupContentId = new Guid;
	        this.setAria("id", this._popupContentId, this._popup.content())
	    },
	    _contentReadyHandler: $.noop,
	    _popupConfig: function() {
	        return {
	            onInitialized: this._popupInitializedHandler(),
	            position: $.extend(this.option("popupPosition"), {
	                of: this.element()
	            }),
	            showTitle: this.option("showPopupTitle"),
	            width: "auto",
	            height: "auto",
	            shading: false,
	            closeOnTargetScroll: true,
	            closeOnOutsideClick: $.proxy(this._closeOutsideDropDownHandler, this),
	            animation: {
	                show: {
	                    type: "fade",
	                    duration: 0,
	                    from: 0,
	                    to: 1
	                },
	                hide: {
	                    type: "fade",
	                    duration: 400,
	                    from: 1,
	                    to: 0
	                }
	            },
	            deferRendering: false,
	            focusStateEnabled: false,
	            showCloseButton: false,
	            toolbarItems: this._getPopupToolbarItems(),
	            onPositioned: $.proxy(this._popupPositionedHandler, this),
	            fullScreen: false
	        }
	    },
	    _popupInitializedHandler: function() {
	        if (!this.option("onPopupInitialized")) {
	            return
	        }
	        return $.proxy(function(e) {
	            this._popupInitializedAction({
	                popup: e.component
	            })
	        }, this)
	    },
	    _popupPositionedHandler: function(e) {
	        this._popup.overlayContent().toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, e.position.v.flip)
	    },
	    _popupShowingHandler: $.noop,
	    _popupHidingHandler: function() {
	        this.option("opened", false)
	    },
	    _popupShownHandler: function() {
	        this._openAction();
	        if (this._$validationMessage) {
	            this._$validationMessage.dxOverlay("option", "position", this._getValidationMessagePosition())
	        }
	    },
	    _popupHiddenHandler: function() {
	        this._closeAction();
	        if (this._$validationMessage) {
	            this._$validationMessage.dxOverlay("option", "position", this._getValidationMessagePosition())
	        }
	    },
	    _getValidationMessagePosition: function() {
	        var positionRequest = "below";
	        if (this._popup && this._popup.option("visible")) {
	            var myTop = positionUtils.setup(this.element()).top,
	                popupTop = positionUtils.setup(this._popup.content()).top;
	            positionRequest = myTop + this.option("popupPosition").offset.v > popupTop ? "below" : "above"
	        }
	        return this.callBase(positionRequest)
	    },
	    _renderPopupContent: function() {
	        var contentTemplate = this._getTemplateByOption("contentTemplate");
	        if (!(contentTemplate && this.option("contentTemplate"))) {
	            return
	        }
	        var $popupContent = this._popup.content();
	        $popupContent.empty();
	        contentTemplate.render({
	            container: $popupContent
	        })
	    },
	    _closeOutsideDropDownHandler: function(e) {
	        var $target = $(e.target);
	        var isInputClicked = !!$target.closest(this.element()).length;
	        var isDropButtonClicked = !!$target.closest(this._$dropButton).length;
	        var isOutsideClick = !isInputClicked && !isDropButtonClicked;
	        return isOutsideClick
	    },
	    _clean: function() {
	        delete this._$dropButton;
	        if (this._$popup) {
	            this._$popup.remove();
	            delete this._$popup;
	            delete this._popup
	        }
	        this.callBase()
	    },
	    _setPopupOption: function(optionName, value) {
	        this._setWidgetOption("_popup", arguments)
	    },
	    _validatedOpening: function() {
	        if (!this.option("readOnly")) {
	            this._toggleOpenState(true)
	        }
	    },
	    _getPopupToolbarItems: function() {
	        return "useButtons" === this.option("applyValueMode") ? this._popupToolbarItemsConfig() : []
	    },
	    _getFirstPopupElement: function() {
	        return this._popup._wrapper().find(".dx-popup-done.dx-button")
	    },
	    _getLastPopupElement: function() {
	        return this._popup._wrapper().find(".dx-popup-cancel.dx-button")
	    },
	    _popupElementTabHandler: function(e) {
	        var $element = $(e.currentTarget);
	        if (e.shiftKey && $element.is(this._getFirstPopupElement()) || !e.shiftKey && $element.is(this._getLastPopupElement())) {
	            this._input().focus();
	            e.preventDefault()
	        }
	    },
	    _popupElementEscHandler: function() {
	        this._input().focus();
	        this.close()
	    },
	    _popupButtonInitializedHandler: function(e) {
	        e.component.registerKeyHandler("tab", $.proxy(this._popupElementTabHandler, this));
	        e.component.registerKeyHandler("escape", $.proxy(this._popupElementEscHandler, this))
	    },
	    _popupToolbarItemsConfig: function() {
	        var buttonsConfig = [{
	            shortcut: "done",
	            options: {
	                onClick: $.proxy(this._applyButtonHandler, this),
	                text: this.option("applyButtonText"),
	                onInitialized: $.proxy(this._popupButtonInitializedHandler, this)
	            }
	        }, {
	            shortcut: "cancel",
	            options: {
	                onClick: $.proxy(this._cancelButtonHandler, this),
	                text: this.option("cancelButtonText"),
	                onInitialized: $.proxy(this._popupButtonInitializedHandler, this)
	            }
	        }];
	        return this._applyButtonsLocation(buttonsConfig)
	    },
	    _applyButtonsLocation: function(buttonsConfig) {
	        var buttonsLocation = this.option("buttonsLocation"),
	            resultConfig = buttonsConfig;
	        if ("default" !== buttonsLocation) {
	            var position = commonUtils.splitPair(buttonsLocation);
	            $.each(resultConfig, function(_, element) {
	                $.extend(element, {
	                    toolbar: position[0],
	                    location: position[1]
	                })
	            })
	        }
	        return resultConfig
	    },
	    _applyButtonHandler: function() {
	        this.close();
	        this.option("focusStateEnabled") && this.focus()
	    },
	    _cancelButtonHandler: function() {
	        this.close();
	        this.option("focusStateEnabled") && this.focus()
	    },
	    _toggleReadOnlyState: function() {
	        this.callBase();
	        this._$dropButton && this._$dropButton.dxButton("option", "disabled", this.option("readOnly"))
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "opened":
	                this._renderOpenedState();
	                break;
	            case "onOpened":
	            case "onClosed":
	                this._initVisibilityActions();
	                break;
	            case "onPopupInitialized":
	                this._initPopupInitializedAction();
	                break;
	            case "fieldTemplate":
	                this._renderInputAddons();
	                break;
	            case "showDropButton":
	            case "contentTemplate":
	            case "acceptCustomValue":
	            case "openOnFieldClick":
	                this._invalidate();
	                break;
	            case "popupPosition":
	            case "deferRendering":
	                break;
	            case "applyValueMode":
	            case "applyButtonText":
	            case "cancelButtonText":
	            case "buttonsLocation":
	                this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
	                break;
	            case "showPopupTitle":
	                this._setPopupOption("showTitle", args.value);
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    open: function() {
	        this.option("opened", true)
	    },
	    close: function() {
	        this.option("opened", false)
	    },
	    reset: function() {
	        this.option("value", null)
	    },
	    field: function() {
	        return this._input()
	    },
	    content: function() {
	        return this._popup ? this._popup.content() : null
	    }
	});
	registerComponent("dxDropDownEditor", DropDownEditor);
	module.exports = DropDownEditor;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_box.strategy.calendar.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Calendar = __webpack_require__(245),
	    DateBoxStrategy = __webpack_require__(250),
	    dateUtils = __webpack_require__(51),
	    commonUtils = __webpack_require__(8),
	    messageLocalization = __webpack_require__(79);
	var CalendarStrategy = DateBoxStrategy.inherit({
	    NAME: "Calendar",
	    supportedKeys: function() {
	        return {
	            rightArrow: function() {
	                if (this.option("opened")) {
	                    return true
	                }
	            },
	            leftArrow: function() {
	                if (this.option("opened")) {
	                    return true
	                }
	            },
	            enter: $.proxy(function(e) {
	                if (this.dateBox.option("opened")) {
	                    e.preventDefault();
	                    if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
	                        var contouredDate = this._widget._view.option("contouredDate");
	                        contouredDate && this.dateBoxValue(contouredDate);
	                        this.dateBox.close();
	                        this.dateBox._valueChangeEventHandler(e)
	                    } else {
	                        return true
	                    }
	                }
	            }, this)
	        }
	    },
	    getDisplayFormat: function(displayFormat) {
	        return displayFormat || "shortdate"
	    },
	    _getWidgetName: function() {
	        return Calendar
	    },
	    _getWidgetOptions: function() {
	        return $.extend(this.dateBox.option("calendarOptions"), {
	            value: this.dateBoxValue() || null,
	            _keyboardProcessor: this._widgetKeyboardProcessor,
	            min: this.dateBox.dateOption("min"),
	            max: this.dateBox.dateOption("max"),
	            onValueChanged: $.proxy(this._valueChangedHandler, this),
	            onCellClick: $.proxy(this._cellClickHandler, this),
	            tabIndex: null,
	            maxZoomLevel: this.dateBox.option("maxZoomLevel"),
	            minZoomLevel: this.dateBox.option("minZoomLevel"),
	            onContouredChanged: $.proxy(this._refreshActiveDescendant, this),
	            hasFocus: function() {
	                return true
	            }
	        })
	    },
	    _refreshActiveDescendant: function(e) {
	        this.dateBox.setAria("activedescendant", e.actionValue)
	    },
	    popupConfig: function(popupConfig) {
	        var toolbarItems = popupConfig.toolbarItems,
	            buttonsLocation = this.dateBox.option("buttonsLocation");
	        var position = [];
	        if ("default" !== buttonsLocation) {
	            position = commonUtils.splitPair(buttonsLocation)
	        } else {
	            position = ["bottom", "center"]
	        }
	        if ("useButtons" === this.dateBox.option("applyValueMode")) {
	            toolbarItems.unshift({
	                widget: "dxButton",
	                toolbar: position[0],
	                location: "after" === position[1] ? "before" : position[1],
	                options: {
	                    onClick: $.proxy(function() {
	                        this._widget._toTodayView()
	                    }, this),
	                    text: messageLocalization.format("dxCalendar-todayButtonText"),
	                    type: "today"
	                }
	            })
	        }
	        return $.extend(true, popupConfig, {
	            toolbarItems: toolbarItems,
	            position: {
	                collision: "flipfit flip"
	            }
	        })
	    },
	    _valueChangedHandler: function(e) {
	        var dateBox = this.dateBox,
	            value = e.value,
	            prevValue = e.previousValue;
	        if (dateUtils.sameDate(value, prevValue)) {
	            return
	        }
	        if ("instantly" === dateBox.option("applyValueMode")) {
	            this.dateBoxValue(this.getValue())
	        }
	    },
	    _updateValue: function() {
	        if (!this._widget) {
	            return
	        }
	        this._widget.option("value", this.dateBoxValue())
	    },
	    textChangedHandler: function() {
	        if (this.dateBox.option("opened") && this._widget) {
	            this._updateValue(true)
	        }
	    },
	    _cellClickHandler: function() {
	        var dateBox = this.dateBox;
	        if ("instantly" === dateBox.option("applyValueMode")) {
	            dateBox.option("opened", false);
	            this.dateBoxValue(this.getValue())
	        }
	    },
	    dispose: function() {
	        this.dateBox.off("optionChanged");
	        this.callBase()
	    }
	});
	module.exports = CalendarStrategy;


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/calendar.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(246);
	module.exports.default = module.exports;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/calendar/ui.calendar.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    Button = __webpack_require__(114),
	    Editor = __webpack_require__(95),
	    Swipeable = __webpack_require__(209),
	    Navigator = __webpack_require__(247),
	    Views = __webpack_require__(248),
	    translator = __webpack_require__(59),
	    browser = __webpack_require__(16),
	    dateUtils = __webpack_require__(51),
	    devices = __webpack_require__(40),
	    fx = __webpack_require__(58),
	    dateLocalization = __webpack_require__(55),
	    config = __webpack_require__(9),
	    messageLocalization = __webpack_require__(79),
	    FunctionTemplate = __webpack_require__(87);
	var CALENDAR_CLASS = "dx-calendar",
	    CALENDAR_BODY_CLASS = "dx-calendar-body",
	    CALENDAR_CELL_CLASS = "dx-calendar-cell",
	    CALENDAR_FOOTER_CLASS = "dx-calendar-footer",
	    CALENDAR_TODAY_BUTTON_CLASS = "dx-calendar-today-button",
	    CALENDAR_HAS_FOOTER_CLASS = "dx-calendar-with-footer",
	    CALENDAR_VIEWS_WRAPPER_CLASS = "dx-calendar-views-wrapper",
	    CALENDAR_VIEW_CLASS = "dx-calendar-view",
	    FOCUSED_STATE_CLASS = "dx-state-focused",
	    ANIMATION_DURATION_SHOW_VIEW = 250,
	    POP_ANIMATION_FROM = .6,
	    POP_ANIMATION_TO = 1,
	    CALENDAR_INPUT_STANDARD_PATTERN = "yyyy-MM-dd",
	    CALENDAR_DATE_VALUE_KEY = "dxDateValueKey",
	    LEVEL_COMPARE_MAP = {
	        month: 3,
	        year: 2,
	        decade: 1,
	        century: 0
	    };
	var Calendar = Editor.inherit({
	    _activeStateUnit: "." + CALENDAR_CELL_CLASS,
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            hoverStateEnabled: true,
	            activeStateEnabled: true,
	            currentDate: new Date,
	            value: null,
	            min: new Date(1e3, 0),
	            max: new Date(3e3, 0),
	            firstDayOfWeek: void 0,
	            zoomLevel: "month",
	            maxZoomLevel: "month",
	            minZoomLevel: "century",
	            showTodayButton: false,
	            cellTemplate: "cell",
	            onCellClick: null,
	            onContouredChanged: null,
	            hasFocus: function(element) {
	                return element.hasClass(FOCUSED_STATE_CLASS)
	            }
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }])
	    },
	    _supportedKeys: function() {
	        return $.extend(this.callBase(), {
	            rightArrow: function(e) {
	                e.preventDefault();
	                if (e.ctrlKey) {
	                    this._waitRenderView(1)
	                } else {
	                    this._moveCurrentDate(1 * this._getRtlCorrection())
	                }
	            },
	            leftArrow: function(e) {
	                e.preventDefault();
	                if (e.ctrlKey) {
	                    this._waitRenderView(-1)
	                } else {
	                    this._moveCurrentDate(-1 * this._getRtlCorrection())
	                }
	            },
	            upArrow: function(e) {
	                e.preventDefault();
	                if (e.ctrlKey) {
	                    this._navigateUp()
	                } else {
	                    if (fx.isAnimating(this._view.element())) {
	                        return
	                    }
	                    this._moveCurrentDate(-1 * this._view.option("colCount"))
	                }
	            },
	            downArrow: function(e) {
	                e.preventDefault();
	                if (e.ctrlKey) {
	                    this._navigateDown()
	                } else {
	                    if (fx.isAnimating(this._view.element())) {
	                        return
	                    }
	                    this._moveCurrentDate(1 * this._view.option("colCount"))
	                }
	            },
	            home: function(e) {
	                e.preventDefault();
	                var zoomLevel = this.option("zoomLevel");
	                var currentDate = this.option("currentDate");
	                var min = this._dateOption("min");
	                var date = dateUtils.sameView(zoomLevel, currentDate, min) ? min : dateUtils.getViewFirstCellDate(zoomLevel, currentDate);
	                this.option("currentDate", date)
	            },
	            end: function(e) {
	                e.preventDefault();
	                var zoomLevel = this.option("zoomLevel");
	                var currentDate = this.option("currentDate");
	                var max = this._dateOption("max");
	                var date = dateUtils.sameView(zoomLevel, currentDate, max) ? max : dateUtils.getViewLastCellDate(zoomLevel, currentDate);
	                this.option("currentDate", date)
	            },
	            pageUp: function(e) {
	                e.preventDefault();
	                this._waitRenderView(-1)
	            },
	            pageDown: function(e) {
	                e.preventDefault();
	                this._waitRenderView(1)
	            },
	            tab: $.noop,
	            enter: function() {
	                if (!this._isMaxZoomLevel()) {
	                    this._navigateDown()
	                } else {
	                    var value = this._updateTimeComponent(this.option("currentDate"));
	                    this._dateOption("value", value)
	                }
	            }
	        })
	    },
	    _getSerializationFormat: function() {
	        var value = this.option("value");
	        if (commonUtils.isNumber(value)) {
	            return "number"
	        }
	        if (!commonUtils.isString(value)) {
	            return
	        }
	        return dateUtils.getDateSerializationFormat(value)
	    },
	    _convertToDate: function(value) {
	        var serializationFormat = this._getSerializationFormat();
	        var date = dateUtils.deserializeDate(value, serializationFormat, $.proxy(dateLocalization.parse, dateLocalization));
	        return date
	    },
	    _dateOption: function(optionName, optionValue) {
	        if (1 === arguments.length) {
	            return this._convertToDate(this.option(optionName))
	        }
	        var serializationFormat = this._getSerializationFormat();
	        this.option(optionName, dateUtils.serializeDate(optionValue, serializationFormat, $.proxy(dateLocalization.format, dateLocalization)))
	    },
	    _moveCurrentDate: function(offset) {
	        var currentDate = new Date(this.option("currentDate"));
	        var newDate = new Date(currentDate);
	        var zoomLevel = this.option("zoomLevel");
	        switch (zoomLevel) {
	            case "month":
	                newDate.setDate(currentDate.getDate() + offset);
	                break;
	            case "year":
	                newDate.setMonth(currentDate.getMonth() + offset);
	                break;
	            case "decade":
	                newDate.setFullYear(currentDate.getFullYear() + offset);
	                break;
	            case "century":
	                newDate.setFullYear(currentDate.getFullYear() + 10 * offset)
	        }
	        var offsetCorrection = 2 * offset / Math.abs(offset);
	        if (Math.abs(offset) > 1 && !dateUtils.sameView(zoomLevel, currentDate, newDate)) {
	            if ("decade" === zoomLevel) {
	                newDate.setFullYear(currentDate.getFullYear() + offset - offsetCorrection)
	            }
	            if ("century" === zoomLevel) {
	                newDate.setFullYear(currentDate.getFullYear() + 10 * (offset - offsetCorrection))
	            }
	        }
	        this.option("currentDate", newDate)
	    },
	    _init: function() {
	        this.callBase();
	        this._correctZoomLevel();
	        this._initCurrentDate();
	        this._initActions()
	    },
	    _correctZoomLevel: function() {
	        var minZoomLevel = this.option("minZoomLevel"),
	            maxZoomLevel = this.option("maxZoomLevel"),
	            zoomLevel = this.option("zoomLevel");
	        if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
	            return
	        }
	        if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
	            this.option("zoomLevel", maxZoomLevel)
	        } else {
	            if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
	                this.option("zoomLevel", minZoomLevel)
	            }
	        }
	    },
	    _initCurrentDate: function() {
	        var currentDate = this._getNormalizedDate(this._dateOption("value")) || this._getNormalizedDate(this.option("currentDate"));
	        this.option("currentDate", currentDate)
	    },
	    _getNormalizedDate: function(date) {
	        date = dateUtils.normalizeDate(date, this._getMinDate(), this._getMaxDate());
	        return commonUtils.isDefined(date) ? new Date(date) : date
	    },
	    _initActions: function() {
	        this._cellClickAction = this._createActionByOption("onCellClick");
	        this._onContouredChanged = this._createActionByOption("onContouredChanged")
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.cell = new FunctionTemplate(function(options) {
	            var data = options.model;
	            options.container.append($("<span>").text(data && data.text || String(data)))
	        }, this)
	    },
	    _updateCurrentDate: function(date) {
	        if (fx.isAnimating(this._$viewsWrapper)) {
	            fx.stop(this._$viewsWrapper, true)
	        }
	        var min = this._getMinDate(),
	            max = this._getMaxDate();
	        if (min > max) {
	            this.option("currentDate", new Date);
	            return
	        }
	        var normalizedDate = this._getNormalizedDate(date);
	        if (date.getTime() !== normalizedDate.getTime()) {
	            this.option("currentDate", new Date(normalizedDate));
	            return
	        }
	        var offset = this._getViewsOffset(this._view.option("date"), normalizedDate);
	        if (0 !== offset && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
	            offset = 0
	        }
	        if (this._view && 0 !== offset && !this._suppressNavigation) {
	            this._navigate(offset, normalizedDate)
	        } else {
	            this._renderNavigator();
	            this._setViewContoured(normalizedDate);
	            this._updateAriaId(normalizedDate)
	        }
	    },
	    _setViewContoured: function(date) {
	        if (this.option("hasFocus")(this._focusTarget())) {
	            this._view.option("contouredDate", date)
	        }
	    },
	    _getMinDate: function() {
	        if (this.min) {
	            return this.min
	        }
	        this.min = this._dateOption("min") || new Date(1e3, 0);
	        return this.min
	    },
	    _getMaxDate: function() {
	        if (this.max) {
	            return this.max
	        }
	        this.max = this._dateOption("max") || new Date(3e3, 0);
	        return this.max
	    },
	    _getViewsOffset: function(startDate, endDate) {
	        var zoomLevel = this.option("zoomLevel");
	        if ("month" === zoomLevel) {
	            return this._getMonthsOffset(startDate, endDate)
	        }
	        var zoomCorrection;
	        switch (zoomLevel) {
	            case "century":
	                zoomCorrection = 100;
	                break;
	            case "decade":
	                zoomCorrection = 10;
	                break;
	            default:
	                zoomCorrection = 1
	        }
	        return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection)
	    },
	    _getMonthsOffset: function(startDate, endDate) {
	        var yearOffset = endDate.getFullYear() - startDate.getFullYear(),
	            monthOffset = endDate.getMonth() - startDate.getMonth();
	        return 12 * yearOffset + monthOffset
	    },
	    _waitRenderView: function(offset) {
	        if (this._alreadyViewRender) {
	            return
	        }
	        this._alreadyViewRender = true;
	        var date = this._getDateByOffset(offset * this._getRtlCorrection());
	        this.option("currentDate", date);
	        setTimeout($.proxy(function() {
	            this._alreadyViewRender = false
	        }, this))
	    },
	    _getRtlCorrection: function() {
	        return this.option("rtlEnabled") ? -1 : 1
	    },
	    _getDateByOffset: function(offset, date) {
	        date = new Date(date || this.option("currentDate"));
	        var currentDay = date.getDate();
	        var difference = dateUtils.getDifferenceInMonth(this.option("zoomLevel")) * offset;
	        date.setDate(1);
	        date.setMonth(date.getMonth() + difference);
	        var lastDay = dateUtils.getLastMonthDate(date).getDate();
	        date.setDate(currentDay > lastDay ? lastDay : currentDay);
	        return date
	    },
	    _focusTarget: function() {
	        return this.element()
	    },
	    _render: function() {
	        this._renderSubmitElement();
	        this.callBase();
	        var $element = this.element();
	        $element.addClass(CALENDAR_CLASS);
	        this._renderBody();
	        $element.append(this.$body);
	        this._renderViews();
	        this._renderNavigator();
	        this._renderSwipeable();
	        this._renderFooter();
	        this.setAria({
	            role: "listbox",
	            label: messageLocalization.format("dxCalendar-ariaWidgetName")
	        });
	        this._updateAriaSelected();
	        this._updateAriaId();
	        this._setViewContoured(this.option("currentDate"));
	        $element.append(this._navigator.element())
	    },
	    _renderBody: function() {
	        if (!this._$viewsWrapper) {
	            this.$body = $("<div>").addClass(CALENDAR_BODY_CLASS);
	            this._$viewsWrapper = $("<div>").addClass(CALENDAR_VIEWS_WRAPPER_CLASS);
	            this.$body.append(this._$viewsWrapper)
	        }
	    },
	    _renderViews: function() {
	        this.element().addClass(CALENDAR_VIEW_CLASS + "-" + this.option("zoomLevel"));
	        var currentDate = this.option("currentDate");
	        this._view = this._renderSpecificView(currentDate);
	        this._view.option("_keyboardProcessor", this._viewKeyboardProcessor);
	        var beforeDate = this._getDateByOffset(-1, currentDate);
	        this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
	        var afterDate = this._getDateByOffset(1, currentDate);
	        this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
	        this._translateViews()
	    },
	    _renderSpecificView: function(date) {
	        var specificView = Views[this.option("zoomLevel")],
	            $view = $("<div>").appendTo(this._$viewsWrapper),
	            config = this._viewConfig(date);
	        return new specificView($view, config)
	    },
	    _viewConfig: function(date) {
	        return {
	            date: date,
	            min: this._getMinDate(),
	            max: this._getMaxDate(),
	            firstDayOfWeek: this.option("firstDayOfWeek"),
	            value: this._dateOption("value"),
	            rtl: this.option("rtlEnabled"),
	            disabled: this.option("disabled") || config().designMode,
	            tabIndex: void 0,
	            focusStateEnabled: this.option("focusStateEnabled"),
	            hoverStateEnabled: this.option("hoverStateEnabled"),
	            onCellClick: $.proxy(this._cellClickHandler, this),
	            cellTemplate: this._getTemplateByOption("cellTemplate"),
	            allowValueSelection: this._isMaxZoomLevel()
	        }
	    },
	    _isViewAvailable: function(date) {
	        var zoomLevel = this.option("zoomLevel");
	        var min = dateUtils.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
	        var max = dateUtils.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
	        return dateUtils.dateInRange(date, min, max)
	    },
	    _translateViews: function() {
	        translator.move(this._view.element(), {
	            left: 0,
	            top: 0
	        });
	        this._beforeView && translator.move(this._beforeView.element(), {
	            left: this._getViewPosition(-1),
	            top: 0
	        });
	        this._afterView && translator.move(this._afterView.element(), {
	            left: this._getViewPosition(1),
	            top: 0
	        })
	    },
	    _getViewPosition: function(coefficient) {
	        var rtlCorrection = this.option("rtlEnabled") && !(browser.msie && "8" !== browser.version[0]) ? -1 : 1;
	        return 100 * coefficient * rtlCorrection + "%"
	    },
	    _cellClickHandler: function(e) {
	        var zoomLevel = this.option("zoomLevel"),
	            nextView = dateUtils.getViewDown(zoomLevel);
	        var isMaxZoomLevel = this._isMaxZoomLevel();
	        if (nextView && !isMaxZoomLevel) {
	            this._navigateDown(e.jQueryEvent.currentTarget)
	        } else {
	            var newValue = this._updateTimeComponent(e.value);
	            this._dateOption("value", newValue);
	            this._cellClickAction(e)
	        }
	    },
	    _updateTimeComponent: function(date) {
	        var result = new Date(date);
	        var currentValue = this._dateOption("value");
	        if (currentValue) {
	            result.setHours(currentValue.getHours());
	            result.setMinutes(currentValue.getMinutes());
	            result.setSeconds(currentValue.getSeconds());
	            result.setMilliseconds(currentValue.getMilliseconds())
	        }
	        return result
	    },
	    _isMaxZoomLevel: function() {
	        return this.option("zoomLevel") === this.option("maxZoomLevel")
	    },
	    _navigateDown: function(cell) {
	        var zoomLevel = this.option("zoomLevel");
	        if (this._isMaxZoomLevel()) {
	            return
	        }
	        var nextView = dateUtils.getViewDown(zoomLevel);
	        if (!nextView) {
	            return
	        }
	        var newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
	        if (cell) {
	            newCurrentDate = $(cell).data(CALENDAR_DATE_VALUE_KEY)
	        }
	        this._isOtherViewCellClicked = true;
	        this.option("currentDate", newCurrentDate);
	        this.option("zoomLevel", nextView);
	        this._isOtherViewCellClicked = false;
	        this._renderNavigator();
	        this._animateShowView();
	        this._setViewContoured(this._getNormalizedDate(newCurrentDate))
	    },
	    _renderNavigator: function() {
	        if (!this._navigator) {
	            this._navigator = new Navigator($("<div>"), this._navigatorConfig())
	        }
	        this._navigator.option("text", this._view.getNavigatorCaption());
	        this._updateButtonsVisibility()
	    },
	    _navigatorConfig: function() {
	        return {
	            text: this._view.getNavigatorCaption(),
	            onClick: $.proxy(this._navigatorClickHandler, this),
	            onCaptionClick: $.proxy(this._navigateUp, this),
	            rtlEnabled: this.option("rtlEnabled")
	        }
	    },
	    _navigatorClickHandler: function(e) {
	        var currentDate = this._getDateByOffset(e.direction, this.option("currentDate"));
	        this.option("currentDate", currentDate);
	        this._updateNavigatorCaption(-e.direction * this._getRtlCorrection())
	    },
	    _navigateUp: function() {
	        var zoomLevel = this.option("zoomLevel"),
	            nextView = dateUtils.getViewUp(zoomLevel);
	        if (!nextView || this._isMinZoomLevel(zoomLevel)) {
	            return
	        }
	        var contouredDate = this._view.option("contouredDate");
	        this.option("zoomLevel", nextView);
	        this.option("currentDate", contouredDate || this._view.option("date"));
	        this._renderNavigator();
	        this._animateShowView().done($.proxy(function() {
	            this._setViewContoured(contouredDate)
	        }, this))
	    },
	    _isMinZoomLevel: function(zoomLevel) {
	        var min = this._getMinDate(),
	            max = this._getMaxDate();
	        return dateUtils.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel
	    },
	    _updateButtonsVisibility: function() {
	        this._navigator.toggleButton("next", !commonUtils.isDefined(this._getRequiredView("next")));
	        this._navigator.toggleButton("prev", !commonUtils.isDefined(this._getRequiredView("prev")))
	    },
	    _renderSwipeable: function() {
	        if (!this._swipeable) {
	            this._swipeable = this._createComponent(this.element(), Swipeable, {
	                onStart: $.proxy(this._swipeStartHandler, this),
	                onUpdated: $.proxy(this._swipeUpdateHandler, this),
	                onEnd: $.proxy(this._swipeEndHandler, this),
	                itemSizeFunc: $.proxy(this._viewWidth, this)
	            })
	        }
	    },
	    _swipeStartHandler: function(e) {
	        fx.stop(this._$viewsWrapper, true);
	        e.jQueryEvent.maxLeftOffset = this._getRequiredView("next") ? 1 : 0;
	        e.jQueryEvent.maxRightOffset = this._getRequiredView("prev") ? 1 : 0
	    },
	    _getRequiredView: function(name) {
	        var view;
	        var isRtl = this.option("rtlEnabled");
	        if ("next" === name) {
	            view = isRtl ? this._beforeView : this._afterView
	        } else {
	            if ("prev" === name) {
	                view = isRtl ? this._afterView : this._beforeView
	            }
	        }
	        return view
	    },
	    _swipeUpdateHandler: function(e) {
	        var offset = e.jQueryEvent.offset;
	        translator.move(this._$viewsWrapper, {
	            left: offset * this._viewWidth(),
	            top: 0
	        });
	        this._updateNavigatorCaption(offset)
	    },
	    _swipeEndHandler: function(e) {
	        var targetOffset = e.jQueryEvent.targetOffset,
	            moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
	        if (0 === moveOffset) {
	            this._animateWrapper(0, ANIMATION_DURATION_SHOW_VIEW);
	            return
	        }
	        var date = this._getDateByOffset(-moveOffset * this._getRtlCorrection());
	        if (this._isDateInInvalidRange(date)) {
	            if (moveOffset >= 0) {
	                date = new Date(this._getMinDate())
	            } else {
	                date = new Date(this._getMaxDate())
	            }
	        }
	        this.option("currentDate", date)
	    },
	    _viewWidth: function() {
	        if (!this._viewWidthValue) {
	            this._viewWidthValue = this.element().width()
	        }
	        return this._viewWidthValue
	    },
	    _updateNavigatorCaption: function(offset) {
	        offset *= this._getRtlCorrection();
	        var view = this._view;
	        if (offset > .5 && this._beforeView) {
	            view = this._beforeView
	        } else {
	            if (offset < -.5 && this._afterView) {
	                view = this._afterView
	            }
	        }
	        this._navigator.option("text", view.getNavigatorCaption())
	    },
	    _isDateInInvalidRange: function(date) {
	        if (this._view.isBoundary(date)) {
	            return
	        }
	        var min = this._getMinDate(),
	            max = this._getMaxDate(),
	            normalizedDate = dateUtils.normalizeDate(date, min, max);
	        return normalizedDate === min || normalizedDate === max
	    },
	    _renderFooter: function() {
	        var showTodayButton = this.option("showTodayButton");
	        if (showTodayButton) {
	            var $todayButton = this._createComponent($("<a>"), Button, {
	                focusStateEnabled: false,
	                text: messageLocalization.format("dxCalendar-todayButtonText"),
	                onClick: $.proxy(function() {
	                    this._toTodayView()
	                }, this),
	                integrationOptions: {}
	            }).element().addClass(CALENDAR_TODAY_BUTTON_CLASS);
	            this._$footer = $("<div>").addClass(CALENDAR_FOOTER_CLASS).append($todayButton);
	            this.element().append(this._$footer)
	        }
	        this.element().toggleClass(CALENDAR_HAS_FOOTER_CLASS, showTodayButton)
	    },
	    _renderSubmitElement: function() {
	        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element());
	        this._setSubmitValue(this.option("value"))
	    },
	    _setSubmitValue: function(value) {
	        var dateValue = this._convertToDate(value);
	        this._$submitElement.val(dateLocalization.format(dateValue, CALENDAR_INPUT_STANDARD_PATTERN))
	    },
	    _getSubmitElement: function() {
	        return this._$submitElement
	    },
	    _animateShowView: function() {
	        fx.stop(this._view.element(), true);
	        return this._popAnimationView(this._view, POP_ANIMATION_FROM, POP_ANIMATION_TO, ANIMATION_DURATION_SHOW_VIEW).promise()
	    },
	    _popAnimationView: function(view, from, to, duration) {
	        return fx.animate(view.element(), {
	            type: "pop",
	            from: {
	                scale: from,
	                opacity: from
	            },
	            to: {
	                scale: to,
	                opacity: to
	            },
	            duration: duration
	        })
	    },
	    _navigate: function(offset, value) {
	        if (0 !== offset && 1 !== Math.abs(offset) && this._isViewAvailable(value)) {
	            var newView = this._renderSpecificView(value);
	            if (offset > 0) {
	                this._afterView && this._afterView.element().remove();
	                this._afterView = newView
	            } else {
	                this._beforeView && this._beforeView.element().remove();
	                this._beforeView = newView
	            }
	            this._translateViews()
	        }
	        var rtlCorrection = this._getRtlCorrection(),
	            offsetSign = offset > 0 ? 1 : offset < 0 ? -1 : 0,
	            endPosition = -rtlCorrection * offsetSign * this._viewWidth();
	        var viewsWrapperPosition = this._$viewsWrapper.position().left;
	        if (viewsWrapperPosition !== endPosition) {
	            if (this._preventViewChangeAnimation) {
	                this._wrapperAnimationEndHandler(offset, value)
	            } else {
	                this._animateWrapper(endPosition, ANIMATION_DURATION_SHOW_VIEW).done($.proxy(this._wrapperAnimationEndHandler, this, offset, value))
	            }
	        }
	    },
	    _animateWrapper: function(to, duration) {
	        return fx.animate(this._$viewsWrapper, {
	            type: "slide",
	            from: {
	                left: this._$viewsWrapper.position().left
	            },
	            to: {
	                left: to
	            },
	            duration: duration
	        })
	    },
	    _toTodayView: function() {
	        var today = new Date;
	        if (this._isMaxZoomLevel()) {
	            this._dateOption("value", today);
	            return
	        }
	        this._preventViewChangeAnimation = true;
	        this.option("zoomLevel", this.option("maxZoomLevel"));
	        this._dateOption("value", today);
	        this._animateShowView();
	        this._preventViewChangeAnimation = false
	    },
	    _wrapperAnimationEndHandler: function(offset, newDate) {
	        this._rearrangeViews(offset);
	        this._translateViews();
	        this._resetLocation();
	        this._renderNavigator();
	        this._setViewContoured(newDate);
	        this._updateAriaId(newDate)
	    },
	    _rearrangeViews: function(offset) {
	        if (0 === offset) {
	            return
	        }
	        var viewOffset, viewToCreateKey, viewToRemoveKey;
	        if (offset < 0) {
	            viewOffset = 1;
	            viewToCreateKey = "_beforeView";
	            viewToRemoveKey = "_afterView"
	        } else {
	            viewOffset = -1;
	            viewToCreateKey = "_afterView";
	            viewToRemoveKey = "_beforeView"
	        }
	        if (!this[viewToCreateKey]) {
	            return
	        }
	        var destinationDate = this[viewToCreateKey].option("date");
	        if (this[viewToRemoveKey]) {
	            this[viewToRemoveKey].element().remove()
	        }
	        if (offset === viewOffset) {
	            this[viewToRemoveKey] = this._view
	        } else {
	            this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset, destinationDate));
	            this._view.element().remove()
	        }
	        this._view = this[viewToCreateKey];
	        var dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
	        this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null
	    },
	    _resetLocation: function() {
	        translator.move(this._$viewsWrapper, {
	            left: 0,
	            top: 0
	        })
	    },
	    _clean: function() {
	        this.callBase();
	        this._clearViewWidthCache();
	        delete this._$viewsWrapper;
	        delete this._navigator;
	        delete this._$footer
	    },
	    _clearViewWidthCache: function() {
	        delete this._viewWidthValue
	    },
	    _disposeViews: function() {
	        this._view.element().remove();
	        this._beforeView && this._beforeView.element().remove();
	        this._afterView && this._afterView.element().remove();
	        delete this._view;
	        delete this._beforeView;
	        delete this._afterView
	    },
	    _refreshViews: function() {
	        this._disposeViews();
	        this._renderViews()
	    },
	    _visibilityChanged: function() {
	        this._translateViews()
	    },
	    _focusInHandler: function() {
	        this.callBase.apply(this, arguments);
	        this._view.option("contouredDate", this.option("currentDate"))
	    },
	    _focusOutHandler: function() {
	        this.callBase.apply(this, arguments);
	        this._view.option("contouredDate", null)
	    },
	    _updateViewsValue: function(value) {
	        var newValue = value ? new Date(value) : null;
	        this._view.option("value", newValue);
	        this._beforeView && this._beforeView.option("value", newValue);
	        this._afterView && this._afterView.option("value", newValue)
	    },
	    _updateAriaSelected: function(value, previousValue) {
	        value = value || this._dateOption("value");
	        var $prevSelectedCell = this._view._getCellByDate(previousValue);
	        var $selectedCell = this._view._getCellByDate(value);
	        this.setAria("selected", void 0, $prevSelectedCell);
	        this.setAria("selected", true, $selectedCell);
	        if (value && this.option("currentDate").getTime() === value.getTime()) {
	            this._updateAriaId(value)
	        }
	    },
	    _updateAriaId: function(value) {
	        value = value || this.option("currentDate");
	        var ariaId = new Guid;
	        var $newCell = this._view._getCellByDate(value);
	        this.setAria("id", ariaId, $newCell);
	        this.setAria("activedescendant", ariaId);
	        this._onContouredChanged(ariaId)
	    },
	    _suppressingNavigation: function(callback, args) {
	        this._suppressNavigation = true;
	        callback.apply(this, args);
	        delete this._suppressNavigation
	    },
	    _optionChanged: function(args) {
	        var value = args.value;
	        var previousValue = args.previousValue;
	        switch (args.name) {
	            case "width":
	                this.callBase(args);
	                this._clearViewWidthCache();
	                break;
	            case "min":
	            case "max":
	                this.min = void 0;
	                this.max = void 0;
	                this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
	                this._refreshViews();
	                this._renderNavigator();
	                break;
	            case "firstDayOfWeek":
	                this._refreshViews();
	                this._updateButtonsVisibility();
	                break;
	            case "currentDate":
	                this.setAria("id", void 0, this._view._getCellByDate(previousValue));
	                this._updateCurrentDate(value);
	                break;
	            case "zoomLevel":
	                this.element().removeClass(CALENDAR_VIEW_CLASS + "-" + previousValue);
	                this._correctZoomLevel();
	                this._refreshViews();
	                this._renderNavigator();
	                this._updateAriaId();
	                break;
	            case "minZoomLevel":
	            case "maxZoomLevel":
	                this._correctZoomLevel();
	                this._updateButtonsVisibility();
	                break;
	            case "value":
	                value = this._convertToDate(value);
	                previousValue = this._convertToDate(previousValue);
	                this._updateAriaSelected(value, previousValue);
	                this.option("currentDate", commonUtils.isDefined(value) ? new Date(value) : new Date);
	                this._updateViewsValue(value);
	                this._setSubmitValue(value);
	                this.callBase(args);
	                break;
	            case "disabled":
	                this._view.option("disabled", value);
	                this.callBase(args);
	                break;
	            case "showTodayButton":
	                this._invalidate();
	                break;
	            case "onCellClick":
	                this._view.option("onCellClick", value);
	                break;
	            case "onContouredChanged":
	                this._onContouredChanged = this._createActionByOption("onContouredChanged");
	                break;
	            case "cellTemplate":
	                this._invalidate();
	                break;
	            case "hasFocus":
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxCalendar", Calendar);
	module.exports = Calendar;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/calendar/ui.calendar.navigator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Widget = __webpack_require__(84),
	    Button = __webpack_require__(114);
	var CALENDAR_NAVIGATOR_CLASS = "dx-calendar-navigator",
	    CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS = "dx-calendar-navigator-previous-month",
	    CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS = "dx-calendar-navigator-next-month",
	    CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS = "dx-calendar-navigator-previous-view",
	    CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS = "dx-calendar-navigator-next-view",
	    CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS = "dx-calendar-disabled-navigator-link",
	    CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS = "dx-calendar-caption-button";
	var Navigator = Widget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            onClick: null,
	            onCaptionClick: null,
	            text: ""
	        })
	    },
	    _init: function() {
	        this.callBase();
	        this._initActions()
	    },
	    _initActions: function() {
	        this._clickAction = this._createActionByOption("onClick");
	        this._captionClickAction = this._createActionByOption("onCaptionClick")
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(CALENDAR_NAVIGATOR_CLASS);
	        this._renderButtons();
	        this._renderCaption()
	    },
	    _renderButtons: function() {
	        var that = this,
	            direction = this.option("rtlEnabled") ? -1 : 1;
	        this._prevButton = this._createComponent($("<a>"), Button, {
	            focusStateEnabled: false,
	            icon: "chevronleft",
	            onClick: function(e) {
	                that._clickAction({
	                    direction: -direction,
	                    jQueryEvent: e
	                })
	            },
	            integrationOptions: {}
	        });
	        var $prevButton = this._prevButton.element().addClass(CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS);
	        this._nextButton = this._createComponent($("<a>"), Button, {
	            focusStateEnabled: false,
	            icon: "chevronright",
	            onClick: function(e) {
	                that._clickAction({
	                    direction: direction,
	                    jQueryEvent: e
	                })
	            },
	            integrationOptions: {}
	        });
	        var $nextButton = this._nextButton.element().addClass(CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS);
	        this._caption = this._createComponent($("<a>").addClass(CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS), Button, {
	            focusStateEnabled: false,
	            onClick: function(e) {
	                that._captionClickAction({
	                    jQueryEvent: e
	                })
	            },
	            integrationOptions: {}
	        });
	        var $caption = this._caption.element();
	        this.element().append($prevButton, $caption, $nextButton)
	    },
	    _renderCaption: function() {
	        this._caption.option("text", this.option("text"))
	    },
	    toggleButton: function(buttonPrefix, value) {
	        var buttonName = "_" + buttonPrefix + "Button",
	            button = this[buttonName];
	        if (button) {
	            button.option("disabled", value);
	            button.element().toggleClass(CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS, value)
	        }
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "text":
	                this._renderCaption();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	module.exports = Navigator;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/calendar/ui.calendar.views.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    BaseView = __webpack_require__(249),
	    dateUtils = __webpack_require__(51),
	    dateLocalization = __webpack_require__(55);
	var CALENDAR_OTHER_MONTH_CLASS = "dx-calendar-other-month",
	    CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view";
	var Views = {
	    month: BaseView.inherit({
	        _getViewName: function() {
	            return "month"
	        },
	        _getDefaultOptions: function() {
	            return $.extend(this.callBase(), {
	                firstDayOfWeek: void 0,
	                rowCount: 6,
	                colCount: 7
	            })
	        },
	        _renderImpl: function() {
	            this.callBase();
	            this._renderHeader()
	        },
	        _renderBody: function() {
	            this.callBase();
	            this._$table.find("." + CALENDAR_OTHER_VIEW_CLASS).addClass(CALENDAR_OTHER_MONTH_CLASS)
	        },
	        _renderFocusTarget: $.noop,
	        getCellAriaLabel: function(date) {
	            return dateLocalization.format(date, "longdate")
	        },
	        _renderHeader: function() {
	            var that = this;
	            var $header = $("<thead>");
	            this._$table.prepend($header);
	            var $headerRow = $("<tr>");
	            $header.append($headerRow);
	            var appendCell = this.option("rtl") ? function(row, cell) {
	                row.prepend(cell)
	            } : function(row, cell) {
	                row.append(cell)
	            };
	            this._iterateCells(this.option("colCount"), function(i) {
	                var $cell = $("<th>").text(that._getDayCaption(that._getFirstDayOfWeek() + i));
	                appendCell($headerRow, $cell)
	            })
	        },
	        getNavigatorCaption: function() {
	            return dateLocalization.format(this.option("date"), "monthandyear")
	        },
	        _isTodayCell: function(cellDate) {
	            var today = new Date;
	            return dateUtils.sameDate(cellDate, today)
	        },
	        _isDateOutOfRange: function(cellDate) {
	            var minDate = this.option("min"),
	                maxDate = this.option("max");
	            return !dateUtils.dateInRange(cellDate, minDate, maxDate, "date")
	        },
	        _isOtherView: function(cellDate) {
	            return cellDate.getMonth() !== this.option("date").getMonth()
	        },
	        _getCellText: function(cellDate) {
	            return cellDate.getDate()
	        },
	        _getDayCaption: function(day) {
	            var daysInWeek = this.option("colCount");
	            return dateLocalization.getDayNames("abbreviated")[day % daysInWeek]
	        },
	        _getFirstCellData: function() {
	            var firstDay = dateUtils.getFirstMonthDate(this.option("date")),
	                firstMonthDayOffset = this._getFirstDayOfWeek() - firstDay.getDay(),
	                daysInWeek = this.option("colCount");
	            if (firstMonthDayOffset >= 0) {
	                firstMonthDayOffset -= daysInWeek
	            }
	            firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
	            return firstDay
	        },
	        _getNextCellData: function(date) {
	            date = new Date(date);
	            date.setDate(date.getDate() + 1);
	            return date
	        },
	        _getFirstDayOfWeek: function() {
	            return this.option("firstDayOfWeek") || dateLocalization.firstDayOfWeekIndex()
	        },
	        _getCellByDate: function(date) {
	            return this._$table.find("td[data-value='" + dateLocalization.format(date, dateUtils.getShortDateFormat()) + "']")
	        },
	        isBoundary: function(date) {
	            return dateUtils.sameMonthAndYear(date, this.option("min")) || dateUtils.sameMonthAndYear(date, this.option("max"))
	        }
	    }),
	    year: BaseView.inherit({
	        _getViewName: function() {
	            return "year"
	        },
	        _isTodayCell: function(cellDate) {
	            return dateUtils.sameMonthAndYear(cellDate, new Date)
	        },
	        _isDateOutOfRange: function(cellDate) {
	            return !dateUtils.dateInRange(cellDate, dateUtils.getFirstMonthDate(this.option("min")), dateUtils.getLastMonthDate(this.option("max")))
	        },
	        _isOtherView: function() {
	            return false
	        },
	        _getCellText: function(cellDate) {
	            return dateLocalization.getMonthNames()[cellDate.getMonth()].slice(0, 3)
	        },
	        _getFirstCellData: function() {
	            var data = new Date(this.option("date"));
	            data.setDate(1);
	            data.setMonth(0);
	            return data
	        },
	        _getNextCellData: function(date) {
	            date = new Date(date);
	            date.setMonth(date.getMonth() + 1);
	            return date
	        },
	        _getCellByDate: function(date) {
	            var foundDate = new Date(date);
	            foundDate.setDate(1);
	            return this._$table.find("td[data-value='" + dateLocalization.format(foundDate, dateUtils.getShortDateFormat()) + "']")
	        },
	        getCellAriaLabel: function(date) {
	            return dateLocalization.format(date, "monthandyear")
	        },
	        getNavigatorCaption: function() {
	            return this.option("date").getFullYear()
	        },
	        isBoundary: function(date) {
	            return dateUtils.sameYear(date, this.option("min")) || dateUtils.sameYear(date, this.option("max"))
	        }
	    }),
	    decade: BaseView.inherit({
	        _getViewName: function() {
	            return "decade"
	        },
	        _isTodayCell: function(cellDate) {
	            return dateUtils.sameYear(cellDate, new Date)
	        },
	        _isDateOutOfRange: function(cellDate) {
	            var min = this.option("min"),
	                max = this.option("max");
	            return !dateUtils.dateInRange(cellDate.getFullYear(), min && min.getFullYear(), max && max.getFullYear())
	        },
	        _isOtherView: function(cellDate) {
	            var date = new Date(cellDate);
	            date.setMonth(1);
	            return !dateUtils.sameDecade(date, this.option("date"))
	        },
	        _getCellText: function(cellDate) {
	            return cellDate.getFullYear()
	        },
	        _getFirstCellData: function() {
	            var year = dateUtils.getFirstYearInDecade(this.option("date")) - 1;
	            return new Date(year, 0, 1)
	        },
	        _getNextCellData: function(date) {
	            date = new Date(date);
	            date.setFullYear(date.getFullYear() + 1);
	            return date
	        },
	        getNavigatorCaption: function() {
	            var year = dateUtils.getFirstYearInDecade(this.option("date"));
	            return year + "-" + (year + 9)
	        },
	        _isValueOnCurrentView: function(currentDate, value) {
	            return dateUtils.sameDecade(currentDate, value)
	        },
	        _getCellByDate: function(date) {
	            var foundDate = new Date(date);
	            foundDate.setDate(1);
	            foundDate.setMonth(0);
	            return this._$table.find("td[data-value='" + dateLocalization.format(foundDate, dateUtils.getShortDateFormat()) + "']")
	        },
	        isBoundary: function(date) {
	            return dateUtils.sameDecade(date, this.option("min")) || dateUtils.sameDecade(date, this.option("max"))
	        }
	    }),
	    century: BaseView.inherit({
	        _getViewName: function() {
	            return "century"
	        },
	        _isTodayCell: function(cellDate) {
	            return dateUtils.sameDecade(cellDate, new Date)
	        },
	        _isDateOutOfRange: function(cellDate) {
	            var decade = dateUtils.getFirstYearInDecade(cellDate),
	                minDecade = dateUtils.getFirstYearInDecade(this.option("min")),
	                maxDecade = dateUtils.getFirstYearInDecade(this.option("max"));
	            return !dateUtils.dateInRange(decade, minDecade, maxDecade)
	        },
	        _isOtherView: function(cellDate) {
	            var date = new Date(cellDate);
	            date.setMonth(1);
	            return !dateUtils.sameCentury(date, this.option("date"))
	        },
	        _getCellText: function(cellDate) {
	            var decade = cellDate.getFullYear();
	            return decade + " - " + (decade + 9)
	        },
	        _getFirstCellData: function() {
	            var decade = dateUtils.getFirstDecadeInCentury(this.option("date")) - 10;
	            return new Date(decade, 0, 1)
	        },
	        _getNextCellData: function(date) {
	            date = new Date(date);
	            date.setFullYear(date.getFullYear() + 10);
	            return date
	        },
	        _getCellByDate: function(date) {
	            var foundDate = new Date(date);
	            foundDate.setDate(1);
	            foundDate.setMonth(0);
	            foundDate.setFullYear(dateUtils.getFirstYearInDecade(foundDate));
	            return this._$table.find("td[data-value='" + dateLocalization.format(foundDate, dateUtils.getShortDateFormat()) + "']")
	        },
	        getNavigatorCaption: function() {
	            var decade = dateUtils.getFirstDecadeInCentury(this.option("date"));
	            return decade + "-" + (decade + 99)
	        },
	        isBoundary: function(date) {
	            return dateUtils.sameCentury(date, this.option("min")) || dateUtils.sameCentury(date, this.option("max"))
	        }
	    })
	};
	module.exports = Views;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/calendar/ui.calendar.base_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Widget = __webpack_require__(84),
	    dateUtils = __webpack_require__(51),
	    dateLocalization = __webpack_require__(55),
	    eventUtils = __webpack_require__(61),
	    clickEvent = __webpack_require__(65);
	var abstract = Widget.abstract,
	    CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view",
	    CALENDAR_CELL_CLASS = "dx-calendar-cell",
	    CALENDAR_EMPTY_CELL_CLASS = "dx-calendar-empty-cell",
	    CALENDAR_TODAY_CLASS = "dx-calendar-today",
	    CALENDAR_SELECTED_DATE_CLASS = "dx-calendar-selected-date",
	    CALENDAR_CONTOURED_DATE_CLASS = "dx-calendar-contoured-date",
	    CALENDAR_DXCLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, "dxCalendar"),
	    CALENDAR_DATE_VALUE_KEY = "dxDateValueKey";
	var BaseView = Widget.inherit({
	    _getViewName: function() {
	        return "base"
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            date: new Date,
	            focusStateEnabled: false,
	            cellTemplate: null,
	            onCellClick: null,
	            rowCount: 3,
	            colCount: 4,
	            allowValueSelection: true
	        })
	    },
	    _init: function() {
	        this.callBase();
	        var value = this.option("value");
	        this.option("value", new Date(value));
	        if (!this.option("value").valueOf()) {
	            this.option("value", new Date(0, 0, 0, 0, 0, 0))
	        }
	    },
	    _render: function() {
	        this.callBase();
	        this._renderImpl()
	    },
	    _renderImpl: function() {
	        this._$table = $("<table>");
	        this.element().append(this._$table);
	        this._renderBody();
	        this._renderContouredDate();
	        this._renderValue();
	        this._renderEvents()
	    },
	    _renderBody: function() {
	        this.$body = $("<tbody>").appendTo(this._$table);
	        var that = this,
	            cellTemplate = this.option("cellTemplate");
	        var appendChild = this.option("rtl") ? function(row, cell) {
	            row.insertBefore(cell, row.firstChild)
	        } : function(row, cell) {
	            row.appendChild(cell)
	        };

	        function renderCell(cellIndex) {
	            if (prevCellDate) {
	                dateUtils.fixTimezoneGap(prevCellDate, cellDate)
	            }
	            prevCellDate = cellDate;
	            var cell = document.createElement("td"),
	                className = CALENDAR_CELL_CLASS;
	            if (that._isTodayCell(cellDate)) {
	                className = className + " " + CALENDAR_TODAY_CLASS
	            }
	            if (that._isDateOutOfRange(cellDate)) {
	                className = className + " " + CALENDAR_EMPTY_CELL_CLASS
	            }
	            if (that._isOtherView(cellDate)) {
	                className = className + " " + CALENDAR_OTHER_VIEW_CLASS
	            }
	            cell.className = className;
	            cell.setAttribute("data-value", dateLocalization.format(cellDate, dateUtils.getShortDateFormat()));
	            $.data(cell, CALENDAR_DATE_VALUE_KEY, cellDate);
	            that.setAria({
	                role: "option",
	                label: that.getCellAriaLabel(cellDate)
	            }, $(cell));
	            appendChild(row, cell);
	            if (cellTemplate) {
	                cellTemplate.render({
	                    model: {
	                        text: that._getCellText(cellDate),
	                        date: cellDate,
	                        view: that._getViewName()
	                    },
	                    container: $(cell),
	                    index: cellIndex
	                })
	            } else {
	                cell.innerHTML = that._getCellText(cellDate)
	            }
	            cellDate = that._getNextCellData(cellDate)
	        }
	        var prevCellDate, cellDate = this._getFirstCellData(),
	            colCount = this.option("colCount");
	        for (var indexRow = 0, len = this.option("rowCount"); indexRow < len; indexRow++) {
	            var row = document.createElement("tr");
	            this.$body.get(0).appendChild(row);
	            this._iterateCells(colCount, renderCell)
	        }
	    },
	    _iterateCells: function(colCount, delegate) {
	        var i = 0;
	        while (i < colCount) {
	            delegate(i);
	            ++i
	        }
	    },
	    _renderEvents: function() {
	        this._createCellClickAction();
	        this._$table.off(CALENDAR_DXCLICK_EVENT_NAME).on(CALENDAR_DXCLICK_EVENT_NAME, "td", $.proxy(function(e) {
	            if (!$(e.currentTarget).hasClass(CALENDAR_EMPTY_CELL_CLASS)) {
	                this._cellClickAction({
	                    jQueryEvent: e,
	                    value: $(e.currentTarget).data(CALENDAR_DATE_VALUE_KEY)
	                })
	            }
	        }, this))
	    },
	    _createCellClickAction: function() {
	        this._cellClickAction = this._createActionByOption("onCellClick")
	    },
	    _isTodayCell: abstract,
	    _isDateOutOfRange: abstract,
	    _isOtherView: abstract,
	    _getCellText: abstract,
	    _getFirstCellData: abstract,
	    _getNextCellData: abstract,
	    _renderContouredDate: function(contouredDate) {
	        if (!this.option("focusStateEnabled")) {
	            return
	        }
	        contouredDate = contouredDate || this.option("contouredDate");
	        var $oldContouredCell = this._$table.find("." + CALENDAR_CONTOURED_DATE_CLASS);
	        var $newContouredCell = this._getCellByDate(contouredDate);
	        $oldContouredCell.removeClass(CALENDAR_CONTOURED_DATE_CLASS);
	        $newContouredCell.addClass(CALENDAR_CONTOURED_DATE_CLASS)
	    },
	    _dispose: function() {
	        this._keyboardProcessor = void 0;
	        this.callBase()
	    },
	    _changeValue: function(cellDate) {
	        if (cellDate) {
	            var value = this.option("value"),
	                newValue = value ? new Date(value) : new Date;
	            newValue.setDate(cellDate.getDate());
	            newValue.setMonth(cellDate.getMonth());
	            newValue.setFullYear(cellDate.getFullYear());
	            newValue.setDate(cellDate.getDate());
	            this.option("value", newValue)
	        } else {
	            this.option("value", null)
	        }
	    },
	    _renderValue: function() {
	        if (!this.option("allowValueSelection")) {
	            return
	        }
	        var value = this.option("value"),
	            selectedCell = this._getCellByDate(value);
	        if (this._selectedCell) {
	            this._selectedCell.removeClass(CALENDAR_SELECTED_DATE_CLASS)
	        }
	        selectedCell.addClass(CALENDAR_SELECTED_DATE_CLASS);
	        this._selectedCell = selectedCell
	    },
	    getCellAriaLabel: function(date) {
	        return this._getCellText(date)
	    },
	    _getFirstAvailableDate: function() {
	        var date = this.option("date"),
	            min = this.option("min");
	        date = dateUtils.getFirstDateView(this._getViewName(), date);
	        return new Date(min && date < min ? min : date)
	    },
	    _getCellByDate: abstract,
	    isBoundary: abstract,
	    _optionChanged: function(args) {
	        var name = args.name;
	        switch (name) {
	            case "value":
	                this._renderValue();
	                break;
	            case "contouredDate":
	                this._renderContouredDate(args.value);
	                break;
	            case "onCellClick":
	                this._createCellClickAction();
	                break;
	            case "cellTemplate":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	module.exports = BaseView;


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_box.strategy.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    dateLocalization = __webpack_require__(55);
	var abstract = Class.abstract;
	var DateBoxStrategy = Class.inherit({
	    ctor: function(dateBox) {
	        this.dateBox = dateBox
	    },
	    widgetOption: function() {
	        return this._widget && this._widget.option.apply(this._widget, arguments)
	    },
	    _renderWidget: function(element) {
	        element = element || $("<div>");
	        this._widget = this._createWidget(element);
	        this._widget.element().appendTo(this._getWidgetContainer())
	    },
	    _createWidget: function(element) {
	        var widgetName = this._getWidgetName();
	        var widgetOptions = this._getWidgetOptions();
	        return this.dateBox._createComponent(element, widgetName, widgetOptions)
	    },
	    _getWidgetOptions: abstract,
	    _getWidgetName: abstract,
	    getDefaultOptions: function() {
	        return {
	            mode: "text"
	        }
	    },
	    getDisplayFormat: abstract,
	    supportedKeys: $.noop,
	    attachKeyboardEvents: function(keyboardProcessor) {
	        this._widgetKeyboardProcessor = keyboardProcessor.attachChildProcessor()
	    },
	    getParsedText: function(text, format) {
	        return dateLocalization.parse(text, format)
	    },
	    renderInputMinMax: $.noop,
	    renderOpenedState: function() {
	        if (this.dateBox.option("opened")) {
	            this._updateValue()
	        }
	    },
	    popupConfig: abstract,
	    renderPopupContent: function() {
	        var popup = this._getPopup();
	        this._renderWidget();
	        popup.content().parent().off("mousedown").on("mousedown", $.proxy(this._preventFocusOnPopup, this))
	    },
	    getFirstPopupElement: $.noop,
	    getLastPopupElement: $.noop,
	    _preventFocusOnPopup: function(e) {
	        e.preventDefault()
	    },
	    _getWidgetContainer: function() {
	        return this._getPopup().content()
	    },
	    _getPopup: function() {
	        return this.dateBox._popup
	    },
	    popupShowingHandler: $.noop,
	    popupHiddenHandler: $.noop,
	    _updateValue: function() {
	        this._widget && this._widget.option("value", this.dateBoxValue())
	    },
	    _valueChangedHandler: function(args) {
	        if (this.dateBox.option("opened") && "instantly" === this.dateBox.option("applyValueMode")) {
	            this.dateBoxValue(args.value)
	        }
	    },
	    textChangedHandler: $.noop,
	    renderValue: function() {
	        if (this.dateBox.option("opened")) {
	            this._updateValue()
	        }
	    },
	    getValue: function() {
	        return this._widget.option("value")
	    },
	    isAdaptivityChanged: function() {
	        return false
	    },
	    dispose: function() {
	        var popup = this._getPopup();
	        if (popup) {
	            popup.content().empty()
	        }
	    },
	    dateBoxValue: function() {
	        var args = ["value"];
	        arguments.length && args.push(arguments[0]);
	        return this.dateBox.dateOption.apply(this.dateBox, args)
	    }
	});
	module.exports = DateBoxStrategy;


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_box.strategy.date_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    DateView = __webpack_require__(252),
	    DateBoxStrategy = __webpack_require__(250),
	    support = __webpack_require__(48),
	    themes = __webpack_require__(112),
	    dateUtils = __webpack_require__(242),
	    messageLocalization = __webpack_require__(79);
	var DateViewStrategy = DateBoxStrategy.inherit({
	    NAME: "DateView",
	    getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            openOnFieldClick: true,
	            applyButtonText: messageLocalization.format("Done")
	        })
	    },
	    getDisplayFormat: function(displayFormat) {
	        return displayFormat || dateUtils.FORMATS_MAP[this.dateBox.option("type")]
	    },
	    popupConfig: function() {
	        return {
	            showTitle: true,
	            toolbarItems: this.dateBox._popupToolbarItemsConfig(),
	            defaultOptionsRules: [{
	                device: function(device) {
	                    return "win" === device.platform && device.version && 8 === device.version[0]
	                },
	                options: {
	                    showNames: true
	                }
	            }, {
	                device: function(device) {
	                    return "win" === device.platform && device.phone && device.version && 8 === device.version[0]
	                },
	                options: {
	                    animation: null
	                }
	            }, {
	                device: function() {
	                    var currentTheme = (themes.current() || "").split(".")[0];
	                    return "win8" === currentTheme
	                },
	                options: {
	                    fullScreen: true
	                }
	            }, {
	                device: {
	                    platform: "android"
	                },
	                options: {
	                    width: 333,
	                    height: 331
	                }
	            }, {
	                device: function(device) {
	                    var platform = device.platform,
	                        version = device.version;
	                    return "generic" === platform || "ios" === platform || "win" === platform && version && 10 === version[0]
	                },
	                options: {
	                    width: "auto",
	                    height: "auto"
	                }
	            }, {
	                device: function(device) {
	                    var platform = device.platform,
	                        phone = device.phone;
	                    return "generic" === platform && phone
	                },
	                options: {
	                    width: 333,
	                    height: "auto",
	                    position: {
	                        collision: "flipfit flip"
	                    }
	                }
	            }, {
	                device: function(device) {
	                    var currentTheme = (themes.current() || "").split(".")[0];
	                    return device.phone && "win10" === currentTheme
	                },
	                options: {
	                    width: 333,
	                    height: "auto"
	                }
	            }, {
	                device: {
	                    platform: "ios",
	                    phone: true
	                },
	                options: {
	                    width: "100%",
	                    position: {
	                        my: "bottom",
	                        at: "bottom",
	                        of: window
	                    }
	                }
	            }]
	        }
	    },
	    _renderWidget: function() {
	        if (support.inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
	            if (this._widget) {
	                this._widget.element().remove();
	                this._widget = null
	            }
	            return
	        }
	        var popup = this._getPopup();
	        if (this._widget) {
	            this._widget.option(this._getWidgetOptions())
	        } else {
	            var element = $("<div>").appendTo(popup.content());
	            this._widget = this._createWidget(element)
	        }
	        this._widget.element().appendTo(this._getWidgetContainer())
	    },
	    _getWidgetName: function() {
	        return DateView
	    },
	    _getWidgetOptions: function() {
	        return {
	            value: this.dateBoxValue() || new Date,
	            type: this.dateBox.option("type"),
	            minDate: this.dateBox.dateOption("min") || new Date(1900, 1, 1),
	            maxDate: this.dateBox.dateOption("max") || new Date($.now() + 50 * dateUtils.ONE_YEAR),
	            onDisposing: $.proxy(function() {
	                this._widget = null
	            }, this)
	        }
	    },
	    _updateValue: function() {
	        this._widget && this._widget.option("value", this.dateBoxValue())
	    }
	});
	module.exports = DateViewStrategy;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Editor = __webpack_require__(95),
	    DateViewRoller = __webpack_require__(253),
	    dateUtils = __webpack_require__(51),
	    uiDateUtils = __webpack_require__(242),
	    registerComponent = __webpack_require__(44),
	    dateLocalization = __webpack_require__(55);
	var DATEVIEW_CLASS = "dx-dateview",
	    DATEVIEW_WRAPPER_CLASS = "dx-dateview-wrapper",
	    DATEVIEW_ROLLER_CONTAINER_CLASS = "dx-dateview-rollers",
	    DATEVIEW_ROLLER_CLASS = "dx-dateviewroller";
	var TYPE = {
	    date: "date",
	    datetime: "datetime",
	    time: "time"
	};
	var ROLLER_TYPE = {
	    year: "year",
	    month: "month",
	    day: "day"
	};
	var DateView = Editor.inherit({
	    _valueOption: function() {
	        var value = this.option("value"),
	            date = new Date(value);
	        return !value || isNaN(date) ? this._getDefaultDate() : date
	    },
	    _getDefaultDate: function() {
	        var date = new Date;
	        if (this.option("type") === TYPE.date) {
	            return new Date(date.getFullYear(), date.getMonth(), date.getDate())
	        }
	        return date
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            minDate: uiDateUtils.MIN_DATEVIEW_DEFAULT_DATE,
	            maxDate: uiDateUtils.MAX_DATEVIEW_DEFAULT_DATE,
	            type: TYPE.date,
	            value: new Date,
	            showNames: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function(device) {
	                return "win" === device.platform && device.version && 8 === device.version[0]
	            },
	            options: {
	                showNames: true
	            }
	        }])
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(DATEVIEW_CLASS);
	        this._toggleFormatClasses(this.option("type"))
	    },
	    _toggleFormatClasses: function(currentFormat, previousFormat) {
	        this.element().addClass(DATEVIEW_CLASS + "-" + currentFormat);
	        previousFormat && this.element().removeClass(DATEVIEW_CLASS + "-" + previousFormat)
	    },
	    _wrapper: function() {
	        return this._$wrapper
	    },
	    _renderContentImpl: function() {
	        this._$wrapper = $("<div>").addClass(DATEVIEW_WRAPPER_CLASS);
	        this._renderRollers();
	        this._$wrapper.appendTo(this.element())
	    },
	    _renderRollers: function() {
	        if (!this._$rollersContainer) {
	            this._$rollersContainer = $("<div>").addClass(DATEVIEW_ROLLER_CONTAINER_CLASS)
	        }
	        this._$rollersContainer.empty();
	        this._createRollerConfigs();
	        this._rollers = {};
	        var that = this;
	        $.each(that._rollerConfigs, function(name) {
	            var $roller = $("<div>").appendTo(that._$rollersContainer).addClass(DATEVIEW_ROLLER_CLASS + "-" + that._rollerConfigs[name].type);
	            that._rollers[that._rollerConfigs[name].type] = that._createComponent($roller, DateViewRoller, {
	                items: that._rollerConfigs[name].displayItems,
	                selectedIndex: that._rollerConfigs[name].selectedIndex,
	                showScrollbar: false,
	                onStart: function(e) {
	                    var roller = e.component;
	                    roller._toggleActive(true);
	                    that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"))
	                },
	                onEnd: function(e) {
	                    var roller = e.component;
	                    roller._toggleActive(false)
	                },
	                onClick: function(e) {
	                    var roller = e.component;
	                    roller._toggleActive(true);
	                    that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"));
	                    that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"));
	                    roller._toggleActive(false)
	                },
	                onSelectedIndexChanged: function(e) {
	                    var roller = e.component;
	                    that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"))
	                }
	            })
	        });
	        that._$rollersContainer.appendTo(that._wrapper())
	    },
	    _createRollerConfigs: function(type) {
	        var that = this;
	        type = type || that.option("type");
	        that._rollerConfigs = {};
	        dateLocalization.getFormatParts(uiDateUtils.FORMATS_MAP[type]).forEach(function(partName) {
	            that._createRollerConfig(partName)
	        })
	    },
	    _createRollerConfig: function(componentName) {
	        var componentInfo = uiDateUtils.DATE_COMPONENTS_INFO[componentName],
	            valueRange = this._calculateRollerConfigValueRange(componentName),
	            startValue = valueRange.startValue,
	            endValue = valueRange.endValue,
	            formatter = componentInfo.formatter,
	            showNames = this.option("showNames"),
	            curDate = this._getCurrentDate();
	        var config = {
	            type: componentName,
	            setValue: componentInfo.setter,
	            valueItems: [],
	            displayItems: [],
	            getIndex: function(value) {
	                return value[componentInfo.getter]() - startValue
	            }
	        };
	        for (var i = startValue; i <= endValue; i++) {
	            config.valueItems.push(i);
	            config.displayItems.push(formatter(i, showNames, curDate))
	        }
	        config.selectedIndex = config.getIndex(curDate);
	        this._rollerConfigs[componentName] = config
	    },
	    _setActiveRoller: function(currentRoller) {
	        var activeRoller = currentRoller && this._rollers[currentRoller.type];
	        $.each(this._rollers, function() {
	            this.toggleActiveState(this === activeRoller)
	        })
	    },
	    _updateRollersPosition: function() {
	        var that = this;
	        $.each(this._rollers, function(type) {
	            var correctIndex = that._rollerConfigs[type].getIndex(that._getCurrentDate());
	            this.option("selectedIndex", correctIndex)
	        })
	    },
	    _setRollerState: function(roller, selectedIndex) {
	        if (selectedIndex !== roller.selectedIndex) {
	            var rollerValue = roller.valueItems[selectedIndex],
	                setValue = roller.setValue,
	                currentValue = new Date(this._getCurrentDate()),
	                currentDate = currentValue.getDate();
	            if (roller.type === ROLLER_TYPE.month) {
	                currentDate = Math.min(currentDate, uiDateUtils.getMaxMonthDay(currentValue.getFullYear(), rollerValue))
	            } else {
	                if (roller.type === ROLLER_TYPE.year) {
	                    currentDate = Math.min(currentDate, uiDateUtils.getMaxMonthDay(rollerValue, currentValue.getMonth()))
	                }
	            }
	            currentValue.setDate(currentDate);
	            currentValue[setValue](rollerValue);
	            this.option("value", currentValue);
	            roller.selectedIndex = selectedIndex
	        }
	        if (roller.type === ROLLER_TYPE.year) {
	            this._refreshMonthRoller();
	            this._refreshDayRoller()
	        }
	        if (roller.type === ROLLER_TYPE.month) {
	            this._refreshDayRoller()
	        }
	    },
	    _refreshMonthRoller: function() {
	        var monthRoller = this._rollers[ROLLER_TYPE.month];
	        if (monthRoller) {
	            this._createRollerConfig(ROLLER_TYPE.month);
	            var monthRollerConfig = this._rollerConfigs[ROLLER_TYPE.month];
	            if (monthRollerConfig.displayItems.length !== monthRoller.option("items").length) {
	                monthRoller.option({
	                    items: monthRollerConfig.displayItems,
	                    selectedIndex: monthRollerConfig.selectedIndex
	                })
	            }
	        }
	    },
	    _refreshDayRoller: function() {
	        var dayRoller = this._rollers[ROLLER_TYPE.day];
	        if (dayRoller) {
	            this._createRollerConfig(ROLLER_TYPE.day);
	            var dayRollerConfig = this._rollerConfigs[ROLLER_TYPE.day];
	            dayRoller.option({
	                items: dayRollerConfig.displayItems,
	                selectedIndex: dayRollerConfig.selectedIndex
	            })
	        }
	    },
	    _getCurrentDate: function() {
	        var curDate = this._valueOption(),
	            minDate = this.option("minDate"),
	            maxDate = this.option("maxDate");
	        if (minDate && curDate.getTime() <= minDate.getTime()) {
	            curDate = minDate
	        } else {
	            if (maxDate && curDate.getTime() >= maxDate.getTime()) {
	                curDate = maxDate
	            }
	        }
	        return curDate
	    },
	    _calculateRollerConfigValueRange: function(componentName) {
	        var curDate = this._getCurrentDate(),
	            minDate = this.option("minDate"),
	            maxDate = this.option("maxDate"),
	            minYear = dateUtils.sameYear(curDate, minDate),
	            minMonth = minYear && curDate.getMonth() === minDate.getMonth(),
	            maxYear = dateUtils.sameYear(curDate, maxDate),
	            maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth(),
	            componentInfo = uiDateUtils.DATE_COMPONENTS_INFO[componentName],
	            startValue = componentInfo.startValue,
	            endValue = componentInfo.endValue;
	        if (componentName === ROLLER_TYPE.year) {
	            startValue = minDate.getFullYear();
	            endValue = maxDate.getFullYear()
	        }
	        if (componentName === ROLLER_TYPE.month) {
	            if (minYear) {
	                startValue = minDate.getMonth()
	            }
	            if (maxYear) {
	                endValue = maxDate.getMonth()
	            }
	        }
	        if (componentName === ROLLER_TYPE.day) {
	            endValue = uiDateUtils.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
	            if (minYear && minMonth) {
	                startValue = minDate.getDate()
	            }
	            if (maxYear && maxMonth) {
	                endValue = maxDate.getDate()
	            }
	        }
	        return {
	            startValue: startValue,
	            endValue: endValue
	        }
	    },
	    _refreshRollers: function() {
	        this._refreshMonthRoller();
	        this._refreshDayRoller()
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "showNames":
	            case "minDate":
	            case "maxDate":
	            case "type":
	                this._renderRollers();
	                this._toggleFormatClasses(args.value, args.previousValue);
	                break;
	            case "visible":
	                this.callBase(args);
	                if (args.value) {
	                    this._renderRollers()
	                }
	                break;
	            case "value":
	                this.option("value", this._valueOption());
	                this._refreshRollers();
	                this._updateRollersPosition();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _clean: function() {
	        this.callBase();
	        delete this._$rollersContainer
	    },
	    _dispose: function() {
	        clearTimeout(this._deferredRenderDayTimeout);
	        clearTimeout(this._deferredRenderMonthTimeout);
	        this.callBase()
	    }
	});
	registerComponent("dxDateView", DateView);
	module.exports = DateView;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_view_roller.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    eventUtils = __webpack_require__(61),
	    clickEvent = __webpack_require__(65),
	    Scrollable = __webpack_require__(157).default,
	    fx = __webpack_require__(58);
	var DATEVIEW_ROLLER_CLASS = "dx-dateviewroller",
	    DATEVIEW_ROLLER_ACTIVE_CLASS = "dx-state-active",
	    DATEVIEW_ROLLER_CURRENT_CLASS = "dx-dateviewroller-current",
	    DATEVIEW_ROLLER_ITEM_CLASS = "dx-dateview-item",
	    DATEVIEW_ROLLER_ITEM_SELECTED_CLASS = "dx-dateview-item-selected",
	    DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS = "dx-dateview-item-selected-frame",
	    DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS = "dx-dateview-item-selected-border";
	var DateViewRoller = Scrollable.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            showScrollbar: false,
	            useNative: false,
	            selectedIndex: 0,
	            bounceEnabled: false,
	            items: [],
	            showOnClick: false,
	            onClick: null,
	            onSelectedIndexChanged: null
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function(device) {
	                return "win" === device.platform && device.version && 8 === device.version[0]
	            },
	            options: {
	                showOnClick: true
	            }
	        }, {
	            device: {
	                platform: "generic"
	            },
	            options: {
	                scrollByContent: true
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this._renderSelectedItemFrame()
	    },
	    _render: function() {
	        this.callBase();
	        $.each(this._strategy._scrollers, function(index, scroller) {
	            scroller._correctLocation = $.noop
	        });
	        this.element().addClass(DATEVIEW_ROLLER_CLASS);
	        this._renderContainerClick();
	        this._renderItems();
	        this._renderSelectedValue();
	        this._renderItemsClick();
	        this._wrapAction("_endAction", $.proxy(this._endActionHandler, this));
	        this._renderSelectedIndexChanged()
	    },
	    _renderSelectedIndexChanged: function() {
	        this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged")
	    },
	    _renderContainerClick: function() {
	        if (!this.option("showOnClick")) {
	            return
	        }
	        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
	        var clickAction = this._createActionByOption("onClick");
	        this._$container.off(eventName).on(eventName, function(e) {
	            clickAction({
	                jQueryEvent: e
	            })
	        })
	    },
	    _wrapAction: function(actionName, callback) {
	        var strategy = this._strategy,
	            originalAction = strategy[actionName];
	        strategy[actionName] = function() {
	            callback.apply(this, arguments);
	            return originalAction.apply(this, arguments)
	        }
	    },
	    _renderItems: function() {
	        var items = this.option("items") || [],
	            $items = $();
	        this._$content.empty();
	        $.each(items, function() {
	            $items = $items.add($("<div>").addClass(DATEVIEW_ROLLER_ITEM_CLASS).append(this))
	        });
	        this._$content.append($items);
	        this._$items = $items;
	        this.update()
	    },
	    _renderSelectedItemFrame: function() {
	        $("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS).append($("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS)).appendTo(this._$container)
	    },
	    _renderSelectedValue: function(selectedIndex) {
	        var index = this._fitIndex(selectedIndex || this.option("selectedIndex"));
	        this._moveTo({
	            top: this._getItemPosition(index)
	        });
	        this._renderActiveStateItem()
	    },
	    _fitIndex: function(index) {
	        var items = this.option("items") || [],
	            itemCount = items.length;
	        if (index >= itemCount) {
	            return itemCount - 1
	        }
	        if (index < 0) {
	            return 0
	        }
	        return index
	    },
	    _getItemPosition: function(index) {
	        return Math.round(this._itemHeight() * index)
	    },
	    _renderItemsClick: function() {
	        var itemSelector = this._getItemSelector(),
	            eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
	        this.element().off(eventName, itemSelector);
	        this.element().on(eventName, itemSelector, $.proxy(this._itemClickHandler, this))
	    },
	    _getItemSelector: function() {
	        return "." + DATEVIEW_ROLLER_ITEM_CLASS
	    },
	    _itemClickHandler: function(e) {
	        this.option("selectedIndex", this._itemElementIndex(e.currentTarget))
	    },
	    _itemElementIndex: function(itemElement) {
	        return this._itemElements().index(itemElement)
	    },
	    _itemElements: function() {
	        return this.element().find(this._getItemSelector())
	    },
	    _renderActiveStateItem: function() {
	        var selectedIndex = this.option("selectedIndex");
	        $.each(this._$items, function(index) {
	            $(this).toggleClass(DATEVIEW_ROLLER_ITEM_SELECTED_CLASS, selectedIndex === index)
	        })
	    },
	    _moveTo: function(targetLocation) {
	        targetLocation = this._normalizeLocation(targetLocation);
	        var location = this._location(),
	            delta = {
	                x: -(location.left - targetLocation.left),
	                y: -(location.top - targetLocation.top)
	            };
	        if (this._isVisible() && (delta.x || delta.y)) {
	            this._strategy._prepareDirections(true);
	            if (this._animation) {
	                fx.stop(this._$content);
	                fx.animate(this._$content, {
	                    duration: 200,
	                    type: "slide",
	                    to: {
	                        top: Math.floor(delta.y)
	                    }
	                });
	                delete this._animation
	            } else {
	                this._strategy.handleMove({
	                    delta: delta
	                })
	            }
	        }
	    },
	    _validate: function(e) {
	        return this._strategy.validate(e)
	    },
	    _endActionHandler: function() {
	        var currentSelectedIndex = this.option("selectedIndex"),
	            ratio = -this._location().top / this._itemHeight(),
	            newSelectedIndex = Math.round(ratio);
	        this._animation = true;
	        if (newSelectedIndex === currentSelectedIndex) {
	            this._renderSelectedValue(newSelectedIndex)
	        } else {
	            this.option("selectedIndex", newSelectedIndex)
	        }
	    },
	    _itemHeight: function() {
	        var $item = this._$items.first();
	        return $item.get(0) && $item.get(0).getBoundingClientRect().height || 0
	    },
	    _toggleActive: function(state) {
	        this.element().toggleClass(DATEVIEW_ROLLER_ACTIVE_CLASS, state)
	    },
	    _isVisible: function() {
	        return this._$container.is(":visible")
	    },
	    _fireSelectedIndexChanged: function(value, previousValue) {
	        this._selectedIndexChanged({
	            value: value,
	            previousValue: previousValue,
	            jQueryEvent: void 0
	        })
	    },
	    _visibilityChanged: function(visible) {
	        this.callBase(visible);
	        if (visible) {
	            this._renderSelectedValue(this.option("selectedIndex"))
	        }
	        this.toggleActiveState(false)
	    },
	    toggleActiveState: function(state) {
	        this.element().toggleClass(DATEVIEW_ROLLER_CURRENT_CLASS, state)
	    },
	    _refreshSelectedIndex: function() {
	        var selectedIndex = this.option("selectedIndex");
	        var fitIndex = this._fitIndex(selectedIndex);
	        fitIndex === selectedIndex ? this._renderActiveStateItem() : this.option("selectedIndex", fitIndex)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "selectedIndex":
	                this._fireSelectedIndexChanged(args.value, args.previousValue);
	                this._renderSelectedValue(args.value);
	                break;
	            case "items":
	                this._renderItems();
	                this._refreshSelectedIndex();
	                break;
	            case "onClick":
	            case "showOnClick":
	                this._renderContainerClick();
	                break;
	            case "onSelectedIndexChanged":
	                this._renderSelectedIndexChanged();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxDateViewRoller", DateViewRoller);
	module.exports = DateViewRoller;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_box.strategy.native.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    DateBoxStrategy = __webpack_require__(250),
	    support = __webpack_require__(48),
	    dateUtils = __webpack_require__(242),
	    dateLocalization = __webpack_require__(55);
	var NativeStrategy = DateBoxStrategy.inherit({
	    NAME: "Native",
	    popupConfig: $.noop,
	    getParsedText: function(text) {
	        if (!text) {
	            return null
	        }
	        if ("datetime" === this.dateBox.option("type")) {
	            return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0])
	        }
	        return dateUtils.fromStandardDateFormat(text)
	    },
	    renderPopupContent: $.noop,
	    _getWidgetName: $.noop,
	    _getWidgetOptions: $.noop,
	    _getDateBoxType: function() {
	        var type = this.dateBox.option("type");
	        if ($.inArray(type, dateUtils.SUPPORTED_FORMATS) === -1) {
	            type = "date"
	        } else {
	            if ("datetime" === type && !support.inputType(type)) {
	                type = "datetime-local"
	            }
	        }
	        return type
	    },
	    getDefaultOptions: function() {
	        return {
	            mode: this._getDateBoxType()
	        }
	    },
	    getDisplayFormat: function(displayFormat) {
	        var type = this._getDateBoxType();
	        return displayFormat || dateUtils.FORMATS_MAP[type]
	    },
	    renderInputMinMax: function($input) {
	        $input.attr({
	            min: dateLocalization.format(this.dateBox.dateOption("min"), "yyyy-MM-dd"),
	            max: dateLocalization.format(this.dateBox.dateOption("max"), "yyyy-MM-dd")
	        })
	    }
	});
	module.exports = NativeStrategy;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_box.strategy.calendar_with_time.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    CalendarStrategy = __webpack_require__(244),
	    TimeView = __webpack_require__(256),
	    Box = __webpack_require__(229);
	var SHRINK_VIEW_SCREEN_WIDTH = 573,
	    DATEBOX_ADAPTIVITY_MODE_CLASS = "dx-datebox-adaptivity-mode";
	var CalendarWithTimeStrategy = CalendarStrategy.inherit({
	    NAME: "CalendarWithTime",
	    getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            applyValueMode: "useButtons",
	            buttonsLocation: "bottom after",
	            showPopupTitle: false
	        })
	    },
	    getDisplayFormat: function(displayFormat) {
	        return displayFormat || "shortdateshorttime"
	    },
	    _renderWidget: function() {
	        this.callBase();
	        this._timeView = this.dateBox._createComponent($("<div>"), TimeView, {
	            value: this.dateBoxValue(),
	            _showClock: !this._isShrinkView(),
	            onValueChanged: $.proxy(this._valueChangedHandler, this)
	        })
	    },
	    renderOpenedState: function() {
	        this.callBase();
	        var popup = this._getPopup();
	        if (popup) {
	            popup._wrapper().toggleClass(DATEBOX_ADAPTIVITY_MODE_CLASS, this._isSmallScreen())
	        }
	        clearTimeout(this._repaintTimer);
	        this._repaintTimer = setTimeout($.proxy(function() {
	            this._getPopup() && this._getPopup().repaint()
	        }, this), 0)
	    },
	    isAdaptivityChanged: function() {
	        var isAdaptiveMode = this._isShrinkView();
	        if (isAdaptiveMode !== this._currentAdaptiveMode) {
	            this._currentAdaptiveMode = isAdaptiveMode;
	            return true
	        }
	        return this.callBase()
	    },
	    _updateValue: function(preventDefaultValue) {
	        var date = this.dateBoxValue();
	        if (!date && !preventDefaultValue) {
	            date = new Date
	        }
	        this.callBase();
	        if (this._timeView && date) {
	            this._timeView.option("value", date)
	        }
	    },
	    _isSmallScreen: function() {
	        return $(window).width() <= SHRINK_VIEW_SCREEN_WIDTH
	    },
	    _isShrinkView: function() {
	        return this.dateBox.option("adaptivityEnabled") && this._isSmallScreen()
	    },
	    _getBoxItems: function() {
	        var items = [{
	            ratio: 0,
	            shrink: 0,
	            baseSize: "auto",
	            name: "calendar"
	        }];
	        if (!this._isShrinkView()) {
	            items.push({
	                ratio: 0,
	                shrink: 0,
	                baseSize: "auto",
	                name: "time"
	            })
	        }
	        return items
	    },
	    renderPopupContent: function() {
	        this.callBase();
	        this._currentAdaptiveMode = this._isShrinkView();
	        var $popupContent = this._getPopup().content();
	        this._box = this.dateBox._createComponent($("<div>").appendTo($popupContent), Box, {
	            direction: "row",
	            crossAlign: "start",
	            items: this._getBoxItems(),
	            itemTemplate: $.proxy(function(data) {
	                var $container = $("<div>");
	                switch (data.name) {
	                    case "calendar":
	                        $container.append(this._widget.element());
	                        if (this._isShrinkView()) {
	                            $container.append(this._timeView.element())
	                        }
	                        break;
	                    case "time":
	                        $container.append(this._timeView.element())
	                }
	                return $container
	            }, this)
	        });
	        this._attachTabHandler()
	    },
	    popupConfig: function(popupConfig) {
	        var calendarPopupConfig = this.callBase(popupConfig),
	            result = $.extend(calendarPopupConfig, {
	                onShowing: $.proxy(function() {
	                    if ("fallback" === this._box.option("_layoutStrategy")) {
	                        var clockMinWidth = this._getPopup().content().find(".dx-timeview-clock").css("minWidth");
	                        this._timeView.element().css("width", clockMinWidth)
	                    }
	                }, this)
	            });
	        return result
	    },
	    getFirstPopupElement: function() {
	        return this._timeView._hourBox.element().find("input")
	    },
	    _attachTabHandler: function() {
	        var dateBox = this.dateBox,
	            handler = function(e) {
	                if (e.shiftKey) {
	                    e.preventDefault();
	                    dateBox.focus()
	                }
	            };
	        this._timeView._hourBox.registerKeyHandler("tab", handler)
	    },
	    _preventFocusOnPopup: function(e) {
	        if (!$(e.target).hasClass("dx-texteditor-input")) {
	            this.callBase.apply(this, arguments);
	            if (!this.dateBox._hasFocusClass()) {
	                this.dateBox.focus()
	            }
	        }
	    },
	    getValue: function() {
	        var date = this._widget.option("value"),
	            time = this._timeView.option("value");
	        date = date ? new Date(date) : new Date;
	        date.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
	        return date
	    },
	    dispose: function() {
	        clearTimeout(this._removeMinWidthTimer);
	        clearTimeout(this._repaintTimer);
	        this.callBase()
	    }
	});
	module.exports = CalendarWithTimeStrategy;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.time_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Editor = __webpack_require__(95),
	    NumberBox = __webpack_require__(237),
	    Box = __webpack_require__(229),
	    support = __webpack_require__(48),
	    registerComponent = __webpack_require__(44),
	    dateLocalization = __webpack_require__(55);
	var TIMEVIEW_CLASS = "dx-timeview",
	    TIMEVIEW_CLOCK_CLASS = "dx-timeview-clock",
	    TIMEVIEW_FIELD_CLASS = "dx-timeview-field",
	    TIMEVIEW_HOURARROW_CLASS = "dx-timeview-hourarrow",
	    TIMEVIEW_TIME_SEPARATOR_CLASS = "dx-timeview-time-separator",
	    TIMEVIEW_MINUTEARROW_CLASS = "dx-timeview-minutearrow";
	var rotateArrow = function($arrow, angle, offset) {
	    if (!support.transform) {
	        filterRotate($arrow, angle, offset)
	    } else {
	        cssRotate($arrow, angle, offset)
	    }
	};
	var filterRotate = function($arrow, angle, offset) {
	    angle = angle / 180 * Math.PI;
	    var sin = Math.sin(angle),
	        cos = Math.cos(angle);
	    $arrow.css("filter", "none");
	    var originalWidth = $arrow.width(),
	        originalHeight = $arrow.height();
	    $arrow.css("filter", 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + cos + ", M12 = " + -sin + ", M21 = " + sin + ", M22 = " + cos + ")");
	    var width = $arrow.width(),
	        height = $arrow.height();
	    var sx = (width - originalWidth) / 2,
	        sy = (height - originalHeight) / 2;
	    $arrow.css("margin-left", -originalWidth / 2 + (originalHeight / 2 - offset) * sin - sx);
	    $arrow.css("margin-top", originalHeight / 2 - (originalHeight / 2 - offset) * cos - sy)
	};
	var cssRotate = function($arrow, angle, offset) {
	    $arrow.css("transform", "rotate(" + angle + "deg) translate(0," + offset + "px)")
	};
	var TimeView = Editor.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            value: new Date($.now()),
	            _showClock: true,
	            _arrowOffset: 0
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: {
	                platform: "android"
	            },
	            options: {
	                _arrowOffset: 15
	            }
	        }, {
	            device: {
	                platform: "generic"
	            },
	            options: {
	                _arrowOffset: 5
	            }
	        }])
	    },
	    _getValue: function() {
	        return this.option("value") || new Date
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(TIMEVIEW_CLASS)
	    },
	    _render: function() {
	        this.callBase();
	        this._renderBox();
	        this._updateTime()
	    },
	    _renderBox: function() {
	        var $box = $("<div>").appendTo(this.element()),
	            items = [];
	        if (this.option("_showClock")) {
	            items.push({
	                ratio: 1,
	                shrink: 0,
	                baseSize: "auto",
	                template: $.proxy(this._renderClock, this)
	            })
	        }
	        items.push({
	            ratio: 0,
	            shrink: 0,
	            baseSize: 50,
	            template: $.proxy(this._renderField, this)
	        });
	        this._createComponent($box, Box, {
	            height: "100%",
	            width: "100%",
	            direction: "col",
	            items: items
	        })
	    },
	    _renderClock: function(_, __, $container) {
	        this._$hourArrow = $("<div>").addClass(TIMEVIEW_HOURARROW_CLASS);
	        this._$minuteArrow = $("<div>").addClass(TIMEVIEW_MINUTEARROW_CLASS);
	        $container.addClass(TIMEVIEW_CLOCK_CLASS).append(this._$hourArrow).append(this._$minuteArrow);
	        this.setAria("role", "presentation", $container)
	    },
	    _updateClock: function() {
	        var time = this._getValue(),
	            hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30,
	            minuteArrowAngle = time.getMinutes() / 60 * 360;
	        rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
	        rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"))
	    },
	    _renderField: function() {
	        this._createHourBox();
	        this._createMinuteBox();
	        return this._createComponent($("<div>").addClass(TIMEVIEW_FIELD_CLASS), Box, {
	            direction: "row",
	            align: "center",
	            crossAlign: "center",
	            items: [{
	                ratio: 0,
	                shrink: 0,
	                baseSize: "auto",
	                template: $.proxy(function() {
	                    return this._hourBox.element()
	                }, this)
	            }, {
	                ratio: 0,
	                shrink: 0,
	                baseSize: "auto",
	                template: $("<div>", {
	                    "class": TIMEVIEW_TIME_SEPARATOR_CLASS
	                }).text(dateLocalization.getTimeSeparator())
	            }, {
	                ratio: 0,
	                shrink: 0,
	                baseSize: "auto",
	                template: $.proxy(function() {
	                    return this._minuteBox.element()
	                }, this)
	            }]
	        }).element()
	    },
	    _createHourBox: function() {
	        this._hourBox = this._createComponent($("<div>"), NumberBox, $.extend({
	            min: -1,
	            max: 24,
	            value: this._getValue().getHours(),
	            onValueChanged: $.proxy(function(args) {
	                var newHours = (24 + args.value) % 24;
	                this._hourBox.option("value", newHours);
	                var time = new Date(this._getValue());
	                time.setHours(newHours);
	                this.option("value", time)
	            }, this)
	        }, this._getNumberBoxConfig()));
	        this._hourBox.setAria("label", "hours")
	    },
	    _createMinuteBox: function() {
	        this._minuteBox = this._createComponent($("<div>"), NumberBox, $.extend({
	            min: -1,
	            max: 60,
	            value: this._getValue().getMinutes(),
	            onValueChanged: $.proxy(function(args) {
	                var newMinutes = (60 + args.value) % 60;
	                this._minuteBox.option("value", newMinutes);
	                var time = new Date(this._getValue());
	                time.setMinutes(newMinutes);
	                this.option("value", time)
	            }, this)
	        }, this._getNumberBoxConfig()));
	        this._minuteBox.setAria("label", "minutes")
	    },
	    _getNumberBoxConfig: function() {
	        return {
	            showSpinButtons: true,
	            disabled: this.option("disabled"),
	            valueFormat: function(value) {
	                return (value < 10 ? "0" : "") + value
	            }
	        }
	    },
	    _updateField: function() {
	        this._hourBox && this._hourBox.option("value", this._getValue().getHours());
	        this._minuteBox && this._minuteBox.option("value", this._getValue().getMinutes())
	    },
	    _updateTime: function() {
	        if (this.option("_showClock")) {
	            this._updateClock()
	        }
	        this._updateField()
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._updateTime()
	        }
	    },
	    _toggleDisabledState: function(value) {
	        this._hourBox && this._hourBox.option("disabled", value);
	        this._minuteBox && this._minuteBox.option("disabled", value)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "value":
	                this._updateTime();
	                this.callBase(args);
	                break;
	            case "_arrowOffset":
	                break;
	            case "_showClock":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxTimeView", TimeView);
	module.exports = TimeView;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/date_box/ui.date_box.strategy.list.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    List = __webpack_require__(190),
	    DateBoxStrategy = __webpack_require__(250),
	    devices = __webpack_require__(40),
	    commonUtils = __webpack_require__(8),
	    dateUtils = __webpack_require__(242),
	    dateLocalization = __webpack_require__(55);
	var BOUNDARY_VALUES = {
	    min: new Date(0, 0, 0, 0, 0),
	    max: new Date(0, 0, 0, 23, 59)
	};
	var ListStrategy = DateBoxStrategy.inherit({
	    NAME: "List",
	    supportedKeys: function() {
	        return {
	            tab: function() {
	                if (this.option("opened")) {
	                    this.close()
	                }
	            },
	            space: $.noop,
	            home: $.noop,
	            end: $.noop
	        }
	    },
	    getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            applyValueMode: "instantly"
	        })
	    },
	    getDisplayFormat: function(displayFormat) {
	        return displayFormat || "shorttime"
	    },
	    popupConfig: function(popupConfig) {
	        var device = devices.current(),
	            result = $.extend(popupConfig, {
	                width: this._getPopupWidth()
	            });
	        if ("android" === device.platform) {
	            $.extend(result, {
	                position: {
	                    offset: {
	                        h: -16,
	                        v: -10
	                    }
	                }
	            })
	        }
	        return result
	    },
	    _getPopupWidth: function() {
	        var device = devices.current(),
	            result = this.dateBox.element().outerWidth();
	        if ("android" === device.platform) {
	            result += 32
	        }
	        return result
	    },
	    popupShowingHandler: function() {
	        this._dimensionChanged()
	    },
	    _renderWidget: function() {
	        this.callBase();
	        this._refreshItems()
	    },
	    _getWidgetName: function() {
	        return List
	    },
	    _getWidgetOptions: function() {
	        var keyboardProcessor = this.dateBox._keyboardProcessor;
	        return {
	            _keyboardProcessor: keyboardProcessor ? keyboardProcessor.attachChildProcessor() : null,
	            itemTemplate: $.proxy(this._timeListItemTemplate, this),
	            onItemClick: $.proxy(this._listItemClickHandler, this),
	            tabIndex: -1,
	            onFocusedItemChanged: $.proxy(this._refreshActiveDescendant, this),
	            selectionMode: "single"
	        }
	    },
	    _refreshActiveDescendant: function(e) {
	        this.dateBox.setAria("activedescendant", "");
	        this.dateBox.setAria("activedescendant", e.actionValue)
	    },
	    _refreshItems: function() {
	        this._widgetItems = this._getTimeListItems();
	        this._widget.option("items", this._widgetItems)
	    },
	    renderOpenedState: function() {
	        if (!this._widget) {
	            return
	        }
	        this._widget.option("focusedElement", null);
	        this._setSelectedItemsByValue();
	        this._scrollToSelectedItem()
	    },
	    _updateValue: function() {
	        if (!this._widget) {
	            return
	        }
	        this._refreshItems();
	        this._setSelectedItemsByValue();
	        this._scrollToSelectedItem()
	    },
	    _setSelectedItemsByValue: function() {
	        var value = this.dateBoxValue();
	        var dateIndex = this._getDateIndex(value);
	        if (dateIndex === -1) {
	            this._widget.option("selectedItems", [])
	        } else {
	            this._widget.option("selectedIndex", dateIndex)
	        }
	    },
	    _scrollToSelectedItem: function() {
	        this._widget.scrollToItem(this._widget.option("selectedIndex"))
	    },
	    _getDateIndex: function(date) {
	        var result = -1;
	        for (var i = 0, n = this._widgetItems.length; i < n; i++) {
	            if (this._areDatesEqual(date, this._widgetItems[i])) {
	                result = i;
	                break
	            }
	        }
	        return result
	    },
	    _areDatesEqual: function(first, second) {
	        return commonUtils.isDate(first) && commonUtils.isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes()
	    },
	    _getTimeListItems: function() {
	        var min = this.dateBox.dateOption("min") || this._getBoundaryDate("min"),
	            max = this.dateBox.dateOption("max") || this._getBoundaryDate("max"),
	            value = this.dateBox.dateOption("value") || null,
	            delta = max - min,
	            minutes = min.getMinutes() % this.dateBox.option("interval");
	        if (delta < 0) {
	            return []
	        }
	        if (delta > dateUtils.ONE_DAY) {
	            delta = dateUtils.ONE_DAY
	        }
	        if (value - min < dateUtils.ONE_DAY) {
	            return this._getRangeItems(min, new Date(min), delta)
	        }
	        min = this._getBoundaryDate("min");
	        min.setMinutes(minutes);
	        if (value && Math.abs(value - max) < dateUtils.ONE_DAY) {
	            delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * dateUtils.ONE_MINUTE
	        }
	        return this._getRangeItems(min, new Date(min), delta)
	    },
	    _getRangeItems: function(startValue, currentValue, rangeDuration) {
	        var rangeItems = [];
	        var interval = this.dateBox.option("interval");
	        while (currentValue - startValue < rangeDuration) {
	            rangeItems.push(new Date(currentValue));
	            currentValue.setMinutes(currentValue.getMinutes() + interval)
	        }
	        return rangeItems
	    },
	    _getBoundaryDate: function(boundary) {
	        var boundaryValue = BOUNDARY_VALUES[boundary],
	            currentValue = this.dateBox.dateOption("value") || new Date;
	        return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes())
	    },
	    _timeListItemTemplate: function(itemData) {
	        var displayFormat = this.dateBox.option("displayFormat");
	        return dateLocalization.format(itemData, this.getDisplayFormat(displayFormat))
	    },
	    _listItemClickHandler: function(e) {
	        this.dateBox.option("opened", false);
	        var date = this.dateBox.option("value");
	        date = date ? new Date(date) : new Date;
	        date.setHours(e.itemData.getHours());
	        date.setMinutes(e.itemData.getMinutes());
	        date.setSeconds(e.itemData.getSeconds());
	        this.dateBoxValue(date)
	    },
	    attachKeyboardEvents: function(keyboardProcessor) {
	        var child = keyboardProcessor.attachChildProcessor();
	        if (this._widget) {
	            this._widget.option("_keyboardProcessor", child)
	        }
	    },
	    _dimensionChanged: function() {
	        this._getPopup() && this._updatePopupDimensions()
	    },
	    _updatePopupDimensions: function() {
	        this._updatePopupWidth();
	        this._updatePopupHeight()
	    },
	    _updatePopupWidth: function() {
	        this.dateBox._setPopupOption("width", this._getPopupWidth())
	    },
	    _updatePopupHeight: function() {
	        this.dateBox._setPopupOption("height", "auto");
	        var popupHeight = this._widget.element().outerHeight();
	        var maxHeight = .45 * $(window).height();
	        this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
	        this.dateBox._timeList && this.dateBox._timeList.updateDimensions()
	    }
	});
	module.exports = ListStrategy;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/tab_panel.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    support = __webpack_require__(48),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    MultiView = __webpack_require__(259),
	    Tabs = __webpack_require__(260),
	    iconUtils = __webpack_require__(104),
	    BindableTemplate = __webpack_require__(134);
	var TABPANEL_CLASS = "dx-tabpanel",
	    TABPANEL_TABS_CLASS = "dx-tabpanel-tabs",
	    TABPANEL_CONTAINER_CLASS = "dx-tabpanel-container",
	    TABS_ITEM_TEXT_CLASS = "dx-tab-text";
	var TabPanel = MultiView.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            itemTitleTemplate: "title",
	            hoverStateEnabled: true,
	            showNavButtons: false,
	            scrollByContent: true,
	            scrollingEnabled: true,
	            onTitleClick: null,
	            onTitleHold: null,
	            onTitleRendered: null
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }, {
	            device: function() {
	                return !support.touch
	            },
	            options: {
	                swipeEnabled: false
	            }
	        }, {
	            device: {
	                platform: "generic"
	            },
	            options: {
	                animationEnabled: false
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this.element().addClass(TABPANEL_CLASS);
	        this.setAria("role", "tabpanel");
	        this._renderLayout()
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.title = new BindableTemplate(function($container, data) {
	            $container.text(data.title || String(data));
	            var icon = data.icon,
	                iconSrc = data.iconSrc,
	                $iconElement = iconUtils.getImageContainer(icon || iconSrc);
	            $container.wrapInner($("<span>").addClass(TABS_ITEM_TEXT_CLASS));
	            $iconElement && $iconElement.prependTo($container)
	        }, ["title", "html", "icon", "iconSrc"], this.option("integrationOptions.watchMethod"))
	    },
	    _renderContent: function() {
	        var that = this;
	        this.callBase();
	        if (this.option("templatesRenderAsynchronously")) {
	            this._resizeEventTimer = setTimeout(function() {
	                that._updateLayout()
	            }, 0)
	        }
	    },
	    _renderLayout: function() {
	        var $element = this.element();
	        this._$tabContainer = $("<div>").addClass(TABPANEL_TABS_CLASS).appendTo($element);
	        var $tabs = $("<div>").appendTo(this._$tabContainer);
	        this._tabs = this._createComponent($tabs, Tabs, this._tabConfig());
	        this._$container = $("<div>").addClass(TABPANEL_CONTAINER_CLASS).appendTo($element);
	        this._$container.append(this._$wrapper);
	        this._updateLayout()
	    },
	    _updateLayout: function() {
	        var tabsHeight = this._$tabContainer.outerHeight();
	        this._$container.css({
	            "margin-top": -tabsHeight,
	            "padding-top": tabsHeight
	        })
	    },
	    _refreshActiveDescendant: function() {
	        var tabs = this._tabs,
	            tabItems = tabs.itemElements(),
	            $activeTab = $(tabItems[tabs.option("selectedIndex")]),
	            id = this.getFocusedItemId();
	        this.setAria("controls", void 0, $(tabItems));
	        this.setAria("controls", id, $activeTab)
	    },
	    _tabConfig: function() {
	        return {
	            selectOnFocus: true,
	            focusStateEnabled: this.option("focusStateEnabled"),
	            hoverStateEnabled: this.option("hoverStateEnabled"),
	            tabIndex: this.option("tabIndex"),
	            selectedIndex: this.option("selectedIndex"),
	            onItemClick: this.option("onTitleClick"),
	            onItemHold: this.option("onTitleHold"),
	            itemHoldTimeout: this.option("itemHoldTimeout"),
	            onSelectionChanged: $.proxy(function(e) {
	                this.option("selectedIndex", e.component.option("selectedIndex"));
	                this._refreshActiveDescendant()
	            }, this),
	            onItemRendered: this.option("onTitleRendered"),
	            itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
	            items: this.option("items"),
	            noDataText: null,
	            scrollingEnabled: this.option("scrollingEnabled"),
	            scrollByContent: this.option("scrollByContent"),
	            showNavButtons: this.option("showNavButtons"),
	            itemTemplateProperty: "tabTemplate",
	            loopItemFocus: this.option("loop"),
	            selectionRequired: true,
	            onOptionChanged: $.proxy(function(args) {
	                var name = args.name,
	                    value = args.value;
	                if ("focusedElement" === name) {
	                    var id = value ? value.index() : value;
	                    var newItem = value ? this._itemElements().eq(id) : value;
	                    this.option("focusedElement", newItem)
	                }
	            }, this),
	            onFocusIn: $.proxy(function(args) {
	                this._focusInHandler(args.jQueryEvent)
	            }, this),
	            onFocusOut: $.proxy(function(args) {
	                this._focusOutHandler(args.jQueryEvent)
	            }, this)
	        }
	    },
	    _renderFocusTarget: function() {
	        this._focusTarget().attr("tabindex", -1);
	        this._refreshActiveDescendant()
	    },
	    _updateFocusState: function(e, isFocused) {
	        this.callBase(e, isFocused);
	        if (e.target === this._tabs._focusTarget().get(0)) {
	            this._toggleFocusClass(isFocused, this._focusTarget())
	        }
	    },
	    _setTabsOption: function(name, value) {
	        if (this._tabs) {
	            this._tabs.option(name, value)
	        }
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._tabs._dimensionChanged();
	            this._updateLayout()
	        }
	    },
	    _optionChanged: function(args) {
	        var name = args.name,
	            value = args.value,
	            fullName = args.fullName;
	        switch (name) {
	            case "dataSource":
	                this.callBase(args);
	                break;
	            case "items":
	                this._setTabsOption(fullName, value);
	                this._updateLayout();
	                this.callBase(args);
	                break;
	            case "selectedIndex":
	            case "selectedItem":
	            case "itemHoldTimeout":
	            case "focusStateEnabled":
	            case "hoverStateEnabled":
	                this._setTabsOption(fullName, value);
	                this.callBase(args);
	                break;
	            case "scrollingEnabled":
	            case "scrollByContent":
	            case "showNavButtons":
	                this._setTabsOption(fullName, value);
	                break;
	            case "focusedElement":
	                var id = value ? value.index() : value;
	                var newItem = value ? this._tabs._itemElements().eq(id) : value;
	                this._setTabsOption("focusedElement", newItem);
	                this.callBase(args);
	                this._tabs.focus();
	                break;
	            case "itemTitleTemplate":
	                this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
	                break;
	            case "onTitleClick":
	                this._setTabsOption("onItemClick", value);
	                break;
	            case "onTitleHold":
	                this._setTabsOption("onItemHold", value);
	                break;
	            case "onTitleRendered":
	                this._setTabsOption("onItemRendered", value);
	                break;
	            case "loop":
	                this._setTabsOption("loopItemFocus", value);
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _clean: function() {
	        clearTimeout(this._resizeEventTimer);
	        this.callBase()
	    }
	});
	registerComponent("dxTabPanel", TabPanel);
	module.exports = TabPanel;
	module.exports.default = module.exports;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/multi_view.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    fx = __webpack_require__(58),
	    translator = __webpack_require__(59),
	    mathUtils = __webpack_require__(77),
	    commonUtils = __webpack_require__(8),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    CollectionWidget = __webpack_require__(117),
	    Swipeable = __webpack_require__(209);
	var MULTIVIEW_CLASS = "dx-multiview",
	    MULTIVIEW_WRAPPER_CLASS = "dx-multiview-wrapper",
	    MULTIVIEW_ITEM_CONTAINER_CLASS = "dx-multiview-item-container",
	    MULTIVIEW_ITEM_CLASS = "dx-multiview-item",
	    MULTIVIEW_ITEM_HIDDEN_CLASS = "dx-multiview-item-hidden",
	    MULTIVIEW_ITEM_DATA_KEY = "dxMultiViewItemData",
	    MULTIVIEW_ANIMATION_DURATION = 200;
	var toNumber = function(value) {
	    return +value
	};
	var position = function($element) {
	    return translator.locate($element).left
	};
	var move = function($element, position) {
	    translator.move($element, {
	        left: position
	    })
	};
	var animation = {
	    moveTo: function($element, position, duration, completeAction) {
	        fx.animate($element, {
	            type: "slide",
	            to: {
	                left: position
	            },
	            duration: duration,
	            complete: completeAction
	        })
	    },
	    complete: function($element) {
	        fx.stop($element, true)
	    }
	};
	var MultiView = CollectionWidget.inherit({
	    _activeStateUnit: "." + MULTIVIEW_ITEM_CLASS,
	    _supportedKeys: function() {
	        return $.extend(this.callBase(), {
	            pageUp: $.noop,
	            pageDown: $.noop
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            selectedIndex: 0,
	            swipeEnabled: true,
	            animationEnabled: true,
	            loop: false,
	            deferRendering: true,
	            _itemAttributes: {
	                role: "tabpanel"
	            },
	            loopItemFocus: false,
	            selectOnFocus: true,
	            selectionMode: "single",
	            selectionRequired: true,
	            selectionByClick: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }])
	    },
	    _itemClass: function() {
	        return MULTIVIEW_ITEM_CLASS
	    },
	    _itemDataKey: function() {
	        return MULTIVIEW_ITEM_DATA_KEY
	    },
	    _itemContainer: function() {
	        return this._$itemContainer
	    },
	    _itemElements: function() {
	        return this._itemContainer().children(this._itemSelector())
	    },
	    _itemWidth: function() {
	        if (!this._itemWidthValue) {
	            this._itemWidthValue = this._$wrapper.width()
	        }
	        return this._itemWidthValue
	    },
	    _clearItemWidthCache: function() {
	        delete this._itemWidthValue
	    },
	    _itemsCount: function() {
	        return this.option("items").length
	    },
	    _normalizeIndex: function(index) {
	        var count = this._itemsCount();
	        if (index < 0) {
	            index += count
	        }
	        if (index >= count) {
	            index -= count
	        }
	        return index
	    },
	    _getRTLSignCorrection: function() {
	        return this.option("rtlEnabled") ? -1 : 1
	    },
	    _init: function() {
	        this.callBase.apply(this, arguments);
	        var $element = this.element();
	        $element.addClass(MULTIVIEW_CLASS);
	        this._$wrapper = $("<div>").addClass(MULTIVIEW_WRAPPER_CLASS);
	        this._$wrapper.appendTo($element);
	        this._$itemContainer = $("<div>").addClass(MULTIVIEW_ITEM_CONTAINER_CLASS);
	        this._$itemContainer.appendTo(this._$wrapper);
	        this.option("loopItemFocus", this.option("loop"));
	        this._initSwipeable()
	    },
	    _render: function() {
	        this._deferredItems = [];
	        this.callBase()
	    },
	    _renderItemContent: function(args) {
	        var renderContentDeferred = $.Deferred();
	        var that = this,
	            callBase = this.callBase;
	        var deferred = $.Deferred();
	        deferred.done(function() {
	            var $itemContent = callBase.call(that, args);
	            renderContentDeferred.resolve($itemContent)
	        });
	        this._deferredItems.push(deferred);
	        this.option("deferRendering") || deferred.resolve();
	        return renderContentDeferred.promise()
	    },
	    _renderSelection: function(addedSelection) {
	        this._updateItems(addedSelection[0])
	    },
	    _updateItems: function(selectedIndex, newIndex) {
	        this._updateItemsPosition(selectedIndex, newIndex);
	        this._updateItemsVisibility(selectedIndex, newIndex)
	    },
	    _updateItemsPosition: function(selectedIndex, newIndex) {
	        var $itemElements = this._itemElements(),
	            positionSign = -this._animationDirection(newIndex, selectedIndex),
	            $selectedItem = $itemElements.eq(selectedIndex);
	        move($selectedItem, 0);
	        move($itemElements.eq(newIndex), 100 * positionSign + "%")
	    },
	    _updateItemsVisibility: function(selectedIndex, newIndex) {
	        var $itemElements = this._itemElements();
	        $itemElements.each($.proxy(function(itemIndex, item) {
	            var $item = $(item),
	                isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
	            if (!isHidden) {
	                this._renderSpecificItem(itemIndex)
	            }
	            $item.toggleClass(MULTIVIEW_ITEM_HIDDEN_CLASS, isHidden);
	            this.setAria("hidden", isHidden || void 0, $item)
	        }, this))
	    },
	    _renderSpecificItem: function(index) {
	        var hasItemContent = this._itemElements().eq(index).find(this._itemContentClass()).length > 0;
	        if (commonUtils.isDefined(index) && !hasItemContent) {
	            this._deferredItems[index].resolve()
	        }
	    },
	    _setAriaSelected: $.noop,
	    _updateSelection: function(addedSelection, removedSelection) {
	        var newIndex = addedSelection[0],
	            prevIndex = removedSelection[0];
	        animation.complete(this._$itemContainer);
	        this._updateItems(prevIndex, newIndex);
	        var animationDirection = this._animationDirection(newIndex, prevIndex);
	        this._animateItemContainer(animationDirection * this._itemWidth(), $.proxy(function() {
	            move(this._$itemContainer, 0);
	            this._updateItems(newIndex);
	            this._$itemContainer.width()
	        }, this))
	    },
	    _animateItemContainer: function(position, completeCallback) {
	        var duration = this.option("animationEnabled") ? MULTIVIEW_ANIMATION_DURATION : 0;
	        animation.moveTo(this._$itemContainer, position, duration, completeCallback)
	    },
	    _animationDirection: function(newIndex, prevIndex) {
	        var containerPosition = position(this._$itemContainer),
	            indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection(),
	            isSwipePresent = 0 !== containerPosition,
	            directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
	        return mathUtils.sign(directionSignVariable)
	    },
	    _initSwipeable: function() {
	        this._createComponent(this.element(), Swipeable, {
	            disabled: !this.option("swipeEnabled"),
	            elastic: false,
	            itemSizeFunc: $.proxy(this._itemWidth, this),
	            onStart: $.proxy(function(args) {
	                this._swipeStartHandler(args.jQueryEvent)
	            }, this),
	            onUpdated: $.proxy(function(args) {
	                this._swipeUpdateHandler(args.jQueryEvent)
	            }, this),
	            onEnd: $.proxy(function(args) {
	                this._swipeEndHandler(args.jQueryEvent)
	            }, this)
	        })
	    },
	    _swipeStartHandler: function(e) {
	        animation.complete(this._$itemContainer);
	        var selectedIndex = this.option("selectedIndex"),
	            loop = this.option("loop"),
	            lastIndex = this._itemsCount() - 1,
	            rtl = this.option("rtlEnabled");
	        e.maxLeftOffset = toNumber(loop || (rtl ? selectedIndex > 0 : selectedIndex < lastIndex));
	        e.maxRightOffset = toNumber(loop || (rtl ? selectedIndex < lastIndex : selectedIndex > 0));
	        this._swipeDirection = null
	    },
	    _swipeUpdateHandler: function(e) {
	        var offset = e.offset,
	            swipeDirection = mathUtils.sign(offset) * this._getRTLSignCorrection();
	        move(this._$itemContainer, offset * this._itemWidth());
	        if (swipeDirection !== this._swipeDirection) {
	            this._swipeDirection = swipeDirection;
	            var selectedIndex = this.option("selectedIndex"),
	                newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
	            this._updateItems(selectedIndex, newIndex)
	        }
	    },
	    _swipeEndHandler: function(e) {
	        var targetOffset = e.targetOffset * this._getRTLSignCorrection();
	        if (targetOffset) {
	            this.option("selectedIndex", this._normalizeIndex(this.option("selectedIndex") - targetOffset));
	            var $selectedElement = this.itemElements().filter(".dx-item-selected");
	            this.option("focusStateEnabled") && this.option("focusedElement", $selectedElement)
	        } else {
	            this._animateItemContainer(0, $.noop)
	        }
	    },
	    _getItemFocusLoopSignCorrection: function() {
	        return this._itemFocusLooped ? -1 : 1
	    },
	    _moveFocus: function() {
	        this.callBase.apply(this, arguments);
	        this._itemFocusLooped = false
	    },
	    _prevItem: function($items) {
	        var $result = this.callBase.apply(this, arguments);
	        this._itemFocusLooped = $result.is($items.last());
	        return $result
	    },
	    _nextItem: function($items) {
	        var $result = this.callBase.apply(this, arguments);
	        this._itemFocusLooped = $result.is($items.first());
	        return $result
	    },
	    _dimensionChanged: function() {
	        this._clearItemWidthCache()
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._dimensionChanged()
	        }
	    },
	    _optionChanged: function(args) {
	        var value = args.value;
	        switch (args.name) {
	            case "loop":
	                this.option("loopItemFocus", value);
	                break;
	            case "animationEnabled":
	                break;
	            case "swipeEnabled":
	                Swipeable.getInstance(this.element()).option("disabled", !value);
	                break;
	            case "deferRendering":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxMultiView", MultiView);
	module.exports = MultiView;
	module.exports.default = module.exports;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/tabs.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    devices = __webpack_require__(40),
	    registerComponent = __webpack_require__(44),
	    Button = __webpack_require__(114),
	    inkRipple = __webpack_require__(115),
	    eventUtils = __webpack_require__(61),
	    domUtils = __webpack_require__(43),
	    pointerEvents = __webpack_require__(66),
	    TabsItem = __webpack_require__(261),
	    themes = __webpack_require__(112),
	    holdEvent = __webpack_require__(132),
	    Scrollable = __webpack_require__(157).default,
	    CollectionWidget = __webpack_require__(117),
	    iconUtils = __webpack_require__(104),
	    BindableTemplate = __webpack_require__(134);
	var TABS_CLASS = "dx-tabs",
	    TABS_WRAPPER_CLASS = "dx-tabs-wrapper",
	    TABS_EXPANDED_CLASS = "dx-tabs-expanded",
	    TABS_SCROLLABLE_CLASS = "dx-tabs-scrollable",
	    TABS_NAV_BUTTONS_CLASS = "dx-tabs-nav-buttons",
	    TABS_ITEM_CLASS = "dx-tab",
	    TABS_ITEM_SELECTED_CLASS = "dx-tab-selected",
	    TABS_NAV_BUTTON_CLASS = "dx-tabs-nav-button",
	    TABS_LEFT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-left",
	    TABS_RIGHT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-right",
	    TABS_ITEM_TEXT_CLASS = "dx-tab-text",
	    TABS_ITEM_DATA_KEY = "dxTabData",
	    FEEDBACK_HIDE_TIMEOUT = 100,
	    FEEDBACK_DURATION_INTERVAL = 5,
	    FEEDBACK_SCROLL_TIMEOUT = 300,
	    TAB_OFFSET = 30;
	var Tabs = CollectionWidget.inherit({
	    _activeStateUnit: "." + TABS_ITEM_CLASS,
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            hoverStateEnabled: true,
	            showNavButtons: false,
	            scrollByContent: true,
	            scrollingEnabled: true,
	            selectionMode: "single",
	            activeStateEnabled: true,
	            selectionRequired: false,
	            selectOnFocus: true,
	            loopItemFocus: false,
	            useInkRipple: false,
	            badgeExpr: function(data) {
	                return data ? data.badge : void 0
	            }
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: {
	                platform: "generic"
	            },
	            options: {
	                showNavButtons: true,
	                scrollByContent: false
	            }
	        }, {
	            device: function() {
	                return "desktop" === devices.real().deviceType && !devices.isSimulator()
	            },
	            options: {
	                focusStateEnabled: true
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                useInkRipple: true
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this.setAria("role", "tablist");
	        this.element().addClass(TABS_CLASS);
	        this._renderMultiple();
	        this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.item = new BindableTemplate(function($container, data) {
	            if ($.isPlainObject(data)) {
	                if (data.text) {
	                    $container.text(data.text)
	                }
	                if (data.html) {
	                    $container.html(data.html)
	                }
	            } else {
	                $container.text(String(data))
	            }
	            var icon = data.icon,
	                iconSrc = data.iconSrc,
	                $iconElement = iconUtils.getImageContainer(icon || iconSrc);
	            $container.wrapInner($("<span>").addClass(TABS_ITEM_TEXT_CLASS));
	            $iconElement && $iconElement.prependTo($container)
	        }, ["text", "html", "icon", "iconSrc"], this.option("integrationOptions.watchMethod"))
	    },
	    _itemClass: function() {
	        return TABS_ITEM_CLASS
	    },
	    _selectedItemClass: function() {
	        return TABS_ITEM_SELECTED_CLASS
	    },
	    _itemDataKey: function() {
	        return TABS_ITEM_DATA_KEY
	    },
	    _renderContent: function() {
	        var that = this;
	        this.callBase();
	        if (this.option("templatesRenderAsynchronously")) {
	            this._resizeEventTimer = setTimeout(function() {
	                domUtils.triggerResizeEvent(that._$content)
	            }, 0)
	        }
	    },
	    _render: function() {
	        this.callBase();
	        this._renderWrapper();
	        this._renderScrolling();
	        this.setAria("role", "tab", this.itemElements());
	        this.option("useInkRipple") && this._renderInkRipple()
	    },
	    _renderScrolling: function() {
	        this.element().removeClass(TABS_EXPANDED_CLASS);
	        if (this._allowScrolling() && !this._scrollable) {
	            this._renderScrollable();
	            this._renderNavButtons();
	            this._scrollToItem(this.option("selectedItem"))
	        }
	        if (!this._allowScrolling()) {
	            this._cleanScrolling();
	            this.element().removeClass(TABS_NAV_BUTTONS_CLASS).addClass(TABS_EXPANDED_CLASS)
	        }
	    },
	    _cleanNavButtons: function() {
	        if (!this._leftButton || !this._rightButton) {
	            return
	        }
	        this._leftButton.element().remove();
	        this._rightButton.element().remove();
	        this._leftButton = null;
	        this._rightButton = null
	    },
	    _cleanScrolling: function() {
	        if (!this._scrollable) {
	            return
	        }
	        this._scrollable.content().children("." + TABS_WRAPPER_CLASS).appendTo(this._itemContainer());
	        this._scrollable.element().remove();
	        this._scrollable = null;
	        this._cleanNavButtons()
	    },
	    _renderInkRipple: function() {
	        this._inkRipple = inkRipple.render()
	    },
	    _toggleActiveState: function($element, value, e) {
	        this.callBase.apply(this, arguments);
	        if (!this._inkRipple) {
	            return
	        }
	        var config = {
	            element: $element,
	            jQueryEvent: e
	        };
	        if (value) {
	            this._inkRipple.showWave(config)
	        } else {
	            this._inkRipple.hideWave(config)
	        }
	    },
	    _renderMultiple: function() {
	        if ("multiple" === this.option("selectionMode")) {
	            this.option("selectOnFocus", false)
	        }
	    },
	    _renderWrapper: function() {
	        this.element().wrapInner($("<div>").addClass(TABS_WRAPPER_CLASS))
	    },
	    _renderScrollable: function() {
	        var $itemContainer = this.element().wrapInner($("<div>").addClass(TABS_SCROLLABLE_CLASS)).children();
	        this._scrollable = this._createComponent($itemContainer, Scrollable, {
	            direction: "horizontal",
	            showScrollbar: false,
	            useKeyboard: false,
	            useNative: false,
	            scrollByContent: this.option("scrollByContent"),
	            onScroll: $.proxy(this._updateNavButtonsVisibility, this)
	        });
	        this.element().append(this._scrollable.element())
	    },
	    _scrollToItem: function(itemData) {
	        if (!this._scrollable) {
	            return
	        }
	        var $item = this._editStrategy.getItemElement(itemData);
	        this._scrollable.scrollToElement($item)
	    },
	    _allowScrolling: function() {
	        if (!this.option("scrollingEnabled")) {
	            return false
	        }
	        var tabItemsWidth = 0;
	        this.itemElements().each(function(_, tabItem) {
	            tabItemsWidth += $(tabItem).outerWidth(true)
	        });
	        return tabItemsWidth - 1 > this.element().width()
	    },
	    _renderNavButtons: function() {
	        this.element().toggleClass(TABS_NAV_BUTTONS_CLASS, this.option("showNavButtons"));
	        if (!this.option("showNavButtons")) {
	            return
	        }
	        this._leftButton = this._createNavButton(-TAB_OFFSET, "chevronprev");
	        var $leftButton = this._leftButton.element();
	        $leftButton.addClass(TABS_LEFT_NAV_BUTTON_CLASS);
	        this.element().prepend($leftButton);
	        this._rightButton = this._createNavButton(TAB_OFFSET, "chevronnext");
	        var $rightButton = this._rightButton.element();
	        $rightButton.addClass(TABS_RIGHT_NAV_BUTTON_CLASS);
	        this.element().append($rightButton);
	        this._updateNavButtonsVisibility();
	        this._scrollable.update();
	        if (this.option("rtlEnabled")) {
	            this._scrollable.scrollTo({
	                left: this._scrollable.scrollWidth() - this._scrollable.clientWidth()
	            })
	        }
	    },
	    _updateNavButtonsVisibility: function() {
	        this._leftButton && this._leftButton.option("disabled", this._scrollable.scrollLeft() <= 0);
	        this._rightButton && this._rightButton.option("disabled", this._scrollable.scrollLeft() >= Math.round(this._scrollable.scrollWidth() - this._scrollable.clientWidth()))
	    },
	    _updateScrollPosition: function(offset, duration) {
	        this._scrollable.update();
	        this._scrollable.scrollBy(offset / duration)
	    },
	    _createNavButton: function(offset, icon) {
	        var that = this;
	        var holdAction = that._createAction(function() {
	                that._holdInterval = setInterval(function() {
	                    that._updateScrollPosition(offset, FEEDBACK_DURATION_INTERVAL)
	                }, FEEDBACK_DURATION_INTERVAL)
	            }),
	            holdEventName = eventUtils.addNamespace(holdEvent.name, "dxNavButton"),
	            pointerUpEventName = eventUtils.addNamespace(pointerEvents.up, "dxNavButton"),
	            pointerOutEventName = eventUtils.addNamespace(pointerEvents.out, "dxNavButton");
	        var navButton = this._createComponent($("<div>").addClass(TABS_NAV_BUTTON_CLASS), Button, {
	            focusStateEnabled: false,
	            icon: icon,
	            onClick: function() {
	                that._updateScrollPosition(offset, 1)
	            },
	            integrationOptions: {}
	        });
	        navButton.element().on(holdEventName, {
	            timeout: FEEDBACK_SCROLL_TIMEOUT
	        }, $.proxy(function(e) {
	            holdAction({
	                jQueryEvent: e
	            })
	        }, this)).on(pointerUpEventName, function() {
	            that._clearInterval()
	        }).on(pointerOutEventName, function() {
	            that._clearInterval()
	        });
	        return navButton
	    },
	    _clearInterval: function() {
	        if (this._holdInterval) {
	            clearInterval(this._holdInterval)
	        }
	    },
	    _renderSelection: function(addedSelection) {
	        this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]), {
	            left: 1,
	            right: 1
	        })
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._dimensionChanged()
	        }
	    },
	    _dimensionChanged: function() {
	        if (this.option("scrollingEnabled")) {
	            this._renderScrolling()
	        }
	    },
	    _itemSelectHandler: function(e) {
	        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
	            return
	        }
	        this.callBase(e)
	    },
	    _clean: function() {
	        this._scrollable = null;
	        clearTimeout(this._resizeEventTimer);
	        this.callBase()
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "useInkRipple":
	            case "scrollingEnabled":
	            case "showNavButtons":
	                this._invalidate();
	                break;
	            case "scrollByContent":
	                this._scrollable && this._scrollable.option(args.name, args.value);
	                break;
	            case "selectionMode":
	                this._renderMultiple();
	                this.callBase(args);
	                break;
	            case "badgeExpr":
	                this._invalidate();
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	Tabs.ItemClass = TabsItem;
	registerComponent("dxTabs", Tabs);
	module.exports = Tabs;
	module.exports.default = module.exports;


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/tabs/item.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    CollectionWidgetItem = __webpack_require__(131);
	var TABS_ITEM_BADGE_CLASS = "dx-tabs-item-badge",
	    BADGE_CLASS = "dx-badge";
	var TabsItem = CollectionWidgetItem.inherit({
	    _renderWatchers: function() {
	        this.callBase();
	        this._startWatcher("badge", this._renderBadge.bind(this))
	    },
	    _renderBadge: function(badge) {
	        this._$element.children("." + TABS_ITEM_BADGE_CLASS).remove();
	        if (!badge) {
	            return
	        }
	        var $badge = $("<div>").addClass(TABS_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge);
	        this._$element.append($badge)
	    }
	});
	module.exports = TabsItem;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/validation_summary.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    ValidationMixin = __webpack_require__(96),
	    ValidationEngine = __webpack_require__(106),
	    CollectionWidget = __webpack_require__(117);
	var VALIDATION_SUMMARY_CLASS = "dx-validationsummary",
	    ITEM_CLASS = VALIDATION_SUMMARY_CLASS + "-item",
	    ITEM_DATA_KEY = VALIDATION_SUMMARY_CLASS + "-item-data";
	var ValidationSummary = CollectionWidget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            focusStateEnabled: false,
	            noDataText: null
	        })
	    },
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            validationGroup: true
	        })
	    },
	    _init: function() {
	        this.callBase();
	        this._initGroupRegistration()
	    },
	    _initGroupRegistration: function() {
	        var group = this._findGroup(),
	            groupConfig = ValidationEngine.addGroup(group);
	        this._unsubscribeGroup();
	        this._groupWasInit = true;
	        this._validationGroup = group;
	        this.groupSubscription = $.proxy(this._groupValidationHandler, this);
	        groupConfig.on("validated", this.groupSubscription)
	    },
	    _unsubscribeGroup: function() {
	        var groupConfig = ValidationEngine.getGroupConfig(this._validationGroup);
	        groupConfig && groupConfig.off("validated", this.groupSubscription)
	    },
	    _getOrderedItems: function(validators, items) {
	        var orderedItems = [];
	        $.each(validators, function(_, validator) {
	            var firstItem = $.grep(items, function(item) {
	                if (item.validator === validator) {
	                    return true
	                }
	            })[0];
	            if (firstItem) {
	                orderedItems.push(firstItem)
	            }
	        });
	        return orderedItems
	    },
	    _groupValidationHandler: function(params) {
	        var that = this,
	            items = that._getOrderedItems(params.validators, $.map(params.brokenRules, function(rule) {
	                return {
	                    text: rule.message,
	                    validator: rule.validator
	                }
	            }));
	        that.validators = params.validators;
	        $.each(that.validators, function(_, validator) {
	            if (validator._validationSummary !== this) {
	                var handler = $.proxy(that._itemValidationHandler, that),
	                    disposingHandler = function() {
	                        validator.off("validated", handler);
	                        validator._validationSummary = null;
	                        handler = null
	                    };
	                validator.on("validated", handler);
	                validator.on("disposing", disposingHandler);
	                validator._validationSummary = this
	            }
	        });
	        that.option("items", items)
	    },
	    _itemValidationHandler: function(itemValidationResult) {
	        var elementIndex, items = this.option("items"),
	            isValid = itemValidationResult.isValid,
	            replacementFound = false,
	            newMessage = itemValidationResult.brokenRule && itemValidationResult.brokenRule.message,
	            validator = itemValidationResult.validator;
	        $.each(items, function(index, item) {
	            if (item.validator === validator) {
	                if (isValid) {
	                    elementIndex = index
	                } else {
	                    item.text = newMessage
	                }
	                replacementFound = true;
	                return false
	            }
	        });
	        if (isValid ^ replacementFound) {
	            return
	        }
	        if (isValid) {
	            items.splice(elementIndex, 1)
	        } else {
	            items.push({
	                text: newMessage,
	                validator: validator
	            })
	        }
	        items = this._getOrderedItems(this.validators, items);
	        this.option("items", items)
	    },
	    _render: function() {
	        this.element().addClass(VALIDATION_SUMMARY_CLASS);
	        this.callBase()
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "validationGroup":
	                this._initGroupRegistration();
	                break;
	            default:
	                this.callBase(args)
	        }
	    },
	    _itemClass: function() {
	        return ITEM_CLASS
	    },
	    _itemDataKey: function() {
	        return ITEM_DATA_KEY
	    },
	    _postprocessRenderItem: function(params) {
	        params.itemElement.on("click", function() {
	            params.itemData.validator && params.itemData.validator.focus && params.itemData.validator.focus()
	        })
	    },
	    _dispose: function() {
	        this.callBase();
	        this._unsubscribeGroup()
	    }
	}).include(ValidationMixin);
	registerComponent("dxValidationSummary", ValidationSummary);
	module.exports = ValidationSummary;
	module.exports.default = module.exports;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/validation_group.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    DOMComponent = __webpack_require__(28),
	    ValidationSummary = __webpack_require__(262),
	    ValidationEngine = __webpack_require__(106),
	    Validator = __webpack_require__(226);
	var VALIDATION_ENGINE_CLASS = "dx-validationgroup";
	var ValidationGroup = DOMComponent.inherit({
	    _getDefaultOptions: function() {
	        return this.callBase()
	    },
	    _init: function() {
	        this.callBase()
	    },
	    _render: function() {
	        var $element = this.element();
	        $element.addClass(VALIDATION_ENGINE_CLASS);
	        $element.find(".dx-validator").each(function(_, validatorContainer) {
	            Validator.getInstance($(validatorContainer))._initGroupRegistration()
	        });
	        $element.find(".dx-validationsummary").each(function(_, summaryContainer) {
	            ValidationSummary.getInstance($(summaryContainer))._initGroupRegistration()
	        });
	        this.callBase()
	    },
	    validate: function() {
	        return ValidationEngine.validateGroup(this)
	    },
	    reset: function() {
	        return ValidationEngine.resetGroup(this)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            default: this.callBase(args)
	        }
	    },
	    _dispose: function() {
	        ValidationEngine.removeGroup(this);
	        this.element().removeClass(VALIDATION_ENGINE_CLASS);
	        this.callBase()
	    }
	});
	registerComponent("dxValidationGroup", ValidationGroup);
	module.exports = ValidationGroup;
	module.exports.default = module.exports;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.editor_factory.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    isWrapped = __webpack_require__(37).isWrapped,
	    compileGetter = __webpack_require__(35).compileGetter,
	    gridCore = __webpack_require__(144),
	    browser = __webpack_require__(16),
	    devices = __webpack_require__(40),
	    positionUtils = __webpack_require__(60),
	    eventUtils = __webpack_require__(61),
	    clickEvent = __webpack_require__(65),
	    pointerEvents = __webpack_require__(66),
	    normalizeDataSourceOptions = __webpack_require__(121).normalizeDataSourceOptions,
	    compareVersion = __webpack_require__(11).compare,
	    addNamespace = eventUtils.addNamespace;
	__webpack_require__(230);
	__webpack_require__(237);
	__webpack_require__(204);
	__webpack_require__(265);
	__webpack_require__(240);
	var DATAGRID_CHECKBOX_SIZE_CLASS = "dx-datagrid-checkbox-size",
	    DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
	    DATAGRID_EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
	    DATAGRID_MODULE_NAMESPACE = "dxDataGridEditorFactory",
	    DATAGRID_UPDATE_FOCUS_EVENTS = addNamespace([pointerEvents.down, "focusin", clickEvent.name].join(" "), DATAGRID_MODULE_NAMESPACE),
	    DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
	    DATAGRID_FOCUSED_ELEMENT_CLASS = "dx-focused",
	    DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
	    DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
	    DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
	    DATAGRID_EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])",
	    DX_HIDDEN = "dx-hidden",
	    TAB_KEY = 9;
	exports.EditorFactoryController = gridCore.ViewController.inherit(function() {
	    var getResultConfig = function(config, options) {
	        return $.extend(config, {
	            readOnly: options.readOnly,
	            placeholder: options.placeholder,
	            inputAttr: {
	                id: options.id
	            }
	        }, options.editorOptions)
	    };
	    var checkEnterBug = function() {
	        return browser.msie && parseInt(browser.version) <= 11 || devices.real().ios
	    };
	    var getTextEditorConfig = function(options) {
	        var isValueChanged = false,
	            data = {},
	            isEnterBug = checkEnterBug(),
	            sharedData = options.sharedData || data;
	        return getResultConfig({
	            placeholder: options.placeholder,
	            width: options.width,
	            value: options.value,
	            onValueChanged: function(e) {
	                var updateValue = function(e, notFireEvent) {
	                    isValueChanged = false;
	                    options && options.setValue(e.value, notFireEvent)
	                };
	                window.clearTimeout(data.valueChangeTimeout);
	                if (e.jQueryEvent && "keyup" === e.jQueryEvent.type) {
	                    if ("filterRow" === options.parentType || "searchPanel" === options.parentType) {
	                        sharedData.valueChangeTimeout = data.valueChangeTimeout = window.setTimeout(function() {
	                            updateValue(e, data.valueChangeTimeout !== sharedData.valueChangeTimeout)
	                        }, commonUtils.isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0)
	                    } else {
	                        isValueChanged = true
	                    }
	                } else {
	                    updateValue(e)
	                }
	            },
	            onFocusOut: function(e) {
	                if (isEnterBug && isValueChanged) {
	                    isValueChanged = false;
	                    options.setValue(e.component.option("value"))
	                }
	            },
	            onKeyDown: function(e) {
	                if (isEnterBug && isValueChanged && 13 === e.jQueryEvent.keyCode) {
	                    isValueChanged = false;
	                    options.setValue(e.component.option("value"))
	                }
	            },
	            valueChangeEvent: "change" + ("filterRow" === options.parentType || isEnterBug ? " keyup" : "")
	        }, options)
	    };
	    var prepareDateBox = function(options) {
	        options.editorName = "dxDateBox";
	        options.editorOptions = getResultConfig({
	            value: options.value,
	            onValueChanged: function(args) {
	                options.setValue(args.value)
	            },
	            onKeyDown: function(e) {
	                if (checkEnterBug() && 13 === e.jQueryEvent.keyCode) {
	                    e.component.blur();
	                    e.component.focus()
	                }
	            },
	            displayFormat: options.format,
	            formatWidthCalculator: null,
	            width: "auto"
	        }, options)
	    };
	    var prepareTextBox = function(options) {
	        var config = getTextEditorConfig(options),
	            isSearching = "searchPanel" === options.parentType,
	            toString = function(value) {
	                return commonUtils.isDefined(value) ? value.toString() : ""
	            };
	        config.value = toString(options.value);
	        config.valueChangeEvent += isSearching ? " keyup search" : "";
	        config.mode = isSearching ? "search" : "text";
	        options.editorName = "dxTextBox";
	        options.editorOptions = config
	    };
	    var prepareNumberBox = function(options) {
	        var config = getTextEditorConfig(options);
	        config.value = commonUtils.isDefined(options.value) ? options.value : null;
	        options.editorName = "dxNumberBox";
	        options.editorOptions = config
	    };
	    var prepareBooleanEditor = function(options) {
	        if ("filterRow" === options.parentType) {
	            prepareSelectBox($.extend(options, {
	                lookup: {
	                    displayExpr: function(data) {
	                        if (true === data) {
	                            return options.trueText || "true"
	                        } else {
	                            if (false === data) {
	                                return options.falseText || "false"
	                            }
	                        }
	                    },
	                    dataSource: [true, false]
	                }
	            }))
	        } else {
	            prepareCheckBox(options)
	        }
	    };
	    var prepareSelectBox = function(options) {
	        var displayGetter, dataSource, postProcess, lookup = options.lookup,
	            isFilterRow = "filterRow" === options.parentType;
	        if (lookup) {
	            displayGetter = compileGetter(lookup.displayExpr);
	            dataSource = lookup.dataSource;
	            if (commonUtils.isFunction(dataSource) && !isWrapped(dataSource)) {
	                dataSource = dataSource(options.row || {})
	            }
	            if (commonUtils.isObject(dataSource) || commonUtils.isArray(dataSource)) {
	                dataSource = normalizeDataSourceOptions(dataSource);
	                if (isFilterRow) {
	                    postProcess = dataSource.postProcess;
	                    dataSource.postProcess = function(items) {
	                        if (0 === this.pageIndex()) {
	                            items = items.slice(0);
	                            items.unshift(null)
	                        }
	                        if (postProcess) {
	                            return postProcess.call(this, items)
	                        }
	                        return items
	                    }
	                }
	            }
	            var allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
	            options.editorName = "dxSelectBox";
	            options.editorOptions = getResultConfig({
	                searchEnabled: true,
	                value: options.value,
	                valueExpr: options.lookup.valueExpr,
	                searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
	                allowClearing: allowClearing,
	                showClearButton: allowClearing,
	                displayExpr: function(data) {
	                    if (null === data) {
	                        return options.showAllText
	                    }
	                    return displayGetter(data)
	                },
	                dataSource: dataSource,
	                onValueChanged: function(e) {
	                    var params = [e.value];
	                    !isFilterRow && params.push(e.component.option("text"));
	                    options.setValue.apply(this, params)
	                }
	            }, options)
	        }
	    };
	    var prepareCheckBox = function(options) {
	        options.editorName = "dxCheckBox";
	        options.editorOptions = getResultConfig({
	            value: options.value,
	            hoverStateEnabled: !options.readOnly,
	            focusStateEnabled: !options.readOnly,
	            activeStateEnabled: false,
	            onValueChanged: function(e) {
	                options.setValue && options.setValue(e.value, e)
	            },
	            tabIndex: options.tabIndex ? options.tabIndex : 0
	        }, options)
	    };
	    var createEditorCore = function(that, options) {
	        if (options.editorName && options.editorOptions && options.editorElement[options.editorName]) {
	            if ("dxCheckBox" === options.editorName) {
	                options.editorElement.addClass(DATAGRID_CHECKBOX_SIZE_CLASS);
	                options.editorElement.parent().addClass(DATAGRID_EDITOR_INLINE_BLOCK);
	                if (options.command || options.editorOptions.readOnly) {
	                    options.editorElement.parent().addClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)
	                }
	            }
	            that._createComponent(options.editorElement, options.editorName, options.editorOptions);
	            if ("dxTextBox" === options.editorName) {
	                options.editorElement.dxTextBox("instance").registerKeyHandler("enter", $.noop)
	            }
	        }
	    };
	    return {
	        _getFocusedElement: function($dataGridElement) {
	            return $dataGridElement.find("td[tabindex]:focus, input:focus")
	        },
	        _getFocusCellSelector: function() {
	            return ".dx-row > td"
	        },
	        _updateFocusCore: function() {
	            var $focusCell, hideBorders, $focus = this._$focusedElement,
	                $dataGridElement = this.component && this.component.element();
	            if ($dataGridElement) {
	                $focus = this._getFocusedElement($dataGridElement);
	                if ($focus.length) {
	                    if (!$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
	                        $focusCell = $focus.closest(this._getFocusCellSelector() + ", ." + DATAGRID_CELL_FOCUS_DISABLED_CLASS);
	                        hideBorders = $focusCell.get(0) !== $focus.get(0) && $focusCell.hasClass(DATAGRID_EDITOR_INLINE_BLOCK);
	                        $focus = $focusCell
	                    }
	                    if ($focus.length && !$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
	                        this.focus($focus, hideBorders);
	                        return
	                    }
	                }
	            }
	            this.loseFocus()
	        },
	        _updateFocus: function(e) {
	            var that = this,
	                isFocusOverlay = e && e.jQueryEvent && $(e.jQueryEvent.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
	            that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
	            clearTimeout(that._updateFocusTimeoutID);
	            that._updateFocusTimeoutID = setTimeout(function() {
	                delete that._updateFocusTimeoutID;
	                if (!that._isFocusOverlay) {
	                    that._updateFocusCore()
	                }
	                that._isFocusOverlay = false
	            })
	        },
	        _updateFocusOverlaySize: function($element, position) {
	            var location = positionUtils.calculate($element, $.extend({
	                collision: "fit"
	            }, position));
	            if (location.h.oversize > 0) {
	                $element.outerWidth($element.outerWidth() - location.h.oversize)
	            }
	            if (location.v.oversize > 0) {
	                $element.outerHeight($element.outerHeight() - location.v.oversize)
	            }
	        },
	        callbackNames: function() {
	            return ["focused"]
	        },
	        focus: function($element, hideBorder) {
	            var that = this;
	            if (void 0 === $element) {
	                return that._$focusedElement
	            } else {
	                if ($element) {
	                    that._focusTimeoutID = setTimeout(function() {
	                        delete that._focusTimeoutID;
	                        var focusOverlayPosition, $focusOverlay = that._$focusOverlay = that._$focusOverlay || $("<div>").addClass(DATAGRID_FOCUS_OVERLAY_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS);
	                        if (hideBorder) {
	                            that._$focusOverlay && that._$focusOverlay.addClass(DX_HIDDEN)
	                        } else {
	                            var align = browser.msie ? "left bottom" : browser.mozilla ? "right bottom" : "left top",
	                                $content = $element.closest("." + DATAGRID_CONTENT_CLASS);
	                            $focusOverlay.removeClass(DX_HIDDEN).appendTo($content).outerWidth($element.outerWidth() + 1).outerHeight($element.outerHeight() + 1);
	                            focusOverlayPosition = {
	                                precise: compareVersion($.fn.jquery, [3]) >= 0,
	                                my: align,
	                                at: align,
	                                of: $element,
	                                boundary: $content.length && $content
	                            };
	                            that._updateFocusOverlaySize($focusOverlay, focusOverlayPosition);
	                            positionUtils.setup($focusOverlay, focusOverlayPosition);
	                            $focusOverlay.css("visibility", "visible")
	                        }
	                        that._$focusedElement && that._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
	                        $element.addClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
	                        that._$focusedElement = $element;
	                        that.focused.fire($element)
	                    })
	                }
	            }
	        },
	        resize: function() {
	            var $focusedElement = this._$focusedElement;
	            if ($focusedElement) {
	                this.focus($focusedElement)
	            }
	        },
	        loseFocus: function() {
	            this._$focusedElement && this._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
	            this._$focusedElement = null;
	            this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN)
	        },
	        init: function() {
	            this.createAction("onEditorPreparing", {
	                excludeValidators: ["designMode", "disabled", "readOnly"],
	                category: "rendering"
	            });
	            this.createAction("onEditorPrepared", {
	                excludeValidators: ["designMode", "disabled", "readOnly"],
	                category: "rendering"
	            });
	            this._updateFocusHandler = this._updateFocusHandler || this.createAction($.proxy(this._updateFocus, this));
	            $(document).on(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
	            this._attachContainerEventHandlers()
	        },
	        _attachContainerEventHandlers: function() {
	            var that = this,
	                $container = that.component && that.component.element(),
	                isIE10OrLower = browser.msie && parseInt(browser.version) < 11;
	            if ($container) {
	                $container.on(addNamespace("keydown", DATAGRID_MODULE_NAMESPACE), function(e) {
	                    if (e.which === TAB_KEY) {
	                        that._updateFocusHandler(e)
	                    }
	                });
	                isIE10OrLower && $container.on([pointerEvents.down, pointerEvents.move, pointerEvents.up, clickEvent.name].join(" "), "." + DATAGRID_POINTER_EVENTS_TARGET_CLASS, $.proxy(that._focusOverlayEventProxy, that))
	            }
	        },
	        _focusOverlayEventProxy: function(e) {
	            var element, $target = $(e.target),
	                $currentTarget = $(e.currentTarget),
	                needProxy = $target.hasClass(DATAGRID_POINTER_EVENTS_TARGET_CLASS) || $target.hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS),
	                $focusedElement = this._$focusedElement;
	            if (!needProxy || $currentTarget.hasClass(DX_HIDDEN)) {
	                return
	            }
	            $currentTarget.addClass(DX_HIDDEN);
	            element = $target.get(0).ownerDocument.elementFromPoint(e.clientX, e.clientY);
	            eventUtils.fireEvent({
	                originalEvent: e,
	                target: element
	            });
	            e.stopPropagation();
	            $currentTarget.removeClass(DX_HIDDEN);
	            $focusedElement && $focusedElement.find(DATAGRID_EDITORS_INPUT_SELECTOR).focus()
	        },
	        dispose: function() {
	            clearTimeout(this._focusTimeoutID);
	            clearTimeout(this._updateFocusTimeoutID);
	            $(document).off(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler)
	        },
	        createEditor: function($container, options) {
	            options.cancel = false;
	            options.editorElement = $container;
	            if (options.lookup) {
	                prepareSelectBox(options)
	            } else {
	                switch (options.dataType) {
	                    case "date":
	                        prepareDateBox(options);
	                        break;
	                    case "boolean":
	                        prepareBooleanEditor(options);
	                        break;
	                    case "number":
	                        prepareNumberBox(options);
	                        break;
	                    default:
	                        prepareTextBox(options)
	                }
	            }
	            this.executeAction("onEditorPreparing", options);
	            if (options.cancel) {
	                return
	            }
	            createEditorCore(this, options);
	            this.executeAction("onEditorPrepared", options)
	        }
	    }
	}());
	gridCore.registerModule("editorFactory", {
	    defaultOptions: function() {
	        return {}
	    },
	    controllers: {
	        editorFactory: exports.EditorFactoryController
	    },
	    extenders: {
	        controllers: {
	            columnsResizer: {
	                _startResizing: function(args) {
	                    this.callBase(args);
	                    if (this.isResizing()) {
	                        this.getController("editorFactory").loseFocus()
	                    }
	                }
	            }
	        }
	    }
	});


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/select_box.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    errors = __webpack_require__(3),
	    inkRipple = __webpack_require__(115),
	    messageLocalization = __webpack_require__(79),
	    registerComponent = __webpack_require__(44),
	    eventUtils = __webpack_require__(61),
	    DropDownList = __webpack_require__(266),
	    themes = __webpack_require__(112),
	    clickEvent = __webpack_require__(65);
	var DISABLED_STATE_SELECTOR = ".dx-state-disabled",
	    SELECTBOX_CLASS = "dx-selectbox",
	    SELECTBOX_POPUP_CLASS = "dx-selectbox-popup",
	    SELECTBOX_CONTAINER_CLASS = "dx-selectbox-container",
	    SELECTBOX_POPUP_WRAPPER_CLASS = "dx-selectbox-popup-wrapper";
	var SelectBox = DropDownList.inherit({
	    _supportedKeys: function() {
	        var that = this,
	            parent = this.callBase(),
	            clearSelectBox = function(e) {
	                var isEditable = this._isEditable();
	                if (!isEditable) {
	                    if (this.option("showClearButton")) {
	                        e.preventDefault();
	                        this.reset()
	                    }
	                } else {
	                    if (this._valueSubstituted()) {
	                        this._preventFiltering = true
	                    }
	                }
	                this._preventSubstitution = true
	            };
	        var searchIfNeeded = function() {
	            if (that.option("searchEnabled") && that._valueSubstituted()) {
	                that._searchHandler()
	            }
	        };
	        return $.extend({}, parent, {
	            tab: function() {
	                if (this.option("opened") && "instantly" === this.option("applyValueMode")) {
	                    this._cleanInputSelection()
	                }
	                parent.tab.apply(this, arguments)
	            },
	            upArrow: function() {
	                if (parent.upArrow.apply(this, arguments)) {
	                    if (!this.option("opened")) {
	                        this._setNextValue(-1)
	                    }
	                    return true
	                }
	            },
	            downArrow: function() {
	                if (parent.downArrow.apply(this, arguments)) {
	                    if (!this.option("opened")) {
	                        this._setNextValue(1)
	                    }
	                    return true
	                }
	            },
	            leftArrow: function() {
	                searchIfNeeded();
	                parent.leftArrow.apply(this, arguments)
	            },
	            rightArrow: function() {
	                searchIfNeeded();
	                parent.rightArrow.apply(this, arguments)
	            },
	            home: function() {
	                searchIfNeeded();
	                parent.home.apply(this, arguments)
	            },
	            end: function() {
	                searchIfNeeded();
	                parent.end.apply(this, arguments)
	            },
	            enter: function(e) {
	                if ("" === this._input().val() && this.option("value")) {
	                    this.option({
	                        selectedItem: null,
	                        value: null
	                    });
	                    this.close()
	                } else {
	                    if (this.option("acceptCustomValue")) {
	                        e.preventDefault()
	                    }
	                    if (parent.enter.apply(this, arguments)) {
	                        return this.option("opened")
	                    }
	                }
	            },
	            backspace: clearSelectBox,
	            del: clearSelectBox
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            placeholder: messageLocalization.format("Select"),
	            fieldTemplate: null,
	            valueChangeEvent: "change",
	            acceptCustomValue: false,
	            onCustomItemCreating: function(e) {
	                return e.text
	            },
	            showSelectionControls: false,
	            autocompletionEnabled: true,
	            allowClearing: true,
	            tooltipEnabled: false,
	            openOnFieldClick: true,
	            showDropButton: true,
	            displayCustomValue: false,
	            _isAdaptablePopupPosition: false,
	            useInkRipple: false
	        })
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function() {
	                return /win8/.test(themes.current())
	            },
	            options: {
	                _isAdaptablePopupPosition: true,
	                popupPosition: {
	                    at: "left top",
	                    offset: {
	                        h: 0,
	                        v: 0
	                    }
	                }
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                _isAdaptablePopupPosition: true,
	                popupPosition: {
	                    offset: {
	                        h: -16,
	                        v: -8
	                    }
	                }
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                useInkRipple: true
	            }
	        }])
	    },
	    _init: function() {
	        this.callBase();
	        this._initCustomItemCreatingAction()
	    },
	    _render: function() {
	        this._renderSubmitElement();
	        this.callBase();
	        this.element().addClass(SELECTBOX_CLASS);
	        this.option("useInkRipple") && this._renderInkRipple();
	        this._renderTooltip();
	        this._$container.addClass(SELECTBOX_CONTAINER_CLASS)
	    },
	    _renderSubmitElement: function() {
	        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
	    },
	    _renderInkRipple: function() {
	        this._inkRipple = inkRipple.render()
	    },
	    _toggleActiveState: function($element, value, e) {
	        this.callBase.apply(this, arguments);
	        if (!this._inkRipple || this._isEditable()) {
	            return
	        }
	        var config = {
	            element: this._inputWrapper(),
	            jQueryEvent: e
	        };
	        if (value) {
	            this._inkRipple.showWave(config)
	        } else {
	            this._inkRipple.hideWave(config)
	        }
	    },
	    _createPopup: function() {
	        this.callBase();
	        this._popup.element().addClass(SELECTBOX_POPUP_CLASS)
	    },
	    _popupWrapperClass: function() {
	        return this.callBase() + " " + SELECTBOX_POPUP_WRAPPER_CLASS
	    },
	    _renderOpenedState: function() {
	        this.callBase();
	        if (this.option("opened")) {
	            this._scrollToSelectedItem();
	            this._focusSelectedElement()
	        }
	    },
	    _focusSelectedElement: function() {
	        var searchValue = this._searchValue();
	        if (!searchValue) {
	            this._focusListElement(null);
	            return
	        }
	        var $listItems = this._list._itemElements(),
	            selectedItem = this.option("selectedItem"),
	            index = $.inArray(selectedItem, this.option("items")),
	            isSelectedItemDisplayed = selectedItem && searchValue === this._displayGetter(selectedItem).toString(),
	            focusedElement = index >= 0 && isSelectedItemDisplayed ? $listItems.eq(index) : null;
	        this._focusListElement(focusedElement)
	    },
	    _renderFocusedElement: function() {
	        if (!this._list) {
	            return
	        }
	        var searchValue = this._searchValue();
	        if (!searchValue || this.option("acceptCustomValue")) {
	            this._focusListElement(null);
	            return
	        }
	        var $listItems = this._list._itemElements(),
	            focusedElement = $listItems.not(DISABLED_STATE_SELECTOR).eq(0);
	        this._focusListElement(focusedElement)
	    },
	    _focusListElement: function(element) {
	        this._preventInputValueRender = true;
	        this._list.option("focusedElement", element);
	        delete this._preventInputValueRender
	    },
	    _scrollToSelectedItem: function() {
	        if (this._dataSource.paginate() && this._isEditable()) {
	            this._list.scrollTo(0)
	        } else {
	            this._list.scrollToItem(this._list.option("selectedItem"))
	        }
	    },
	    _listContentReadyHandler: function() {
	        this.callBase();
	        var isPaginate = this._dataSource.paginate();
	        if (isPaginate && this._needPopupRepaint()) {
	            return
	        }
	        if (!isPaginate || !this._isEditable()) {
	            this._list.scrollToItem(this._list.option("selectedItem"))
	        }
	    },
	    _renderValue: function() {
	        this._renderInputValue();
	        this._setSubmitValue()
	    },
	    _setSubmitValue: function() {
	        var value = this.option("value"),
	            submitValue = "this" === this.option("valueExpr") ? this._displayGetter(value) : value;
	        this._$submitElement.val(submitValue)
	    },
	    _getSubmitElement: function() {
	        return this._$submitElement
	    },
	    _renderInputValue: function() {
	        return this.callBase().always($.proxy(function() {
	            this._renderTooltip();
	            this._renderInputValueImpl();
	            this._refreshSelected()
	        }, this))
	    },
	    _renderInputValueImpl: function() {
	        this._renderInputAddons()
	    },
	    _fitIntoRange: function(value, start, end) {
	        if (value > end) {
	            return start
	        }
	        if (value < start) {
	            return end
	        }
	        return value
	    },
	    _setNextValue: function(step) {
	        var dataSourceIsLoaded = this._dataSource.isLoaded() ? $.Deferred().resolve() : this._dataSource.load();
	        dataSourceIsLoaded.done($.proxy(function() {
	            var item = this._calcNextItem(step),
	                value = this._valueGetter(item);
	            this._setValue(value)
	        }, this))
	    },
	    _calcNextItem: function(step) {
	        var items = this._items();
	        var nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
	        return items[nextIndex]
	    },
	    _items: function() {
	        return this._list ? this.option("items") : this._dataSource.items()
	    },
	    _getSelectedIndex: function() {
	        var items = this._items();
	        var selectedItem = this.option("selectedItem");
	        var result = -1;
	        $.each(items, $.proxy(function(index, item) {
	            if (this._isValueEquals(item, selectedItem)) {
	                result = index;
	                return false
	            }
	        }, this));
	        return result
	    },
	    _setSelectedItem: function(item) {
	        var isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
	        this.callBase(isUnknownItem ? null : item)
	    },
	    _isCustomValueAllowed: function() {
	        return this.option("acceptCustomValue") || this.callBase()
	    },
	    _displayValue: function(item) {
	        item = !commonUtils.isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
	        return this.callBase(item)
	    },
	    _listConfig: function() {
	        var result = $.extend(this.callBase(), {
	            pageLoadMode: "scrollBottom",
	            onSelectionChanged: this._getSelectionChangeHandler(),
	            onFocusedItemChanged: $.proxy(this._listFocusedItemChangeHandler, this)
	        });
	        if (this.option("showSelectionControls")) {
	            $.extend(result, {
	                showSelectionControls: true,
	                selectionByClick: true
	            })
	        }
	        return result
	    },
	    _listFocusedItemChangeHandler: function(e) {
	        if (this._preventInputValueRender) {
	            return
	        }
	        var list = e.component,
	            focusedElement = list.option("focusedElement"),
	            focusedItem = list._getItemData(focusedElement);
	        this._updateField(focusedItem)
	    },
	    _updateField: function(item) {
	        var fieldTemplate = this._getTemplateByOption("fieldTemplate");
	        if (!(fieldTemplate && this.option("fieldTemplate"))) {
	            this._renderDisplayText(this._displayGetter(item));
	            return
	        }
	        this._renderTemplatedField(fieldTemplate, item)
	    },
	    _getSelectionChangeHandler: function() {
	        return this.option("showSelectionControls") ? $.proxy(this._selectionChangeHandler, this) : $.noop
	    },
	    _selectionChangeHandler: function(e) {
	        $.each(e.addedItems || [], $.proxy(function(_, addedItem) {
	            this._setValue(this._valueGetter(addedItem))
	        }, this))
	    },
	    _toggleOpenState: function(isVisible) {
	        if (this.option("disabled")) {
	            return
	        }
	        isVisible = arguments.length ? isVisible : !this.option("opened");
	        if (this._wasSearch() && isVisible) {
	            this._wasSearch(false);
	            if (this.option("showDataBeforeSearch") || 0 === this.option("minSearchLength")) {
	                this._filterDataSource(null)
	            } else {
	                this._setListOption("items", []);
	                this._list && this._setListOption("noDataText", this._list.initialOption("noDataText"))
	            }
	        }
	        this.callBase(isVisible)
	    },
	    _renderTooltip: function() {
	        if (this.option("tooltipEnabled")) {
	            this.element().attr("title", this.option("displayValue"))
	        }
	    },
	    _renderDimensions: function() {
	        this.callBase();
	        this._setPopupOption("width")
	    },
	    _focusOutHandler: function(e) {
	        this.callBase(e);
	        if (!this.option("searchEnabled") || this.option("acceptCustomValue")) {
	            return
	        }
	        if (!this._searchValue() && this.option("allowClearing")) {
	            this._clearTextValue();
	            return
	        }
	        var selectedItem = this.option("selectedItem");
	        this._renderInputValue().always($.proxy(function() {
	            this._setSelectedItem(selectedItem);
	            this._updateField(this.option("selectedItem"))
	        }, this))
	    },
	    _clearTextValue: function() {
	        this.reset()
	    },
	    _renderValueChangeEvent: function() {
	        if (this._isEditable()) {
	            this.callBase()
	        }
	    },
	    _isEditable: function() {
	        return this.option("acceptCustomValue") || this.option("searchEnabled")
	    },
	    _fieldRenderData: function() {
	        return this.option("selectedItem")
	    },
	    _readOnlyPropValue: function() {
	        return !this._isEditable() || this.option("readOnly")
	    },
	    _isSelectedValue: function(value) {
	        return this._isValueEquals(value, this.option("value"))
	    },
	    _shouldCloseOnItemClick: function() {
	        return !(this.option("showSelectionControls") && "single" !== this.option("selectionMode"))
	    },
	    _listItemClickHandler: function(e) {
	        var previousValue = this._getCurrentValue();
	        this._saveValueChangeEvent(e.jQueryEvent);
	        this._completeSelection(this._valueGetter(e.itemData));
	        if (this._shouldCloseOnItemClick()) {
	            this.option("opened", false)
	        }
	        if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
	            this._updateField(e.itemData)
	        }
	    },
	    _completeSelection: function(value) {
	        if (this._wasSearch()) {
	            this._clearFilter()
	        }
	        this._setValue(value)
	    },
	    _clearValueHandler: function() {
	        this.reset()
	    },
	    _loadItem: function(value) {
	        var that = this,
	            deferred = $.Deferred();
	        this.callBase(value).done(function(item) {
	            deferred.resolve(item)
	        }).fail(function() {
	            if (that.option("acceptCustomValue")) {
	                deferred.resolve(that.option("selectedItem"))
	            } else {
	                deferred.reject()
	            }
	        });
	        return deferred.promise()
	    },
	    _valueChangeEventHandler: function() {
	        if (!this.option("acceptCustomValue")) {
	            return
	        }
	        this._customItemAddedHandler()
	    },
	    _initCustomItemCreatingAction: function() {
	        this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating")
	    },
	    _customItemAddedHandler: function() {
	        var searchValue = this._searchValue(),
	            item = this._customItemCreatingAction({
	                text: searchValue
	            }),
	            isDeferred = item && item.promise && item.done && item.fail;
	        if (void 0 === item) {
	            this._renderValue();
	            throw errors.Error("E0121")
	        }
	        isDeferred ? item.always($.proxy(this._setCustomItem, this)) : this._setCustomItem(item)
	    },
	    _setCustomItem: function(item) {
	        item = item || null;
	        this.option("selectedItem", item);
	        this._setValue(this._valueGetter(item));
	        this._renderDisplayText(this._displayGetter(item))
	    },
	    _createClearButton: function() {
	        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
	        return this.callBase().on(eventName, function() {
	            return false
	        })
	    },
	    _wasSearch: function(value) {
	        if (!arguments.length) {
	            return this._wasSearchValue
	        }
	        this._wasSearchValue = value
	    },
	    _searchHandler: function(e) {
	        if (e && this._isControlKey(e.which || e.keyCode) || this._preventFiltering) {
	            delete this._preventFiltering;
	            return
	        }
	        if (this._needPassDataSourceToList()) {
	            this._wasSearch(true)
	        }
	        this.callBase(e)
	    },
	    _filterDataSource: function(searchValue) {
	        this.callBase(searchValue);
	        this._setCollectionWidgetOption("noDataText", searchValue ? "" : this._list && this._list.initialOption("noDataText"))
	    },
	    _dataSourceFiltered: function(searchValue) {
	        this.callBase();
	        if (null !== searchValue) {
	            this._renderInputSubstitution();
	            this._renderFocusedElement()
	        }
	    },
	    _valueSubstituted: function() {
	        var input = this._input().get(0),
	            inputHasSelection = input.selectionStart !== input.selectionEnd;
	        return this._wasSearch() && inputHasSelection
	    },
	    _shouldSubstitutionBeRendered: function() {
	        return this.option("autocompletionEnabled") && !this._preventSubstitution && this.option("searchEnabled") && !this.option("acceptCustomValue") && "startswith" === this.option("searchMode")
	    },
	    _renderInputSubstitution: function() {
	        if (!this._shouldSubstitutionBeRendered()) {
	            delete this._preventSubstitution;
	            return
	        }
	        var item = this._list && this._list.option("items")[0];
	        if (!item) {
	            return
	        }
	        var $input = this._input(),
	            valueLength = $input.val().length;
	        if (0 === valueLength) {
	            return
	        }
	        var inputElement = $input.get(0),
	            displayValue = this._displayGetter(item);
	        inputElement.value = displayValue;
	        inputElement.selectionStart = valueLength;
	        inputElement.selectionEnd = displayValue.length
	    },
	    _cleanInputSelection: function() {
	        var inputElement = this._input().get(0),
	            endPosition = inputElement.value.length;
	        inputElement.selectionStart = endPosition;
	        inputElement.selectionEnd = endPosition
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "_isAdaptablePopupPosition":
	            case "autocompletionEnabled":
	                break;
	            case "onCustomItemCreating":
	                this._initCustomItemCreatingAction();
	                break;
	            case "tooltipEnabled":
	                this._renderTooltip();
	                break;
	            case "displayCustomValue":
	            case "acceptCustomValue":
	            case "showSelectionControls":
	            case "useInkRipple":
	                this._invalidate();
	                break;
	            case "allowClearing":
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	});
	registerComponent("dxSelectBox", SelectBox);
	module.exports = SelectBox;
	module.exports.default = module.exports;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/drop_down_editor/ui.drop_down_list.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    DropDownEditor = __webpack_require__(243),
	    List = __webpack_require__(190),
	    errors = __webpack_require__(15),
	    eventUtils = __webpack_require__(61),
	    devices = __webpack_require__(40),
	    DataExpressionMixin = __webpack_require__(267),
	    messageLocalization = __webpack_require__(79),
	    themes = __webpack_require__(112),
	    ChildDefaultTemplate = __webpack_require__(89);
	var LIST_ITEM_SELECTOR = ".dx-list-item",
	    LIST_ITEM_DATA_KEY = "dxListItemData",
	    DROPDOWNLIST_POPUP_WRAPPER_CLASS = "dx-dropdownlist-popup-wrapper",
	    SKIP_GESTURE_EVENT_CLASS = "dx-skip-gesture-event",
	    SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
	var DropDownList = DropDownEditor.inherit({
	    _supportedKeys: function() {
	        var parent = this.callBase();
	        return $.extend({}, parent, {
	            tab: function() {
	                if (this.option("opened") && "instantly" === this.option("applyValueMode")) {
	                    var $focusedItem = this._list.option("focusedElement");
	                    $focusedItem && this._setSelectedElement($focusedItem)
	                } else {
	                    this._focusTarget().focusout()
	                }
	                parent.tab.apply(this, arguments)
	            },
	            space: $.noop,
	            home: $.noop,
	            end: $.noop
	        })
	    },
	    _setSelectedElement: function($element) {
	        this._list.selectItem($element);
	        var selectedItems = this._list.option("selectedItems");
	        var value = this._valueGetter(selectedItems[selectedItems.length - 1]);
	        this._setValue(value)
	    },
	    _setValue: function(value) {
	        this.option("value", value)
	    },
	    _setDeprecatedOptions: function() {
	        this.callBase();
	        $.extend(this._deprecatedOptions, {
	            pagingEnabled: {
	                since: "15.1",
	                message: "Use the 'dataSource.paginate' option instead"
	            }
	        })
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), $.extend(DataExpressionMixin._dataExpressionDefaultOptions(), {
	            displayValue: void 0,
	            searchEnabled: false,
	            searchMode: "contains",
	            searchTimeout: 500,
	            minSearchLength: 0,
	            searchExpr: null,
	            valueChangeEvent: "input change keyup",
	            selectedItem: null,
	            pagingEnabled: void 0,
	            noDataText: messageLocalization.format("dxCollectionWidget-noDataText"),
	            onSelectionChanged: null,
	            onItemClick: $.noop,
	            showDataBeforeSearch: false,
	            popupPosition: {
	                my: "left top",
	                at: "left bottom",
	                offset: {
	                    h: 0,
	                    v: 0
	                },
	                collision: "flip"
	            },
	            popupWidthExtension: 0
	        }))
	    },
	    _defaultOptionsRules: function() {
	        return this.callBase().concat([{
	            device: function(device) {
	                return "win" === device.platform && device.version && 8 === device.version[0]
	            },
	            options: {
	                popupPosition: {
	                    offset: {
	                        v: -6
	                    }
	                }
	            }
	        }, {
	            device: function() {
	                return /android5/.test(themes.current())
	            },
	            options: {
	                popupWidthExtension: 32
	            }
	        }, {
	            device: {
	                platform: "ios"
	            },
	            options: {
	                popupPosition: {
	                    offset: {
	                        v: -1
	                    }
	                }
	            }
	        }, {
	            device: {
	                platform: "generic"
	            },
	            options: {
	                buttonsLocation: "bottom center"
	            }
	        }])
	    },
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            value: true,
	            selectedItem: true,
	            displayValue: true
	        })
	    },
	    _init: function() {
	        this.callBase();
	        this._initDataExpressions();
	        this._initActions();
	        this._setListDataSource();
	        this._validateSearchMode();
	        this._clearSelectedItem()
	    },
	    _initActions: function() {
	        this._initContentReadyAction();
	        this._initSelectionChangedAction();
	        this._initItemClickAction()
	    },
	    _initContentReadyAction: function() {
	        this._contentReadyAction = this._createActionByOption("onContentReady", {
	            excludeValidators: ["disabled", "readOnly"]
	        })
	    },
	    _initSelectionChangedAction: function() {
	        this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
	            excludeValidators: ["disabled", "readOnly"]
	        })
	    },
	    _initItemClickAction: function() {
	        this._itemClickAction = this._createActionByOption("onItemClick")
	    },
	    _initTemplates: function() {
	        this.callBase();
	        this._defaultTemplates.item = new ChildDefaultTemplate("item", this)
	    },
	    _renderField: function() {
	        this.callBase();
	        this._input().on("input", $.proxy(this._setFocusPolicy, this))
	    },
	    _preventFocusOnPopup: function(e) {
	        if (this._list && this._list.initialOption("focusStateEnabled")) {
	            e.preventDefault()
	        }
	    },
	    _createPopup: function() {
	        this.callBase();
	        this._popup._wrapper().addClass(this._popupWrapperClass());
	        this._popup.content().off("mousedown").on("mousedown", $.proxy(this._preventFocusOnPopup, this))
	    },
	    _popupWrapperClass: function() {
	        return DROPDOWNLIST_POPUP_WRAPPER_CLASS
	    },
	    _renderInputValue: function() {
	        var callBase = $.proxy(this.callBase, this),
	            value = this._getCurrentValue();
	        return this._loadItem(value).always($.proxy(function(item) {
	            this._setSelectedItem(item);
	            callBase(value)
	        }, this))
	    },
	    _loadItem: function(value) {
	        var selectedItem = $.grep(this.option("items") || [], $.proxy(function(item) {
	            return this._isValueEquals(this._valueGetter(item), value)
	        }, this))[0];
	        return void 0 !== selectedItem ? $.Deferred().resolve(selectedItem).promise() : this._loadValue(value)
	    },
	    _setSelectedItem: function(item) {
	        var displayValue = this._displayValue(item);
	        this.option("selectedItem", commonUtils.ensureDefined(item, null));
	        this.option("displayValue", displayValue)
	    },
	    _displayValue: function(item) {
	        return this._displayGetter(item)
	    },
	    _refreshSelected: function() {
	        this._listItemElements().each($.proxy(function(_, itemElement) {
	            var $itemElement = $(itemElement);
	            var itemValue = this._valueGetter($itemElement.data(LIST_ITEM_DATA_KEY));
	            var isItemSelected = this._isSelectedValue(itemValue);
	            if (isItemSelected) {
	                this._list.selectItem($itemElement)
	            } else {
	                this._list.unselectItem($itemElement)
	            }
	        }, this))
	    },
	    _popupShownHandler: function() {
	        this.callBase();
	        this._setFocusPolicy()
	    },
	    _setFocusPolicy: function() {
	        if (!this.option("focusStateEnabled") || !this._list) {
	            return
	        }
	        this._list.option("focusedElement", null)
	    },
	    _isSelectedValue: function(value) {
	        return this._isValueEquals(value, this.option("value"))
	    },
	    _validateSearchMode: function() {
	        var searchMode = this.option("searchMode"),
	            normalizedSearchMode = searchMode.toLowerCase();
	        if ($.inArray(normalizedSearchMode, SEARCH_MODES) < 0) {
	            throw errors.Error("E1019", searchMode)
	        }
	    },
	    _clearSelectedItem: function() {
	        this.option("selectedItem", null)
	    },
	    _processDataSourceChanging: function() {
	        this._setListDataSource();
	        this._renderInputValue().fail($.proxy(function() {
	            if (this._isCustomValueAllowed()) {
	                return
	            }
	            this._clearSelectedItem()
	        }, this))
	    },
	    _isCustomValueAllowed: function() {
	        return this.option("displayCustomValue")
	    },
	    reset: function() {
	        this.callBase();
	        this._clearFilter();
	        this._clearSelectedItem()
	    },
	    _listItemElements: function() {
	        return this._$list ? this._$list.find(LIST_ITEM_SELECTOR) : $()
	    },
	    _popupConfig: function() {
	        var that = this;
	        return $.extend(this.callBase(), {
	            width: this.option("width"),
	            onShowing: function() {
	                that.element().addClass(SKIP_GESTURE_EVENT_CLASS)
	            },
	            onHidden: function() {
	                that.element().removeClass(SKIP_GESTURE_EVENT_CLASS)
	            },
	            height: "auto",
	            maxHeight: $.proxy(this._getMaxHeight, this)
	        })
	    },
	    _renderPopupContent: function() {
	        this._renderList()
	    },
	    _attachChildKeyboardEvents: function() {
	        this._childKeyboardProcessor = this._keyboardProcessor.attachChildProcessor();
	        this._setListOption("_keyboardProcessor", this._childKeyboardProcessor)
	    },
	    _fireContentReadyAction: $.noop,
	    _setAriaTargetForList: function() {
	        this._list._getAriaTarget = $.proxy(this._getAriaTarget, this);
	        this._list.setAria("role", "combobox")
	    },
	    _renderList: function() {
	        this._listId = (new Guid)._value;
	        var $list = this._$list = $("<div>", {
	            id: this._listId
	        }).appendTo(this._popup.content());
	        this._list = this._createComponent($list, List, this._listConfig());
	        this._refreshList();
	        this._setAriaTargetForList()
	    },
	    _renderOpenedState: function() {
	        this.callBase();
	        var opened = this.option("opened") || void 0;
	        this.setAria({
	            activedescendant: opened && this._list.getFocusedItemId(),
	            owns: opened && this._listId
	        })
	    },
	    _refreshList: function() {
	        if (this._list && this._shouldRefreshDataSource()) {
	            this._setListDataSource()
	        }
	    },
	    _shouldRefreshDataSource: function() {
	        var dataSourceProvided = !!this._list.option("dataSource");
	        return dataSourceProvided !== this._needPassDataSourceToList()
	    },
	    _isDesktopDevice: function() {
	        return "desktop" === devices.real().deviceType
	    },
	    _listConfig: function() {
	        return {
	            selectionMode: "single",
	            _templates: this.option("_templates"),
	            templateProvider: this.option("templateProvider"),
	            noDataText: this.option("noDataText"),
	            onContentReady: $.proxy(this._listContentReadyHandler, this),
	            itemTemplate: this._getTemplateByOption("itemTemplate"),
	            indicateLoading: false,
	            tabIndex: -1,
	            onItemClick: $.proxy(this._listItemClickAction, this),
	            dataSource: this._getDataSource(),
	            _keyboardProcessor: this._childKeyboardProcessor,
	            hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
	            focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false,
	            selectedItem: this.option("selectedItem")
	        }
	    },
	    _getDataSource: function() {
	        return this._needPassDataSourceToList() ? this._dataSource : null
	    },
	    _dataSourceOptions: function() {
	        this._suppressDeprecatedWarnings();
	        var pagingEnabled = this.option("pagingEnabled");
	        this._resumeDeprecatedWarnings();
	        return {
	            paginate: commonUtils.ensureDefined(pagingEnabled, false)
	        }
	    },
	    _listContentReadyHandler: function() {
	        this._list = this._list || this._$list.dxList("instance");
	        this._dimensionChanged();
	        this._contentReadyAction()
	    },
	    _setListOption: function(optionName, value) {
	        this._setWidgetOption("_list", arguments)
	    },
	    _listItemClickAction: function(e) {
	        this._listItemClickHandler(e);
	        this._itemClickAction(e)
	    },
	    _listItemClickHandler: $.noop,
	    _setListDataSource: function() {
	        if (!this._list) {
	            return
	        }
	        this._setListOption("dataSource", this._getDataSource());
	        if (!this._needPassDataSourceToList()) {
	            this._setListOption("items", [])
	        }
	    },
	    _needPassDataSourceToList: function() {
	        return this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded()
	    },
	    _isMinSearchLengthExceeded: function() {
	        return this._searchValue().toString().length >= this.option("minSearchLength")
	    },
	    _searchValue: function() {
	        return this._input().val() || ""
	    },
	    _getSearchEvent: function() {
	        return eventUtils.addNamespace("keyup", this.NAME + "Search")
	    },
	    _renderEvents: function() {
	        this.callBase();
	        if (this._shouldRenderSearchEvent()) {
	            this._input().on(this._getSearchEvent(), $.proxy(this._searchHandler, this))
	        }
	    },
	    _shouldRenderSearchEvent: function() {
	        return this.option("searchEnabled")
	    },
	    _refreshEvents: function() {
	        this._input().off(this._getSearchEvent());
	        this.callBase()
	    },
	    _searchHandler: function() {
	        if (!this._isMinSearchLengthExceeded()) {
	            this._searchCanceled();
	            return
	        }
	        var searchTimeout = this.option("searchTimeout");
	        if (searchTimeout) {
	            this._clearSearchTimer();
	            this._searchTimer = setTimeout($.proxy(this._searchDataSource, this), searchTimeout)
	        } else {
	            this._searchDataSource()
	        }
	    },
	    _searchCanceled: function() {
	        this._clearSearchTimer();
	        if (this._needPassDataSourceToList()) {
	            this._filterDataSource(null)
	        }
	        this._refreshList()
	    },
	    _searchDataSource: function() {
	        this._filterDataSource(this._searchValue())
	    },
	    _filterDataSource: function(searchValue) {
	        this._clearSearchTimer();
	        var dataSource = this._dataSource;
	        dataSource.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
	        dataSource.searchOperation(this.option("searchMode"));
	        dataSource.searchValue(searchValue);
	        return dataSource.load().done($.proxy(this._dataSourceFiltered, this, searchValue))
	    },
	    _clearFilter: function() {
	        var dataSource = this._dataSource;
	        dataSource && dataSource.searchValue() && dataSource.searchValue(null)
	    },
	    _dataSourceFiltered: function() {
	        this._refreshList();
	        this._refreshPopupVisibility()
	    },
	    _refreshPopupVisibility: function() {
	        if (this.option("readOnly")) {
	            return
	        }
	        this.option("opened", this._hasItemsToShow());
	        if (this.option("opened")) {
	            this._dimensionChanged()
	        }
	    },
	    _dataSourceChangedHandler: function(newItems) {
	        if (0 === this._dataSource.pageIndex()) {
	            this.option().items = newItems
	        } else {
	            this.option().items = this.option().items.concat(newItems)
	        }
	    },
	    _hasItemsToShow: function() {
	        var resultItems = this._dataSource && this._dataSource.items() || [];
	        var resultAmount = resultItems.length;
	        var isMinSearchLengthExceeded = this._needPassDataSourceToList();
	        return isMinSearchLengthExceeded && resultAmount && this._hasFocusClass()
	    },
	    _clearSearchTimer: function() {
	        clearTimeout(this._searchTimer);
	        delete this._searchTimer
	    },
	    _popupShowingHandler: function() {
	        this._dimensionChanged()
	    },
	    _dimensionChanged: function() {
	        this._popup && this._updatePopupDimensions()
	    },
	    _updatePopupDimensions: function() {
	        this._updatePopupWidth();
	        this._updatePopupHeight()
	    },
	    _updatePopupWidth: function() {
	        this._setPopupOption("width", this.element().outerWidth() + this.option("popupWidthExtension"))
	    },
	    _needPopupRepaint: function() {
	        var currentPageIndex = this._dataSource.pageIndex(),
	            needRepaint = commonUtils.isDefined(this._pageIndex) && currentPageIndex <= this._pageIndex;
	        this._pageIndex = currentPageIndex;
	        return needRepaint
	    },
	    _updatePopupHeight: function() {
	        if (this._needPopupRepaint()) {
	            this._popup.repaint()
	        }
	        this._list && this._list.updateDimensions()
	    },
	    _getMaxHeight: function() {
	        var $element = this.element(),
	            offset = $element.offset(),
	            windowHeight = $(window).height(),
	            maxHeight = Math.max(offset.top, windowHeight - offset.top - $element.outerHeight());
	        return Math.min(.5 * windowHeight, maxHeight)
	    },
	    _clean: function() {
	        if (this._list) {
	            delete this._list
	        }
	        this.callBase()
	    },
	    _dispose: function() {
	        this._clearSearchTimer();
	        this.callBase()
	    },
	    _setCollectionWidgetOption: function() {
	        this._setListOption.apply(this, arguments)
	    },
	    _optionChanged: function(args) {
	        this._dataExpressionOptionChanged(args);
	        switch (args.name) {
	            case "hoverStateEnabled":
	            case "focusStateEnabled":
	                this._isDesktopDevice() && this._setListOption(args.name, args.value);
	                this.callBase(args);
	                break;
	            case "items":
	                if (!this.option("dataSource")) {
	                    this._processDataSourceChanging()
	                }
	                break;
	            case "dataSource":
	                this._processDataSourceChanging();
	                break;
	            case "valueExpr":
	            case "displayExpr":
	                this._renderValue();
	                break;
	            case "searchMode":
	                this._validateSearchMode();
	                break;
	            case "minSearchLength":
	                this._refreshList();
	                break;
	            case "searchEnabled":
	            case "showDataBeforeSearch":
	            case "searchExpr":
	            case "pagingEnabled":
	                this._invalidate();
	                break;
	            case "onContentReady":
	                this._initContentReadyAction();
	                break;
	            case "onSelectionChanged":
	                this._initSelectionChangedAction();
	                break;
	            case "onItemClick":
	                this._initItemClickAction();
	                break;
	            case "noDataText":
	                this._setListOption("noDataText");
	                break;
	            case "displayValue":
	                this.option("text", args.value);
	                break;
	            case "itemTemplate":
	            case "searchTimeout":
	            case "popupWidthExtension":
	                break;
	            case "selectedItem":
	                this._selectionChangedAction({
	                    selectedItem: args.value
	                });
	                break;
	            default:
	                this.callBase(args)
	        }
	    }
	}).include(DataExpressionMixin);
	registerComponent("dxDropDownList", DropDownList);
	module.exports = DropDownList;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/editor/ui.data_expression.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    variableWrapper = __webpack_require__(37),
	    dataCoreUtils = __webpack_require__(35),
	    commonUtils = __webpack_require__(8),
	    FunctionTemplate = __webpack_require__(87),
	    DataHelperMixin = __webpack_require__(120),
	    DataSourceModule = __webpack_require__(121),
	    ArrayStore = __webpack_require__(129);
	var DataExpressionMixin = $.extend(DataHelperMixin, {
	    _dataExpressionDefaultOptions: function() {
	        return {
	            items: [],
	            dataSource: null,
	            itemTemplate: "item",
	            value: null,
	            valueExpr: "this",
	            displayExpr: void 0
	        }
	    },
	    _initDataExpressions: function() {
	        this._compileValueGetter();
	        this._compileDisplayGetter();
	        this._initDynamicTemplates();
	        this._initDataSource();
	        this._itemsToDataSource()
	    },
	    _itemsToDataSource: function() {
	        if (!this.option("dataSource")) {
	            this._dataSource = new DataSourceModule.DataSource({
	                store: new ArrayStore(this.option("items")),
	                pageSize: 0
	            })
	        }
	    },
	    _compileDisplayGetter: function() {
	        this._displayGetter = dataCoreUtils.compileGetter(this._displayGetterExpr())
	    },
	    _displayGetterExpr: function() {
	        return this.option("displayExpr")
	    },
	    _compileValueGetter: function() {
	        this._valueGetter = dataCoreUtils.compileGetter(this._valueGetterExpr())
	    },
	    _valueGetterExpr: function() {
	        return this.option("valueExpr") || "this"
	    },
	    _loadValue: function(value) {
	        var deferred = $.Deferred();
	        value = this._unwrappedValue(value);
	        if (!commonUtils.isDefined(value)) {
	            return deferred.reject().promise()
	        }
	        this._loadSingle(this._valueGetterExpr(), value).done($.proxy(function(item) {
	            this._isValueEquals(this._valueGetter(item), value) ? deferred.resolve(item) : deferred.reject()
	        }, this)).fail(function() {
	            deferred.reject()
	        });
	        return deferred.promise()
	    },
	    _getCurrentValue: function() {
	        return this.option("value")
	    },
	    _unwrappedValue: function(value) {
	        value = commonUtils.isDefined(value) ? value : this._getCurrentValue();
	        if (value && this._dataSource && "this" === this._valueGetterExpr()) {
	            value = this._getItemKey(value)
	        }
	        return variableWrapper.unwrap(value)
	    },
	    _getItemKey: function(value) {
	        var key = this._dataSource.key();
	        if (commonUtils.isArray(key)) {
	            var result = {};
	            for (var i = 0, n = key.length; i < n; i++) {
	                result[key[i]] = value[key[i]]
	            }
	            return result
	        }
	        if (key && "object" === typeof value) {
	            value = value[key]
	        }
	        return value
	    },
	    _isValueEquals: function(value1, value2) {
	        var dataSourceKey = this._dataSource && this._dataSource.key();
	        if (commonUtils.isArray(dataSourceKey)) {
	            return this._compareByCompositeKey(value1, value2, dataSourceKey)
	        }
	        var isDefined = commonUtils.isDefined;
	        var result = this._compareValues(value1, value2);
	        if (!result && isDefined(value1) && isDefined(value2) && dataSourceKey) {
	            result = this._compareByKey(value1, value2, dataSourceKey)
	        }
	        return result
	    },
	    _compareByCompositeKey: function(value1, value2, key) {
	        for (var i = 0, n = key.length; i < n; i++) {
	            if (value1[key[i]] !== value2[key[i]]) {
	                return false
	            }
	        }
	        return true
	    },
	    _compareByKey: function(value1, value2, key) {
	        var ensureDefined = commonUtils.ensureDefined;
	        var unwrapObservable = variableWrapper.unwrap;
	        var valueKey1 = ensureDefined(unwrapObservable(value1[key]), value1);
	        var valueKey2 = ensureDefined(unwrapObservable(value2[key]), value2);
	        return this._compareValues(valueKey1, valueKey2)
	    },
	    _compareValues: function(value1, value2) {
	        return dataCoreUtils.toComparable(value1) === dataCoreUtils.toComparable(value2)
	    },
	    _initDynamicTemplates: function() {
	        if (this._displayGetterExpr()) {
	            this._originalItemTemplate = this._defaultTemplates.item;
	            this._defaultTemplates.item = new FunctionTemplate($.proxy(function(options) {
	                return $("<div/>").text(this._displayGetter(options.model)).html()
	            }, this))
	        } else {
	            if (this._originalItemTemplate) {
	                this._defaultTemplates.item = this._originalItemTemplate
	            }
	        }
	    },
	    _setCollectionWidgetItemTemplate: function() {
	        this._initDynamicTemplates();
	        this._setCollectionWidgetOption("itemTemplate", this._getTemplateByOption("itemTemplate"))
	    },
	    _dataExpressionOptionChanged: function(args) {
	        switch (args.name) {
	            case "items":
	                this._itemsToDataSource();
	                this._setCollectionWidgetOption("items");
	                break;
	            case "dataSource":
	                this._initDataSource();
	                break;
	            case "itemTemplate":
	                this._setCollectionWidgetItemTemplate();
	                break;
	            case "valueExpr":
	                this._compileValueGetter();
	                break;
	            case "displayExpr":
	                this._compileDisplayGetter();
	                this._setCollectionWidgetItemTemplate()
	        }
	    }
	});
	module.exports = DataExpressionMixin;


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.validation_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    gridCoreUtils = __webpack_require__(148),
	    commonUtils = __webpack_require__(8),
	    equalByValue = commonUtils.equalByValue,
	    messageLocalization = __webpack_require__(79),
	    Button = __webpack_require__(114),
	    pointerEvents = __webpack_require__(66),
	    ValidationEngine = __webpack_require__(106),
	    Validator = __webpack_require__(226),
	    Tooltip = __webpack_require__(269),
	    Overlay = __webpack_require__(97);
	__webpack_require__(222);
	var DATAGRID_INVALIDATE_CLASS = "dx-datagrid-invalid",
	    DATAGRID_INVALID_MESSAGE_CLASS = "dx-invalid-message",
	    DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always",
	    DATAGRID_REVERT_BUTTON_CLASS = "dx-revert-button",
	    DATAGRID_REVERT_TOOLTIP_CLASS = "dx-datagrid-revert-tooltip",
	    DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
	    DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
	    DATAGRID_EDIT_MODE_ROW = "row",
	    DATAGRID_EDIT_MODE_FORM = "form",
	    DATAGRID_EDIT_MODE_BATCH = "batch",
	    DATAGRID_EDIT_MODE_CELL = "cell";
	exports.ValidatingController = gridCore.Controller.inherit(function() {
	    return {
	        init: function() {
	            this._editingController = this.getController("editing");
	            this.createAction("onRowValidating")
	        },
	        _rowValidating: function(editData, validate) {
	            var that = this,
	                brokenRules = validate ? validate.brokenRules || validate.brokenRule && [validate.brokenRule] : [],
	                isValid = validate ? validate.isValid : editData.isValid,
	                parameters = {
	                    brokenRules: brokenRules,
	                    isValid: isValid,
	                    key: editData.key,
	                    newData: editData.data,
	                    oldData: editData.oldData,
	                    errorText: null
	                };
	            that.executeAction("onRowValidating", parameters);
	            editData.isValid = parameters.isValid;
	            editData.errorText = parameters.errorText;
	            return parameters
	        },
	        validate: function(isFull) {
	            var that = this,
	                isValid = true,
	                editingController = that._editingController;
	            isFull = isFull || editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW;
	            if (that._isValidationInProgress) {
	                return false
	            }
	            that._isValidationInProgress = true;
	            if (isFull) {
	                $.each(editingController._editData, function(index, editData) {
	                    var validationResult;
	                    if (editData.type && "remove" !== editData.type) {
	                        validationResult = that.validateGroup(editData);
	                        if (!validationResult.isValid) {
	                            $.each(validationResult.brokenRules, function() {
	                                var value = this.validator.option("adapter").getValue();
	                                if (void 0 === value) {
	                                    value = null
	                                }
	                                if (this.column) {
	                                    editingController.updateFieldValue({
	                                        key: editData.key,
	                                        column: this.column
	                                    }, value, null, true)
	                                }
	                            })
	                        }
	                        isValid = isValid && validationResult.isValid
	                    }
	                })
	            } else {
	                if (that._currentCellValidator) {
	                    isValid = that.validateGroup(that._currentCellValidator._findGroup()).isValid
	                }
	            }
	            that._isValidationInProgress = false;
	            return isValid
	        },
	        validateGroup: function(editData) {
	            var validationResults, that = this,
	                validateGroup = ValidationEngine.getGroupConfig(editData);
	            if (validateGroup && validateGroup.validators.length) {
	                validationResults = ValidationEngine.validateGroup(editData)
	            }
	            return that._rowValidating(editData, validationResults)
	        },
	        updateEditData: function(editData) {
	            if (this._editingController.getEditMode() !== DATAGRID_EDIT_MODE_FORM) {
	                this.setDisableApplyValidationResults(true);
	                editData.isValid = ValidationEngine.getGroupConfig(editData) ? ValidationEngine.validateGroup(editData).isValid : true;
	                this.setDisableApplyValidationResults(false)
	            } else {
	                editData.isValid = true
	            }
	        },
	        setValidator: function(validator) {
	            this._currentCellValidator = validator
	        },
	        getValidator: function() {
	            return this._currentCellValidator
	        },
	        removeValidators: function(editIndex) {
	            var that = this,
	                editingController = that._editingController;
	            $.each(editingController._editData, function(index, editData) {
	                var validateGroup = ValidationEngine.getGroupConfig(editData);
	                if (!commonUtils.isDefined(editIndex) || editIndex === index) {
	                    if (validateGroup) {
	                        for (var i = 0; i < validateGroup.validators.length; i++) {
	                            validateGroup.validators[i]._dispose();
	                            i--
	                        }
	                    }
	                }
	            })
	        },
	        createValidator: function(parameters, $container) {
	            var editData, editIndex, that = this,
	                editingController = that._editingController,
	                column = parameters.column,
	                defaultValidationResult = function(options) {
	                    if (options.brokenRule) {
	                        options.brokenRule.columnIndex = column.index;
	                        options.brokenRule.column = column
	                    }
	                    if ($container && !that.getDisableApplyValidationResults()) {
	                        if (!options.isValid) {
	                            var $focus = $container.find(":focus");
	                            editingController.showHighlighting($container, true);
	                            if (!$focus.is(":focus")) {
	                                $focus.focus().trigger(pointerEvents.down)
	                            }
	                        }
	                        $container.toggleClass(DATAGRID_INVALIDATE_CLASS, !options.isValid)
	                    }
	                };
	            if (!column.validationRules || !commonUtils.isArray(column.validationRules) || commonUtils.isDefined(column.command)) {
	                return
	            }
	            editIndex = editingController.getIndexByKey(parameters.key, editingController._editData);
	            if (editIndex < 0 && column.showEditorAlways) {
	                editIndex = editingController._addEditData({
	                    key: parameters.key
	                })
	            }
	            if (editIndex >= 0) {
	                editData = editingController._editData[editIndex];
	                return new Validator($container || {}, {
	                    name: column.caption,
	                    validationRules: $.extend(true, [], column.validationRules),
	                    validationGroup: editData,
	                    adapter: $container && $container.hasClass("dx-widget") ? null : {
	                        getValue: function() {
	                            var value = column.calculateCellValue(editData.data || {});
	                            return void 0 !== value ? value : parameters.value
	                        },
	                        applyValidationResults: defaultValidationResult
	                    }
	                })
	            }
	        },
	        setDisableApplyValidationResults: function(flag) {
	            this._disableApplyValidationResults = flag
	        },
	        getDisableApplyValidationResults: function() {
	            return this._disableApplyValidationResults
	        }
	    }
	}());
	gridCore.registerModule("validating", {
	    defaultOptions: function() {
	        return {
	            editing: {
	                texts: {
	                    validationCancelChanges: messageLocalization.format("dxDataGrid-validationCancelChanges")
	                }
	            }
	        }
	    },
	    controllers: {
	        validating: exports.ValidatingController
	    },
	    extenders: {
	        controllers: {
	            editing: {
	                _addEditData: function(options) {
	                    var editData, that = this,
	                        validatingController = that.getController("validating"),
	                        editDataIndex = that.callBase(options);
	                    if (editDataIndex >= 0) {
	                        editData = that._editData[editDataIndex];
	                        validatingController.updateEditData(editData)
	                    }
	                    return editDataIndex
	                },
	                _updateRowAndPageIndices: function() {
	                    var that = this,
	                        startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex(),
	                        rowIndex = startInsertIndex;
	                    $.each(that._editData, function(_, editData) {
	                        if (!editData.isValid && editData.pageIndex !== that._pageIndex) {
	                            editData.pageIndex = that._pageIndex;
	                            if ("insert" === editData.type) {
	                                editData.rowIndex = startInsertIndex
	                            } else {
	                                editData.rowIndex = rowIndex
	                            }
	                            rowIndex++
	                        }
	                    })
	                },
	                _needInsertItem: function(editData) {
	                    var result = this.callBase.apply(this, arguments);
	                    if (result && !editData.isValid) {
	                        result = editData.key.pageIndex === this._pageIndex
	                    }
	                    return result
	                },
	                processItems: function(items, changeType) {
	                    var i, itemsCount, that = this,
	                        insertCount = 0,
	                        editData = that._editData,
	                        dataController = that.getController("data"),
	                        getIndexByEditData = function(editData, items) {
	                            var index = -1,
	                                isInsert = "insert" === editData.type,
	                                key = editData.key;
	                            $.each(items, function(i, item) {
	                                if (equalByValue(key, isInsert ? item : dataController.keyOf(item))) {
	                                    index = i;
	                                    return false
	                                }
	                            });
	                            return index
	                        },
	                        addInValidItem = function(editData) {
	                            var rowIndex, data = {
	                                    key: editData.key
	                                },
	                                index = getIndexByEditData(editData, items);
	                            if (index >= 0) {
	                                return
	                            }
	                            editData.rowIndex = editData.rowIndex > itemsCount ? editData.rowIndex % itemsCount : editData.rowIndex;
	                            rowIndex = editData.rowIndex;
	                            data[DATAGRID_INSERT_INDEX] = 1;
	                            if (index >= 0) {
	                                items.splice(index, 1);
	                                rowIndex -= insertCount
	                            }
	                            items.splice(rowIndex, 0, data);
	                            insertCount++
	                        };
	                    items = that.callBase(items, changeType);
	                    itemsCount = items.length;
	                    if (that.getEditMode() === DATAGRID_EDIT_MODE_BATCH && "prepend" !== changeType && "append" !== changeType) {
	                        for (i = 0; i < editData.length; i++) {
	                            if (editData[i].type && editData[i].pageIndex === that._pageIndex && editData[i].key.pageIndex !== that._pageIndex) {
	                                addInValidItem(editData[i])
	                            }
	                        }
	                    }
	                    return items
	                },
	                processDataItem: function(item) {
	                    var editIndex, editData, that = this,
	                        isInserted = item.data[DATAGRID_INSERT_INDEX],
	                        key = isInserted ? item.data.key : item.key,
	                        editMode = that.getEditMode();
	                    if (editMode === DATAGRID_EDIT_MODE_BATCH && isInserted && key) {
	                        editIndex = gridCoreUtils.getIndexByKey(key, that._editData);
	                        if (editIndex >= 0) {
	                            editData = that._editData[editIndex];
	                            if ("insert" !== editData.type) {
	                                item.data = $.extend(true, {}, editData.oldData, editData.data);
	                                item.key = key
	                            }
	                        }
	                    }
	                    that.callBase.apply(that, arguments)
	                },
	                _afterInsertRow: function(options) {
	                    var validatingController = this.getController("validating"),
	                        invisibleColumns = $.grep(this.getController("columns").getInvisibleColumns(), function(column) {
	                            return !column.isBand
	                        });
	                    if (this.getEditMode() !== DATAGRID_EDIT_MODE_FORM) {
	                        $.each(invisibleColumns, function(_, column) {
	                            validatingController.createValidator({
	                                column: column,
	                                key: options.key,
	                                value: column.calculateCellValue(options.data)
	                            })
	                        })
	                    }
	                    this.callBase(options)
	                },
	                _beforeSaveEditData: function(editData, editIndex) {
	                    var isValid, isFullValid, that = this,
	                        result = that.callBase.apply(that, arguments),
	                        validatingController = that.getController("validating");
	                    if (editData) {
	                        isValid = "remove" === editData.type || editData.isValid;
	                        if (isValid) {
	                            validatingController.removeValidators(editIndex)
	                        }
	                        result = result || !isValid
	                    } else {
	                        isFullValid = validatingController.validate(true);
	                        that._updateRowAndPageIndices();
	                        if (that.getEditMode() === DATAGRID_EDIT_MODE_CELL) {
	                            if (!isFullValid) {
	                                that._focusEditingCell();
	                                result = true
	                            }
	                        } else {
	                            if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW) {
	                                result = !isFullValid
	                            }
	                        }
	                    }
	                    return result
	                },
	                _beforeEditCell: function(rowIndex, columnIndex, item) {
	                    var result = this.callBase(rowIndex, columnIndex, item),
	                        $cell = this.component.getCellElement(rowIndex, columnIndex),
	                        validator = $cell && $cell.data("dxValidator");
	                    if (this.getEditMode(this) === DATAGRID_EDIT_MODE_CELL && (!validator || validator.validate().isValid)) {
	                        return result
	                    }
	                },
	                _afterSaveEditData: function() {
	                    var that = this;
	                    $.each(that._editData, function(_, editData) {
	                        that._showErrorRow(editData)
	                    })
	                },
	                _beforeCancelEditData: function() {
	                    var validatingController = this.getController("validating");
	                    validatingController.removeValidators();
	                    this.callBase()
	                },
	                _showErrorRow: function(editData) {
	                    var errorHandling = this.getController("errorHandling"),
	                        items = this.getController("data").items(),
	                        rowIndex = this.getIndexByKey(editData.key, items);
	                    if (!editData.isValid && editData.errorText && rowIndex >= 0) {
	                        errorHandling && errorHandling.renderErrorRow(editData.errorText, rowIndex)
	                    }
	                },
	                updateFieldValue: function() {
	                    var that = this;
	                    that.callBase.apply(that, arguments);
	                    if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW) {
	                        var currentValidator = that.getController("validating").getValidator();
	                        currentValidator && currentValidator.validate()
	                    }
	                },
	                showHighlighting: function($cell, skipValidation) {
	                    var validator, isValid = true;
	                    if (!skipValidation) {
	                        validator = $cell.data("dxValidator");
	                        if (validator) {
	                            isValid = validator.validate().isValid
	                        }
	                    }
	                    if (isValid) {
	                        this.callBase($cell)
	                    }
	                },
	                getEditDataByKey: function(key) {
	                    return this._editData[gridCoreUtils.getIndexByKey(key, this._editData)]
	                }
	            },
	            editorFactory: {
	                _showRevertButton: function($container, $targetElement) {
	                    var that = this;
	                    if ($targetElement && $targetElement.length) {
	                        new Tooltip($("<div>").addClass(DATAGRID_REVERT_TOOLTIP_CLASS).appendTo($container), {
	                            animation: null,
	                            visible: true,
	                            target: $targetElement,
	                            closeOnOutsideClick: false,
	                            closeOnTargetScroll: false,
	                            boundary: that._rowsView.element(),
	                            contentTemplate: function() {
	                                return new Button($("<div>").addClass(DATAGRID_REVERT_BUTTON_CLASS), {
	                                    icon: "revert",
	                                    hint: that.option("editing.texts.validationCancelChanges"),
	                                    onClick: function() {
	                                        that._editingController.cancelEditData()
	                                    }
	                                }).element()
	                            },
	                            position: {
	                                my: "left top",
	                                at: "right top",
	                                of: $targetElement,
	                                offset: "1 0",
	                                collision: "flip"
	                            }
	                        })
	                    }
	                },
	                _showValidationMessage: function($cell, message, alignment) {
	                    var that = this,
	                        $highlightContainer = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE);
	                    new Overlay($("<div/>").addClass(DATAGRID_INVALID_MESSAGE_CLASS).addClass(DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS).text(message).appendTo($cell), {
	                        target: $highlightContainer.length ? $highlightContainer : $cell,
	                        container: $cell,
	                        shading: false,
	                        width: "auto",
	                        height: "auto",
	                        visible: true,
	                        animation: false,
	                        closeOnOutsideClick: false,
	                        closeOnTargetScroll: false,
	                        position: {
	                            collision: "fit flip",
	                            boundary: that._rowsView.element(),
	                            boundaryOffset: "0 0",
	                            my: "top " + alignment,
	                            at: "bottom " + alignment
	                        },
	                        onPositioned: function() {
	                            that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight()
	                        }
	                    })
	                },
	                _getTooltipsSelector: function() {
	                    return ".dx-editor-cell .dx-tooltip, .dx-editor-cell .dx-invalid-message"
	                },
	                init: function() {
	                    this.callBase();
	                    this._editingController = this.getController("editing");
	                    this._rowsView = this.getView("rowsView")
	                },
	                loseFocus: function(skipValidator) {
	                    if (!skipValidator) {
	                        this.getController("validating").setValidator(null)
	                    }
	                    this.callBase()
	                },
	                focus: function($element, hideBorder) {
	                    var validationResult, that = this,
	                        $focus = $element && $element.closest(that._getFocusCellSelector()),
	                        validator = $focus && ($focus.data("dxValidator") || $element.find(".dx-validator").eq(0).data("dxValidator")),
	                        rowOptions = $focus && $focus.closest(".dx-row").data("options"),
	                        editData = rowOptions ? that.getController("editing").getEditDataByKey(rowOptions.key) : null,
	                        $tooltips = $focus && $focus.closest(".dx-datagrid-rowsview").find(that._getTooltipsSelector()),
	                        $cell = $focus && $focus.is("td") ? $focus : null,
	                        column = $cell && that.getController("columns").getVisibleColumns()[$cell.index()];
	                    if (!arguments.length) {
	                        return that.callBase()
	                    }
	                    $tooltips && $tooltips.remove();
	                    if (validator) {
	                        that.getController("validating").setValidator(validator);
	                        if (void 0 !== validator.option("adapter").getValue()) {
	                            validationResult = validator.validate();
	                            if (!validationResult.isValid) {
	                                hideBorder = true;
	                                if ($cell && column) {
	                                    that._showValidationMessage($focus, validationResult.brokenRule.message, column.alignment)
	                                }
	                            }
	                        }
	                    }
	                    if (validationResult && !validationResult.isValid || editData && "update" === editData.type) {
	                        if (that._editingController.getEditMode() === DATAGRID_EDIT_MODE_CELL) {
	                            that._showRevertButton($focus, $cell ? $focus.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE).first() : $focus)
	                        }
	                    }!hideBorder && that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight();
	                    return that.callBase($element, hideBorder)
	                }
	            }
	        },
	        views: {
	            rowsView: {
	                updateFreeSpaceRowHeight: function($table) {
	                    var that = this,
	                        $rowElements = that._getRowElements(),
	                        $freeSpaceRowElements = that._getFreeSpaceRowElements($table),
	                        $freeSpaceRowElement = $freeSpaceRowElements.first(),
	                        $tooltipContent = that.element().find(".dx-invalid-message .dx-overlay-content");
	                    that.callBase($table);
	                    if ($tooltipContent.length && $freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(":visible") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {
	                        $freeSpaceRowElements.show();
	                        $freeSpaceRowElements.height($tooltipContent.outerHeight())
	                    }
	                },
	                _formItemPrepared: function(cellOptions, $container) {
	                    this.callBase.apply(this, arguments);
	                    this.getController("validating").createValidator(cellOptions, $container.children(".dx-widget"))
	                },
	                _cellPrepared: function($cell, parameters) {
	                    this.getController("validating").createValidator(parameters, $cell);
	                    this.callBase.apply(this, arguments)
	                }
	            }
	        }
	    }
	});


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/tooltip.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(270);
	module.exports.show = __webpack_require__(271).show;
	module.exports.hide = __webpack_require__(271).hide;
	module.exports.default = module.exports;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/tooltip/tooltip.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Guid = __webpack_require__(119),
	    registerComponent = __webpack_require__(44),
	    Popover = __webpack_require__(178),
	    TOOLTIP_CLASS = "dx-tooltip",
	    TOOLTIP_WRAPPER_CLASS = "dx-tooltip-wrapper";
	var Tooltip = Popover.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            toolbarItems: [],
	            showCloseButton: false,
	            showTitle: false,
	            title: null,
	            titleTemplate: null,
	            onTitleRendered: null,
	            bottomTemplate: null,
	            propagateOutsideClick: true
	        })
	    },
	    _render: function() {
	        this.element().addClass(TOOLTIP_CLASS);
	        this._wrapper().addClass(TOOLTIP_WRAPPER_CLASS);
	        this.callBase()
	    },
	    _renderContent: function() {
	        this.callBase();
	        this._contentId = new Guid;
	        this._$content.attr({
	            id: this._contentId,
	            role: "tooltip"
	        });
	        this._toggleAriaDescription(true)
	    },
	    _toggleAriaDescription: function(showing) {
	        var $target = $(this.option("target")),
	            label = showing ? this._contentId : void 0;
	        this.setAria("describedby", label, $target)
	    }
	});
	registerComponent("dxTooltip", Tooltip);
	module.exports = Tooltip;


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/tooltip/ui.tooltip.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Tooltip = __webpack_require__(270),
	    viewPortUtils = __webpack_require__(42);
	var tooltip = null;
	var removeTooltipElement = null;
	var createTooltip = function(options) {
	    options = $.extend({
	        position: "top"
	    }, options);
	    var content = options.content;
	    delete options.content;
	    var $tooltip = $("<div />").html(content).appendTo(viewPortUtils.value());
	    removeTooltipElement = function() {
	        $tooltip.remove()
	    };
	    tooltip = new Tooltip($tooltip, options)
	};
	var removeTooltip = function() {
	    if (!tooltip) {
	        return
	    }
	    removeTooltipElement();
	    tooltip = null
	};
	exports.show = function(options) {
	    removeTooltip();
	    createTooltip(options);
	    return tooltip.show()
	};
	exports.hide = function() {
	    if (!tooltip) {
	        return $.Deferred().resolve()
	    }
	    return tooltip.hide().done(removeTooltip).promise()
	};


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.virtual_scrolling_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    virtualScrollingCore = __webpack_require__(273),
	    gridCore = __webpack_require__(144),
	    browser = __webpack_require__(16),
	    dataSourceAdapter = __webpack_require__(153),
	    translator = __webpack_require__(59),
	    LoadIndicator = __webpack_require__(150);
	var DATAGRID_TABLE_CLASS = "dx-datagrid-table",
	    DATAGRID_ROW_CLASS = "dx-row",
	    DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
	    DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
	    DATAGRID_BOTTOM_LOAD_PANEL_CLASS = "dx-datagrid-bottom-load-panel",
	    DATAGRID_TABLE_CONTENT_CLASS = "dx-datagrid-table-content",
	    DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
	    DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
	    SCROLLING_MODE_INFINITE = "infinite",
	    SCROLLING_MODE_VIRTUAL = "virtual",
	    PIXELS_LIMIT = 25e4,
	    CONTENT_HEIGHT_LIMIT = browser.msie ? 4e6 : 15e6;
	__webpack_require__(217);
	var isVirtualMode = function(that) {
	    return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
	};
	var isAppendMode = function(that) {
	    return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
	};
	var VirtualScrollingDataSourceAdapterExtender = function() {
	    var updateLoading = function(that) {
	        var beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
	        if (isVirtualMode(that)) {
	            if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
	                if (!that._isLoading) {
	                    that._isLoading = true;
	                    that.loadingChanged.fire(true)
	                }
	            } else {
	                if (that._isLoading) {
	                    that._isLoading = false;
	                    that.loadingChanged.fire(false)
	                }
	            }
	        }
	    };
	    return {
	        init: function(dataSource) {
	            var that = this;
	            that.callBase.apply(that, arguments);
	            that._items = [];
	            that._isLoaded = true;
	            that._virtualScrollController = new virtualScrollingCore.VirtualScrollController(that.component, {
	                pageSize: function() {
	                    return that.pageSize()
	                },
	                totalItemsCount: function() {
	                    return that.totalItemsCount()
	                },
	                hasKnownLastPage: function() {
	                    return that.hasKnownLastPage()
	                },
	                pageIndex: function(index) {
	                    return dataSource.pageIndex(index)
	                },
	                isLoading: function() {
	                    return dataSource.isLoading()
	                },
	                pageCount: function() {
	                    return that.pageCount()
	                },
	                load: function() {
	                    return dataSource.load()
	                },
	                updateLoading: function() {
	                    updateLoading(that)
	                },
	                itemsCount: function() {
	                    return that.itemsCount(true)
	                },
	                items: function() {
	                    return dataSource.items()
	                },
	                viewportItems: function(items) {
	                    if (items) {
	                        that._items = items
	                    }
	                    return that._items
	                },
	                onChanged: function(e) {
	                    that.changed.fire(e)
	                }
	            })
	        },
	        _handleLoadingChanged: function(isLoading) {
	            var that = this;
	            if (!isVirtualMode(that)) {
	                that._isLoading = isLoading;
	                that.callBase.apply(that, arguments)
	            }
	        },
	        _handleLoadError: function() {
	            var that = this;
	            that._isLoading = false;
	            that.loadingChanged.fire(false);
	            that.callBase.apply(that, arguments)
	        },
	        _handleDataChanged: function() {
	            var callBase = $.proxy(this.callBase, this);
	            this._virtualScrollController.handleDataChanged(callBase)
	        },
	        items: function() {
	            return this._items
	        },
	        itemsCount: function(isBase) {
	            if (isBase) {
	                return this.callBase()
	            }
	            return this._virtualScrollController.itemsCount()
	        },
	        virtualItemsCount: function() {
	            return this._virtualScrollController.virtualItemsCount()
	        },
	        getViewportItemIndex: function() {
	            return this._virtualScrollController.getViewportItemIndex()
	        },
	        setViewportItemIndex: function(itemIndex) {
	            return this._virtualScrollController.setViewportItemIndex(itemIndex)
	        },
	        viewportSize: function(size) {
	            return this._virtualScrollController.viewportSize(size)
	        },
	        pageIndex: function(pageIndex) {
	            return this._virtualScrollController.pageIndex(pageIndex)
	        },
	        beginPageIndex: function() {
	            return this._virtualScrollController.beginPageIndex()
	        },
	        endPageIndex: function() {
	            return this._virtualScrollController.endPageIndex()
	        },
	        load: function(loadOptions) {
	            if (loadOptions) {
	                return this.callBase(loadOptions)
	            }
	            return this._virtualScrollController.load()
	        },
	        loadIfNeed: function() {
	            return this._virtualScrollController.loadIfNeed()
	        },
	        isLoading: function() {
	            return this._isLoading
	        },
	        isLoaded: function() {
	            return this._dataSource.isLoaded() && this._isLoaded
	        },
	        _changeRowExpandCore: function() {
	            var result = this.callBase.apply(this, arguments);
	            this._virtualScrollController.reset();
	            updateLoading(this);
	            return result
	        },
	        refresh: function(options, isReload, operationTypes) {
	            var that = this,
	                storeLoadOptions = options.storeLoadOptions,
	                dataSource = that._dataSource;
	            if (isReload || operationTypes.reload) {
	                that._virtualScrollController.reset();
	                that._isLoaded = false;
	                updateLoading(that);
	                that._isLoaded = true;
	                if (isAppendMode(that)) {
	                    that.pageIndex(0);
	                    dataSource.pageIndex(0);
	                    storeLoadOptions.pageIndex = 0;
	                    storeLoadOptions.skip = 0
	                } else {
	                    dataSource.pageIndex(that.pageIndex());
	                    if (dataSource.paginate()) {
	                        storeLoadOptions.skip = that.pageIndex() * that.pageSize()
	                    }
	                }
	            }
	            return that.callBase.apply(that, arguments)
	        }
	    }
	}();
	dataSourceAdapter.extend(VirtualScrollingDataSourceAdapterExtender);
	var VirtualScrollingRowsViewExtender = function() {
	    return {
	        init: function() {
	            var that = this,
	                dataController = that.getController("data");
	            that.callBase();
	            dataController.pageChanged.add(function() {
	                that.scrollToPage(dataController.pageIndex())
	            })
	        },
	        scrollToPage: function(pageIndex) {
	            var scrollPosition, that = this,
	                dataController = that._dataController,
	                pageSize = dataController ? dataController.pageSize() : 0;
	            if (isVirtualMode(that) || isAppendMode(that)) {
	                scrollPosition = pageIndex * that._rowHeight * pageSize
	            } else {
	                scrollPosition = 0
	            }
	            that.scrollTo({
	                y: scrollPosition,
	                x: that._scrollLeft
	            })
	        },
	        _renderCore: function() {
	            var that = this,
	                startRenderDate = new Date;
	            that.callBase.apply(that, arguments);
	            that._updateContentPosition();
	            that._renderTime = new Date - startRenderDate
	        },
	        _renderContent: function(contentElement, tableElement) {
	            var that = this,
	                virtualItemsCount = that._dataController.virtualItemsCount();
	            if (virtualItemsCount) {
	                tableElement.addClass(DATAGRID_TABLE_CONTENT_CLASS);
	                if (!contentElement.children().length) {
	                    contentElement.append(tableElement)
	                } else {
	                    contentElement.children().first().replaceWith(tableElement)
	                }
	                if (1 === contentElement.children("table").length) {
	                    contentElement.append(that._createTable());
	                    that._contentHeight = 0
	                }
	                return contentElement
	            } else {
	                return that.callBase.apply(that, arguments)
	            }
	        },
	        _updateContent: function(tableElement, change) {
	            var contentTable, that = this,
	                contentElement = that._findContentElement(),
	                changeType = change && change.changeType;
	            if ("append" === changeType || "prepend" === changeType) {
	                contentTable = contentElement.children().first();
	                tableElement.children("tbody")["append" === changeType ? "appendTo" : "prependTo"](contentTable);
	                tableElement.remove();
	                that._getFreeSpaceRowElements().not(":last").remove()
	            } else {
	                that.callBase.apply(that, arguments)
	            }
	            that._updateBottomLoading()
	        },
	        _updateContentPosition: commonUtils.deferUpdater(function() {
	            var contentElement, contentHeight, $tables, $contentTable, virtualTable, isRenderVirtualTableContentRequired, that = this,
	                rowHeight = that._rowHeight || 20,
	                virtualItemsCount = that._dataController.virtualItemsCount();
	            if (virtualItemsCount) {
	                contentElement = that._findContentElement();
	                $tables = contentElement.children();
	                $contentTable = $tables.eq(0);
	                virtualTable = $tables.eq(1);
	                that._contentTableHeight = $contentTable[0].offsetHeight;
	                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end + that._dataController.itemsCount()) * that._rowHeight;
	                if (contentHeight > CONTENT_HEIGHT_LIMIT) {
	                    that._heightRatio = CONTENT_HEIGHT_LIMIT / contentHeight
	                } else {
	                    that._heightRatio = 1
	                }
	                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end) * rowHeight * that._heightRatio + that._contentTableHeight;
	                var top = Math.floor(virtualItemsCount.begin * rowHeight * that._heightRatio);
	                commonUtils.deferRender(function() {
	                    translator.move($contentTable, {
	                        left: 0,
	                        top: top
	                    });
	                    isRenderVirtualTableContentRequired = that._contentHeight !== contentHeight || 0 === contentHeight || !that._isTableLinesDisplaysCorrect(virtualTable) || !that._isColumnElementsEqual($contentTable.find("col"), virtualTable.find("col"));
	                    if (isRenderVirtualTableContentRequired) {
	                        that._contentHeight = contentHeight;
	                        that._renderVirtualTableContent(virtualTable, contentHeight)
	                    }
	                    if (that._scrollTop < top && that._dataController.pageIndex() > 0) {
	                        that.scrollTo({
	                            top: top,
	                            left: that._scrollLeft
	                        })
	                    }
	                })
	            }
	        }),
	        _isTableLinesDisplaysCorrect: function(table) {
	            var hasColumnLines = table.find("." + DATAGRID_COLUMN_LINES_CLASS).length > 0;
	            return hasColumnLines === this.option("showColumnLines")
	        },
	        _isColumnElementsEqual: function($columns, $virtualColumns) {
	            var result = $columns.length === $virtualColumns.length;
	            if (result) {
	                $.each($columns, function(index, element) {
	                    if (element.style.width !== $virtualColumns[index].style.width) {
	                        result = false;
	                        return result
	                    }
	                })
	            }
	            return result
	        },
	        _renderVirtualTableContent: function(container, height) {
	            var i, that = this,
	                columns = that._columnsController.getVisibleColumns(),
	                html = that._createColGroup(columns).prop("outerHTML"),
	                freeSpaceCellsHtml = "",
	                columnLinesClass = that.option("showColumnLines") ? DATAGRID_COLUMN_LINES_CLASS : "",
	                createFreeSpaceRowHtml = function(height) {
	                    return "<tr style='height:" + height + "px;' class='" + DATAGRID_FREESPACE_CLASS + " " + DATAGRID_ROW_CLASS + " " + columnLinesClass + "' >" + freeSpaceCellsHtml + "</tr>"
	                };
	            for (i = 0; i < columns.length; i++) {
	                freeSpaceCellsHtml += "expand" === columns[i].command ? "<td class='" + DATAGRID_GROUP_SPACE_CLASS + "'/>" : "<td />"
	            }
	            while (height > PIXELS_LIMIT) {
	                html += createFreeSpaceRowHtml(PIXELS_LIMIT);
	                height -= PIXELS_LIMIT
	            }
	            html += createFreeSpaceRowHtml(height);
	            container.addClass(DATAGRID_TABLE_CLASS);
	            container.html(html)
	        },
	        _findBottomLoadPanel: function() {
	            var $element = this.element();
	            var $bottomLoadPanel = $element && $element.find("." + DATAGRID_BOTTOM_LOAD_PANEL_CLASS);
	            if ($bottomLoadPanel && $bottomLoadPanel.length) {
	                return $bottomLoadPanel
	            }
	        },
	        _updateBottomLoading: function() {
	            var that = this,
	                scrollingMode = that.option("scrolling.mode"),
	                virtualMode = scrollingMode === SCROLLING_MODE_VIRTUAL,
	                appendMode = scrollingMode === SCROLLING_MODE_INFINITE,
	                showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode),
	                bottomLoadPanelElement = that._findBottomLoadPanel();
	            if (showBottomLoading) {
	                if (!bottomLoadPanelElement) {
	                    $("<div>").addClass(DATAGRID_BOTTOM_LOAD_PANEL_CLASS).append(that._createComponent($("<div>"), LoadIndicator).element()).appendTo(that._findContentElement())
	                }
	            } else {
	                if (bottomLoadPanelElement) {
	                    bottomLoadPanelElement.remove()
	                }
	            }
	        },
	        _handleScroll: function(e) {
	            var that = this;
	            if (that._hasHeight && that._rowHeight) {
	                that._setViewportScrollTop(e.scrollOffset.top)
	            }
	            that.callBase.apply(that, arguments)
	        },
	        _setViewportScrollTop: function(scrollTop) {
	            var that = this,
	                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._renderTime || 0);
	            clearTimeout(that._scrollTimeoutID);
	            if (scrollingTimeout > 0) {
	                that._scrollTimeoutID = setTimeout(function() {
	                    that._setViewportScrollTopCore(scrollTop)
	                }, scrollingTimeout)
	            } else {
	                that._setViewportScrollTopCore(scrollTop)
	            }
	        },
	        _setViewportScrollTopCore: function(scrollTop) {
	            var that = this,
	                virtualItemsCount = that._dataController.virtualItemsCount(),
	                heightRatio = that._heightRatio || 1,
	                rowHeight = that._rowHeight,
	                beginHeight = virtualItemsCount ? Math.floor(virtualItemsCount.begin * rowHeight * heightRatio) : 0;
	            if (virtualItemsCount && scrollTop >= beginHeight && scrollTop <= beginHeight + that._contentTableHeight) {
	                that._dataController.setViewportItemIndex(virtualItemsCount.begin + (scrollTop - beginHeight) / rowHeight)
	            } else {
	                that._dataController.setViewportItemIndex(scrollTop / (rowHeight * heightRatio))
	            }
	        },
	        _needUpdateRowHeight: function(itemsCount) {
	            var that = this;
	            return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
	        },
	        _updateRowHeight: function() {
	            var viewportHeight, that = this;
	            that.callBase.apply(that, arguments);
	            if (that._rowHeight) {
	                that._updateContentPosition();
	                viewportHeight = that._hasHeight ? that.element().outerHeight() : $(window).outerHeight();
	                that._dataController.viewportSize(Math.round(viewportHeight / that._rowHeight))
	            }
	        },
	        setLoading: function(isLoading, messageText) {
	            var that = this,
	                callBase = that.callBase,
	                hasBottomLoadPanel = !!that._findBottomLoadPanel() && that._dataController.isLoaded();
	            if (hasBottomLoadPanel) {
	                isLoading = false
	            }
	            callBase.call(that, isLoading, messageText)
	        },
	        _resizeCore: function() {
	            var that = this,
	                $element = that.element();
	            that.callBase();
	            if (that.component.element() && !that._windowScroll && $element.closest(document).length) {
	                that._windowScroll = virtualScrollingCore.subscribeToExternalScrollers($element, function(scrollPos) {
	                    if (!that._hasHeight && that._rowHeight) {
	                        that._setViewportScrollTop(scrollPos)
	                    }
	                }, that.component.element());
	                that.on("disposing", function() {
	                    that._windowScroll.dispose()
	                })
	            }
	            var dataSource = that._dataController.dataSource();
	            if (dataSource && dataSource.loadIfNeed) {
	                dataSource.loadIfNeed()
	            }
	        },
	        setColumnWidths: function(widths) {
	            var selector, $content, scrollable = this.getScrollable();
	            this.callBase.apply(this, arguments);
	            if ("virtual" === this.option("scrolling.mode")) {
	                selector = "> ." + DATAGRID_CONTENT_CLASS;
	                $content = scrollable ? scrollable.content() : this.element();
	                this.callBase(widths, $content.find(selector).children(":not(." + DATAGRID_TABLE_CONTENT_CLASS + ")"))
	            }
	        },
	        dispose: function() {
	            clearTimeout(this._scrollTimeoutID);
	            this.callBase()
	        }
	    }
	}();
	gridCore.registerModule("virtualScrolling", {
	    defaultOptions: function() {
	        return {
	            scrolling: {
	                timeout: 300,
	                mode: "standard",
	                preloadEnabled: false,
	                useNative: "auto"
	            }
	        }
	    },
	    extenders: {
	        controllers: {
	            data: function() {
	                var members = {};
	                gridCore.proxyMethod(members, "virtualItemsCount");
	                gridCore.proxyMethod(members, "viewportSize");
	                gridCore.proxyMethod(members, "setViewportItemIndex");
	                return members
	            }()
	        },
	        views: {
	            rowsView: VirtualScrollingRowsViewExtender
	        }
	    }
	});


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/grid_core/ui.grid_core.virtual_scrolling.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    browser = __webpack_require__(16),
	    positionUtils = __webpack_require__(60),
	    Class = __webpack_require__(18);
	var SCROLLING_MODE_INFINITE = "infinite",
	    SCROLLING_MODE_VIRTUAL = "virtual",
	    CONTENT_HEIGHT_LIMIT = browser.msie ? 4e6 : 15e6;
	var isVirtualMode = function(that) {
	    return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
	};
	var isAppendMode = function(that) {
	    return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
	};
	exports.subscribeToExternalScrollers = function($element, scrollChangedHandler, $targetElement) {
	    var $scrollElement, scrollableArray = [],
	        scrollToArray = [],
	        disposeArray = [];
	    $targetElement = $targetElement || $element;

	    function getElementOffset(scrollable) {
	        var $scrollableElement = scrollable.element ? scrollable.element() : scrollable,
	            scrollableOffset = positionUtils.offset($scrollableElement);
	        if (!scrollableOffset) {
	            return $element.offset().top
	        }
	        return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top)
	    }

	    function createWindowScrollHandler(scrollable) {
	        return function() {
	            var scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);
	            scrollTop = scrollTop > 0 ? scrollTop : 0;
	            scrollChangedHandler(scrollTop)
	        }
	    }

	    function subscribeToScrollEvents($scrollElement) {
	        var handler, isDocument = "#document" === $scrollElement.get(0).nodeName,
	            scrollable = $scrollElement.data("dxScrollable") || isDocument && $(window) || "auto" === $scrollElement.css("overflow-y") && $scrollElement;
	        if (scrollable) {
	            handler = createWindowScrollHandler(scrollable);
	            scrollable.on("scroll", handler);
	            scrollToArray.push(function(pos) {
	                var topOffset = getElementOffset(scrollable),
	                    scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
	                if (pos - topOffset >= 0) {
	                    scrollable[scrollMethod](pos + topOffset)
	                }
	            });
	            scrollableArray.push(scrollable);
	            disposeArray.push(function() {
	                scrollable.off("scroll", handler)
	            })
	        }
	    }
	    for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent()) {
	        subscribeToScrollEvents($scrollElement)
	    }
	    return {
	        scrollTo: function(pos) {
	            $.each(scrollToArray, function(_, scrollTo) {
	                scrollTo(pos)
	            })
	        },
	        dispose: function() {
	            $.each(disposeArray, function(_, dispose) {
	                dispose()
	            })
	        }
	    }
	};
	exports.VirtualScrollController = Class.inherit(function() {
	    var getViewportPageCount = function(that) {
	        var pageSize = that._dataSource.pageSize(),
	            preventPreload = that.option("scrolling.preventPreload");
	        if (preventPreload) {
	            return 0
	        }
	        return pageSize && that._viewportSize > 0 ? Math.ceil(that._viewportSize / pageSize) : 1
	    };
	    var getPreloadPageCount = function(that) {
	        var preloadEnabled = that.option("scrolling.preloadEnabled"),
	            pageCount = getViewportPageCount(that);
	        if (pageCount) {
	            if (preloadEnabled) {
	                pageCount++
	            }
	            if (isAppendMode(that)) {
	                pageCount--
	            }
	        }
	        return pageCount
	    };
	    var getBeginPageIndex = function(that) {
	        return that._cache.length ? that._cache[0].pageIndex : -1
	    };
	    var getEndPageIndex = function(that) {
	        return that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1
	    };
	    var fireChanged = function(that, changed, args) {
	        that._isChangedFiring = true;
	        changed(args);
	        that._isChangedFiring = false
	    };
	    var processDelayChanged = function(that, changed, args) {
	        if (that._isDelayChanged) {
	            that._isDelayChanged = false;
	            fireChanged(that, changed, args);
	            return true
	        }
	    };
	    var processChanged = function(that, changed, changeType, isDelayChanged) {
	        var change, dataSource = that._dataSource,
	            items = dataSource.items();
	        if (changeType && !that._isDelayChanged) {
	            change = {
	                changeType: changeType,
	                items: items
	            }
	        }
	        var viewportItems = that._dataSource.viewportItems();
	        if ("append" === changeType) {
	            viewportItems.push.apply(viewportItems, items)
	        } else {
	            if ("prepend" === changeType) {
	                viewportItems.unshift.apply(viewportItems, items)
	            } else {
	                that._dataSource.viewportItems(items)
	            }
	        }
	        dataSource.updateLoading();
	        that._lastPageIndex = that.pageIndex();
	        that._isDelayChanged = isDelayChanged;
	        if (!isDelayChanged) {
	            fireChanged(that, changed, change)
	        }
	    };
	    return {
	        ctor: function(component, dataSource) {
	            var that = this;
	            that._dataSource = dataSource;
	            that.component = component;
	            that._pageIndex = that._lastPageIndex = dataSource.pageIndex();
	            that._viewportSize = 0;
	            that._viewportItemSize = 20;
	            that._viewportItemIndex = -1;
	            that._sizeRatio = 1;
	            that._items = [];
	            that._cache = []
	        },
	        option: function() {
	            return this.component.option.apply(this.component, arguments)
	        },
	        virtualItemsCount: function() {
	            var pageIndex, beginItemsCount, endItemsCount, that = this,
	                itemsCount = 0;
	            if (isVirtualMode(that)) {
	                pageIndex = getBeginPageIndex(that);
	                if (pageIndex < 0) {
	                    pageIndex = 0
	                }
	                beginItemsCount = pageIndex * that._dataSource.pageSize();
	                itemsCount = that._cache.length * that._dataSource.pageSize();
	                endItemsCount = Math.max(0, that._dataSource.totalItemsCount() - itemsCount - beginItemsCount);
	                return {
	                    begin: beginItemsCount,
	                    end: endItemsCount
	                }
	            }
	        },
	        _setViewportPositionCore: function(position, isNear) {
	            var that = this,
	                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._dataSource.changingDuration());
	            if (isNear && scrollingTimeout < that.option("scrolling.renderingThreshold")) {
	                scrollingTimeout = 10
	            }
	            clearTimeout(that._scrollTimeoutID);
	            if (scrollingTimeout > 0) {
	                that._scrollTimeoutID = setTimeout(function() {
	                    that.setViewportItemIndex(position)
	                }, scrollingTimeout)
	            } else {
	                that.setViewportItemIndex(position)
	            }
	        },
	        getViewportPosition: function() {
	            return this._position || 0
	        },
	        setViewportPosition: function(position) {
	            var that = this,
	                virtualItemsCount = that.virtualItemsCount(),
	                sizeRatio = that._sizeRatio || 1,
	                itemSize = that._viewportItemSize,
	                offset = virtualItemsCount ? Math.floor(virtualItemsCount.begin * itemSize * sizeRatio) : 0;
	            that._position = position;
	            if (virtualItemsCount && position >= offset && position <= offset + that._contentSize) {
	                that._setViewportPositionCore(virtualItemsCount.begin + (position - offset) / itemSize, true)
	            } else {
	                that._setViewportPositionCore(position / (itemSize * sizeRatio))
	            }
	        },
	        setContentSize: function(size) {
	            var that = this,
	                virtualItemsCount = that.virtualItemsCount();
	            that._contentSize = size;
	            if (virtualItemsCount) {
	                var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + that.itemsCount()) * that._viewportItemSize;
	                if (virtualContentSize > CONTENT_HEIGHT_LIMIT) {
	                    that._sizeRatio = CONTENT_HEIGHT_LIMIT / virtualContentSize
	                } else {
	                    that._sizeRatio = 1
	                }
	            }
	        },
	        getContentOffset: function() {
	            var that = this,
	                virtualItemsCount = that.virtualItemsCount();
	            return virtualItemsCount ? Math.floor(virtualItemsCount.begin * that._viewportItemSize * that._sizeRatio) : 0
	        },
	        getVirtualContentSize: function() {
	            var that = this,
	                virtualItemsCount = that.virtualItemsCount();
	            return virtualItemsCount ? (virtualItemsCount.begin + virtualItemsCount.end) * that._viewportItemSize * that._sizeRatio + that._contentSize : 0
	        },
	        getViewportItemIndex: function() {
	            return this._viewportItemIndex
	        },
	        setViewportItemIndex: function(itemIndex) {
	            var lastPageSize, maxPageIndex, newPageIndex, that = this,
	                pageSize = that._dataSource.pageSize(),
	                pageCount = that._dataSource.pageCount(),
	                virtualMode = isVirtualMode(that),
	                appendMode = isAppendMode(that),
	                totalItemsCount = that._dataSource.totalItemsCount(),
	                needLoad = that._viewportItemIndex < 0;
	            that._viewportItemIndex = itemIndex;
	            if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
	                if (that._viewportSize && itemIndex + that._viewportSize >= totalItemsCount) {
	                    if (that._dataSource.hasKnownLastPage()) {
	                        newPageIndex = pageCount - 1;
	                        lastPageSize = totalItemsCount % pageSize;
	                        if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < pageSize / 2) {
	                            newPageIndex--
	                        }
	                    } else {
	                        newPageIndex = pageCount
	                    }
	                } else {
	                    newPageIndex = Math.floor(itemIndex / pageSize);
	                    maxPageIndex = pageCount - 1;
	                    newPageIndex = Math.max(newPageIndex, 0);
	                    newPageIndex = Math.min(newPageIndex, maxPageIndex)
	                }
	                if (that.pageIndex() !== newPageIndex || needLoad) {
	                    that.pageIndex(newPageIndex);
	                    that.load()
	                }
	            }
	        },
	        viewportItemSize: function(size) {
	            if (void 0 !== size) {
	                this._viewportItemSize = size
	            }
	            return this._viewportItemSize
	        },
	        viewportSize: function(size) {
	            if (void 0 !== size) {
	                this._viewportSize = size
	            }
	            return this._viewportSize
	        },
	        pageIndex: function(pageIndex) {
	            if (isVirtualMode(this) || isAppendMode(this)) {
	                if (void 0 !== pageIndex) {
	                    this._pageIndex = pageIndex
	                }
	                return this._pageIndex
	            } else {
	                return this._dataSource.pageIndex(pageIndex)
	            }
	        },
	        beginPageIndex: function(defaultPageIndex) {
	            var beginPageIndex = getBeginPageIndex(this);
	            if (beginPageIndex < 0) {
	                beginPageIndex = void 0 !== defaultPageIndex ? defaultPageIndex : this.pageIndex()
	            }
	            return beginPageIndex
	        },
	        endPageIndex: function() {
	            var endPageIndex = getEndPageIndex(this);
	            return endPageIndex > 0 ? endPageIndex : this._lastPageIndex
	        },
	        load: function() {
	            var result, beginPageIndex = getBeginPageIndex(this),
	                pageIndexForLoad = -1,
	                dataSource = this._dataSource;
	            var loadCore = function(that, pageIndex) {
	                var dataSource = that._dataSource;
	                if (pageIndex === that.pageIndex() || !dataSource.isLoading() && pageIndex < dataSource.pageCount() || !dataSource.hasKnownLastPage() && pageIndex === dataSource.pageCount()) {
	                    dataSource.pageIndex(pageIndex);
	                    return dataSource.load()
	                }
	            };
	            if (isVirtualMode(this) || isAppendMode(this)) {
	                if (beginPageIndex < 0 || !this._cache[this._pageIndex - beginPageIndex]) {
	                    pageIndexForLoad = this._pageIndex
	                }
	                if (beginPageIndex >= 0 && pageIndexForLoad < 0 && this._viewportSize >= 0) {
	                    if (beginPageIndex > 0 && getEndPageIndex(this) + 1 === dataSource.pageCount() && this._cache.length < getPreloadPageCount(this) + 1) {
	                        pageIndexForLoad = beginPageIndex - 1
	                    } else {
	                        if (beginPageIndex + this._cache.length <= this._pageIndex + getPreloadPageCount(this)) {
	                            pageIndexForLoad = beginPageIndex + this._cache.length
	                        }
	                    }
	                }
	                if (pageIndexForLoad >= 0) {
	                    result = loadCore(this, pageIndexForLoad)
	                }
	                dataSource.updateLoading()
	            } else {
	                result = dataSource.load()
	            }
	            if (!result && this._lastPageIndex !== this.pageIndex()) {
	                this._dataSource.onChanged({
	                    changeType: "pageIndex"
	                })
	            }
	            return result || $.Deferred().resolve()
	        },
	        loadIfNeed: function() {
	            var that = this;
	            if ((isVirtualMode(that) || isAppendMode(that)) && !that._dataSource.isLoading() && !that._isChangedFiring) {
	                that.load()
	            }
	        },
	        handleDataChanged: function(callBase) {
	            var beginPageIndex, changeType, removeInvisiblePages, cacheItem, that = this,
	                dataSource = that._dataSource,
	                lastCacheLength = that._cache.length;
	            if (isVirtualMode(that) || isAppendMode(that)) {
	                beginPageIndex = getBeginPageIndex(that);
	                if (beginPageIndex >= 0) {
	                    if (isVirtualMode(that) && beginPageIndex + that._cache.length !== dataSource.pageIndex() && beginPageIndex - 1 !== dataSource.pageIndex()) {
	                        that._cache = []
	                    }
	                    if (isAppendMode(that)) {
	                        if (0 === dataSource.pageIndex()) {
	                            that._cache = []
	                        } else {
	                            if (dataSource.pageIndex() < getEndPageIndex(that)) {
	                                fireChanged(that, callBase, {
	                                    changeType: "append",
	                                    items: []
	                                });
	                                return
	                            }
	                        }
	                    }
	                }
	                cacheItem = {
	                    pageIndex: dataSource.pageIndex(),
	                    itemsCount: that.itemsCount(true)
	                };
	                if (that.option("scrolling.removeInvisiblePages")) {
	                    removeInvisiblePages = that._cache.length > Math.max(getPreloadPageCount(this), 2)
	                } else {
	                    processDelayChanged(that, callBase, {
	                        isDelayed: true
	                    })
	                }
	                if (beginPageIndex === dataSource.pageIndex() + 1) {
	                    if (removeInvisiblePages) {
	                        that._cache.pop()
	                    } else {
	                        changeType = "prepend"
	                    }
	                    that._cache.unshift(cacheItem)
	                } else {
	                    if (removeInvisiblePages) {
	                        that._cache.shift()
	                    } else {
	                        changeType = "append"
	                    }
	                    that._cache.push(cacheItem)
	                }
	                processChanged(that, callBase, that._cache.length > 1 ? changeType : void 0, 0 === lastCacheLength);
	                that.load().done(function() {
	                    if (processDelayChanged(that, callBase)) {
	                        that.load()
	                    }
	                })
	            } else {
	                processChanged(that, callBase)
	            }
	        },
	        itemsCount: function(isBase) {
	            var itemsCount = 0;
	            if (!isBase && isVirtualMode(this)) {
	                $.each(this._cache, function() {
	                    itemsCount += this.itemsCount
	                })
	            } else {
	                itemsCount = this._dataSource.itemsCount()
	            }
	            return itemsCount
	        },
	        reset: function() {
	            this._cache = []
	        },
	        subscribeToWindowScrollEvents: function($element) {
	            var that = this;
	            that._windowScroll = that._windowScroll || exports.subscribeToExternalScrollers($element, function(scrollTop) {
	                if (that.viewportItemSize()) {
	                    that.setViewportPosition(scrollTop)
	                }
	            })
	        },
	        dispose: function() {
	            clearTimeout(this._scrollTimeoutID);
	            this._windowScroll && this._windowScroll.dispose();
	            this._windowScroll = null
	        },
	        scrollTo: function(pos) {
	            this._windowScroll && this._windowScroll.scrollTo(pos)
	        }
	    }
	}());


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.filter_row.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    gridCore = __webpack_require__(144),
	    messageLocalization = __webpack_require__(79),
	    Editor = __webpack_require__(95),
	    Overlay = __webpack_require__(97),
	    Menu = __webpack_require__(275);
	__webpack_require__(264);
	var OPERATION_ICONS = {
	    "=": "filter-operation-equals",
	    "<>": "filter-operation-not-equals",
	    "<": "filter-operation-less",
	    "<=": "filter-operation-less-equal",
	    ">": "filter-operation-greater",
	    ">=": "filter-operation-greater-equal",
	    "default": "filter-operation-default",
	    notcontains: "filter-operation-not-contains",
	    contains: "filter-operation-contains",
	    startswith: "filter-operation-starts-with",
	    endswith: "filter-operation-ends-with",
	    between: "filter-operation-between"
	};
	var OPERATION_DESCRIPTORS = {
	    "=": "equal",
	    "<>": "notEqual",
	    "<": "lessThan",
	    "<=": "lessThanOrEqual",
	    ">": "greaterThan",
	    ">=": "greaterThanOrEqual",
	    startswith: "startsWith",
	    contains: "contains",
	    notcontains: "notContains",
	    endswith: "endsWith",
	    between: "between"
	};
	var FILTERING_TIMEOUT = 700,
	    CORRECT_FILTER_RANGE_OVERLAY_WIDTH = 1,
	    DATAGRID_CLASS = "dx-datagrid",
	    DATAGRID_FILTER_ROW_CLASS = "dx-datagrid-filter-row",
	    DATAGRID_MENU_CLASS = "dx-menu",
	    DATAGRID_EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu",
	    DATAGRID_EDITOR_CONTAINER_CLASS = "dx-editor-container",
	    DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
	    DATAGRID_FILTER_MENU = "dx-filter-menu",
	    DATAGRID_APPLY_BUTTON_CLASS = "dx-apply-button",
	    DATAGRID_HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline",
	    DATAGRID_FOCUSED_CLASS = "dx-focused",
	    DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
	    DATAGRID_FILTER_RANGE_OVERLAY_CLASS = "dx-datagrid-filter-range-overlay",
	    DATAGRID_FILTER_RANGE_CONTENT_CLASS = "dx-filter-range-content",
	    DATAGRID_FILTER_RANGE_START_CLASS = "dx-datagrid-filter-range-start",
	    DATAGRID_FILTER_RANGE_END_CLASS = "dx-datagrid-filter-range-end",
	    DATAGRID_EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";

	function isOnClickApplyFilterMode(that) {
	    return "onClick" === that.option("filterRow.applyFilter")
	}
	var ColumnHeadersViewFilterRowExtender = function() {
	    var getEditorInstance = function($editorContainer) {
	        var $editor = $editorContainer && $editorContainer.children(),
	            componentNames = $editor && $editor.data("dxComponents"),
	            editor = componentNames && componentNames.length && $editor.data(componentNames[0]);
	        if (editor instanceof Editor) {
	            return editor
	        }
	    };
	    var getRangeTextByFilterValue = function(that, column) {
	        var result = "",
	            rangeEnd = "",
	            filterValue = getColumnFilterValue(that, column),
	            formatOptions = gridCore.getFormatOptionsByColumn(column, "filterRow");
	        if (commonUtils.isArray(filterValue)) {
	            result = gridCore.formatValue(filterValue[0], formatOptions);
	            rangeEnd = gridCore.formatValue(filterValue[1], formatOptions);
	            if ("" !== rangeEnd) {
	                result += " - " + rangeEnd
	            }
	        } else {
	            if (commonUtils.isDefined(filterValue)) {
	                result = gridCore.formatValue(filterValue, formatOptions)
	            }
	        }
	        return result
	    };
	    var getColumnFilterValue = function(that, column) {
	        if (column) {
	            return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedFilterValue ? column.bufferedFilterValue : column.filterValue
	        }
	    };
	    var getColumnSelectedFilterOperation = function(that, column) {
	        if (column) {
	            return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedSelectedFilterOperation ? column.bufferedSelectedFilterOperation : column.selectedFilterOperation
	        }
	    };
	    var getFilterValue = function(that, columnIndex, $editorContainer) {
	        var column = that._columnsController.columnOption(columnIndex),
	            filterValue = getColumnFilterValue(that, column),
	            isFilterRange = $editorContainer.closest("." + DATAGRID_FILTER_RANGE_OVERLAY_CLASS).length,
	            isRangeStart = $editorContainer.hasClass(DATAGRID_FILTER_RANGE_START_CLASS);
	        if (filterValue && commonUtils.isArray(filterValue) && "between" === getColumnSelectedFilterOperation(that, column)) {
	            if (isRangeStart) {
	                return filterValue[0]
	            } else {
	                return filterValue[1]
	            }
	        }
	        return !isFilterRange ? filterValue : void 0
	    };
	    var normalizeFilterValue = function(that, filterValue, column, $editorContainer) {
	        if ("between" === getColumnSelectedFilterOperation(that, column)) {
	            var columnFilterValue = getColumnFilterValue(that, column);
	            if ($editorContainer.hasClass(DATAGRID_FILTER_RANGE_START_CLASS)) {
	                return [filterValue, commonUtils.isArray(columnFilterValue) ? columnFilterValue[1] : void 0]
	            } else {
	                return [commonUtils.isArray(columnFilterValue) ? columnFilterValue[0] : columnFilterValue, filterValue]
	            }
	        }
	        return filterValue
	    };
	    var updateFilterValue = function(that, options) {
	        var value = "" === options.value ? null : options.value,
	            $editorContainer = options.container,
	            column = that._columnsController.columnOption(options.column.index),
	            filterValue = getFilterValue(that, column.index, $editorContainer);
	        if (!commonUtils.isDefined(filterValue) && !commonUtils.isDefined(value)) {
	            return
	        }
	        that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value);
	        that._columnsController.columnOption(column.index, isOnClickApplyFilterMode(that) ? "bufferedFilterValue" : "filterValue", normalizeFilterValue(that, value, column, $editorContainer), options.notFireEvent)
	    };
	    return {
	        _updateEditorValue: function(column, $editorContainer) {
	            var that = this,
	                editor = getEditorInstance($editorContainer);
	            editor && editor.option("value", getFilterValue(that, column.index, $editorContainer))
	        },
	        _columnOptionChanged: function(e) {
	            var overlayInstance, visibleIndex, column, $cell, $editorContainer, $editorRangeElements, $menu, that = this,
	                optionNames = e.optionNames;
	            if (gridCore.checkChanges(optionNames, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation"]) && void 0 !== e.columnIndex) {
	                visibleIndex = that._columnsController.getVisibleIndex(e.columnIndex);
	                column = that._columnsController.columnOption(e.columnIndex);
	                $cell = that.getCellElement(that.element().find("." + DATAGRID_FILTER_ROW_CLASS).index(), visibleIndex) || $();
	                $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
	                if (optionNames.filterValue || optionNames.bufferedFilterValue) {
	                    that._updateEditorValue(column, $editorContainer);
	                    overlayInstance = $cell.find("." + DATAGRID_FILTER_RANGE_OVERLAY_CLASS).data("dxOverlay");
	                    if (overlayInstance) {
	                        $editorRangeElements = overlayInstance.content().find("." + DATAGRID_EDITOR_CONTAINER_CLASS);
	                        that._updateEditorValue(column, $editorRangeElements.first());
	                        that._updateEditorValue(column, $editorRangeElements.last())
	                    }
	                    if (!overlayInstance || !overlayInstance.option("visible")) {
	                        that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column))
	                    }
	                }
	                if (optionNames.selectedFilterOperation || optionNames.bufferedSelectedFilterOperation) {
	                    if (visibleIndex >= 0 && column) {
	                        $menu = $cell.find("." + DATAGRID_MENU_CLASS);
	                        if ($menu.length) {
	                            that._updateFilterOperationChooser($menu, column, $editorContainer);
	                            if ("between" === getColumnSelectedFilterOperation(that, column)) {
	                                that._renderFilterRangeContent($cell, column)
	                            } else {
	                                if ($editorContainer.find("." + DATAGRID_FILTER_RANGE_CONTENT_CLASS).length) {
	                                    that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
	                                    that._hideFilterRange()
	                                }
	                            }
	                        }
	                    }
	                }
	                return
	            }
	            that.callBase(e)
	        },
	        _resizeCore: function() {
	            this.callBase.apply(this, arguments);
	            this._filterRangeOverlayInstance && this._filterRangeOverlayInstance.repaint()
	        },
	        isFilterRowVisible: function() {
	            return this._isElementVisible(this.option("filterRow"))
	        },
	        isVisible: function() {
	            return this.callBase() || this.isFilterRowVisible()
	        },
	        init: function() {
	            this.callBase();
	            this._applyFilterViewController = this.getController("applyFilter")
	        },
	        _initFilterRangeOverlay: function($cell, column) {
	            var that = this,
	                sharedData = {},
	                $editorContainer = $cell.find(".dx-editor-container"),
	                $overlay = $("<div>").addClass(DATAGRID_FILTER_RANGE_OVERLAY_CLASS).appendTo($cell);
	            return that._createComponent($overlay, Overlay, {
	                height: "auto",
	                shading: false,
	                showTitle: false,
	                focusStateEnabled: false,
	                closeOnTargetScroll: true,
	                closeOnOutsideClick: true,
	                animation: false,
	                position: {
	                    my: "top",
	                    at: "top",
	                    of: $editorContainer.length && $editorContainer || $cell,
	                    offset: "0 -1"
	                },
	                contentTemplate: function(contentElement) {
	                    var editorOptions, $editor = $("<div>").addClass(DATAGRID_EDITOR_CONTAINER_CLASS + " " + DATAGRID_FILTER_RANGE_START_CLASS).appendTo(contentElement);
	                    column = that._columnsController.columnOption(column.index);
	                    editorOptions = that._getEditorOptions($editor, column);
	                    editorOptions.sharedData = sharedData;
	                    that._renderEditor($editor, editorOptions);
	                    $editor.find(DATAGRID_EDITORS_INPUT_SELECTOR).on("keydown", function(e) {
	                        var $prevElement = $cell.find("[tabindex]").not(e.target).first();
	                        if (9 === e.which && e.shiftKey) {
	                            e.preventDefault();
	                            that._hideFilterRange();
	                            if (!$prevElement.length) {
	                                $prevElement = $cell.prev().find("[tabindex]").last()
	                            }
	                            $prevElement.focus()
	                        }
	                    });
	                    $editor = $("<div>").addClass(DATAGRID_EDITOR_CONTAINER_CLASS + " " + DATAGRID_FILTER_RANGE_END_CLASS).appendTo(contentElement);
	                    editorOptions = that._getEditorOptions($editor, column);
	                    editorOptions.sharedData = sharedData;
	                    that._renderEditor($editor, editorOptions);
	                    $editor.find(DATAGRID_EDITORS_INPUT_SELECTOR).on("keydown", function(e) {
	                        if (9 === e.which && !e.shiftKey) {
	                            e.preventDefault();
	                            that._hideFilterRange();
	                            $cell.next().find("[tabindex]").first().focus()
	                        }
	                    });
	                    return contentElement.addClass(DATAGRID_CLASS)
	                },
	                onShown: function(e) {
	                    var $editor = e.component.content().find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
	                    $editor.find(DATAGRID_EDITORS_INPUT_SELECTOR).focus()
	                },
	                onHidden: function() {
	                    column = that._columnsController.columnOption(column.index);
	                    $cell.find("." + DATAGRID_MENU_CLASS).parent().addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
	                    if ("between" === getColumnSelectedFilterOperation(that, column)) {
	                        that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
	                        that.component.updateDimensions()
	                    }
	                }
	            })
	        },
	        _updateFilterRangeOverlay: function(options) {
	            var overlayInstance = this._filterRangeOverlayInstance;
	            overlayInstance && overlayInstance.option(options)
	        },
	        _showFilterRange: function($cell, column) {
	            var that = this,
	                $overlay = $cell.children("." + DATAGRID_FILTER_RANGE_OVERLAY_CLASS),
	                overlayInstance = $overlay.length && $overlay.data("dxOverlay");
	            if (!overlayInstance && column) {
	                overlayInstance = that._initFilterRangeOverlay($cell, column)
	            }
	            if (!overlayInstance.option("visible")) {
	                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.hide();
	                that._filterRangeOverlayInstance = overlayInstance;
	                that._updateFilterRangeOverlay({
	                    width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
	                });
	                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.show()
	            }
	        },
	        _hideFilterRange: function() {
	            var overlayInstance = this._filterRangeOverlayInstance;
	            overlayInstance && overlayInstance.hide()
	        },
	        getFilterRangeOverlayInstance: function() {
	            return this._filterRangeOverlayInstance
	        },
	        _createRow: function(row) {
	            var $row = this.callBase(row);
	            if ("filter" === row.rowType) {
	                $row.addClass(DATAGRID_FILTER_ROW_CLASS)
	            }
	            return $row
	        },
	        _getRows: function() {
	            var result = this.callBase();
	            if (this.isFilterRowVisible()) {
	                result.push({
	                    rowType: "filter"
	                })
	            }
	            return result
	        },
	        _renderCellContent: function($cell, options) {
	            var $container, $editorContainer, that = this,
	                column = options.column;
	            if ("filter" === options.rowType) {
	                if (column.command) {
	                    $cell.html("&nbsp;")
	                } else {
	                    if (column.allowFiltering) {
	                        that.setAria("label", messageLocalization.format("dxDataGrid-ariaColumn") + " " + column.caption + ", " + messageLocalization.format("dxDataGrid-ariaFilterCell"), $cell);
	                        $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
	                        $container = $("<div>").appendTo($cell);
	                        $editorContainer = $("<div>").addClass(DATAGRID_EDITOR_CONTAINER_CLASS).appendTo($container);
	                        if ("between" === getColumnSelectedFilterOperation(that, column)) {
	                            that._renderFilterRangeContent($cell, column)
	                        } else {
	                            that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column))
	                        }
	                        if (column.alignment) {
	                            $cell.find(DATAGRID_EDITORS_INPUT_SELECTOR).first().css("text-align", column.alignment)
	                        }
	                        if (column.filterOperations && column.filterOperations.length) {
	                            that._renderFilterOperationChooser($container, column, $editorContainer)
	                        }
	                    }
	                }
	            }
	            that.callBase($cell, options)
	        },
	        _getEditorOptions: function($editorContainer, column) {
	            var that = this,
	                result = $.extend({}, column, {
	                    value: getFilterValue(that, column.index, $editorContainer),
	                    parentType: "filterRow",
	                    showAllText: that.option("filterRow.showAllText"),
	                    updateValueTimeout: "onClick" === that.option("filterRow.applyFilter") ? 0 : FILTERING_TIMEOUT,
	                    width: null,
	                    setValue: function(value, notFireEvent) {
	                        updateFilterValue(that, {
	                            column: column,
	                            value: value,
	                            container: $editorContainer,
	                            notFireEvent: notFireEvent
	                        })
	                    }
	                });
	            if ("between" === getColumnSelectedFilterOperation(that, column)) {
	                if ($editorContainer.hasClass(DATAGRID_FILTER_RANGE_START_CLASS)) {
	                    result.placeholder = that.option("filterRow.betweenStartText")
	                } else {
	                    result.placeholder = that.option("filterRow.betweenEndText")
	                }
	            }
	            return result
	        },
	        _renderEditor: function($editorContainer, options) {
	            $editorContainer.empty();
	            return this.getController("editorFactory").createEditor($("<div>").appendTo($editorContainer), options)
	        },
	        _renderFilterRangeContent: function($cell, column) {
	            var that = this,
	                $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
	            $editorContainer.empty();
	            $("<div>").addClass(DATAGRID_FILTER_RANGE_CONTENT_CLASS).attr("tabindex", 0).on("focusin", function() {
	                that._showFilterRange($cell, column)
	            }).appendTo($editorContainer);
	            that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column))
	        },
	        _updateFilterRangeContent: function($cell, value) {
	            var $filterRangeContent = $cell.find("." + DATAGRID_FILTER_RANGE_CONTENT_CLASS);
	            if ($filterRangeContent.length) {
	                if ("" === value) {
	                    $filterRangeContent.html("&nbsp;")
	                } else {
	                    $filterRangeContent.text(value)
	                }
	            }
	        },
	        _updateFilterOperationChooser: function($menu, column, $editorContainer) {
	            var isCellWasFocused, that = this;
	            that._createComponent($menu, Menu, {
	                integrationOptions: {},
	                activeStateEnabled: false,
	                selectionMode: "single",
	                cssClass: DATAGRID_CLASS + " " + DATAGRID_CELL_FOCUS_DISABLED_CLASS + " " + DATAGRID_FILTER_MENU,
	                showFirstSubmenuMode: "onHover",
	                hideSubmenuOnMouseLeave: true,
	                items: [{
	                    disabled: column.filterOperations && column.filterOperations.length ? false : true,
	                    icon: OPERATION_ICONS[getColumnSelectedFilterOperation(that, column) || "default"],
	                    selectable: false,
	                    items: that._getFilterOperationMenuItems(column)
	                }],
	                onItemClick: function(properties) {
	                    var selectedFilterOperation = properties.itemData.name,
	                        columnSelectedFilterOperation = getColumnSelectedFilterOperation(that, column),
	                        notFocusEditor = false,
	                        isOnClickMode = isOnClickApplyFilterMode(that),
	                        options = {};
	                    if (properties.itemData.items || selectedFilterOperation === columnSelectedFilterOperation) {
	                        return
	                    }
	                    if (selectedFilterOperation) {
	                        options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = selectedFilterOperation;
	                        if ("between" === selectedFilterOperation || "between" === columnSelectedFilterOperation) {
	                            notFocusEditor = "between" === selectedFilterOperation;
	                            options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null
	                        }
	                    } else {
	                        options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = column.defaultSelectedFilterOperation || null;
	                        options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null
	                    }
	                    that._columnsController.columnOption(column.index, options);
	                    that._applyFilterViewController.setHighLight($editorContainer, true);
	                    if (!notFocusEditor) {
	                        that._focusEditor($editorContainer)
	                    } else {
	                        that._showFilterRange($editorContainer.closest("." + DATAGRID_EDITOR_CELL_CLASS), column)
	                    }
	                },
	                onSubmenuShown: function() {
	                    isCellWasFocused = that._isEditorFocused($editorContainer);
	                    that.getController("editorFactory").loseFocus()
	                },
	                onSubmenuHiding: function() {
	                    $menu.blur();
	                    Menu.getInstance($menu).option("focusedElement", null);
	                    isCellWasFocused && that._focusEditor($editorContainer)
	                },
	                rtlEnabled: that.option("rtlEnabled")
	            })
	        },
	        _isEditorFocused: function($container) {
	            return $container.hasClass(DATAGRID_FOCUSED_CLASS) || $container.parents("." + DATAGRID_FOCUSED_CLASS).length
	        },
	        _focusEditor: function($container) {
	            this.getController("editorFactory").focus($container);
	            $container.find(DATAGRID_EDITORS_INPUT_SELECTOR).focus()
	        },
	        _renderFilterOperationChooser: function($container, column, $editorContainer) {
	            var $menu, that = this;
	            if (that.option("filterRow.showOperationChooser")) {
	                $container.addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
	                $menu = $("<div>").prependTo($container);
	                that._updateFilterOperationChooser($menu, column, $editorContainer)
	            }
	        },
	        _getFilterOperationMenuItems: function(column) {
	            var that = this,
	                result = [{}],
	                filterRowOptions = that.option("filterRow"),
	                operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
	            if (column.filterOperations && column.filterOperations.length) {
	                result = $.map(column.filterOperations, function(value) {
	                    var descriptionName = OPERATION_DESCRIPTORS[value];
	                    return {
	                        name: value,
	                        selected: (getColumnSelectedFilterOperation(that, column) || column.defaultFilterOperation) === value,
	                        text: operationDescriptions[descriptionName],
	                        icon: OPERATION_ICONS[value]
	                    }
	                });
	                result.push({
	                    name: null,
	                    text: filterRowOptions && filterRowOptions.resetOperationText,
	                    icon: OPERATION_ICONS.default
	                })
	            }
	            return result
	        },
	        optionChanged: function(args) {
	            var that = this;
	            switch (args.name) {
	                case "filterRow":
	                case "showColumnLines":
	                    this._invalidate(true, true);
	                    args.handled = true;
	                    break;
	                default:
	                    that.callBase(args)
	            }
	        }
	    }
	}();
	var DataControllerFilterRowExtender = {
	    _calculateAdditionalFilter: function() {
	        var that = this,
	            filters = [that.callBase()],
	            columns = that._columnsController.getVisibleColumns();
	        $.each(columns, function() {
	            var filter;
	            if (this.allowFiltering && this.calculateFilterExpression && commonUtils.isDefined(this.filterValue)) {
	                filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
	                filters.push(filter)
	            }
	        });
	        return gridCore.combineFilters(filters)
	    }
	};
	exports.ApplyFilterViewController = gridCore.ViewController.inherit({
	    _getHeaderPanel: function() {
	        if (!this._headerPanel) {
	            this._headerPanel = this.getView("headerPanel")
	        }
	        return this._headerPanel
	    },
	    setHighLight: function($element, value) {
	        if (isOnClickApplyFilterMode(this)) {
	            $element && $element.toggleClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS, value);
	            this._getHeaderPanel().enableApplyButton(value)
	        }
	    },
	    applyFilter: function() {
	        var columnsController = this.getController("columns"),
	            columns = columnsController.getColumns();
	        columnsController.beginUpdate();
	        for (var i = 0; i < columns.length; i++) {
	            if (void 0 !== columns[i].bufferedFilterValue) {
	                columnsController.columnOption(i, "filterValue", columns[i].bufferedFilterValue);
	                columns[i].bufferedFilterValue = void 0
	            }
	            if (void 0 !== columns[i].bufferedSelectedFilterOperation) {
	                columnsController.columnOption(i, "selectedFilterOperation", columns[i].bufferedSelectedFilterOperation);
	                columns[i].bufferedSelectedFilterOperation = void 0
	            }
	        }
	        columnsController.endUpdate();
	        this.removeHighLights()
	    },
	    removeHighLights: function() {
	        if (isOnClickApplyFilterMode(this)) {
	            var columnHeadersView = this.getView("columnHeadersView");
	            columnHeadersView.element().find("." + DATAGRID_FILTER_ROW_CLASS + " ." + DATAGRID_HIGHLIGHT_OUTLINE_CLASS).removeClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS);
	            this._getHeaderPanel().enableApplyButton(false)
	        }
	    }
	});
	gridCore.registerModule("filterRow", {
	    defaultOptions: function() {
	        return {
	            filterRow: {
	                visible: false,
	                showOperationChooser: true,
	                showAllText: messageLocalization.format("dxDataGrid-filterRowShowAllText"),
	                resetOperationText: messageLocalization.format("dxDataGrid-filterRowResetOperationText"),
	                applyFilter: "auto",
	                applyFilterText: messageLocalization.format("dxDataGrid-applyFilterText"),
	                operationDescriptions: {
	                    equal: messageLocalization.format("dxDataGrid-filterRowOperationEquals"),
	                    notEqual: messageLocalization.format("dxDataGrid-filterRowOperationNotEquals"),
	                    lessThan: messageLocalization.format("dxDataGrid-filterRowOperationLess"),
	                    lessThanOrEqual: messageLocalization.format("dxDataGrid-filterRowOperationLessOrEquals"),
	                    greaterThan: messageLocalization.format("dxDataGrid-filterRowOperationGreater"),
	                    greaterThanOrEqual: messageLocalization.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
	                    startsWith: messageLocalization.format("dxDataGrid-filterRowOperationStartsWith"),
	                    contains: messageLocalization.format("dxDataGrid-filterRowOperationContains"),
	                    notContains: messageLocalization.format("dxDataGrid-filterRowOperationNotContains"),
	                    endsWith: messageLocalization.format("dxDataGrid-filterRowOperationEndsWith"),
	                    between: messageLocalization.format("dxDataGrid-filterRowOperationBetween")
	                },
	                betweenStartText: messageLocalization.format("dxDataGrid-filterRowOperationBetweenStartText"),
	                betweenEndText: messageLocalization.format("dxDataGrid-filterRowOperationBetweenEndText")
	            }
	        }
	    },
	    controllers: {
	        applyFilter: exports.ApplyFilterViewController
	    },
	    extenders: {
	        controllers: {
	            data: DataControllerFilterRowExtender,
	            columnsResizer: {
	                _startResizing: function() {
	                    var cellIndex, overlayInstance, that = this;
	                    that.callBase.apply(that, arguments);
	                    if (that.isResizing()) {
	                        overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
	                        if (overlayInstance) {
	                            cellIndex = overlayInstance.element().closest("td").index();
	                            if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1) {
	                                overlayInstance.content().hide()
	                            }
	                        }
	                    }
	                },
	                _endResizing: function() {
	                    var $cell, overlayInstance, that = this;
	                    if (that.isResizing()) {
	                        overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
	                        if (overlayInstance) {
	                            $cell = overlayInstance.element().closest("td");
	                            that._columnHeadersView._updateFilterRangeOverlay({
	                                width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
	                            });
	                            overlayInstance.content().show()
	                        }
	                    }
	                    that.callBase.apply(that, arguments)
	                }
	            }
	        },
	        views: {
	            columnHeadersView: ColumnHeadersViewFilterRowExtender,
	            headerPanel: {
	                _getToolbarItems: function() {
	                    var items = this.callBase(),
	                        filterItem = this._prepareFilterItem(items);
	                    return filterItem.concat(items)
	                },
	                _prepareFilterItem: function() {
	                    var that = this,
	                        itemDisabledState = that.getToolbarItemOption("filterRow", "disabled"),
	                        disabled = commonUtils.isDefined(itemDisabledState) ? itemDisabledState : true,
	                        filterItem = [];
	                    if (that._isShowApplyFilterButton()) {
	                        var hintText = that.option("filterRow.applyFilterText"),
	                            onInitialized = function(e) {
	                                e.element.addClass(that._getToolbarButtonClass(DATAGRID_APPLY_BUTTON_CLASS))
	                            },
	                            onClickHandler = function() {
	                                that._applyFilterViewController.applyFilter()
	                            },
	                            toolbarItem = {
	                                widget: "dxButton",
	                                options: {
	                                    icon: "apply-filter",
	                                    onClick: onClickHandler,
	                                    hint: hintText,
	                                    text: hintText,
	                                    onInitialized: onInitialized
	                                },
	                                showText: "inMenu",
	                                name: "applyFilterButton",
	                                disabled: disabled,
	                                location: "after",
	                                locateInMenu: "auto"
	                            };
	                        filterItem.push(toolbarItem)
	                    }
	                    return filterItem
	                },
	                _isShowApplyFilterButton: function() {
	                    var filterRowOptions = this.option("filterRow");
	                    return filterRowOptions && filterRowOptions.visible && "onClick" === filterRowOptions.applyFilter
	                },
	                init: function() {
	                    this.callBase();
	                    this._dataController = this.getController("data");
	                    this._applyFilterViewController = this.getController("applyFilter")
	                },
	                enableApplyButton: function(value) {
	                    this.updateToolbarItemOption("applyFilterButton", "disabled", !value)
	                },
	                isVisible: function() {
	                    return this.callBase() || this._isShowApplyFilterButton()
	                },
	                optionChanged: function(args) {
	                    if ("filterRow" === args.name) {
	                        this._invalidate();
	                        this.updateToolbar();
	                        args.handled = true
	                    } else {
	                        this.callBase(args)
	                    }
	                }
	            }
	        }
	    }
	});
	exports.ColumnHeadersViewFilterRowExtender = ColumnHeadersViewFilterRowExtender;
	exports.DataControllerFilterRowExtender = DataControllerFilterRowExtender;


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/menu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = __webpack_require__(276);
	module.exports.default = module.exports;


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/menu/ui.menu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    hoverEvents = __webpack_require__(92),
	    MenuBase = __webpack_require__(166),
	    Overlay = __webpack_require__(97),
	    Submenu = __webpack_require__(277),
	    Button = __webpack_require__(114),
	    TreeView = __webpack_require__(215);
	var DX_MENU_CLASS = "dx-menu",
	    DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + "-vertical",
	    DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + "-horizontal",
	    DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
	    DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
	    DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
	    DX_CONTEXT_MENU_CLASS = "dx-context-menu",
	    DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + "-container-border",
	    DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter",
	    DX_SUBMENU_CLASS = "dx-submenu",
	    DX_STATE_DISABLED_CLASS = "dx-state-disabled",
	    DX_STATE_HOVER_CLASS = "dx-state-hover",
	    DX_STATE_ACTIVE_CLASS = "dx-state-active",
	    DX_ADAPTIVE_MODE_CLASS = DX_MENU_CLASS + "-adaptive-mode",
	    DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS = DX_MENU_CLASS + "-hamburger-button",
	    FOCUS_UP = "up",
	    FOCUS_DOWN = "down",
	    FOCUS_LEFT = "left",
	    FOCUS_RIGHT = "right",
	    SHOW_SUBMENU_OPERATION = "showSubmenu",
	    NEXTITEM_OPERATION = "nextItem",
	    PREVITEM_OPERATION = "prevItem",
	    DEFAULT_DELAY = {
	        show: 50,
	        hide: 300
	    },
	    ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged"];
	var Menu = MenuBase.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            orientation: "horizontal",
	            submenuDirection: "auto",
	            showFirstSubmenuMode: {
	                name: "onClick",
	                delay: {
	                    show: 50,
	                    hide: 300
	                }
	            },
	            hideSubmenuOnMouseLeave: false,
	            onSubmenuShowing: null,
	            onSubmenuShown: null,
	            onSubmenuHiding: null,
	            onSubmenuHidden: null,
	            adaptivityEnabled: false
	        })
	    },
	    _setOptionsByReference: function() {
	        this.callBase();
	        $.extend(this._optionsByReference, {
	            animation: true,
	            selectedItem: true
	        })
	    },
	    _itemElements: function() {
	        var rootMenuElements = this.callBase(),
	            submenuElements = this._submenuItemElements();
	        return rootMenuElements.add(submenuElements)
	    },
	    _submenuItemElements: function() {
	        var elements = [],
	            itemSelector = "." + DX_MENU_ITEM_CLASS,
	            currentSubmenu = this._submenus.length && this._submenus[0];
	        if (currentSubmenu && currentSubmenu.itemsContainer()) {
	            elements = currentSubmenu.itemsContainer().find(itemSelector)
	        }
	        return elements
	    },
	    _focusTarget: function() {
	        return this.element()
	    },
	    _isMenuHorizontal: function() {
	        return "horizontal" === this.option("orientation")
	    },
	    _moveFocus: function(location) {
	        var argument, operation, navigationAction, $newTarget, $items = this._getAvailableItems(),
	            isMenuHorizontal = this._isMenuHorizontal(),
	            $activeItem = this._getActiveItem(true);
	        switch (location) {
	            case FOCUS_UP:
	                operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
	                argument = isMenuHorizontal ? $activeItem : $items;
	                navigationAction = this._getKeyboardNavigationAction(operation, argument);
	                $newTarget = navigationAction();
	                break;
	            case FOCUS_DOWN:
	                operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
	                argument = isMenuHorizontal ? $activeItem : $items;
	                navigationAction = this._getKeyboardNavigationAction(operation, argument);
	                $newTarget = navigationAction();
	                break;
	            case FOCUS_RIGHT:
	                operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
	                argument = isMenuHorizontal ? $items : $activeItem;
	                navigationAction = this._getKeyboardNavigationAction(operation, argument);
	                $newTarget = navigationAction();
	                break;
	            case FOCUS_LEFT:
	                operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
	                argument = isMenuHorizontal ? $items : $activeItem;
	                navigationAction = this._getKeyboardNavigationAction(operation, argument);
	                $newTarget = navigationAction();
	                break;
	            default:
	                return this.callBase(location)
	        }
	        if ($newTarget && 0 !== $newTarget.length) {
	            this.option("focusedElement", $newTarget)
	        }
	    },
	    _getItemsNavigationOperation: function(operation) {
	        var navOperation = operation;
	        if (this.option("rtlEnabled")) {
	            navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION
	        }
	        return navOperation
	    },
	    _getKeyboardNavigationAction: function(operation, argument) {
	        var action = $.noop;
	        switch (operation) {
	            case SHOW_SUBMENU_OPERATION:
	                if (!argument.hasClass(DX_STATE_DISABLED_CLASS)) {
	                    action = $.proxy(this._showSubmenu, this, argument)
	                }
	                break;
	            case NEXTITEM_OPERATION:
	                action = $.proxy(this._nextItem, this, argument);
	                break;
	            case PREVITEM_OPERATION:
	                action = $.proxy(this._prevItem, this, argument)
	        }
	        return action
	    },
	    _clean: function() {
	        this.callBase();
	        this.option("templatesRenderAsynchronously") && clearTimeout(this._resizeEventTimer)
	    },
	    _visibilityChanged: function(visible) {
	        if (visible) {
	            this._dimensionChanged()
	        }
	    },
	    _isAdaptivityEnabled: function() {
	        return this.option("adaptivityEnabled") && "horizontal" === this.option("orientation")
	    },
	    _dimensionChanged: function() {
	        if (!this._isAdaptivityEnabled()) {
	            return
	        }
	        var $menuItems = this.element().find("ul:first>li>." + DX_MENU_ITEM_CLASS),
	            menuItemsWidth = 0,
	            containerWidth = this.element().outerWidth();
	        $menuItems.each(function(_, menuItem) {
	            menuItemsWidth += $(menuItem).outerWidth(true)
	        });
	        this._toggleAdaptiveMode(menuItemsWidth > containerWidth)
	    },
	    _init: function() {
	        this.callBase();
	        this._submenus = []
	    },
	    _initActions: function() {
	        this._actions = {};
	        $.each(ACTIONS, $.proxy(function(index, action) {
	            this._actions[action] = this._createActionByOption(action)
	        }, this))
	    },
	    _render: function() {
	        this._visibleSubmenu = null;
	        this.callBase();
	        this.element().addClass(DX_MENU_CLASS);
	        this._isAdaptivityEnabled() && this._initAdaptivity();
	        this.setAria("role", "menubar")
	    },
	    _renderHamburgerButton: function() {
	        this._hamburger = new Button($("<div>", {
	            "class": DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS
	        }), {
	            icon: "menu",
	            activeStateEnabled: false,
	            onClick: $.proxy(this._toggleTreeView, this)
	        });
	        return this._hamburger.element()
	    },
	    _toggleTreeView: function(state) {
	        if ($.isPlainObject(state)) {
	            state = !this._overlay.option("visible")
	        }
	        this._overlay.option("visible", state);
	        this._toggleHamburgerActiveState(state)
	    },
	    _toggleHamburgerActiveState: function(state) {
	        this._hamburger && this._hamburger.element().toggleClass(DX_STATE_ACTIVE_CLASS, state)
	    },
	    _toggleAdaptiveMode: function(state) {
	        var $menuItemsContainer = this.element().find("." + DX_MENU_ITEMS_CONTAINER_CLASS),
	            $adaptiveElements = this.element().find("." + DX_ADAPTIVE_MODE_CLASS);
	        if (state) {
	            this._hideVisibleSubmenu()
	        } else {
	            this._treeView && this._treeView.collapseAll();
	            this._overlay && this._toggleTreeView(state)
	        }
	        $menuItemsContainer.toggle(!state);
	        $adaptiveElements.toggle(state)
	    },
	    _removeAdaptivity: function() {
	        if (!this._$adaptiveContainer) {
	            return
	        }
	        this._toggleAdaptiveMode(false);
	        this._$adaptiveContainer.remove();
	        this._$adaptiveContainer = null;
	        this._treeView = null;
	        this._hamburger = null;
	        this._overlay = null
	    },
	    _treeviewItemClickHandler: function(e) {
	        this._actions.onItemClick(e);
	        if (!e.node.children.length) {
	            this._toggleTreeView(false)
	        }
	    },
	    _getAdaptiveOverlayOptions: function() {
	        var rtl = this.option("rtlEnabled"),
	            position = rtl ? "right" : "left";
	        return {
	            deferRendering: false,
	            shading: false,
	            animation: false,
	            closeOnTargetScroll: true,
	            onPositioned: $.proxy(function() {
	                this._overlay.option("height", this._overlay.content().outerHeight())
	            }, this),
	            onHidden: $.proxy(function() {
	                this._toggleHamburgerActiveState(false)
	            }, this),
	            height: "auto",
	            closeOnOutsideClick: function(e) {
	                return !!!$(e.target).closest("." + DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS).length
	            },
	            position: {
	                collision: "flipfit",
	                at: "bottom " + position,
	                my: "top " + position,
	                of: this._hamburger.element()
	            }
	        }
	    },
	    _getTreeViewOptions: function() {
	        var menuOptions = {},
	            that = this,
	            optionsToTransfer = ["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"],
	            actionsToTransfer = ["onItemContextMenu", "onSelectionChanged"];
	        $.each(optionsToTransfer, function(_, option) {
	            menuOptions[option] = that.option(option)
	        });
	        $.each(actionsToTransfer, function(_, actionName) {
	            menuOptions[actionName] = $.proxy(function(e) {
	                this._actions[actionName](e)
	            }, that)
	        });
	        return $.extend(menuOptions, {
	            onItemClick: $.proxy(that._treeviewItemClickHandler, that),
	            onItemExpanded: $.proxy(function(e) {
	                this._actions.onSubmenuShown(e)
	            }, that),
	            onItemCollapsed: $.proxy(function(e) {
	                this._actions.onSubmenuHidden(e)
	            }, that),
	            selectNodesRecursive: false,
	            selectByClick: this.option("selectByClick"),
	            expandEvent: "click"
	        })
	    },
	    _initAdaptivity: function() {
	        if (!this._isAdaptivityEnabled()) {
	            return
	        }
	        this._$adaptiveContainer = $("<div>", {
	            "class": DX_ADAPTIVE_MODE_CLASS
	        });
	        var $hamburger = this._renderHamburgerButton();
	        this._treeView = this._createComponent($("<div>"), TreeView, this._getTreeViewOptions());
	        this._overlay = this._createComponent($("<div>"), Overlay, this._getAdaptiveOverlayOptions());
	        this._overlay.content().append(this._treeView.element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(this.option("cssClass"));
	        this._$adaptiveContainer.append($hamburger);
	        this._$adaptiveContainer.append(this._overlay.element());
	        this.element().append(this._$adaptiveContainer);
	        if (this.option("templatesRenderAsynchronously")) {
	            this._resizeEventTimer = setTimeout($.proxy(function() {
	                this._dimensionChanged()
	            }, this), 0)
	        } else {
	            this._dimensionChanged()
	        }
	    },
	    _getDelay: function(delayType) {
	        var delay = this.option("showFirstSubmenuMode").delay;
	        if (!commonUtils.isDefined(delay)) {
	            return DEFAULT_DELAY[delayType]
	        } else {
	            return commonUtils.isObject(delay) ? delay[delayType] : delay
	        }
	    },
	    _renderContainer: function() {
	        var $wrapper = $("<div>");
	        $wrapper.appendTo(this.element()).addClass(this._isMenuHorizontal() ? DX_MENU_HORIZONTAL_CLASS : DX_MENU_VERTICAL_CLASS);
	        return this.callBase($wrapper)
	    },
	    _renderSubmenuItems: function(node, $itemFrame) {
	        var submenu = this._createSubmenu(node, $itemFrame);
	        this._submenus.push(submenu);
	        this._renderBorderElement($itemFrame);
	        return submenu
	    },
	    _createSubmenu: function(node, $rootItem) {
	        var $submenuContainer = $("<div>").addClass(DX_CONTEXT_MENU_CLASS).appendTo($rootItem);
	        var items = this._getChildNodes(node),
	            result = this._createComponent($submenuContainer, Submenu, $.extend(this._getSubmenuOptions(), {
	                _dataAdapter: this._dataAdapter,
	                _parentKey: node.internalFields.key,
	                items: items,
	                onHoverStart: $.proxy(this._clearTimeouts, this),
	                position: this.getSubmenuPosition($rootItem)
	            }));
	        this._attachSubmenuHandlers($rootItem, result);
	        return result
	    },
	    _getSubmenuOptions: function() {
	        var $submenuTarget = $("<div>"),
	            isMenuHorizontal = this._isMenuHorizontal();
	        return {
	            itemTemplate: this.option("itemTemplate"),
	            target: $submenuTarget,
	            orientation: this.option("orientation"),
	            selectionMode: this.option("selectionMode"),
	            cssClass: this.option("cssClass"),
	            selectByClick: this.option("selectByClick"),
	            hoverStateEnabled: this.option("hoverStateEnabled"),
	            activeStateEnabled: this.option("activeStateEnabled"),
	            focusStateEnabled: this.option("focusStateEnabled"),
	            animation: this.option("animation"),
	            showSubmenuMode: this.option("showSubmenuMode"),
	            displayExpr: this.option("displayExpr"),
	            disabledExpr: this.option("disabledExpr"),
	            selectedExpr: this.option("selectedExpr"),
	            itemsExpr: this.option("itemsExpr"),
	            onSelectionChanged: $.proxy(this._nestedItemOnSelectionChangedHandler, this),
	            onItemClick: $.proxy(this._nestedItemOnItemClickHandler, this),
	            onItemRendered: this.option("onItemRendered"),
	            onLeftFirstItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION),
	            onLeftLastItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION),
	            onCloseRootSubmenu: $.proxy(this._moveMainMenuFocus, this, isMenuHorizontal ? PREVITEM_OPERATION : null),
	            onExpandLastSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION) : null,
	            _hideDelimiter: this.option("_hideDelimiter")
	        }
	    },
	    _getShowFirstSubmenuMode: function() {
	        if (!this._isDesktopDevice()) {
	            return "onClick"
	        }
	        var optionValue = this.option("showFirstSubmenuMode");
	        return commonUtils.isObject(optionValue) ? optionValue.name : optionValue
	    },
	    _moveMainMenuFocus: function(direction) {
	        var $items = this._getAvailableItems(),
	            itemCount = $items.length,
	            $currentItem = $items.filter("." + DX_MENU_ITEM_EXPANDED_CLASS).eq(0),
	            itemIndex = $items.index($currentItem);
	        itemIndex += direction === PREVITEM_OPERATION ? -1 : 1;
	        if (itemIndex >= itemCount) {
	            itemIndex = 0
	        } else {
	            if (itemIndex < 0) {
	                itemIndex = itemCount - 1
	            }
	        }
	        var $newItem = $items.eq(itemIndex);
	        this._hideSubmenu(this._visibleSubmenu);
	        this.focus();
	        this.option("focusedElement", $newItem)
	    },
	    _nestedItemOnSelectionChangedHandler: function(args) {
	        var selectedItem = args.addedItems.length && args.addedItems[0],
	            submenu = Submenu.getInstance(args.element),
	            onSelectionChanged = this._actions.onSelectionChanged;
	        onSelectionChanged(args);
	        selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
	        this._clearRootSelection();
	        this._setOptionSilent("selectedItem", selectedItem)
	    },
	    _clearSelectionInSubmenus: function(item, targetSubmenu) {
	        var that = this,
	            cleanAllSubmenus = !arguments.length;
	        $.each(this._submenus, function(index, submenu) {
	            var $submenu = submenu._itemContainer(),
	                isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer()),
	                $selectedItem = $submenu.find("." + that._selectedItemClass());
	            if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
	                var selectedItemData;
	                $selectedItem.removeClass(that._selectedItemClass());
	                selectedItemData = that._getItemData($selectedItem);
	                if (selectedItemData) {
	                    selectedItemData.selected = false
	                }
	                submenu._clearSelectedItems()
	            }
	        })
	    },
	    _clearRootSelection: function() {
	        var $prevSelectedItem = this.element().find("." + DX_MENU_ITEMS_CONTAINER_CLASS).first().children().children().filter("." + this._selectedItemClass());
	        if ($prevSelectedItem.length) {
	            var prevSelectedItemData;
	            prevSelectedItemData = this._getItemData($prevSelectedItem);
	            prevSelectedItemData.selected = false;
	            $prevSelectedItem.removeClass(this._selectedItemClass())
	        }
	    },
	    _nestedItemOnItemClickHandler: function(e) {
	        this._actions.onItemClick(e)
	    },
	    _attachSubmenuHandlers: function($rootItem, submenu) {
	        var that = this,
	            $submenuOverlayContent = submenu.getOverlayContent(),
	            submenus = $submenuOverlayContent.find("." + DX_SUBMENU_CLASS),
	            submenuMouseLeaveName = eventUtils.addNamespace(hoverEvents.end, this.NAME + "_submenu");
	        submenu.option({
	            onShowing: $.proxy(this._submenuOnShowingHandler, this, $rootItem, submenu),
	            onShown: $.proxy(this._submenuOnShownHandler, this, $rootItem, submenu),
	            onHiding: $.proxy(this._submenuOnHidingHandler, this, $rootItem, submenu),
	            onHidden: $.proxy(this._submenuOnHiddenHandler, this, $rootItem, submenu)
	        });
	        $.each(submenus, function(index, submenu) {
	            $(submenu).off(submenuMouseLeaveName).on(submenuMouseLeaveName, null, $.proxy(that._submenuMouseLeaveHandler, that, $rootItem))
	        })
	    },
	    _submenuOnShowingHandler: function($rootItem, submenu) {
	        var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS);
	        this._actions.onSubmenuShowing({
	            rootItem: $rootItem,
	            submenu: submenu
	        });
	        $border.show();
	        $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
	    },
	    _submenuOnShownHandler: function($rootItem, submenu) {
	        this._actions.onSubmenuShown({
	            rootItem: $rootItem,
	            submenu: submenu
	        })
	    },
	    _submenuOnHidingHandler: function($rootItem, submenu, eventArgs) {
	        var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS),
	            args = eventArgs;
	        args.rootItem = $rootItem;
	        args.submenu = submenu;
	        this._actions.onSubmenuHiding(args);
	        eventArgs = args;
	        if (!eventArgs.cancel) {
	            if (this._visibleSubmenu === submenu) {
	                this._visibleSubmenu = null
	            }
	            $border.hide();
	            $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS)
	        }
	    },
	    _submenuOnHiddenHandler: function($rootItem, submenu) {
	        this._actions.onSubmenuHidden({
	            rootItem: $rootItem,
	            submenu: submenu
	        })
	    },
	    _submenuMouseLeaveHandler: function($rootItem, eventArgs) {
	        var that = this,
	            target = $(eventArgs.relatedTarget).parents("." + DX_CONTEXT_MENU_CLASS)[0],
	            contextMenu = that._getSubmenuByRootElement($rootItem).getOverlayContent()[0];
	        if (that.option("hideSubmenuOnMouseLeave") && target !== contextMenu) {
	            that._clearTimeouts();
	            setTimeout($.proxy(that._hideSubmenuAfterTimeout, that), that._getDelay("hide"))
	        }
	    },
	    _hideSubmenuAfterTimeout: function() {
	        if (!this._visibleSubmenu) {
	            return
	        }
	        var isRootItemHovered = $(this._visibleSubmenu.element().context).hasClass(DX_STATE_HOVER_CLASS),
	            isSubmenuItemHovered = this._visibleSubmenu.getOverlayContent().find("." + DX_STATE_HOVER_CLASS).length;
	        if (!isSubmenuItemHovered && !isRootItemHovered) {
	            this._visibleSubmenu.hide()
	        }
	    },
	    _getSubmenuByRootElement: function($rootItem) {
	        if (!$rootItem) {
	            return false
	        }
	        var $submenu = $rootItem.children("." + DX_CONTEXT_MENU_CLASS);
	        return $submenu.length && Submenu.getInstance($submenu)
	    },
	    getSubmenuPosition: function($rootItem) {
	        var isHorizontalMenu = this._isMenuHorizontal(),
	            submenuDirection = this.option("submenuDirection").toLowerCase(),
	            rtlEnabled = this.option("rtlEnabled"),
	            submenuPosition = {
	                collision: "flip",
	                of: $rootItem
	            };
	        switch (submenuDirection) {
	            case "leftortop":
	                submenuPosition.at = "left top";
	                submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
	                break;
	            case "rightorbottom":
	                submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
	                submenuPosition.my = "left top";
	                break;
	            default:
	                if (isHorizontalMenu) {
	                    submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
	                    submenuPosition.my = rtlEnabled ? "right top" : "left top"
	                } else {
	                    submenuPosition.at = rtlEnabled ? "left top" : "right top";
	                    submenuPosition.my = rtlEnabled ? "right top" : "left top"
	                }
	        }
	        return submenuPosition
	    },
	    _renderBorderElement: function($item) {
	        $("<div>").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide()
	    },
	    _itemPointerDownHandler: function(e) {
	        var $target = $(e.target),
	            $closestItem = $target.closest(this._itemElements());
	        if ($closestItem.hasClass("dx-menu-item-has-submenu")) {
	            this.option("focusedElement", null);
	            e.preventDefault();
	            return
	        }
	        this.callBase(e)
	    },
	    _hoverStartHandler: function(e) {
	        var mouseMoveEventName = eventUtils.addNamespace(pointerEvents.move, this.NAME),
	            $item = this._getItemElementByEventArgs(e),
	            node = this._dataAdapter.getNodeByItem(this._getItemData($item)),
	            isSelectionActive = commonUtils.isDefined(e.buttons) && 1 === e.buttons || !commonUtils.isDefined(e.buttons) && 1 === e.which;
	        if (this._isItemDisabled($item)) {
	            return
	        }
	        $item.off(mouseMoveEventName);
	        if (!this._hasChildren(node)) {
	            setTimeout($.proxy(this._hideSubmenuAfterTimeout, this), this._getDelay("hide"));
	            return
	        }
	        if ("onHover" === this._getShowFirstSubmenuMode() && !isSelectionActive) {
	            var submenu = this._getSubmenuByElement($item);
	            this._clearTimeouts();
	            if (!submenu.isOverlayVisible()) {
	                $item.on(mouseMoveEventName, $.proxy(this._itemMouseMoveHandler, this));
	                this._showSubmenuTimer = this._getDelay("hide")
	            }
	        }
	    },
	    _hoverEndHandler: function(eventArg) {
	        var that = this,
	            $item = that._getItemElementByEventArgs(eventArg),
	            relatedTarget = $(eventArg.relatedTarget);
	        if (that._isItemDisabled($item)) {
	            return
	        }
	        if (relatedTarget.hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)) {
	            return
	        }
	        if (that.option("hideSubmenuOnMouseLeave") && !relatedTarget.hasClass(DX_MENU_ITEMS_CONTAINER_CLASS)) {
	            that._clearTimeouts();
	            that._hideSubmenuTimer = setTimeout(function() {
	                that._hideSubmenuAfterTimeout()
	            }, that._getDelay("hide"))
	        }
	    },
	    _hideVisibleSubmenu: function() {
	        if (!this._visibleSubmenu) {
	            return false
	        }
	        this._hideSubmenu(this._visibleSubmenu);
	        return true
	    },
	    _showSubmenu: function($itemElement) {
	        var submenu = this._getSubmenuByElement($itemElement);
	        if (this._visibleSubmenu !== submenu) {
	            this._hideVisibleSubmenu()
	        }
	        submenu && submenu.show();
	        this._visibleSubmenu = submenu;
	        this._hoveredRootItem = $itemElement
	    },
	    _hideSubmenu: function(submenu) {
	        submenu && submenu.hide();
	        if (this._visibleSubmenu === submenu) {
	            this._visibleSubmenu = null
	        }
	        this._hoveredRootItem = null
	    },
	    _itemMouseMoveHandler: function(e) {
	        if (e.pointers && e.pointers.length) {
	            return
	        }
	        var that = this,
	            $item = $(e.currentTarget);
	        if (!commonUtils.isDefined(that._showSubmenuTimer)) {
	            return
	        }
	        that._clearTimeouts();
	        that._showSubmenuTimer = setTimeout(function() {
	            var submenu = that._getSubmenuByElement($item);
	            if (submenu && !submenu.isOverlayVisible()) {
	                that._showSubmenu($item)
	            }
	        }, that._getDelay("show"))
	    },
	    _clearTimeouts: function() {
	        clearTimeout(this._hideSubmenuTimer);
	        clearTimeout(this._showSubmenuTimer)
	    },
	    _getSubmenuByElement: function($itemElement, itemData) {
	        var submenu = this._getSubmenuByRootElement($itemElement);
	        if (submenu) {
	            return submenu
	        } else {
	            itemData = itemData || this._getItemData($itemElement);
	            var node = this._dataAdapter.getNodeByItem(itemData);
	            return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement)
	        }
	    },
	    _updateSubmenuVisibilityOnClick: function(actionArgs) {
	        var currentSubmenu, args = actionArgs.args.length && actionArgs.args[0];
	        if (!args || this._disabledGetter(args.itemData)) {
	            return
	        }
	        args.jQueryEvent.stopPropagation();
	        currentSubmenu = this._getSubmenuByElement(args.itemElement, args.itemData);
	        this._updateSelectedItemOnClick(actionArgs);
	        if (this._visibleSubmenu) {
	            if (this._visibleSubmenu === currentSubmenu) {
	                if ("onClick" === this.option("showFirstSubmenuMode")) {
	                    this._hideSubmenu(this._visibleSubmenu)
	                }
	                return
	            } else {
	                this._hideSubmenu(this._visibleSubmenu)
	            }
	        }
	        if (!currentSubmenu) {
	            return
	        }
	        if (!currentSubmenu.isOverlayVisible()) {
	            this._showSubmenu(args.itemElement);
	            return
	        }
	    },
	    _optionChanged: function(args) {
	        if (this._cancelOptionChange === args.name) {
	            return
	        }
	        this._hideShownSubmenuOnOptionChange(args.name);
	        switch (args.name) {
	            case "orientation":
	            case "submenuDirection":
	            case "hideSubmenuOnMouseLeave":
	            case "showFirstSubmenuMode":
	                this._invalidate();
	                break;
	            case "showSubmenuMode":
	                this._changeSubmenusOption(args.name, args.value);
	                break;
	            case "onSubmenuShowing":
	            case "onSubmenuShown":
	            case "onSubmenuHiding":
	            case "onSubmenuHidden":
	                this._initActions();
	                break;
	            case "adaptivityEnabled":
	                args.value ? this._initAdaptivity() : this._removeAdaptivity();
	                break;
	            case "width":
	                if (this._isAdaptivityEnabled()) {
	                    this._treeView.option(args.name, args.value);
	                    this._overlay.option(args.name, args.value)
	                }
	                this.callBase(args);
	                this._dimensionChanged();
	                break;
	            default:
	                if (this._isAdaptivityEnabled()) {
	                    this._treeView.option(args.name, args.value)
	                }
	                this.callBase(args)
	        }
	    },
	    _hideShownSubmenuOnOptionChange: function(optionName) {
	        if ("focusedElement" !== optionName && this._visibleSubmenu) {
	            this._hideSubmenu(this._visibleSubmenu)
	        }
	    },
	    _changeSubmenusOption: function(name, value) {
	        $.each(this._submenus, function(index, submenu) {
	            submenu.option(name, value)
	        })
	    },
	    selectItem: function(itemElement) {
	        this._hideSubmenu(this._visibleSubmenu);
	        this.callBase(itemElement)
	    },
	    unselectItem: function(itemElement) {
	        this._hideSubmenu(this._visibleSubmenu);
	        this.callBase(itemElement)
	    }
	});
	registerComponent("dxMenu", Menu);
	module.exports = Menu;


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/menu/ui.submenu.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    positionUtils = __webpack_require__(60),
	    ContextMenu = __webpack_require__(164);
	var DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter",
	    DX_SUBMENU_CLASS = "dx-submenu";
	var Submenu = ContextMenu.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            orientation: "horizontal",
	            onHoverStart: $.noop
	        })
	    },
	    _initDataAdapter: function() {
	        this._dataAdapter = this.option("_dataAdapter");
	        if (!this._dataAdapter) {
	            this.callBase()
	        }
	    },
	    _renderContentImpl: function() {
	        this._renderContextMenuOverlay();
	        this._detachShowContextMenuEvents(this.option("target"));
	        this._attachShowContextMenuEvents();
	        var node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
	        node && this._renderItems(this._getChildNodes(node));
	        if (!this.option("_hideDelimiter")) {
	            this._renderDelimiter()
	        }
	    },
	    _renderDelimiter: function() {
	        this.$contentDelimiter = $("<div>").appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)
	    },
	    _overlayPositionedActionHandler: function(arg) {
	        this._showDelimiter(arg)
	    },
	    _hoverEndHandler: function(e) {
	        this._toggleFocusClass(false, e.currentTarget)
	    },
	    _isMenuHorizontal: function() {
	        return "horizontal" === this.option("orientation")
	    },
	    _hoverStartHandler: function(e) {
	        var hoverStartAction = this.option("onHoverStart");
	        hoverStartAction(e);
	        this.callBase(e);
	        this._toggleFocusClass(true, e.currentTarget)
	    },
	    _showDelimiter: function(arg) {
	        var containerOffset, rootOffset, $submenu = this._itemContainer().children("." + DX_SUBMENU_CLASS).eq(0),
	            $rootItem = this.option("position").of,
	            position = {
	                of: $submenu
	            };
	        if (this.$contentDelimiter) {
	            containerOffset = arg.position;
	            rootOffset = $rootItem.offset();
	            this.$contentDelimiter.css("display", "block");
	            if (this._isMenuHorizontal()) {
	                this.$contentDelimiter.width($rootItem.width() < $submenu.width() ? $rootItem.width() - 2 : $submenu.width());
	                this.$contentDelimiter.height(2);
	                if (containerOffset.v.location > rootOffset.top) {
	                    if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
	                        position.offset = "1 -1";
	                        position.at = "left top";
	                        position.my = "left top"
	                    } else {
	                        position.offset = "-1 -1";
	                        position.at = "right top";
	                        position.my = "right top"
	                    }
	                } else {
	                    this.$contentDelimiter.height(5);
	                    if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
	                        position.offset = "1 4";
	                        position.at = "left bottom";
	                        position.my = "left bottom"
	                    } else {
	                        position.offset = "-1 2";
	                        position.at = "right bottom";
	                        position.my = "right bottom"
	                    }
	                }
	            } else {
	                this.$contentDelimiter.width(2);
	                this.$contentDelimiter.height($rootItem.height() < $submenu.height() ? $rootItem.height() - 2 : $submenu.height());
	                if (containerOffset.h.location > rootOffset.left) {
	                    if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
	                        position.offset = "-1 1";
	                        position.at = "left top";
	                        position.my = "left top"
	                    } else {
	                        position.offset = "-1 -1";
	                        position.at = "left bottom";
	                        position.my = "left bottom"
	                    }
	                } else {
	                    if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
	                        position.offset = "1 1";
	                        position.at = "right top";
	                        position.my = "right top"
	                    } else {
	                        position.offset = "1 -1";
	                        position.at = "right bottom";
	                        position.my = "right bottom"
	                    }
	                }
	            }
	            positionUtils.setup(this.$contentDelimiter, position)
	        }
	    },
	    _getContextMenuPosition: function() {
	        return this.option("position")
	    },
	    isOverlayVisible: function() {
	        return this._overlay.option("visible")
	    },
	    getOverlayContent: function() {
	        return this._overlay.content()
	    }
	});
	module.exports = Submenu;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.header_filter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    gridCoreUtils = __webpack_require__(148),
	    headerFilterCore = __webpack_require__(279),
	    headerFilterMixin = headerFilterCore.headerFilterMixin,
	    messageLocalization = __webpack_require__(79),
	    allowHeaderFiltering = headerFilterCore.allowHeaderFiltering,
	    clickEvent = __webpack_require__(65),
	    dataUtils = __webpack_require__(122),
	    dataCoreUtils = __webpack_require__(35),
	    commonUtils = __webpack_require__(8),
	    normalizeDataSourceOptions = __webpack_require__(121).normalizeDataSourceOptions,
	    dateLocalization = __webpack_require__(55),
	    isWrapped = __webpack_require__(37).isWrapped;
	var DATE_INTERVAL_FORMATS = {
	    month: function(value) {
	        return dateLocalization.getMonthNames()[value - 1]
	    },
	    quarter: function(value) {
	        return dateLocalization.format(new Date(2e3, 3 * value - 1), "quarter")
	    }
	};
	exports.HeaderFilterController = gridCore.ViewController.inherit(function() {
	    var getFormatOptions = function(value, column, currentLevel) {
	        var groupInterval = gridCore.getGroupInterval(column),
	            result = gridCore.getFormatOptionsByColumn(column, "headerFilter");
	        if (groupInterval) {
	            result.groupInterval = groupInterval[currentLevel];
	            if ("date" === column.dataType) {
	                result.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]]
	            } else {
	                if ("number" === column.dataType) {
	                    result.getDisplayFormat = function() {
	                        var formatOptions = {
	                                format: column.format,
	                                precision: column.precision,
	                                target: "headerFilter"
	                            },
	                            firstValueText = gridCore.formatValue(value, formatOptions),
	                            secondValue = value + groupInterval[currentLevel],
	                            secondValueText = gridCore.formatValue(secondValue, formatOptions);
	                        return firstValueText && secondValueText ? firstValueText + " - " + secondValueText : ""
	                    }
	                }
	            }
	        }
	        return result
	    };
	    return {
	        init: function() {
	            this._columnsController = this.getController("columns");
	            this._dataController = this.getController("data");
	            this._headerFilterView = this.getView("headerFilterView")
	        },
	        _updateSelectedState: function(items, column) {
	            var i = items.length,
	                isExclude = "exclude" === column.filterType;
	            while (i--) {
	                var item = items[i];
	                if ("items" in items[i]) {
	                    this._updateSelectedState(items[i].items, column)
	                }
	                headerFilterCore.updateHeaderFilterItemSelectionState(item, gridCoreUtils.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude)
	            }
	        },
	        _normalizeGroupItem: function(item, currentLevel, options) {
	            var value, displayValue, path = options.path,
	                valueSelector = options.valueSelector,
	                displaySelector = options.displaySelector,
	                column = options.column;
	            if (valueSelector && displaySelector) {
	                value = valueSelector(item);
	                displayValue = displaySelector(item)
	            } else {
	                value = item.key;
	                displayValue = value
	            }
	            item = commonUtils.isObject(item) ? item : {};
	            path.push(value);
	            if (1 === path.length) {
	                item.value = path[0]
	            } else {
	                item.value = path.join("/")
	            }
	            item.text = gridCore.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
	            if (!item.text) {
	                item.text = options.headerFilterOptions.texts.emptyValue
	            }
	            delete item.key;
	            return item
	        },
	        _processGroupItems: function(groupItems, currentLevel, path, options) {
	            var displaySelector, valueSelector, that = this,
	                column = options.column,
	                lookup = column.lookup,
	                level = options.level;
	            path = path || [];
	            currentLevel = currentLevel || 0;
	            if (lookup) {
	                displaySelector = dataCoreUtils.compileGetter(lookup.displayExpr);
	                valueSelector = dataCoreUtils.compileGetter(lookup.valueExpr)
	            }
	            for (var i = 0; i < groupItems.length; i++) {
	                groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
	                    column: options.column,
	                    headerFilterOptions: options.headerFilterOptions,
	                    displaySelector: displaySelector,
	                    valueSelector: valueSelector,
	                    path: path
	                });
	                if ("items" in groupItems[i]) {
	                    if (currentLevel === level || !commonUtils.isDefined(groupItems[i].value)) {
	                        delete groupItems[i].items
	                    } else {
	                        that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options)
	                    }
	                }
	                path.pop()
	            }
	        },
	        getDataSource: function(column) {
	            var filter, cutoffLevel, origPostProcess, that = this,
	                dataSource = that._dataController.dataSource(),
	                group = gridCore.getHeaderFilterGroupParameters(column, dataSource && dataSource.remoteOperations().grouping),
	                headerFilterDataSource = column.headerFilter && column.headerFilter.dataSource,
	                headerFilterOptions = that.option("headerFilter"),
	                options = {
	                    component: that.component
	                };
	            if (!dataSource) {
	                return
	            }
	            if (commonUtils.isDefined(headerFilterDataSource) && !commonUtils.isFunction(headerFilterDataSource)) {
	                dataSource = normalizeDataSourceOptions(headerFilterDataSource);
	                dataSource.postProcess = function(items) {
	                    that._updateSelectedState(items, column);
	                    return items
	                };
	                return dataSource
	            }
	            if (column.lookup) {
	                dataSource = column.lookup.dataSource;
	                if (commonUtils.isFunction(dataSource) && !isWrapped(dataSource)) {
	                    dataSource = dataSource({})
	                }
	                dataSource = normalizeDataSourceOptions(dataSource);
	                dataSource.postProcess = function(items) {
	                    if (0 === this.pageIndex()) {
	                        items = items.slice(0);
	                        items.unshift(null)
	                    }
	                    that._processGroupItems(items, null, null, {
	                        level: 0,
	                        column: column,
	                        headerFilterOptions: headerFilterOptions
	                    });
	                    that._updateSelectedState(items, column);
	                    return items
	                };
	                options.dataSource = dataSource
	            } else {
	                cutoffLevel = commonUtils.isArray(group) ? group.length - 1 : 0;
	                that._currentColumn = column;
	                filter = that._dataController.getCombinedFilter();
	                that._currentColumn = null;
	                options.dataSource = {
	                    filter: filter,
	                    group: group,
	                    load: function(options) {
	                        var d = $.Deferred();
	                        options.dataField = column.dataField || column.name;
	                        dataSource.load(options).done(function(data) {
	                            that._processGroupItems(data, null, null, {
	                                level: cutoffLevel,
	                                column: column,
	                                headerFilterOptions: headerFilterOptions
	                            });
	                            that._updateSelectedState(data, column);
	                            d.resolve(data)
	                        }).fail(d.reject);
	                        return d
	                    }
	                }
	            }
	            if (commonUtils.isFunction(headerFilterDataSource)) {
	                headerFilterDataSource.call(column, options);
	                origPostProcess = options.dataSource.postProcess;
	                options.dataSource.postProcess = function(data) {
	                    var items = origPostProcess && origPostProcess.apply(this, arguments) || data;
	                    that._updateSelectedState(items, column);
	                    return items
	                }
	            }
	            return options.dataSource
	        },
	        getCurrentColumn: function() {
	            return this._currentColumn
	        },
	        showHeaderFilterMenu: function(columnIndex) {
	            var that = this,
	                column = $.extend(true, {}, that._columnsController.getColumns()[columnIndex]);
	            if (column) {
	                var visibleIndex = that._columnsController.getVisibleIndex(columnIndex),
	                    isGroupColumn = column && commonUtils.isDefined(column.groupIndex),
	                    view = isGroupColumn ? that.getView("headerPanel") : that.getView("columnHeadersView"),
	                    $columnElement = view.getColumnElements().eq(isGroupColumn ? column.groupIndex : visibleIndex),
	                    groupInterval = gridCore.getGroupInterval(column);
	                var options = $.extend(column, {
	                    type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
	                    apply: function() {
	                        that._columnsController.columnOption(columnIndex, {
	                            filterValues: this.filterValues,
	                            filterType: this.filterType
	                        })
	                    },
	                    onShowing: function(e) {
	                        var dxResizableInstance = e.component.overlayContent().dxResizable("instance");
	                        dxResizableInstance && dxResizableInstance.option("onResizeEnd", function(e) {
	                            var columnsController = that.getController("columns"),
	                                headerFilterByColumn = columnsController.columnOption(options.dataField, "headerFilter");
	                            headerFilterByColumn = headerFilterByColumn || {};
	                            headerFilterByColumn.width = e.width;
	                            headerFilterByColumn.height = e.height;
	                            columnsController.columnOption(options.dataField, "headerFilter", headerFilterByColumn, true)
	                        })
	                    }
	                });
	                options.dataSource = that.getDataSource(options);
	                that._headerFilterView.showHeaderFilterMenu($columnElement, options)
	            }
	        },
	        hideHeaderFilterMenu: function() {
	            this._headerFilterView.hideHeaderFilterMenu()
	        }
	    }
	}());
	var ColumnHeadersViewHeaderFilterExtender = $.extend({}, headerFilterCore.headerFilterMixin, {
	    _renderCellContent: function($cell, options) {
	        var $headerFilterIndicator, that = this,
	            column = options.column;
	        that.callBase($cell, options);
	        if (!column.command && !commonUtils.isDefined(column.groupIndex) && allowHeaderFiltering(column) && that.option("headerFilter.visible") && "header" === options.rowType) {
	            $headerFilterIndicator = that._applyColumnState({
	                name: "headerFilter",
	                rootElement: $cell,
	                column: column,
	                showColumnLines: that.option("showColumnLines")
	            });
	            $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter")
	        }
	    },
	    _subscribeToIndicatorEvent: function($indicator, column, indicatorName) {
	        var that = this;
	        if ("headerFilter" === indicatorName) {
	            $indicator.on(clickEvent.name, that.createAction(function(e) {
	                var event = e.jQueryEvent;
	                event.stopPropagation();
	                that.getController("headerFilter").showHeaderFilterMenu(column.index)
	            }))
	        }
	    },
	    _updateIndicator: function($cell, column, indicatorName) {
	        var $indicator = this.callBase($cell, column, indicatorName);
	        $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName)
	    },
	    _columnOptionChanged: function(e) {
	        var optionNames = e.optionNames;
	        if (gridCore.checkChanges(optionNames, ["filterValues", "filterType"])) {
	            if (this.option("headerFilter.visible")) {
	                this._updateIndicators("headerFilter")
	            }
	            return
	        }
	        this.callBase(e)
	    }
	});
	var HeaderPanelHeaderFilterExtender = $.extend({}, headerFilterMixin, {
	    _createGroupPanelItem: function($rootElement, groupColumn) {
	        var $headerFilterIndicator, that = this,
	            $item = that.callBase.apply(that, arguments);
	        if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
	            $headerFilterIndicator = that._applyColumnState({
	                name: "headerFilter",
	                rootElement: $item,
	                column: {
	                    alignment: commonUtils.getDefaultAlignment(that.option("rtlEnabled")),
	                    filterValues: groupColumn.filterValues,
	                    allowHeaderFiltering: true
	                },
	                showColumnLines: true
	            });
	            $headerFilterIndicator && $headerFilterIndicator.on(clickEvent.name, that.createAction(function(e) {
	                var event = e.jQueryEvent;
	                event.stopPropagation();
	                that.getController("headerFilter").showHeaderFilterMenu(groupColumn.index)
	            }))
	        }
	        return $item
	    }
	});
	var INVERTED_BINARY_OPERATIONS = {
	    "=": "<>",
	    "<>": "=",
	    ">": "<=",
	    ">=": "<",
	    "<": ">=",
	    "<=": ">",
	    contains: "notcontains",
	    notcontains: "contains",
	    startswith: "notcontains",
	    endswith: "notcontains"
	};

	function invertFilterExpression(filter) {
	    var i, currentGroupOperation, result;
	    if ($.isArray(filter[0])) {
	        result = [];
	        for (i = 0; i < filter.length; i++) {
	            if ($.isArray(filter[i])) {
	                if (currentGroupOperation) {
	                    result.push(currentGroupOperation)
	                }
	                result.push(invertFilterExpression(filter[i]));
	                currentGroupOperation = "or"
	            } else {
	                currentGroupOperation = dataUtils.isConjunctiveOperator(filter[i]) ? "or" : "and"
	            }
	        }
	        return result
	    }
	    result = dataUtils.normalizeBinaryCriterion(filter);
	    result[1] = INVERTED_BINARY_OPERATIONS[result[1]] || result[1];
	    return result
	}
	exports.invertFilterExpression = invertFilterExpression;
	var DataControllerFilterRowExtender = {
	    _calculateAdditionalFilter: function() {
	        var that = this,
	            filters = [that.callBase()],
	            columns = that._columnsController.getVisibleColumns(),
	            headerFilterController = that.getController("headerFilter"),
	            currentColumn = headerFilterController.getCurrentColumn();
	        $.each(columns, function(_, column) {
	            var filter;
	            if (currentColumn && currentColumn.index === column.index) {
	                return
	            }
	            if (allowHeaderFiltering(column) && column.calculateFilterExpression && commonUtils.isArray(column.filterValues) && column.filterValues.length) {
	                var filterValues = [],
	                    isExclude = "exclude" === column.filterType;
	                $.each(column.filterValues, function(_, filterValue) {
	                    if (commonUtils.isArray(filterValue)) {
	                        filter = isExclude ? invertFilterExpression(filterValue) : filterValue
	                    } else {
	                        if (column.deserializeValue && "date" !== column.dataType && "number" !== column.dataType) {
	                            filterValue = column.deserializeValue(filterValue)
	                        }
	                        filter = column.createFilterExpression(filterValue, isExclude ? "<>" : "=", "headerFilter")
	                    }
	                    if (filter) {
	                        filter.columnIndex = column.index
	                    }
	                    filterValues.push(filter)
	                });
	                filterValues = gridCore.combineFilters(filterValues, isExclude ? "and" : "or");
	                filters.push(filterValues)
	            }
	        });
	        return gridCore.combineFilters(filters)
	    }
	};
	gridCore.registerModule("headerFilter", {
	    defaultOptions: function() {
	        return {
	            headerFilter: {
	                visible: false,
	                width: 252,
	                height: 300,
	                texts: {
	                    emptyValue: messageLocalization.format("dxDataGrid-headerFilterEmptyValue"),
	                    ok: messageLocalization.format("dxDataGrid-headerFilterOK"),
	                    cancel: messageLocalization.format("dxDataGrid-headerFilterCancel")
	                }
	            }
	        }
	    },
	    controllers: {
	        headerFilter: exports.HeaderFilterController
	    },
	    views: {
	        headerFilterView: headerFilterCore.HeaderFilterView
	    },
	    extenders: {
	        controllers: {
	            data: DataControllerFilterRowExtender
	        },
	        views: {
	            columnHeadersView: ColumnHeadersViewHeaderFilterExtender,
	            headerPanel: HeaderPanelHeaderFilterExtender
	        }
	    }
	});


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/grid_core/ui.grid_core.header_filter.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    modules = __webpack_require__(145),
	    gridCoreUtils = __webpack_require__(148),
	    commonUtils = __webpack_require__(8),
	    Popup = __webpack_require__(113),
	    TreeView = __webpack_require__(215),
	    List = __webpack_require__(190);
	var DATAGRID_HEADER_FILTER_CLASS = "dx-header-filter",
	    DATAGRID_HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu";

	function resetChildrenItemSelection(items) {
	    items = items || [];
	    for (var i = 0; i < items.length; i++) {
	        items[i].selected = false;
	        resetChildrenItemSelection(items[i].items)
	    }
	}
	exports.updateHeaderFilterItemSelectionState = function(item, filterValuesMatch, isExcludeFilter) {
	    if (filterValuesMatch ^ isExcludeFilter) {
	        item.selected = true;
	        if (isExcludeFilter && item.items) {
	            for (var j = 0; j < item.items.length; j++) {
	                if (!item.items[j].selected) {
	                    item.selected = void 0;
	                    break
	                }
	            }
	        }
	    } else {
	        if (isExcludeFilter) {
	            item.selected = false;
	            resetChildrenItemSelection(item.items)
	        }
	    }
	};
	exports.HeaderFilterView = modules.View.inherit({
	    getPopupContainer: function() {
	        return this._popupContainer
	    },
	    getListContainer: function() {
	        return this._listContainer
	    },
	    applyHeaderFilter: function(options) {
	        var that = this,
	            list = that.getListContainer(),
	            isSelectAll = list.element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked"),
	            filterValues = [];
	        var fillSelectedItemKeys = function(filterValues, items, isExclude) {
	            $.each(items, function(_, item) {
	                if (void 0 !== item.selected && !!item.selected ^ isExclude) {
	                    filterValues.push(item.value)
	                } else {
	                    if (item.items && item.items.length) {
	                        fillSelectedItemKeys(filterValues, item.items, isExclude)
	                    }
	                }
	            })
	        };
	        if (!isSelectAll) {
	            if ("tree" === options.type) {
	                fillSelectedItemKeys(filterValues, list.option("items"), "exclude" === options.filterType);
	                options.filterValues = filterValues
	            }
	        } else {
	            if (commonUtils.isArray(options.filterValues)) {
	                options.filterValues = []
	            }
	        }
	        if (options.filterValues && !options.filterValues.length) {
	            options.filterValues = void 0
	        }
	        options.apply();
	        that.hideHeaderFilterMenu()
	    },
	    showHeaderFilterMenu: function($columnElement, options) {
	        var popupContainer, that = this;
	        if (options) {
	            that._initializePopupContainer(options);
	            popupContainer = that.getPopupContainer();
	            that.hideHeaderFilterMenu();
	            that.updatePopup($columnElement, options);
	            popupContainer.show()
	        }
	    },
	    hideHeaderFilterMenu: function() {
	        var headerFilterMenu = this.getPopupContainer();
	        headerFilterMenu && headerFilterMenu.hide()
	    },
	    updatePopup: function($element, options) {
	        var that = this,
	            alignment = "right" === options.alignment ? "left" : "right";
	        if (that._popupContainer) {
	            that._cleanPopupContent();
	            that._popupContainer.option("position", {
	                my: alignment + " top",
	                at: alignment + " bottom",
	                of: $element,
	                collision: "flip fit"
	            })
	        }
	    },
	    _cleanPopupContent: function() {
	        this._popupContainer && this._popupContainer.content().empty()
	    },
	    _initializePopupContainer: function(options) {
	        var that = this,
	            $element = that.element(),
	            headerFilterOptions = that.option("headerFilter"),
	            width = options.headerFilter && options.headerFilter.width || headerFilterOptions && headerFilterOptions.width,
	            height = options.headerFilter && options.headerFilter.height || headerFilterOptions && headerFilterOptions.height,
	            dxPopupOptions = {
	                width: width,
	                height: height,
	                visible: false,
	                shading: false,
	                showTitle: false,
	                showCloseButton: false,
	                closeOnTargetScroll: true,
	                dragEnabled: false,
	                closeOnOutsideClick: true,
	                toolbarItems: [{
	                    toolbar: "bottom",
	                    location: "after",
	                    widget: "dxButton",
	                    options: {
	                        text: headerFilterOptions.texts.ok,
	                        onClick: function() {
	                            that.applyHeaderFilter(options)
	                        }
	                    }
	                }, {
	                    toolbar: "bottom",
	                    location: "after",
	                    widget: "dxButton",
	                    options: {
	                        text: headerFilterOptions.texts.cancel,
	                        onClick: function() {
	                            that.hideHeaderFilterMenu()
	                        }
	                    }
	                }],
	                resizeEnabled: true,
	                onShowing: function(e) {
	                    that._initializeListContainer(options);
	                    options.onShowing && options.onShowing(e)
	                },
	                onInitialized: function(e) {
	                    var component = e.component;
	                    component.option("animation", component._getDefaultOptions().animation)
	                }
	            };
	        if (!commonUtils.isDefined(that._popupContainer)) {
	            that._popupContainer = that._createComponent($element, Popup, dxPopupOptions)
	        } else {
	            that._popupContainer.option(dxPopupOptions)
	        }
	    },
	    _initializeListContainer: function(options) {
	        var that = this,
	            $content = that._popupContainer.content(),
	            widgetOptions = {
	                dataSource: options.dataSource,
	                onContentReady: function() {
	                    that.renderCompleted.fire()
	                },
	                itemTemplate: function(data, _, $element) {
	                    if (options.encodeHtml) {
	                        return $element.text(data.text)
	                    }
	                    return $element.html(data.text)
	                }
	            };
	        if ("tree" === options.type) {
	            that._listContainer = that._createComponent($("<div>").appendTo($content), TreeView, $.extend(widgetOptions, {
	                showCheckBoxesMode: "selectAll",
	                keyExpr: "id"
	            }))
	        } else {
	            that._listContainer = that._createComponent($("<div>").appendTo($content), List, $.extend(widgetOptions, {
	                pageLoadMode: "scrollBottom",
	                showSelectionControls: true,
	                selectionMode: "all",
	                onSelectionChanged: function(e) {
	                    var items = e.component.option("items"),
	                        selectedItems = e.component.option("selectedItems");
	                    if (!e.component._selectedItemsUpdating) {
	                        if (0 === selectedItems.length && items.length) {
	                            options.filterType = "include";
	                            options.filterValues = []
	                        } else {
	                            if (selectedItems.length === items.length) {
	                                options.filterType = "exclude";
	                                options.filterValues = []
	                            }
	                        }
	                    }
	                    $.each(items, function(index, item) {
	                        var filterValueIndex, selected = gridCoreUtils.getIndexByKey(item, selectedItems, null) >= 0,
	                            oldSelected = !!item.selected;
	                        if (oldSelected !== selected) {
	                            item.selected = selected;
	                            options.filterValues = options.filterValues || [];
	                            filterValueIndex = gridCoreUtils.getIndexByKey(item.value, options.filterValues, null);
	                            if (filterValueIndex >= 0) {
	                                options.filterValues.splice(filterValueIndex, 1)
	                            }
	                            if (selected ^ "exclude" === options.filterType) {
	                                options.filterValues.push(item.value)
	                            }
	                        }
	                    })
	                },
	                onContentReady: function(e) {
	                    var component = e.component,
	                        items = component.option("items"),
	                        selectedItems = [],
	                        selectAllCheckBox = e.element.find(".dx-list-select-all-checkbox").dxCheckBox("instance");
	                    $.each(items, function() {
	                        if (this.selected) {
	                            selectedItems.push(this)
	                        }
	                    });
	                    component._selectedItemsUpdating = true;
	                    component.option("selectedItems", selectedItems);
	                    component._selectedItemsUpdating = false;
	                    if (options.filterValues && options.filterValues.length) {
	                        selectAllCheckBox.option("value", void 0)
	                    }
	                }
	            }))
	        }
	    },
	    _renderCore: function() {
	        this.element().addClass(DATAGRID_HEADER_FILTER_MENU_CLASS)
	    }
	});
	var allowHeaderFiltering = exports.allowHeaderFiltering = function(column) {
	    return commonUtils.isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering
	};
	exports.headerFilterMixin = {
	    _applyColumnState: function(options) {
	        var $headerFilterIndicator, rootElement = options.rootElement,
	            column = options.column;
	        if ("headerFilter" === options.name) {
	            rootElement.find("." + DATAGRID_HEADER_FILTER_CLASS).remove();
	            if (allowHeaderFiltering(column)) {
	                $headerFilterIndicator = this.callBase(options).toggleClass("dx-header-filter-empty", !column.filterValues || !column.filterValues.length)
	            }
	            return $headerFilterIndicator
	        }
	        return this.callBase(options)
	    },
	    _getIndicatorClassName: function(name) {
	        if ("headerFilter" === name) {
	            return DATAGRID_HEADER_FILTER_CLASS
	        }
	        return this.callBase(name)
	    },
	    _renderIndicator: function(options) {
	        var rtlEnabled, $container = options.container,
	            $indicator = options.indicator;
	        if ("headerFilter" === options.name) {
	            rtlEnabled = this.option("rtlEnabled");
	            if ($container.children().length && (!rtlEnabled && "right" === options.columnAlignment || rtlEnabled && "left" === options.columnAlignment)) {
	                $container.prepend($indicator);
	                return
	            }
	        }
	        this.callBase(options)
	    },
	    optionChanged: function(args) {
	        if ("headerFilter" === args.name) {
	            this._invalidate();
	            args.handled = true
	        } else {
	            this.callBase(args)
	        }
	    }
	};


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.search.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    compileGetter = __webpack_require__(35).compileGetter,
	    gridCore = __webpack_require__(144),
	    selectors = __webpack_require__(91),
	    messageLocalization = __webpack_require__(79),
	    dataQuery = __webpack_require__(125);
	__webpack_require__(264);
	var DATAGRID_SEARCH_PANEL_CLASS = "dx-datagrid-search-panel",
	    DATAGRID_SEARCH_TEXT_CLASS = "dx-datagrid-search-text",
	    FILTERING_TIMEOUT = 700;

	function allowSearch(column) {
	    return commonUtils.isDefined(column.allowSearch) ? column.allowSearch : column.allowFiltering
	}

	function parseValue(column, text) {
	    var lookup = column.lookup;
	    if (lookup) {
	        return column.parseValue.call(lookup, text)
	    } else {
	        return column.parseValue ? column.parseValue(text) : text
	    }
	}
	gridCore.registerModule("search", {
	    defaultOptions: function() {
	        return {
	            searchPanel: {
	                visible: false,
	                width: 160,
	                placeholder: messageLocalization.format("dxDataGrid-searchPanelPlaceholder"),
	                highlightSearchText: true,
	                text: "",
	                searchVisibleColumnsOnly: false
	            }
	        }
	    },
	    extenders: {
	        controllers: {
	            data: function() {
	                var calculateSearchFilter = function(that, text) {
	                    var i, column, filterValue, lookup, columns = that._columnsController.getColumns(),
	                        searchVisibleColumnsOnly = that.option("searchPanel.searchVisibleColumnsOnly"),
	                        filters = [];
	                    if (!text) {
	                        return null
	                    }

	                    function onQueryDone(items) {
	                        var i, value, valueGetter = compileGetter(lookup.valueExpr);
	                        for (i = 0; i < items.length; i++) {
	                            value = valueGetter(items[i]);
	                            filters.push(column.createFilterExpression(value, null, "search"))
	                        }
	                    }
	                    for (i = 0; i < columns.length; i++) {
	                        column = columns[i];
	                        if (searchVisibleColumnsOnly && !column.visible) {
	                            continue
	                        }
	                        if (allowSearch(column) && column.calculateFilterExpression) {
	                            lookup = column.lookup;
	                            filterValue = parseValue(column, text);
	                            if (lookup && lookup.items) {
	                                dataQuery(lookup.items).filter(column.createFilterExpression.call({
	                                    dataField: lookup.displayExpr,
	                                    dataType: lookup.dataType,
	                                    calculateFilterExpression: column.calculateFilterExpression
	                                }, filterValue, null, "search")).enumerate().done(onQueryDone)
	                            } else {
	                                if (void 0 !== filterValue) {
	                                    filters.push(column.createFilterExpression(filterValue, null, "search"))
	                                }
	                            }
	                        }
	                    }
	                    return gridCore.combineFilters(filters, "or")
	                };
	                return {
	                    publicMethods: function() {
	                        return this.callBase().concat(["searchByText"])
	                    },
	                    _calculateAdditionalFilter: function() {
	                        var that = this,
	                            filter = that.callBase(),
	                            searchFilter = calculateSearchFilter(that, that.option("searchPanel.text"));
	                        return gridCore.combineFilters([filter, searchFilter])
	                    },
	                    searchByText: function(text) {
	                        this.option("searchPanel.text", text)
	                    },
	                    optionChanged: function(args) {
	                        var that = this;
	                        switch (args.fullName) {
	                            case "searchPanel.text":
	                            case "searchPanel":
	                                that._applyFilter();
	                                args.handled = true;
	                                break;
	                            default:
	                                that.callBase(args)
	                        }
	                    }
	                }
	            }()
	        },
	        views: {
	            headerPanel: function() {
	                var getSearchPanelOptions = function(that) {
	                    return that.option("searchPanel")
	                };
	                return {
	                    _getToolbarItems: function() {
	                        var items = this.callBase();
	                        return this._prepareSearchItem(items)
	                    },
	                    _prepareSearchItem: function(items) {
	                        var that = this,
	                            dataController = that.getController("data"),
	                            searchPanelOptions = getSearchPanelOptions(that);
	                        if (searchPanelOptions && searchPanelOptions.visible) {
	                            var toolbarItem = {
	                                template: function(data, index, $container) {
	                                    var $search = $("<div>").addClass(DATAGRID_SEARCH_PANEL_CLASS).appendTo($container);
	                                    that.setAria("label", messageLocalization.format("dxDataGrid-ariaSearchInGrid"), $search);
	                                    that.getController("editorFactory").createEditor($search, {
	                                        width: searchPanelOptions.width,
	                                        placeholder: searchPanelOptions.placeholder,
	                                        parentType: "searchPanel",
	                                        value: that.option("searchPanel.text"),
	                                        updateValueTimeout: FILTERING_TIMEOUT,
	                                        setValue: function(value) {
	                                            dataController.searchByText(value)
	                                        }
	                                    });
	                                    that.resize()
	                                },
	                                name: "searchPanel",
	                                location: "after",
	                                locateInMenu: "never"
	                            };
	                            items.push(toolbarItem)
	                        }
	                        return items
	                    },
	                    _getSearchTextEditor: function() {
	                        var $searchPanel = this.element().find("." + DATAGRID_SEARCH_PANEL_CLASS);
	                        if ($searchPanel.length) {
	                            return $searchPanel.dxTextBox("instance")
	                        }
	                        return null
	                    },
	                    isVisible: function() {
	                        var searchPanelOptions = getSearchPanelOptions(this);
	                        return this.callBase() || searchPanelOptions && searchPanelOptions.visible
	                    },
	                    optionChanged: function(args) {
	                        if ("searchPanel" === args.name) {
	                            if ("searchPanel.text" === args.fullName) {
	                                var editor = this._getSearchTextEditor();
	                                if (editor) {
	                                    editor.option("value", args.value)
	                                }
	                            } else {
	                                this.updateToolbar()
	                            }
	                            args.handled = true
	                        } else {
	                            this.callBase(args)
	                        }
	                    }
	                }
	            }(),
	            rowsView: {
	                _highlightSearchText: function(cellElement, isEquals, column) {
	                    var $parent, that = this,
	                        searchText = that.option("searchPanel.text");
	                    if (searchText && that.option("searchPanel.highlightSearchText")) {
	                        var store = that._dataController.store(),
	                            isODataStore = store && store._url && store._version,
	                            normalizeString = isODataStore ? function(str) {
	                                return str
	                            } : function(str) {
	                                return str.toLowerCase()
	                            };
	                        if (isEquals && column) {
	                            var value = parseValue(column, searchText),
	                                formatOptions = gridCore.getFormatOptionsByColumn(column, "search");
	                            searchText = gridCore.formatValue(value, formatOptions);
	                            if (!searchText) {
	                                return
	                            }
	                        }
	                        $parent = cellElement.parent();
	                        if (!$parent.length) {
	                            $parent = $("<div>").append(cellElement)
	                        }
	                        $.each($parent.find(selectors.icontains + "('" + searchText + "')"), function(index, element) {
	                            $.each($(element).contents(), function(index, content) {
	                                if (3 !== content.nodeType) {
	                                    return
	                                }
	                                var highlightSearchTextInTextNode = function($content, searchText) {
	                                    var $searchTextSpan = $("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS),
	                                        text = $content.text(),
	                                        index = normalizeString(text).indexOf(normalizeString(searchText));
	                                    if (index >= 0) {
	                                        if ($content[0].textContent) {
	                                            $content[0].textContent = text.substr(0, index)
	                                        } else {
	                                            $content[0].nodeValue = text.substr(0, index)
	                                        }
	                                        $content.after($searchTextSpan.text(text.substr(index, searchText.length)));
	                                        $content = $(document.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
	                                        return highlightSearchTextInTextNode($content, searchText)
	                                    }
	                                };
	                                if (isEquals) {
	                                    if (normalizeString($(content).text()) === normalizeString(searchText)) {
	                                        $(this).replaceWith($("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS).text($(content).text()))
	                                    }
	                                } else {
	                                    highlightSearchTextInTextNode($(content), searchText)
	                                }
	                            })
	                        })
	                    }
	                },
	                _renderCore: function() {
	                    this.callBase.apply(this, arguments);
	                    if (this.option("rowTemplate")) {
	                        this._highlightSearchText(this._getTableElement())
	                    }
	                },
	                _updateCell: function($cell, parameters) {
	                    var that = this,
	                        column = parameters.column,
	                        dataType = column.lookup && column.lookup.dataType || column.dataType,
	                        isEquals = "string" !== dataType;
	                    if (allowSearch(column)) {
	                        that._highlightSearchText($cell, isEquals, column)
	                    }
	                    that.callBase($cell, parameters)
	                }
	            }
	        }
	    }
	});


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.pager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    Pager = __webpack_require__(282),
	    commonUtils = __webpack_require__(8);
	var DATAGRID_PAGER_CLASS = "dx-datagrid-pager",
	    MAX_PAGES_COUNT = 10;
	exports.PagerView = gridCore.View.inherit({
	    init: function() {
	        var that = this,
	            dataController = that.getController("data");
	        that._isVisible = false;
	        dataController.changed.add(function(e) {
	            if (!e || "update" !== e.changeType) {
	                that.render()
	            }
	        })
	    },
	    _getPager: function() {
	        var $element = this.element();
	        return $element && $element.data("dxPager")
	    },
	    _renderCore: function() {
	        var that = this,
	            $element = that.element().addClass(DATAGRID_PAGER_CLASS),
	            pagerOptions = that.option("pager") || {},
	            dataController = that.getController("data"),
	            options = {
	                maxPagesCount: MAX_PAGES_COUNT,
	                pageIndex: 1 + (parseInt(dataController.pageIndex()) || 0),
	                pageCount: dataController.pageCount(),
	                pageSize: dataController.pageSize(),
	                showPageSizes: pagerOptions.showPageSizeSelector,
	                showInfo: pagerOptions.showInfo,
	                pagesNavigatorVisible: pagerOptions.visible,
	                showNavigationButtons: pagerOptions.showNavigationButtons,
	                pageSizes: that.getPageSizes(),
	                totalCount: dataController.totalCount(),
	                hasKnownLastPage: dataController.hasKnownLastPage(),
	                pageIndexChanged: function(pageIndex) {
	                    if (dataController.pageIndex() !== pageIndex - 1) {
	                        setTimeout(function() {
	                            dataController.pageIndex(pageIndex - 1)
	                        })
	                    }
	                },
	                pageSizeChanged: function(pageSize) {
	                    setTimeout(function() {
	                        dataController.pageSize(pageSize)
	                    })
	                }
	            };
	        if (commonUtils.isDefined(pagerOptions.infoText)) {
	            options.infoText = pagerOptions.infoText
	        }
	        that._createComponent($element, Pager, options)
	    },
	    getPageSizes: function() {
	        var that = this,
	            dataController = that.getController("data"),
	            pagerOptions = that.option("pager"),
	            allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes,
	            pageSize = dataController.pageSize();
	        if (!commonUtils.isDefined(that._pageSizes) || $.inArray(pageSize, that._pageSizes) === -1) {
	            that._pageSizes = [];
	            if (pagerOptions) {
	                if ($.isArray(allowedPageSizes)) {
	                    that._pageSizes = allowedPageSizes
	                } else {
	                    if (allowedPageSizes && pageSize > 1) {
	                        that._pageSizes = [Math.floor(pageSize / 2), pageSize, 2 * pageSize]
	                    }
	                }
	            }
	        }
	        return that._pageSizes
	    },
	    isVisible: function() {
	        var that = this,
	            dataController = that.getController("data"),
	            pagerOptions = that.option("pager"),
	            pagerVisible = pagerOptions && pagerOptions.visible,
	            scrolling = that.option("scrolling");
	        if (that._isVisible) {
	            return true
	        }
	        if ("auto" === pagerVisible) {
	            if (scrolling && ("virtual" === scrolling.mode || "infinite" === scrolling.mode)) {
	                pagerVisible = false
	            } else {
	                pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage()
	            }
	        }
	        that._isVisible = pagerVisible;
	        return pagerVisible
	    },
	    getHeight: function() {
	        var $element = this.element();
	        return $element ? $element.outerHeight(true) : 0
	    },
	    optionChanged: function(args) {
	        var that = this,
	            name = args.name,
	            isPager = "pager" === name,
	            isPaging = "paging" === name,
	            isDataSource = "dataSource" === name,
	            isScrolling = "scrolling" === name;
	        if (isPager || isPaging || isScrolling || isDataSource) {
	            if (isPager || isPaging) {
	                that._pageSizes = null
	            }
	            if (isPager || isPaging || isScrolling) {
	                that._isVisible = false
	            }
	            if (!isDataSource) {
	                that._invalidate();
	                if (isPager && that.component) {
	                    that.component.resize()
	                }
	            }
	            args.handled = true
	        }
	    }
	});
	gridCore.registerModule("pager", {
	    defaultOptions: function() {
	        return {
	            pager: {
	                visible: "auto",
	                showPageSizeSelector: false,
	                allowedPageSizes: "auto"
	            }
	        }
	    },
	    views: {
	        pagerView: exports.PagerView
	    }
	});


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/pager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    stringUtils = __webpack_require__(7),
	    registerComponent = __webpack_require__(44),
	    commonUtils = __webpack_require__(8),
	    clickEvent = __webpack_require__(65),
	    messageLocalization = __webpack_require__(79),
	    Widget = __webpack_require__(84),
	    SelectBox = __webpack_require__(265),
	    NumberBox = __webpack_require__(237),
	    eventUtils = __webpack_require__(61);
	var PAGES_LIMITER = 4,
	    PAGER_CLASS = "dx-pager",
	    PAGER_PAGE_CLASS = "dx-page",
	    PAGER_PAGES_CLASS = "dx-pages",
	    LIGHT_MODE_CLASS = "dx-light-mode",
	    LIGHT_PAGES_CLASS = "dx-light-pages",
	    PAGER_PAGE_INDEX_CLASS = "dx-page-index",
	    PAGER_PAGES_COUNT_CLASS = "dx-pages-count",
	    PAGER_SELECTION_CLASS = "dx-selection",
	    PAGER_PAGE_SEPARATOR_CLASS = "dx-separator",
	    PAGER_PAGE_SIZES_CLASS = "dx-page-sizes",
	    PAGER_PAGE_SIZE_CLASS = "dx-page-size",
	    PAGER_NAVIGATE_BUTTON = "dx-navigate-button",
	    PAGER_PREV_BUTTON_CLASS = "dx-prev-button",
	    PAGER_NEXT_BUTTON_CLASS = "dx-next-button",
	    PAGER_INFO_CLASS = "dx-info",
	    PAGER_INFO_TEXT_CLASS = "dx-info-text",
	    PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
	var Page = Class.inherit({
	    ctor: function(value, index) {
	        var that = this;
	        that.index = index;
	        that._$page = $("<div />").text(value).addClass(PAGER_PAGE_CLASS)
	    },
	    value: function(value) {
	        var that = this;
	        if (commonUtils.isDefined(value)) {
	            that._$page.text(value)
	        } else {
	            var text = that._$page.text();
	            if (commonUtils.isNumber(text)) {
	                return parseInt(text)
	            } else {
	                return text
	            }
	        }
	    },
	    element: function() {
	        return this._$page
	    },
	    select: function(value) {
	        this._$page.toggleClass(PAGER_SELECTION_CLASS, value)
	    },
	    render: function(rootElement, rtlEnabled) {
	        rtlEnabled ? this._$page.prependTo(rootElement) : this._$page.appendTo(rootElement)
	    }
	});
	var Pager = Widget.inherit({
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            visible: true,
	            pagesNavigatorVisible: "auto",
	            pageIndex: 1,
	            maxPagesCount: 10,
	            pageCount: 10,
	            totalCount: 0,
	            pageSize: 5,
	            showPageSizes: true,
	            pageSizes: [5, 10],
	            hasKnownLastPage: true,
	            showNavigationButtons: false,
	            showInfo: false,
	            infoText: messageLocalization.getFormatter("dxPager-infoText"),
	            pagesCountText: messageLocalization.getFormatter("dxPager-pagesCountText"),
	            rtlEnabled: false,
	            lightModeEnabled: false,
	            pageIndexChanged: $.noop,
	            pageSizeChanged: $.noop
	        })
	    },
	    _toggleVisibility: function(value) {
	        var $element = this.element();
	        if ($element) {
	            $element.css("display", value ? "" : "none")
	        }
	    },
	    _getPages: function(currentPage, count) {
	        var firstValue, i, pages = [],
	            showMoreButton = !this.option("hasKnownLastPage");
	        if (count > 0 || showMoreButton) {
	            if (count <= this.option("maxPagesCount")) {
	                for (i = 1; i <= count; i++) {
	                    pages.push(new Page(i, i - 1))
	                }
	                if (showMoreButton) {
	                    pages.push(new Page(">", i - 1))
	                }
	            } else {
	                pages.push(new Page(1, 0));
	                firstValue = currentPage ? currentPage.value() - currentPage.index : 1;
	                for (i = 1; i <= PAGES_LIMITER; i++) {
	                    pages.push(new Page(firstValue + i, i))
	                }
	                pages.push(new Page(count, PAGES_LIMITER + 1));
	                if (showMoreButton) {
	                    pages.push(new Page(">", PAGES_LIMITER + 1))
	                }
	            }
	        }
	        return pages
	    },
	    _getPageByValue: function(value) {
	        var page, i, that = this;
	        for (i = 0; i < that._pages.length; i++) {
	            page = that._pages[i];
	            if (page.value() === value) {
	                return page
	            }
	        }
	    },
	    _processSelectedPage: function(maxPagesCount, pageIndex, pageCount) {
	        var selectedPageIndex, that = this,
	            isPageIndexValid = false;
	        if (that._pages) {
	            $.each(that._pages, function(key, page) {
	                if (pageIndex === page.value()) {
	                    isPageIndexValid = true
	                }
	            });
	            if (!isPageIndexValid) {
	                that.selectedPage = null
	            }
	        }
	        if (commonUtils.isDefined(that.selectedPage)) {
	            if (pageIndex === pageCount && pageCount > maxPagesCount && that.selectedPage.index !== PAGES_LIMITER + 1) {
	                that.selectedPage.index = PAGES_LIMITER + 1
	            }
	        } else {
	            if (pageIndex > PAGES_LIMITER && pageIndex < pageCount) {
	                selectedPageIndex = pageCount - PAGES_LIMITER < pageIndex ? PAGES_LIMITER - (pageCount - pageIndex) + 1 : 2;
	                that.selectedPage = new Page(pageIndex, selectedPageIndex)
	            }
	        }
	    },
	    _selectPageByValue: function(value) {
	        var i, prevPage, nextPage, morePage, that = this,
	            page = that._getPageByValue(value),
	            pages = that._pages,
	            pagesLength = pages.length;
	        if (!commonUtils.isDefined(page)) {
	            return
	        }
	        prevPage = that._pages[page.index - 1];
	        nextPage = that._pages[page.index + 1];
	        if (nextPage && ">" === nextPage.value()) {
	            morePage = nextPage;
	            nextPage = void 0;
	            pagesLength--;
	            pages.pop()
	        }
	        if (that.selectedPage) {
	            that.selectedPage.select(false)
	        }
	        page.select(true);
	        that.selectedPage = page;
	        if (nextPage && nextPage.value() - value > 1) {
	            if (0 !== page.index) {
	                prevPage.value(value + 1);
	                that._pages.splice(page.index, 1);
	                that._pages.splice(page.index - 1, 0, page);
	                that._pages[page.index].index = page.index;
	                page.index = page.index - 1;
	                for (i = page.index - 1; i > 0; i--) {
	                    that._pages[i].value(that._pages[i + 1].value() - 1)
	                }
	            } else {
	                for (i = 0; i < pagesLength - 1; i++) {
	                    that._pages[i].value(i + 1)
	                }
	            }
	        }
	        if (prevPage && value - prevPage.value() > 1) {
	            if (page.index !== pagesLength - 1) {
	                nextPage.value(value - 1);
	                that._pages.splice(page.index, 1);
	                that._pages.splice(page.index + 1, 0, page);
	                that._pages[page.index].index = page.index;
	                page.index = page.index + 1;
	                for (i = page.index + 1; i < pagesLength - 1; i++) {
	                    that._pages[i].value(that._pages[i - 1].value() + 1)
	                }
	            } else {
	                for (i = 1; i <= pagesLength - 2; i++) {
	                    that._pages[pagesLength - 1 - i].value(that._pages[pagesLength - 1].value() - i)
	                }
	            }
	        }
	        if (morePage) {
	            pages.push(morePage)
	        }
	    },
	    _nextPage: function(direction) {
	        var pageIndex = this.option("pageIndex"),
	            pageCount = this.option("pageCount");
	        if (commonUtils.isDefined(pageIndex)) {
	            pageIndex = "next" === direction ? ++pageIndex : --pageIndex;
	            if (pageIndex > 0 && pageIndex <= pageCount) {
	                this.option("pageIndex", pageIndex)
	            }
	        }
	    },
	    _renderPages: function(pages) {
	        var $separator, page, that = this,
	            pagesLength = pages.length,
	            clickPagesIndexAction = that._createAction(function(args) {
	                var e = args.jQueryEvent,
	                    pageNumber = $(e.target).text(),
	                    pageIndex = ">" === pageNumber ? that.option("pageCount") + 1 : Number(pageNumber);
	                that.option("pageIndex", pageIndex)
	            });
	        if (pagesLength > 1) {
	            that._pageClickHandler = function(e) {
	                clickPagesIndexAction({
	                    jQueryEvent: e
	                })
	            };
	            that._$pagesChooser.on(eventUtils.addNamespace(clickEvent.name, that.Name + "Pages"), "." + PAGER_PAGE_CLASS, that._pageClickHandler)
	        }
	        for (var i = 0; i < pagesLength; i++) {
	            page = pages[i];
	            page.render(that._$pagesChooser, that.option("rtlEnabled"));
	            that.setAria({
	                role: "button",
	                label: "Page " + page.value()
	            }, page.element());
	            if (pages[i + 1] && pages[i + 1].value() - page.value() > 1) {
	                $separator = $("<div>. . .</div>").addClass(PAGER_PAGE_SEPARATOR_CLASS);
	                that.option("rtlEnabled") ? $separator.prependTo(that._$pagesChooser) : $separator.appendTo(that._$pagesChooser)
	            }
	        }
	    },
	    _calculateLightPagesWidth: function($pageIndex, pageCount) {
	        return Number($pageIndex.css("min-width").replace("px", "")) + 10 * pageCount.toString().length
	    },
	    _renderLightPages: function() {
	        var $pageCount, $pageIndex, that = this,
	            pageCount = this.option("pageCount"),
	            pageIndex = this.option("pageIndex"),
	            clickAction = that._createAction(function() {
	                that.option("pageIndex", pageCount)
	            }),
	            pagesCountText = this.option("pagesCountText");
	        var $container = $("<div/>").addClass(LIGHT_PAGES_CLASS).appendTo(this._$pagesChooser);
	        $pageIndex = $("<div/>").addClass(PAGER_PAGE_INDEX_CLASS).appendTo($container);
	        that._pageIndexEditor = that._createComponent($pageIndex, NumberBox, {
	            value: pageIndex,
	            min: 1,
	            max: pageCount,
	            width: that._calculateLightPagesWidth($pageIndex, pageCount),
	            onValueChanged: function(e) {
	                that.option("pageIndex", e.value)
	            }
	        });
	        $("<span/>").text(pagesCountText).addClass(PAGER_INFO_TEXT_CLASS + " " + PAGER_INFO_CLASS).appendTo($container);
	        $pageCount = $("<span/>").addClass(PAGER_PAGES_COUNT_CLASS).text(pageCount).on(eventUtils.addNamespace(clickEvent.name, that.Name + "PagesCount"), function(e) {
	            clickAction({
	                jQueryEvent: e
	            })
	        }).appendTo($container);
	        that.setAria({
	            role: "button",
	            label: "Navigates to the last page"
	        }, $pageCount)
	    },
	    _renderPagesChooser: function() {
	        var that = this,
	            lightModeEnabled = that.option("lightModeEnabled"),
	            pagesNavigatorVisible = that.option("pagesNavigatorVisible"),
	            $element = that.element();
	        that._$pagesChooser && that._$pagesChooser.remove();
	        if (!pagesNavigatorVisible) {
	            return
	        }
	        if (that._pages && 0 === that._pages.length) {
	            that.selectedPage = null;
	            return
	        }
	        that._$pagesChooser = $("<div />").addClass(PAGER_PAGES_CLASS).appendTo($element);
	        if ("auto" === pagesNavigatorVisible) {
	            that._$pagesChooser.css("visibility", 1 === that.option("pageCount") ? "hidden" : "")
	        }
	        if (!lightModeEnabled) {
	            that._renderInfo()
	        }
	        that._renderNavigateButton("prev");
	        if (lightModeEnabled) {
	            that._renderLightPages()
	        } else {
	            that._renderPages(that._pages)
	        }
	        that._renderNavigateButton("next");
	        that._updatePagesChooserWidth()
	    },
	    _renderPageSizes: function() {
	        var i, pageSizeValue, $pageSize, that = this,
	            pageSizes = that.option("pageSizes"),
	            pagesSizesLength = pageSizes && pageSizes.length,
	            currentPageSize = that.option("pageSize"),
	            clickPagesSizeAction = that._createAction(function(args) {
	                var e = args.jQueryEvent;
	                pageSizeValue = parseInt($(e.target).text());
	                that.option("pageSize", pageSizeValue)
	            });
	        that._$pagesSizeChooser.on(eventUtils.addNamespace(clickEvent.name, that.Name + "PageSize"), "." + PAGER_PAGE_SIZE_CLASS, function(e) {
	            clickPagesSizeAction({
	                jQueryEvent: e
	            })
	        });
	        for (i = 0; i < pagesSizesLength; i++) {
	            $pageSize = $("<div />").text(pageSizes[i]).addClass(PAGER_PAGE_SIZE_CLASS);
	            that.setAria({
	                role: "button",
	                label: "Display " + pageSizes[i] + " items on page"
	            }, $pageSize);
	            if (currentPageSize === pageSizes[i]) {
	                $pageSize.addClass(PAGER_SELECTION_CLASS)
	            }
	            that._$pagesSizeChooser.append($pageSize)
	        }
	    },
	    _calculateLightPageSizesWidth: function(pageSizes) {
	        return Number(this._$pagesSizeChooser.css("min-width").replace("px", "")) + 10 * Math.max.apply(Math, pageSizes).toString().length
	    },
	    _renderLightPageSizes: function() {
	        var $editor, that = this,
	            pageSizes = that.option("pageSizes");
	        $editor = $("<div/>").appendTo(that._$pagesSizeChooser);
	        that._pageSizeEditor = that._createComponent($editor, SelectBox, {
	            dataSource: pageSizes,
	            value: that.option("pageSize"),
	            onSelectionChanged: function(e) {
	                that.option("pageSize", e.selectedItem)
	            },
	            width: that._calculateLightPageSizesWidth(pageSizes)
	        })
	    },
	    _renderPagesSizeChooser: function() {
	        var that = this,
	            pageSizes = that.option("pageSizes"),
	            showPageSizes = that.option("showPageSizes"),
	            pagesSizesLength = pageSizes && pageSizes.length,
	            $element = that.element();
	        if (!showPageSizes || !pagesSizesLength) {
	            return
	        }
	        that._$pagesSizeChooser && that._$pagesSizeChooser.remove();
	        that._$pagesSizeChooser = $("<div />").addClass(PAGER_PAGE_SIZES_CLASS).appendTo($element);
	        if (that.option("lightModeEnabled")) {
	            that._renderLightPageSizes()
	        } else {
	            that._renderPageSizes()
	        }
	        that._pagesSizeChooserWidth = that._$pagesSizeChooser.width()
	    },
	    _renderInfo: function() {
	        var infoText = this.option("infoText");
	        if (this.option("showInfo") && commonUtils.isDefined(infoText)) {
	            this._$info = $("<div>").css("display", this._isInfoHide ? "none" : "").addClass(PAGER_INFO_CLASS).text(stringUtils.format(infoText, this.selectedPage && this.selectedPage.value(), this.option("pageCount"), this.option("totalCount"))).appendTo(this._$pagesChooser);
	            if (!this._isInfoHide) {
	                this._infoWidth = this._$info.outerWidth(true)
	            }
	        }
	    },
	    _renderNavigateButton: function(direction) {
	        var $button, that = this,
	            clickAction = that._createAction(function() {
	                that._nextPage(direction)
	            });
	        if (that.option("showNavigationButtons") || that.option("lightModeEnabled")) {
	            $button = $("<div>").addClass(PAGER_NAVIGATE_BUTTON).on(eventUtils.addNamespace(clickEvent.name, that.Name + "Pages"), function(e) {
	                clickAction({
	                    jQueryEvent: e
	                })
	            });
	            that.setAria({
	                role: "button",
	                label: "prev" === direction ? "Previous page" : " Next page"
	            }, $button);
	            if (that.option("rtlEnabled")) {
	                $button.addClass("prev" === direction ? PAGER_NEXT_BUTTON_CLASS : PAGER_PREV_BUTTON_CLASS);
	                $button.prependTo(this._$pagesChooser)
	            } else {
	                $button.addClass("prev" === direction ? PAGER_PREV_BUTTON_CLASS : PAGER_NEXT_BUTTON_CLASS);
	                $button.appendTo(this._$pagesChooser)
	            }
	        }
	    },
	    _render: function() {
	        this.callBase();
	        this.element().addClass(PAGER_CLASS).toggleClass(LIGHT_MODE_CLASS, this.option("lightModeEnabled"));
	        this._toggleVisibility(this.option("visible"));
	        this._updatePageSizes(true);
	        this._updatePages(true);
	        this._updateLightMode()
	    },
	    _updatePageSizes: function(forceRender) {
	        var lightModeEnabled = this.option("lightModeEnabled"),
	            pageSize = this.option("pageSize"),
	            pageSizes = this.option("pageSizes");
	        if (lightModeEnabled) {
	            this._pageSizeEditor && this._pageSizeEditor.option({
	                value: pageSize,
	                dataSource: pageSizes,
	                width: this._calculateLightPageSizesWidth(pageSizes)
	            })
	        }
	        if (!lightModeEnabled || forceRender) {
	            this._renderPagesSizeChooser()
	        }
	    },
	    _updatePages: function(forceRender) {
	        var pageCount = this.option("pageCount"),
	            pageIndex = this.option("pageIndex"),
	            lightModeEnabled = this.option("lightModeEnabled");
	        if (!lightModeEnabled) {
	            this._processSelectedPage(this.option("maxPagesCount"), pageIndex, pageCount);
	            this._pages = this._getPages(this.selectedPage, pageCount);
	            this._selectPageByValue(pageIndex)
	        } else {
	            this._pageIndexEditor && this._pageIndexEditor.option({
	                value: pageIndex,
	                width: this._calculateLightPagesWidth(this._pageIndexEditor.element(), pageCount)
	            })
	        }
	        if (!lightModeEnabled || forceRender) {
	            this._renderPagesChooser()
	        }
	        this._updateButtonsState(pageIndex)
	    },
	    _updateButtonsState: function(pageIndex) {
	        var nextButton = this.element().find("." + PAGER_NEXT_BUTTON_CLASS),
	            prevButton = this.element().find("." + PAGER_PREV_BUTTON_CLASS);
	        nextButton.toggleClass(PAGER_BUTTON_DISABLE_CLASS, pageIndex >= this.option("pageCount"));
	        prevButton.toggleClass(PAGER_BUTTON_DISABLE_CLASS, pageIndex <= 1)
	    },
	    _optionChanged: function(args) {
	        switch (args.name) {
	            case "visible":
	                this._toggleVisibility(args.value);
	                break;
	            case "pageIndex":
	                var pageIndexChanged = this.option("pageIndexChanged");
	                if (pageIndexChanged) {
	                    pageIndexChanged(args.value)
	                }
	                this._updatePages();
	                break;
	            case "maxPagesCount":
	            case "pageCount":
	            case "totalCount":
	            case "hasKnownLastPage":
	            case "pagesNavigatorVisible":
	            case "showNavigationButtons":
	                this._updatePages();
	                break;
	            case "pageSize":
	                var pageSizeChanged = this.option("pageSizeChanged");
	                if (pageSizeChanged) {
	                    pageSizeChanged(args.value)
	                }
	                this._updatePageSizes();
	                break;
	            case "pageSizes":
	                this._updatePageSizes();
	                break;
	            default:
	                this._invalidate()
	        }
	    },
	    _clean: function() {
	        this._$pagesChooser && this._$pagesChooser.off(eventUtils.addNamespace(clickEvent.name, this.Name + "Pages"), "." + PAGER_PAGE_CLASS, this._pageClickHandler);
	        this.callBase()
	    },
	    _getMinPagerWidth: function() {
	        var pagesChooserWidth = commonUtils.isDefined(this._pagesChooserWidth) ? this._pagesChooserWidth : 0,
	            pagesSizeChooserWidth = commonUtils.isDefined(this._pagesSizeChooserWidth) ? this._pagesSizeChooserWidth : 0;
	        return pagesChooserWidth + pagesSizeChooserWidth
	    },
	    _updatePagesChooserWidth: commonUtils.deferUpdater(function() {
	        var lastPageWidth = this._pages && this._pages.length > 0 ? this._pages[this._pages.length - 1]._$page.width() : 0;
	        this._pagesChooserWidth = this._$pagesChooser.width() + lastPageWidth
	    }),
	    _updateLightMode: commonUtils.deferUpdater(function() {
	        var that = this,
	            width = this.element().width(),
	            infoWidth = commonUtils.isDefined(this._infoWidth) ? this._infoWidth : 0;
	        commonUtils.deferRender(function() {
	            if (that._isInfoHide && width > that._getMinPagerWidth() + infoWidth) {
	                that._$info.show();
	                that._updatePagesChooserWidth();
	                that._isInfoHide = false
	            }
	            if (!that._isInfoHide && width > that._getMinPagerWidth() - infoWidth && width < that._getMinPagerWidth()) {
	                that._$info.hide();
	                that._updatePagesChooserWidth();
	                that._isInfoHide = true
	            }
	            commonUtils.deferUpdate(function() {
	                commonUtils.deferRender(function() {
	                    if (width < that._getMinPagerWidth() && !that._isLightMode) {
	                        that._optimalPagerWidth = that._getMinPagerWidth();
	                        that._isLightMode = true;
	                        that.option("lightModeEnabled", that._isLightMode)
	                    }
	                    if (width > that._optimalPagerWidth && that._isLightMode) {
	                        that._isLightMode = false;
	                        that.option("lightModeEnabled", that._isLightMode)
	                    }
	                })
	            })
	        })
	    }),
	    _dimensionChanged: function() {
	        this._updateLightMode()
	    },
	    getHeight: function() {
	        return this.option("visible") ? this.element().outerHeight() : 0
	    }
	});
	module.exports = Pager;
	registerComponent("dxPager", Pager);


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.columns_resizing_reordering_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66),
	    dragEvents = __webpack_require__(98),
	    addNamespace = eventUtils.addNamespace,
	    gridCore = __webpack_require__(144),
	    fx = __webpack_require__(58);
	var DATAGRID_COLUMNS_SEPARATOR_CLASS = "dx-datagrid-columns-separator",
	    DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT = "dx-datagrid-columns-separator-transparent",
	    DATAGRID_DRAGGING_HEADER_CLASS = "dx-datagrid-drag-header",
	    DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
	    DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action",
	    DATAGRID_TRACKER_CLASS = "dx-datagrid-tracker",
	    DATAGRID_BLOCK_SEPARATOR_CLASS = "dx-block-separator",
	    DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS = "dx-datagrid-drop-highlight",
	    DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
	    WIDGET_CLASS = "dx-widget",
	    DATAGRID_MODULE_NAMESPACE = "dxDataGridResizingReordering",
	    COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10,
	    DRAGGING_DELTA = 5;
	var allowResizing = function(that) {
	    return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing")
	};
	var allowReordering = function(that) {
	    return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering")
	};
	exports.TrackerView = gridCore.View.inherit({
	    _renderCore: function() {
	        this.callBase();
	        this.element().addClass(DATAGRID_TRACKER_CLASS);
	        this.hide()
	    },
	    _unsubscribeFromCallback: function() {
	        if (this._positionChanged) {
	            this._tablePositionController.positionChanged.remove(this._positionChanged)
	        }
	    },
	    _subscribeToCallback: function() {
	        var that = this;
	        that._positionChanged = function(position) {
	            var $element = that.element();
	            if ($element && $element.hasClass(DATAGRID_TRACKER_CLASS)) {
	                $element.css({
	                    top: position.top
	                });
	                $element.height(position.height)
	            }
	        };
	        this._tablePositionController.positionChanged.add(that._positionChanged)
	    },
	    optionChanged: function(args) {
	        if ("allowColumnResizing" === args.name) {
	            this._unsubscribeFromCallback();
	            if (args.value) {
	                this._subscribeToCallback();
	                this._invalidate()
	            }
	        }
	        this.callBase(args)
	    },
	    init: function() {
	        this.callBase();
	        this._tablePositionController = this.getController("tablePosition");
	        this._subscribeToCallback()
	    },
	    isVisible: function() {
	        return allowResizing(this)
	    },
	    show: function() {
	        this.element().show()
	    },
	    hide: function() {
	        this.element().hide()
	    },
	    setHeight: function(value) {
	        this.element().height(value)
	    },
	    dispose: function() {
	        this._unsubscribeFromCallback();
	        this.callBase()
	    }
	});
	exports.SeparatorView = gridCore.View.inherit({
	    _renderSeparator: function() {},
	    _renderCore: function(options) {
	        this.callBase(options);
	        this._isShown = true;
	        this._renderSeparator();
	        this.hide()
	    },
	    show: function() {
	        this._isShown = true
	    },
	    hide: function() {
	        this._isShown = false
	    },
	    height: function(value) {
	        var $element = this.element();
	        if ($element) {
	            if (commonUtils.isDefined(value)) {
	                $element.height(value)
	            } else {
	                return $element.height()
	            }
	        }
	    },
	    width: function(value) {
	        var $element = this.element();
	        if ($element) {
	            if (commonUtils.isDefined(value)) {
	                $element.width(value)
	            } else {
	                return $element.width()
	            }
	        }
	    }
	});
	exports.ColumnsSeparatorView = exports.SeparatorView.inherit({
	    _renderSeparator: function() {
	        this.callBase();
	        var $element = this.element();
	        $element.addClass(DATAGRID_COLUMNS_SEPARATOR_CLASS)
	    },
	    _subscribeToCallback: function() {
	        var $element, that = this;
	        that._positionChanged = function(position) {
	            $element = that.element();
	            if ($element) {
	                $element.css({
	                    top: position.top
	                });
	                $element.height(position.height)
	            }
	        };
	        that._tablePositionController.positionChanged.add(that._positionChanged)
	    },
	    _unsubscribeFromCallback: function() {
	        this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged)
	    },
	    _init: function() {
	        this._isTransparent = allowResizing(this);
	        if (this.isVisible()) {
	            this._subscribeToCallback()
	        }
	    },
	    isVisible: function() {
	        return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this))
	    },
	    optionChanged: function(args) {
	        if ("allowColumnResizing" === args.name) {
	            if (args.value) {
	                this._init();
	                this._invalidate();
	                this.hide(true)
	            } else {
	                this._unsubscribeFromCallback();
	                this._isTransparent = allowResizing(this);
	                this.hide(true)
	            }
	        }
	        this.callBase(args)
	    },
	    init: function() {
	        this.callBase();
	        this._tablePositionController = this.getController("tablePosition");
	        this._init()
	    },
	    show: function() {
	        var that = this,
	            $element = this.element();
	        if ($element && !that._isShown) {
	            if (that._isTransparent) {
	                $element.removeClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT)
	            } else {
	                $element.show()
	            }
	        }
	        this.callBase()
	    },
	    hide: function(force) {
	        var $element = this.element();
	        if ($element && (this._isShown || force)) {
	            if (this._isTransparent) {
	                $element.addClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
	                if ("none" === $element.css("display")) {
	                    $element.show()
	                }
	            } else {
	                if ($element.hasClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT)) {
	                    $element.removeClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT)
	                }
	                $element.hide()
	            }
	        }
	        this.callBase()
	    },
	    moveByX: function(outerX) {
	        var $element = this.element();
	        if ($element) {
	            $element.css("left", outerX - this._parentElement().offset().left)
	        }
	    },
	    changeCursor: function(cursorName) {
	        cursorName = commonUtils.isDefined(cursorName) ? cursorName : "";
	        var $element = this.element();
	        if ($element) {
	            $element.css("cursor", cursorName)
	        }
	    },
	    dispose: function() {
	        this._unsubscribeFromCallback();
	        this.callBase()
	    }
	});
	exports.BlockSeparatorView = exports.SeparatorView.inherit({
	    init: function() {
	        var that = this;
	        this.callBase();
	        this.getController("data").loadingChanged.add(function(isLoading) {
	            var element = that.element();
	            if (!isLoading && element && "none" !== element.css("display")) {
	                that.hide()
	            }
	        })
	    },
	    _renderSeparator: function() {
	        this.callBase();
	        this.element().addClass(DATAGRID_BLOCK_SEPARATOR_CLASS).html("&nbsp;")
	    },
	    hide: function() {
	        var that = this,
	            $parent = this._parentElement(),
	            $element = this.element();
	        if ($element && this._isShown) {
	            $element.hide()
	        }
	        if ($parent && !$parent.children("." + DATAGRID_BLOCK_SEPARATOR_CLASS).length) {
	            $parent.prepend(that.element())
	        }
	        that.callBase()
	    },
	    isVisible: function() {
	        var groupPanelOptions = this.option("groupPanel"),
	            columnChooserOptions = this.option("columnChooser");
	        return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled
	    },
	    show: function(targetLocation) {
	        var that = this,
	            $element = this.element(),
	            startAnimate = function(toOptions) {
	                fx.stop($element, true);
	                fx.animate($element, {
	                    type: "slide",
	                    from: {
	                        width: 0,
	                        display: toOptions.display
	                    },
	                    to: toOptions,
	                    duration: 300,
	                    easing: "swing"
	                })
	            };
	        if ($element && !that._isShown) {
	            switch (targetLocation) {
	                case "group":
	                    startAnimate({
	                        width: "50px",
	                        display: "inline-block"
	                    });
	                    break;
	                case "columnChooser":
	                    startAnimate({
	                        width: "100%",
	                        display: "block"
	                    });
	                    break;
	                default:
	                    $element.show()
	            }
	        }
	        that.callBase()
	    }
	});
	exports.DraggingHeaderView = gridCore.View.inherit({
	    _isDragging: false,
	    _getDraggingPanelByPos: function(pos) {
	        var result, that = this;
	        $.each(that._dragOptions.draggingPanels, function(index, draggingPanel) {
	            if (draggingPanel) {
	                var boundingRect = draggingPanel.getBoundingRect();
	                if (boundingRect && (void 0 === boundingRect.bottom || pos.y < boundingRect.bottom) && (void 0 === boundingRect.top || pos.y > boundingRect.top) && (void 0 === boundingRect.left || pos.x > boundingRect.left) && (void 0 === boundingRect.right || pos.x < boundingRect.right)) {
	                    result = draggingPanel;
	                    return false
	                }
	            }
	        });
	        return result
	    },
	    _renderCore: function() {
	        this.element().addClass(DATAGRID_DRAGGING_HEADER_CLASS + " " + DATAGRID_CELL_CONTENT_CLASS + " " + WIDGET_CLASS).css("display", "none")
	    },
	    _resetTargetColumnOptions: function() {
	        var params = this._dropOptions;
	        params.targetColumnIndex = -1;
	        delete params.targetColumnElement;
	        delete params.isLast;
	        delete params.posX;
	        delete params.posY
	    },
	    _getVisibleIndexObject: function(rowIndex, visibleIndex) {
	        if (commonUtils.isDefined(rowIndex)) {
	            return {
	                columnIndex: visibleIndex,
	                rowIndex: rowIndex
	            }
	        }
	        return visibleIndex
	    },
	    dispose: function() {
	        var element = this.element();
	        this._dragOptions = null;
	        element && element.parent().find("." + DATAGRID_DRAGGING_HEADER_CLASS).remove()
	    },
	    isVisible: function() {
	        var columnsController = this.getController("columns"),
	            commonColumnSettings = columnsController.getCommonSettings();
	        return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding)
	    },
	    init: function() {
	        var that = this;
	        this.callBase();
	        this._controller = this.getController("draggingHeader");
	        this._columnsResizerViewController = this.getController("columnsResizer");
	        this.getController("data").loadingChanged.add(function(isLoading) {
	            var element = that.element();
	            if (!isLoading && element && "none" !== element.css("display")) {
	                element.hide()
	            }
	        })
	    },
	    dragHeader: function(options) {
	        var that = this,
	            columnElement = options.columnElement;
	        that._isDragging = true;
	        that._dragOptions = options;
	        that._dropOptions = {
	            sourceIndex: options.index,
	            sourceColumnIndex: that._getVisibleIndexObject(options.rowIndex, options.columnIndex),
	            sourceColumnElement: options.columnElement,
	            sourceLocation: options.sourceLocation
	        };
	        that._onSelectStart = document.onselectstart;
	        document.onselectstart = function() {
	            return false
	        };
	        that.element().css({
	            textAlign: columnElement && columnElement.css("text-align"),
	            height: columnElement && columnElement.height(),
	            width: columnElement && columnElement.width(),
	            whiteSpace: columnElement && columnElement.css("white-space")
	        }).addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS).text(options.sourceColumn.caption);
	        that.element().appendTo($(document.body))
	    },
	    moveHeader: function(args) {
	        var newLeft, newTop, moveDeltaX, moveDeltaY, e = args.jQueryEvent,
	            that = e.data.that,
	            eventData = eventUtils.eventData(e),
	            isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false,
	            dragOptions = that._dragOptions;
	        if (that._isDragging && !isResizing) {
	            moveDeltaX = Math.abs(eventData.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
	            moveDeltaY = Math.abs(eventData.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
	            if (that.element().is(":visible") || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
	                that.element().show();
	                newLeft = eventData.x - dragOptions.deltaX;
	                newTop = eventData.y - dragOptions.deltaY;
	                that.element().offset({
	                    left: newLeft,
	                    top: newTop
	                });
	                that.dockHeader(eventData)
	            }
	            e.preventDefault()
	        }
	    },
	    dockHeader: function(eventData) {
	        var i, centerPosition, that = this,
	            targetDraggingPanel = that._getDraggingPanelByPos(eventData),
	            controller = that._controller,
	            params = that._dropOptions;
	        if (targetDraggingPanel) {
	            var rtlEnabled = that.option("rtlEnabled"),
	                isVerticalOrientation = "columnChooser" === targetDraggingPanel.getName(),
	                axisName = isVerticalOrientation ? "y" : "x",
	                targetLocation = targetDraggingPanel.getName(),
	                rowIndex = "headers" === targetLocation ? that._dragOptions.rowIndex : void 0,
	                sourceColumn = that._dragOptions.sourceColumn,
	                columnElements = targetDraggingPanel.getColumnElements(rowIndex, sourceColumn && sourceColumn.ownerBand) || [],
	                pointsByColumns = controller._generatePointsByColumns($.extend({}, that._dragOptions, {
	                    targetDraggingPanel: targetDraggingPanel,
	                    columns: targetDraggingPanel.getColumns(rowIndex),
	                    columnElements: columnElements,
	                    isVerticalOrientation: isVerticalOrientation,
	                    startColumnIndex: "headers" === targetLocation && $(columnElements[0]).index()
	                }));
	            params.targetLocation = targetLocation;
	            if (pointsByColumns.length > 0) {
	                for (i = 0; i < pointsByColumns.length; i++) {
	                    centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
	                    if (void 0 === centerPosition || (rtlEnabled && "x" === axisName ? eventData[axisName] > centerPosition : eventData[axisName] < centerPosition)) {
	                        params.targetColumnIndex = that._getVisibleIndexObject(rowIndex, pointsByColumns[i].columnIndex);
	                        if (columnElements[i]) {
	                            params.targetColumnElement = columnElements.eq(i);
	                            params.isLast = false
	                        } else {
	                            params.targetColumnElement = columnElements.last();
	                            params.isLast = true
	                        }
	                        params.posX = pointsByColumns[i].x;
	                        params.posY = pointsByColumns[i].y;
	                        controller.dock(params);
	                        break
	                    }
	                }
	            } else {
	                that._resetTargetColumnOptions();
	                controller.dock(params)
	            }
	        }
	    },
	    dropHeader: function(args) {
	        var e = args.jQueryEvent,
	            that = e.data.that,
	            controller = that._controller;
	        that.element().hide();
	        if (controller && that._isDragging) {
	            controller.drop(that._dropOptions)
	        }
	        that.element().appendTo(that._parentElement());
	        that._dragOptions = null;
	        that._dropOptions = null;
	        that._isDragging = false;
	        document.onselectstart = that._onSelectStart || null
	    }
	});
	exports.ColumnsResizerViewController = gridCore.ViewController.inherit({
	    _isHeadersRowArea: function(posY) {
	        if (this._columnHeadersView) {
	            var headersRowHeight, offsetTop, element = this._columnHeadersView.element();
	            if (element) {
	                offsetTop = element.offset().top;
	                headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
	                return posY >= offsetTop && posY <= offsetTop + headersRowHeight
	            }
	        }
	        return false
	    },
	    _pointCreated: function(point, cellsLength, columns) {
	        var currentColumn, nextColumn;
	        if (point.index > 0 && point.index < cellsLength) {
	            point.columnIndex -= 1;
	            currentColumn = columns[point.columnIndex] || {};
	            nextColumn = columns[point.columnIndex + 1] || {};
	            return !(currentColumn.allowResizing && nextColumn.allowResizing)
	        }
	        return true
	    },
	    _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
	        if (pointsByColumns) {
	            for (var i = 0; i < pointsByColumns.length; i++) {
	                if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX) {
	                    return pointsByColumns[i]
	                }
	            }
	        }
	        return null
	    },
	    _moveSeparator: function(args) {
	        var e = args.jQueryEvent,
	            that = e.data,
	            columnsSeparatorWidth = that._columnsSeparatorView.width(),
	            columnsSeparatorOffset = that._columnsSeparatorView.element().offset(),
	            deltaX = columnsSeparatorWidth / 2,
	            parentOffset = that._$parentContainer.offset(),
	            parentOffsetLeft = parentOffset.left,
	            eventData = eventUtils.eventData(e);
	        if (that._isResizing) {
	            if (parentOffsetLeft <= eventData.x && eventData.x <= parentOffsetLeft + that._$parentContainer.width()) {
	                if (that._updateColumnsWidthIfNeeded(eventData.x)) {
	                    that._columnsSeparatorView.moveByX(that._targetPoint.x + (eventData.x - that._resizingInfo.startPosX));
	                    that._tablePositionController.update(that._targetPoint.y);
	                    e.preventDefault()
	                }
	            }
	        } else {
	            if (that._isHeadersRowArea(eventData.y)) {
	                if (that._previousParentOffset) {
	                    if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top) {
	                        that.pointsByColumns(null)
	                    }
	                }
	                that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, columnsSeparatorWidth);
	                that._previousParentOffset = parentOffset;
	                that._isReadyResizing = false;
	                if (that._targetPoint && that._targetPoint.y <= eventData.y && columnsSeparatorOffset.top + that._columnsSeparatorView.height() >= eventData.y) {
	                    that._columnsSeparatorView.changeCursor("col-resize");
	                    that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
	                    that._tablePositionController.update(that._targetPoint.y);
	                    that._isReadyResizing = true;
	                    e.preventDefault()
	                } else {
	                    that._columnsSeparatorView.changeCursor()
	                }
	            } else {
	                that.pointsByColumns(null);
	                that._isReadyResizing = false;
	                that._columnsSeparatorView.changeCursor()
	            }
	        }
	    },
	    _endResizing: function(args) {
	        var e = args.jQueryEvent,
	            that = e.data;
	        if (that._isResizing) {
	            that.pointsByColumns(null);
	            that._resizingInfo = null;
	            that._columnsSeparatorView.hide();
	            that._columnsSeparatorView.changeCursor();
	            that._trackerView.hide();
	            that._isReadyResizing = false;
	            that._isResizing = false
	        }
	    },
	    _getNextColumnIndex: function(currentColumnIndex) {
	        return currentColumnIndex + 1
	    },
	    _setupResizingInfo: function(posX) {
	        var that = this,
	            currentColumnIndex = that._targetPoint.columnIndex,
	            nextColumnIndex = that._getNextColumnIndex(currentColumnIndex),
	            currentHeader = that._columnHeadersView.getHeaderElement(currentColumnIndex),
	            nextHeader = that._columnHeadersView.getHeaderElement(nextColumnIndex);
	        that._resizingInfo = {
	            startPosX: posX,
	            currentColumnIndex: currentColumnIndex,
	            currentColumnWidth: currentHeader && currentHeader.length > 0 ? currentHeader.outerWidth() : 0,
	            nextColumnIndex: nextColumnIndex,
	            nextColumnWidth: nextHeader && nextHeader.length > 0 ? nextHeader.outerWidth() : 0
	        }
	    },
	    _startResizing: function(args) {
	        var e = args.jQueryEvent,
	            that = e.data,
	            eventData = eventUtils.eventData(e),
	            editingController = that.getController("editing"),
	            editingMode = that.option("editing.mode"),
	            isCellEditing = editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
	        if (eventUtils.isTouchEvent(e)) {
	            if (that._isHeadersRowArea(eventData.y)) {
	                that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
	                if (that._targetPoint) {
	                    that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
	                    that._isReadyResizing = true
	                }
	            } else {
	                that._isReadyResizing = false
	            }
	        }
	        if (that._isReadyResizing && !isCellEditing) {
	            that._setupResizingInfo(eventData.x);
	            that._tablePositionController.update(that._targetPoint.y);
	            that._columnsSeparatorView.show();
	            that._trackerView.show();
	            that._isResizing = true;
	            e.preventDefault();
	            e.stopPropagation()
	        }
	    },
	    _generatePointsByColumns: function() {
	        var that = this,
	            columns = that._columnsController ? that._columnsController.getVisibleColumns() : [],
	            cells = that._columnHeadersView.getColumnElements(),
	            pointsByColumns = [];
	        if (cells && cells.length > 0) {
	            pointsByColumns = gridCore.getPointsByColumns(cells, function(point) {
	                return that._pointCreated(point, cells.length, columns)
	            })
	        }
	        that._pointsByColumns = pointsByColumns
	    },
	    _unsubscribeFromEvents: function() {
	        this._moveSeparatorHandler && this._$parentContainer.off(addNamespace(pointerEvents.move, DATAGRID_MODULE_NAMESPACE), this._moveSeparatorHandler);
	        this._startResizingHandler && this._$parentContainer.off(addNamespace(pointerEvents.down, DATAGRID_MODULE_NAMESPACE), this._startResizingHandler);
	        if (this._endResizingHandler) {
	            this._columnsSeparatorView.element().off(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this._endResizingHandler);
	            $(document).off(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this._endResizingHandler)
	        }
	    },
	    _subscribeToEvents: function() {
	        this._moveSeparatorHandler = this.createAction(this._moveSeparator);
	        this._startResizingHandler = this.createAction(this._startResizing);
	        this._endResizingHandler = this.createAction(this._endResizing);
	        this._$parentContainer.on(addNamespace(pointerEvents.move, DATAGRID_MODULE_NAMESPACE), this, this._moveSeparatorHandler);
	        this._$parentContainer.on(addNamespace(pointerEvents.down, DATAGRID_MODULE_NAMESPACE), this, this._startResizingHandler);
	        this._columnsSeparatorView.element().on(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler);
	        $(document).on(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler)
	    },
	    _updateColumnsWidthIfNeeded: function(posX) {
	        var deltaX, nextCellWidth, column, nextColumn, cellWidth, isUpdated = false,
	            columnsController = this._columnsController,
	            visibleColumns = columnsController.getVisibleColumns(),
	            columnsSeparatorWidth = this._columnsSeparatorView.width(),
	            contentWidth = this._rowsView.contentWidth(),
	            adaptColumnWidthByRatio = this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth");

	        function setColumnWidth(column, columnWidth, contentWidth, adaptColumnWidthByRatio) {
	            if (column) {
	                var oldColumnWidth = column.width;
	                if (oldColumnWidth) {
	                    adaptColumnWidthByRatio = commonUtils.isString(oldColumnWidth) && "%" === oldColumnWidth.slice(-1)
	                }
	                if (adaptColumnWidthByRatio) {
	                    column && columnsController.columnOption(column.index, "visibleWidth", columnWidth);
	                    column && columnsController.columnOption(column.index, "width", (columnWidth / contentWidth * 100).toFixed(3) + "%")
	                } else {
	                    column && columnsController.columnOption(column.index, "visibleWidth", void 0);
	                    column && columnsController.columnOption(column.index, "width", columnWidth)
	                }
	            }
	        }
	        deltaX = posX - this._resizingInfo.startPosX;
	        if (this.option("rtlEnabled")) {
	            deltaX = -deltaX
	        }
	        cellWidth = this._resizingInfo.currentColumnWidth + deltaX;
	        nextCellWidth = this._resizingInfo.nextColumnWidth - deltaX;
	        isUpdated = !(cellWidth <= columnsSeparatorWidth || nextCellWidth <= columnsSeparatorWidth);
	        if (isUpdated) {
	            column = visibleColumns[this._resizingInfo.currentColumnIndex];
	            nextColumn = visibleColumns[this._resizingInfo.nextColumnIndex];
	            columnsController.beginUpdate();
	            cellWidth = Math.floor(cellWidth);
	            nextCellWidth = Math.floor(nextCellWidth);
	            setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
	            setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio);
	            columnsController.endUpdate()
	        }
	        return isUpdated
	    },
	    _subscribeToCallback: function(callback, handler) {
	        callback.add(handler);
	        this._subscribesToCallbacks.push({
	            callback: callback,
	            handler: handler
	        })
	    },
	    _unsubscribeFromCallbacks: function() {
	        var i, subscribe;
	        for (i = 0; i < this._subscribesToCallbacks.length; i++) {
	            subscribe = this._subscribesToCallbacks[i];
	            subscribe.callback.remove(subscribe.handler)
	        }
	        this._subscribesToCallbacks = []
	    },
	    _unsubscribes: function() {
	        this._unsubscribeFromEvents();
	        this._unsubscribeFromCallbacks()
	    },
	    _init: function() {
	        var gridView, previousScrollbarVisibility, that = this,
	            generatePointsByColumnsHandler = function() {
	                if (!that._isResizing) {
	                    that.pointsByColumns(null)
	                }
	            },
	            generatePointsByColumnsScrollHandler = function(offset) {
	                if (that._scrollLeft !== offset.left) {
	                    that._scrollLeft = offset.left;
	                    that.pointsByColumns(null)
	                }
	            };
	        that._columnsSeparatorView = that.getView("columnsSeparatorView");
	        that._columnHeadersView = that.getView("columnHeadersView");
	        that._trackerView = that.getView("trackerView");
	        that._rowsView = that.getView("rowsView");
	        that._columnsController = that.getController("columns");
	        that._tablePositionController = that.getController("tablePosition");
	        that._$parentContainer = that._columnsSeparatorView.component.element();
	        that._subscribeToCallback(that._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
	        that._subscribeToCallback(that._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
	        that._subscribeToCallback(that._columnsSeparatorView.renderCompleted, function() {
	            that._unsubscribeFromEvents();
	            that._subscribeToEvents()
	        });
	        that._subscribeToCallback(that._rowsView.renderCompleted, function() {
	            that._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
	            that._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler)
	        });
	        gridView = that.getView("gridView");
	        previousScrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
	        that._subscribeToCallback(that.getController("tablePosition").positionChanged, function() {
	            if (that._isResizing && !that._rowsView.isResizing) {
	                var scrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
	                if (previousScrollbarVisibility !== scrollbarVisibility) {
	                    previousScrollbarVisibility = scrollbarVisibility;
	                    gridView.resize()
	                } else {
	                    that._rowsView.updateFreeSpaceRowHeight()
	                }
	            }
	        })
	    },
	    optionChanged: function(args) {
	        this.callBase(args);
	        if ("allowColumnResizing" === args.name) {
	            if (args.value) {
	                this._init();
	                this._subscribeToEvents()
	            } else {
	                this._unsubscribes()
	            }
	        }
	    },
	    isResizing: function() {
	        return this._isResizing
	    },
	    init: function() {
	        this._subscribesToCallbacks = [];
	        if (allowResizing(this)) {
	            this._init()
	        }
	    },
	    pointsByColumns: function(value) {
	        if (void 0 !== value) {
	            this._pointsByColumns = value
	        } else {
	            if (!this._pointsByColumns) {
	                this._generatePointsByColumns()
	            }
	            return this._pointsByColumns
	        }
	    },
	    dispose: function() {
	        this._unsubscribes();
	        this.callBase()
	    }
	});
	exports.TablePositionViewController = gridCore.ViewController.inherit({
	    update: function(top) {
	        var that = this,
	            $element = that._columnHeadersView.element(),
	            offset = $element && $element.offset(),
	            offsetTop = offset && offset.top || 0,
	            diffOffsetTop = commonUtils.isDefined(top) ? Math.abs(top - offsetTop) : 0,
	            columnsHeadersHeight = that._columnHeadersView ? that._columnHeadersView.getHeight() : 0,
	            rowsHeight = that._rowsView ? that._rowsView.height() - that._rowsView.getScrollbarWidth(true) : 0;
	        that.positionChanged.fire({
	            height: columnsHeadersHeight + rowsHeight - diffOffsetTop,
	            top: $element && $element.length && $element[0].offsetTop + diffOffsetTop
	        })
	    },
	    init: function() {
	        var that = this;
	        that.callBase();
	        that._columnHeadersView = this.getView("columnHeadersView");
	        that._rowsView = this.getView("rowsView");
	        that._pagerView = this.getView("pagerView");
	        that._rowsView.resizeCompleted.add(function() {
	            that.update()
	        })
	    },
	    ctor: function(component) {
	        this.callBase(component);
	        this.positionChanged = $.Callbacks()
	    }
	});
	exports.DraggingHeaderViewController = gridCore.ViewController.inherit({
	    _generatePointsByColumns: function(options) {
	        var that = this;
	        return gridCore.getPointsByColumns(options.columnElements, function(point) {
	            return that._pointCreated(point, options.columns, options.targetDraggingPanel.getName(), options.sourceColumn)
	        }, options.isVerticalOrientation, options.startColumnIndex)
	    },
	    _pointCreated: function(point, columns, location, sourceColumn) {
	        var targetColumn = columns[point.columnIndex],
	            prevColumn = columns[point.columnIndex - 1];
	        switch (location) {
	            case "columnChooser":
	                return true;
	            case "headers":
	                return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
	            default:
	                return 0 === columns.length
	        }
	    },
	    _subscribeToEvents: function(draggingHeader, draggingPanels) {
	        var that = this;
	        $.each(draggingPanels, function(_, draggingPanel) {
	            if (draggingPanel) {
	                var i, columns, columnElements, rowCount = draggingPanel.getRowCount ? draggingPanel.getRowCount() : 1,
	                    nameDraggingPanel = draggingPanel.getName(),
	                    subscribeToEvents = function(index, columnElement) {
	                        var $columnElement = $(columnElement),
	                            column = columns[index];
	                        if (draggingPanel.allowDragging(columns[index], nameDraggingPanel, draggingPanels)) {
	                            $columnElement.addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS);
	                            $columnElement.on(addNamespace(dragEvents.start, DATAGRID_MODULE_NAMESPACE), that.createAction(function(args) {
	                                var e = args.jQueryEvent,
	                                    eventData = eventUtils.eventData(e);
	                                draggingHeader.dragHeader({
	                                    deltaX: eventData.x - $(e.currentTarget).offset().left,
	                                    deltaY: eventData.y - $(e.currentTarget).offset().top,
	                                    sourceColumn: column,
	                                    index: column.index,
	                                    columnIndex: index,
	                                    columnElement: $columnElement,
	                                    sourceLocation: nameDraggingPanel,
	                                    draggingPanels: draggingPanels,
	                                    rowIndex: that._columnsController.getRowIndex(column.index, true)
	                                })
	                            }));
	                            $columnElement.on(addNamespace(dragEvents.move, DATAGRID_MODULE_NAMESPACE), {
	                                that: draggingHeader
	                            }, that.createAction(draggingHeader.moveHeader));
	                            $columnElement.on(addNamespace(dragEvents.end, DATAGRID_MODULE_NAMESPACE), {
	                                that: draggingHeader
	                            }, that.createAction(draggingHeader.dropHeader))
	                        }
	                    };
	                for (i = 0; i < rowCount; i++) {
	                    columnElements = draggingPanel.getColumnElements(i) || [];
	                    columns = draggingPanel.getColumns(i) || [];
	                    $.each(columnElements, subscribeToEvents)
	                }
	            }
	        })
	    },
	    _unsubscribeFromEvents: function(draggingHeader, draggingPanels) {
	        $.each(draggingPanels, function(_, draggingPanel) {
	            if (draggingPanel) {
	                var columnElements = draggingPanel.getColumnElements() || [];
	                $.each(columnElements, function(index, columnElement) {
	                    var $columnElement = $(columnElement);
	                    $columnElement.off(addNamespace(dragEvents.start, DATAGRID_MODULE_NAMESPACE));
	                    $columnElement.off(addNamespace(dragEvents.move, DATAGRID_MODULE_NAMESPACE));
	                    $columnElement.off(addNamespace(dragEvents.end, DATAGRID_MODULE_NAMESPACE));
	                    $columnElement.removeClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS)
	                })
	            }
	        })
	    },
	    _getSeparator: function(targetLocation) {
	        return "headers" === targetLocation ? this._columnsSeparatorView : this._blockSeparatorView
	    },
	    hideSeparators: function() {
	        var blockSeparator = this._blockSeparatorView,
	            columnsSeparator = this._columnsSeparatorView;
	        this._animationColumnIndex = null;
	        blockSeparator && blockSeparator.hide();
	        columnsSeparator && columnsSeparator.hide()
	    },
	    init: function() {
	        var subscribeToEvents, that = this;
	        that.callBase();
	        that._columnsController = that.getController("columns");
	        that._columnHeadersView = that.getView("columnHeadersView");
	        that._columnsSeparatorView = that.getView("columnsSeparatorView");
	        that._draggingHeaderView = that.getView("draggingHeaderView");
	        that._rowsView = that.getView("rowsView");
	        that._blockSeparatorView = that.getView("blockSeparatorView");
	        that._headerPanelView = that.getView("headerPanel");
	        that._columnChooserView = that.getView("columnChooserView");
	        subscribeToEvents = function() {
	            if (that._draggingHeaderView) {
	                var draggingPanels = [that._columnChooserView, that._columnHeadersView, that._headerPanelView];
	                that._unsubscribeFromEvents(that._draggingHeaderView, draggingPanels);
	                that._subscribeToEvents(that._draggingHeaderView, draggingPanels)
	            }
	        };
	        that._columnHeadersView.renderCompleted.add(subscribeToEvents);
	        that._headerPanelView && that._headerPanelView.renderCompleted.add(subscribeToEvents);
	        that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvents)
	    },
	    allowDrop: function(parameters) {
	        return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
	    },
	    dock: function(parameters) {
	        var that = this,
	            targetColumnIndex = commonUtils.isObject(parameters.targetColumnIndex) ? parameters.targetColumnIndex.columnIndex : parameters.targetColumnIndex,
	            sourceLocation = parameters.sourceLocation,
	            sourceIndex = parameters.sourceIndex,
	            sourceColumnElement = parameters.sourceColumnElement,
	            targetLocation = parameters.targetLocation,
	            separator = that._getSeparator(targetLocation),
	            hasTargetVisibleIndex = targetColumnIndex >= 0;
	        var showSeparator = function() {
	            if (that._animationColumnIndex !== targetColumnIndex) {
	                that.hideSeparators();
	                separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
	                that._animationColumnIndex = targetColumnIndex;
	                separator.show(targetLocation)
	            }
	        };
	        that._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).toggleClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS, "headers" !== sourceLocation && "headers" === targetLocation && !hasTargetVisibleIndex);
	        if (separator) {
	            if (sourceColumnElement) {
	                sourceColumnElement.css({
	                    opacity: .5
	                });
	                if ("headers" === sourceLocation) {
	                    that._columnHeadersView.setRowsOpacity(sourceIndex, .5);
	                    that._rowsView.setRowsOpacity(sourceIndex, .5)
	                }
	            }
	            if (that.allowDrop(parameters) && hasTargetVisibleIndex) {
	                if ("group" === targetLocation || "columnChooser" === targetLocation) {
	                    showSeparator()
	                } else {
	                    that.hideSeparators();
	                    that.getController("tablePosition").update(parameters.posY);
	                    separator.moveByX(parameters.posX - separator.width());
	                    separator.show()
	                }
	            } else {
	                that.hideSeparators()
	            }
	        }
	    },
	    drop: function(parameters) {
	        var sourceColumnElement = parameters.sourceColumnElement;
	        if (sourceColumnElement) {
	            sourceColumnElement.css({
	                opacity: ""
	            });
	            this._columnHeadersView.setRowsOpacity(parameters.sourceIndex, "");
	            this._rowsView.setRowsOpacity(parameters.sourceIndex, "");
	            this._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).removeClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS)
	        }
	        if (this.allowDrop(parameters)) {
	            var separator = this._getSeparator(parameters.targetLocation);
	            if (separator) {
	                separator.hide()
	            }
	            this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
	        }
	    },
	    dispose: function() {
	        if (this._draggingHeaderView) {
	            this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView])
	        }
	    }
	});
	gridCore.registerModule("columnsResizingReordering", {
	    views: {
	        columnsSeparatorView: exports.ColumnsSeparatorView,
	        blockSeparatorView: exports.BlockSeparatorView,
	        draggingHeaderView: exports.DraggingHeaderView,
	        trackerView: exports.TrackerView
	    },
	    controllers: {
	        draggingHeader: exports.DraggingHeaderViewController,
	        tablePosition: exports.TablePositionViewController,
	        columnsResizer: exports.ColumnsResizerViewController
	    }
	});


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.keyboard_navigation.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    gridCore = __webpack_require__(144),
	    commonUtils = __webpack_require__(8),
	    KeyboardProcessor = __webpack_require__(90),
	    eventUtils = __webpack_require__(61),
	    pointerEvents = __webpack_require__(66);
	var DATAGRID_ROW_CLASS = "dx-row",
	    DATAGRID_DATA_ROW_CLASS = "dx-data-row",
	    DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
	    DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
	    DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
	    DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
	    DATAGRID_EDIT_FORM_CLASS = "dx-datagrid-edit-form",
	    DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
	    DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand",
	    DATAGRID_CLASS_SELECTOR = ".dx-datagrid",
	    DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR = "input:not([type='hidden']), textarea, a, [tabindex]",
	    DATAGRID_VIEWS = ["rowsView"],
	    DATAGRID_EDIT_MODE_ROW = "row",
	    DATAGRID_EDIT_MODE_FORM = "form";

	function isGroupRow($row) {
	    return $row && $row.hasClass(DATAGRID_GROUP_ROW_CLASS)
	}

	function isDetailRow($row) {
	    return $row && $row.hasClass(DATAGRID_MASTER_DETAIL_ROW_CLASS)
	}

	function isCellElement($element) {
	    return $element.length && "TD" === $element[0].tagName
	}
	exports.KeyboardNavigationController = gridCore.ViewController.inherit({
	    _isRowEditMode: function() {
	        var editMode = this._editingController.getEditMode();
	        return editMode === DATAGRID_EDIT_MODE_ROW || editMode === DATAGRID_EDIT_MODE_FORM
	    },
	    _focusView: function(view, viewIndex) {
	        this._focusedViews.viewIndex = viewIndex;
	        this._focusedView = view
	    },
	    _getInteractiveElement: function($cell, isLast) {
	        var $focusedElement = $cell.find(DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR).filter(":visible");
	        return isLast ? $focusedElement.last() : $focusedElement.first()
	    },
	    _focusInteractiveElement: function($cell, isLast) {
	        if (!$cell) {
	            return
	        }
	        var $focusedElement = this._getInteractiveElement($cell, isLast);
	        $focusedElement.focus()
	    },
	    _updateFocus: function() {
	        var that = this,
	            $cell = that._getFocusedCell();
	        if ($cell) {
	            if (that._hasSkipRow($cell.parent())) {
	                $cell = that._getNextCell(this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow")
	            }
	            if ($cell && $cell.length > 0) {
	                setTimeout(function() {
	                    if (that.getController("editorFactory").focus()) {
	                        that._focus($cell)
	                    }
	                    that._editingController.isEditing() && $.proxy(that._focusInteractiveElement, that)($cell)
	                })
	            }
	        }
	    },
	    _clickHandler: function(e) {
	        var event = e.jQueryEvent,
	            $cell = $(event.currentTarget),
	            $grid = $(event.target).closest(DATAGRID_CLASS_SELECTOR).parent(),
	            data = event.data;
	        if ($grid.is(this.component.element()) && this._isCellValid($cell)) {
	            this._focusView(data.view, data.viewIndex);
	            this._updateFocusedCellPosition($cell);
	            if (!this._editingController.isEditing()) {
	                data.view.element().attr("tabIndex", 0);
	                data.view.element().find(".dx-row > td[tabIndex]").attr("tabIndex", null);
	                $cell.focus()
	            }
	        } else {
	            this._resetFocusedCell()
	        }
	    },
	    _initFocusedViews: function() {
	        var that = this,
	            clickAction = that.createAction(that._clickHandler);
	        that._focusedViews = [];
	        $.each(DATAGRID_VIEWS, function(key, viewName) {
	            var view = that.getView(viewName);
	            if (view && view.isVisible()) {
	                that._focusedViews.push(view)
	            }
	        });
	        $.each(that._focusedViews, function(index, view) {
	            if (view) {
	                view.renderCompleted.add(function() {
	                    var $element = view.element();
	                    $element.off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), clickAction);
	                    $element.on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), "." + DATAGRID_ROW_CLASS + " td", {
	                        viewIndex: index,
	                        view: view
	                    }, clickAction);
	                    that._initKeyDownProcessor(that, $element, that._keyDownHandler);
	                    if (that._focusedView && that._focusedView.name === view.name && that._isNeedFocus) {
	                        that._updateFocus()
	                    }
	                })
	            }
	        })
	    },
	    _initKeyDownProcessor: function(context, element, handler) {
	        if (this._keyDownProcessor) {
	            this._keyDownProcessor.dispose();
	            this._keyDownProcessor = null
	        }
	        this._keyDownProcessor = new KeyboardProcessor({
	            element: element,
	            context: context,
	            handler: handler
	        })
	    },
	    _getFocusedCell: function() {
	        if (this._focusedView && this._focusedCellPosition) {
	            return this._focusedView.getCell(this._focusedCellPosition)
	        }
	    },
	    _updateFocusedCellPosition: function($cell) {
	        var that = this;
	        if ($cell.length > 0 && that._focusedView) {
	            this._focusedCellPosition = {
	                columnIndex: that._focusedView.getCellIndex($cell),
	                rowIndex: $cell.parent().length > 0 && that._focusedView.getRowIndex($cell.parent())
	            }
	        }
	    },
	    _isCellValid: function($cell) {
	        if (commonUtils.isDefined($cell)) {
	            var rowsView = this.getView("rowsView"),
	                visibleColumns = this._columnsController.getVisibleColumns(),
	                rowIndex = rowsView.getRowIndex($cell.parent()),
	                columnIndex = rowsView.getCellIndex($cell),
	                column = visibleColumns[columnIndex],
	                visibleColumnCount = this._getVisibleColumnCount(),
	                editingController = this._editingController,
	                editMode = editingController && editingController.getEditMode(),
	                isEditingCurrentRow = editingController && (editMode === DATAGRID_EDIT_MODE_ROW ? editingController.isEditRow(rowIndex) : editingController.isEditing()),
	                isMasterDetailRow = isDetailRow($cell.parent()),
	                isValidGroupSpaceColumn = function() {
	                    return !isMasterDetailRow && column && !commonUtils.isDefined(column.groupIndex) || parseInt($cell.attr("colspan")) > 1
	                };
	            if (this._isMasterDetailCell($cell)) {
	                return true
	            }
	            if (visibleColumnCount > columnIndex && isValidGroupSpaceColumn()) {
	                var isExpandColumn = "expand" === column.command;
	                return column && !column.command && (!isEditingCurrentRow || column.allowEditing) || isExpandColumn
	            }
	        }
	    },
	    _isCellByPositionValid: function(cellPosition) {
	        var $cell = this._focusedView && this._focusedView.getCell(cellPosition);
	        return this._isCellValid($cell)
	    },
	    _focus: function($cell) {
	        var $focusElement, $row = $cell.parent(),
	            $focusedCell = this._getFocusedCell(),
	            focusedView = this._focusedView;
	        $focusedCell && $focusedCell.attr("tabIndex", null);
	        if (isGroupRow($row)) {
	            $focusElement = $row;
	            if (focusedView) {
	                this._focusedCellPosition.rowIndex = focusedView.getRowIndex($row)
	            }
	        } else {
	            if (isCellElement($cell)) {
	                $focusElement = $cell;
	                this._updateFocusedCellPosition($cell)
	            }
	        }
	        focusedView && focusedView.element().attr("tabIndex", null);
	        if ($focusElement) {
	            $focusElement.attr("tabindex", 0);
	            $focusElement.focus()
	        }
	        this.getController("editorFactory").focus($focusElement)
	    },
	    _hasSkipRow: function($row) {
	        return $row && ("none" === $row.css("display") || $row.hasClass(DATAGRID_GROUP_FOOTER_CLASS) || isDetailRow($row) && !$row.hasClass(DATAGRID_EDIT_FORM_CLASS))
	    },
	    _enterKeyHandler: function(eventArgs, isEditing) {
	        var $cell = this._getFocusedCell(),
	            editingOptions = this.option("editing"),
	            rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
	            $row = this._focusedView && this._focusedView.getRow(rowIndex);
	        if (this.option("grouping.allowCollapsing") && isGroupRow($row) || this.option("masterDetail.enabled") && $cell && $cell.hasClass(DATAGRID_COMMAND_EXPAND_CLASS)) {
	            var key = this._dataController.getKeyByRowIndex(rowIndex),
	                item = this._dataController.items()[rowIndex];
	            if (void 0 !== key && item && item.data && !item.data.isContinuation) {
	                this._dataController.changeRowExpand(key)
	            }
	        } else {
	            if (isEditing) {
	                $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
	                this._updateFocusedCellPosition($cell);
	                if (this._isRowEditMode()) {
	                    this._focusEditFormCell($cell);
	                    setTimeout($.proxy(this._editingController.saveEditData, this._editingController))
	                } else {
	                    this._editingController.closeEditCell()
	                }
	            } else {
	                var column = this._columnsController.getVisibleColumns()[this._focusedCellPosition.columnIndex];
	                if (editingOptions.allowUpdating && column && column.allowEditing) {
	                    if (this._isRowEditMode()) {
	                        this._editingController.editRow(rowIndex)
	                    } else {
	                        this._focusedCellPosition && this._editingController.editCell(rowIndex, this._focusedCellPosition.columnIndex)
	                    }
	                }
	            }
	        }
	    },
	    _leftRightKeysHandler: function(eventArgs, isEditing) {
	        var directionCode, $cell, rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
	            $row = this._focusedView && this._focusedView.getRow(rowIndex);
	        if (!isEditing && $row && !isGroupRow($row) && !isDetailRow($row)) {
	            directionCode = this._getDirectionCodeByKey(eventArgs.key);
	            $cell = this._getNextCell(directionCode);
	            if ($cell && this._isCellValid($cell)) {
	                this._focus($cell)
	            }
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _getDirectionCodeByKey: function(key) {
	        var directionCode;
	        if (this.option("rtlEnabled")) {
	            directionCode = "leftArrow" === key ? "nextInRow" : "previousInRow"
	        } else {
	            directionCode = "leftArrow" === key ? "previousInRow" : "nextInRow"
	        }
	        return directionCode
	    },
	    _upDownKeysHandler: function(eventArgs, isEditing) {
	        var $cell, rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
	            $row = this._focusedView && this._focusedView.getRow(rowIndex);
	        if (!isEditing && !isDetailRow($row)) {
	            $cell = this._getNextCell(eventArgs.key);
	            if ($cell && this._isCellValid($cell)) {
	                this._focus($cell)
	            }
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _pageUpKeyHandler: function(eventArgs) {
	        var scrollingMode = this.option("scrolling.mode"),
	            pageIndex = this._dataController.pageIndex(),
	            isVirtualScrolling = "virtual" === scrollingMode || "infinite" === scrollingMode;
	        if (pageIndex > 0 && !isVirtualScrolling) {
	            this._dataController.pageIndex(pageIndex - 1);
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _pageDownKeyHandler: function(eventArgs) {
	        var scrollingMode = this.option("scrolling.mode"),
	            isVirtualScrolling = "virtual" === scrollingMode || "infinite" === scrollingMode,
	            pageIndex = this._dataController.pageIndex(),
	            pageCount = this._dataController.pageCount();
	        if (pageIndex < pageCount - 1 && !isVirtualScrolling) {
	            this._dataController.pageIndex(pageIndex + 1);
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _spaceKeyHandler: function(eventArgs, isEditing) {
	        var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
	            $target = $(eventArgs.originalEvent && eventArgs.originalEvent.target);
	        if (this.option("selection") && "none" !== this.option("selection").mode && !isEditing && ($target.parent().hasClass(DATAGRID_DATA_ROW_CLASS) || $target.hasClass(DATAGRID_ROWS_VIEW_CLASS))) {
	            this._selectionController.changeItemSelection(rowIndex, {
	                shift: eventArgs.shift,
	                control: eventArgs.ctrl
	            });
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _ctrlAKeyHandler: function(eventArgs, isEditing) {
	        if (!isEditing && eventArgs.ctrl && "multiple" === this.option("selection.mode") && this.option("selection.allowSelectAll")) {
	            this._selectionController.selectAll();
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _isMasterDetailCell: function(element) {
	        var $masterDetailCell = $(element).closest("." + DATAGRID_MASTER_DETAIL_CELL_CLASS),
	            $masterDetailGrid = $masterDetailCell.closest(DATAGRID_CLASS_SELECTOR).parent();
	        return $masterDetailCell.length && $masterDetailGrid.is(this.component.element())
	    },
	    _handleTabKeyOnMasterDetailCell: function(target, direction) {
	        if (this._isMasterDetailCell(target)) {
	            this._updateFocusedCellPosition($(target).closest("." + DATAGRID_MASTER_DETAIL_CELL_CLASS));
	            this._getNextCell(direction, "row").attr("tabindex", 0);
	            return true
	        }
	        return false
	    },
	    _tabKeyHandler: function(eventArgs, isEditing) {
	        var $cell, editingOptions = this.option("editing"),
	            direction = eventArgs.shift ? "previous" : "next",
	            isOriginalHandlerRequired = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition),
	            eventTarget = eventArgs.originalEvent.target;
	        if (this._handleTabKeyOnMasterDetailCell(eventTarget, direction)) {
	            return
	        }
	        if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
	            if ($(eventTarget).hasClass(DATAGRID_ROWS_VIEW_CLASS)) {
	                this._resetFocusedCell()
	            }
	            if (isEditing) {
	                var column, isEditingAllowed;
	                this._updateFocusedCellPosition(this._getCellElementFromTarget(eventTarget));
	                $cell = this._getNextCell(direction);
	                if (this._handleTabKeyOnMasterDetailCell($cell, direction)) {
	                    return
	                }
	                column = this._columnsController.getVisibleColumns()[this.getView("rowsView").getCellIndex($cell)];
	                isEditingAllowed = editingOptions.allowUpdating && column.allowEditing;
	                if (!isEditingAllowed) {
	                    this._editingController.closeEditCell()
	                }
	                if (this._focusCell($cell)) {
	                    if (!this._isRowEditMode() && isEditingAllowed) {
	                        this._editingController.editCell(this._focusedCellPosition.rowIndex, this._focusedCellPosition.columnIndex)
	                    } else {
	                        this._focusInteractiveElement($cell, eventArgs.shift)
	                    }
	                }
	            } else {
	                $cell = $(eventTarget).closest(".dx-row > td");
	                var $lastInteractiveElement = this._getInteractiveElement($cell, !eventArgs.shift);
	                if ($lastInteractiveElement.length && eventTarget !== $lastInteractiveElement.get(0)) {
	                    isOriginalHandlerRequired = true
	                } else {
	                    $cell = this._getNextCell(direction, this._getElementType(eventTarget));
	                    this._focusCell($cell);
	                    this._focusInteractiveElement($cell, eventArgs.shift)
	                }
	            }
	        }
	        if (isOriginalHandlerRequired) {
	            this.getController("editorFactory").loseFocus();
	            if (this._editingController.isEditing() && !this._isRowEditMode()) {
	                this._resetFocusedCell();
	                this._editingController.closeEditCell()
	            }
	        } else {
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _focusCell: function($cell) {
	        if (this._isCellValid($cell)) {
	            this._focus($cell);
	            return true
	        }
	    },
	    _getElementType: function(target) {
	        return $(target).is("tr") ? "row" : "cell"
	    },
	    _focusEditFormCell: function($cell) {
	        if ($cell.hasClass(DATAGRID_MASTER_DETAIL_CELL_CLASS)) {
	            this.getController("editorFactory").focus($cell, true)
	        }
	    },
	    _escapeKeyHandler: function(eventArgs, isEditing) {
	        if (isEditing) {
	            var $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
	            this._updateFocusedCellPosition($cell);
	            if (!this._isRowEditMode()) {
	                this._editingController.closeEditCell()
	            } else {
	                this._focusEditFormCell($cell);
	                this._editingController.cancelEditData()
	            }
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _ctrlFKeyHandler: function(eventArgs) {
	        if (eventArgs.ctrl && this.option("searchPanel") && this.option("searchPanel").visible) {
	            this._headerPanel.focus();
	            eventArgs.originalEvent.preventDefault()
	        }
	    },
	    _keyDownHandler: function(e) {
	        var isEditing = this._editingController.isEditing(),
	            needStopPropagation = true,
	            args = {
	                handled: false,
	                jQueryEvent: e.originalEvent
	            };
	        this.executeAction("onKeyDown", args);
	        if (e.originalEvent.isDefaultPrevented()) {
	            return
	        }
	        this._isNeedFocus = true;
	        this._isNeedScroll = true;
	        this._updateFocusedCellPosition(this._getCellElementFromTarget(args.jQueryEvent.target));
	        if (!args.handled) {
	            switch (e.key) {
	                case "leftArrow":
	                case "rightArrow":
	                    this._leftRightKeysHandler(e, isEditing);
	                    break;
	                case "upArrow":
	                case "downArrow":
	                    this._upDownKeysHandler(e, isEditing);
	                    break;
	                case "pageUp":
	                    this._pageUpKeyHandler(e);
	                    break;
	                case "pageDown":
	                    this._pageDownKeyHandler(e);
	                    break;
	                case "space":
	                    this._spaceKeyHandler(e, isEditing);
	                    break;
	                case "A":
	                    this._ctrlAKeyHandler(e, isEditing);
	                    break;
	                case "tab":
	                    this._tabKeyHandler(e, isEditing);
	                    break;
	                case "enter":
	                    this._enterKeyHandler(e, isEditing);
	                    break;
	                case "escape":
	                    this._escapeKeyHandler(e, isEditing);
	                    break;
	                case "F":
	                    this._ctrlFKeyHandler(e);
	                    break;
	                default:
	                    this._isNeedFocus = false;
	                    this._isNeedScroll = false;
	                    needStopPropagation = false
	            }
	            if (needStopPropagation) {
	                e.originalEvent.stopPropagation()
	            }
	        }
	    },
	    _isLastRow: function(rowIndex) {
	        return rowIndex === this.getController("data").items().length - 1
	    },
	    _getNextCell: function(keyCode, elementType, cellPosition) {
	        var rowIndex, newFocusedCellPosition, $cell, $row, focusedCellPosition = cellPosition || this._focusedCellPosition,
	            includeCommandCells = $.inArray(keyCode, ["next", "previous"]) > -1,
	            isLastCellOnDirection = "previous" === keyCode ? this._isFirstValidCell(focusedCellPosition) : this._isLastValidCell(focusedCellPosition);
	        if (this._focusedView && focusedCellPosition) {
	            newFocusedCellPosition = this._getNewPositionByCode(focusedCellPosition, elementType, keyCode);
	            $cell = this._focusedView.getCell(newFocusedCellPosition);
	            if (!this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells) && !isLastCellOnDirection) {
	                $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition)
	            }
	            $row = $cell && $cell.parent();
	            if (this._hasSkipRow($row)) {
	                rowIndex = this._focusedView.getRowIndex($row);
	                if (!this._isLastRow(rowIndex)) {
	                    $cell = this._getNextCell(keyCode, "row", {
	                        columnIndex: focusedCellPosition.columnIndex,
	                        rowIndex: rowIndex
	                    })
	                } else {
	                    return null
	                }
	            }
	            return $cell
	        }
	        return null
	    },
	    _getNewPositionByCode: function(cellPosition, elementType, code) {
	        var visibleColumnsCount, columnIndex = cellPosition.columnIndex,
	            rowIndex = cellPosition.rowIndex;
	        if (void 0 === cellPosition.rowIndex && "next" === code) {
	            return {
	                columnIndex: 0,
	                rowIndex: 0
	            }
	        }
	        switch (code) {
	            case "nextInRow":
	            case "next":
	                visibleColumnsCount = this._getVisibleColumnCount();
	                if (columnIndex < visibleColumnsCount - 1 && !this._isLastValidCell({
	                        columnIndex: columnIndex,
	                        rowIndex: rowIndex
	                    }) && "row" !== elementType) {
	                    columnIndex++
	                } else {
	                    if (!this._isLastRow(rowIndex) && "next" === code) {
	                        columnIndex = 0;
	                        rowIndex++
	                    }
	                }
	                break;
	            case "previousInRow":
	            case "previous":
	                if (columnIndex > 0 && !this._isFirstValidCell({
	                        columnIndex: columnIndex,
	                        rowIndex: rowIndex
	                    }) && "row" !== elementType) {
	                    columnIndex--
	                } else {
	                    if (rowIndex > 0 && "previous" === code) {
	                        rowIndex--;
	                        visibleColumnsCount = this._getVisibleColumnCount();
	                        columnIndex = visibleColumnsCount - 1
	                    }
	                }
	                break;
	            case "upArrow":
	                rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
	                break;
	            case "downArrow":
	                rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex
	        }
	        return {
	            columnIndex: columnIndex,
	            rowIndex: rowIndex
	        }
	    },
	    _isFirstValidCell: function(cellPosition) {
	        var isFirstValidCell = false;
	        if (0 === cellPosition.rowIndex && cellPosition.columnIndex >= 0) {
	            isFirstValidCell = isFirstValidCell || !this._haveValidCellBeforePosition(cellPosition)
	        }
	        return isFirstValidCell
	    },
	    _haveValidCellBeforePosition: function(cellPosition) {
	        var columnIndex = cellPosition.columnIndex,
	            hasValidCells = false;
	        while (columnIndex > 0 && !hasValidCells) {
	            var checkingPosition = {
	                columnIndex: --columnIndex,
	                rowIndex: cellPosition.rowIndex
	            };
	            hasValidCells = this._isCellByPositionValid(checkingPosition)
	        }
	        return hasValidCells
	    },
	    _isLastValidCell: function(cellPosition) {
	        var checkingPosition = {
	                columnIndex: cellPosition.columnIndex + 1,
	                rowIndex: cellPosition.rowIndex
	            },
	            visibleColumnsCount = this._getVisibleColumnCount(),
	            isCheckingCellValid = this._isCellByPositionValid(checkingPosition);
	        if (!this._isLastRow(cellPosition.rowIndex)) {
	            return false
	        }
	        if (cellPosition.columnIndex === visibleColumnsCount - 1) {
	            return true
	        }
	        if (isCheckingCellValid) {
	            return false
	        }
	        return this._isLastValidCell(checkingPosition)
	    },
	    _getVisibleColumnCount: function() {
	        return this.getController("columns").getVisibleColumns().length
	    },
	    _isCellInRow: function(cellPosition, includeCommandCells) {
	        var columnIndex = cellPosition.columnIndex,
	            visibleColumnsCount = this._getVisibleColumnCount();
	        return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1
	    },
	    _resetFocusedCell: function() {
	        var that = this,
	            $cell = that._getFocusedCell();
	        $cell && $cell.attr("tabIndex", null);
	        that._focusedView && that._focusedView.renderFocusState && that._focusedView.renderFocusState();
	        that._isNeedFocus = false;
	        that._isNeedScroll = false;
	        that._focusedCellPosition = {}
	    },
	    _getCellElementFromTarget: function(target) {
	        return $(target).closest("." + DATAGRID_ROW_CLASS + "> td")
	    },
	    init: function() {
	        var that = this;
	        if (that.option("useKeyboard")) {
	            that._dataController = that.getController("data");
	            that._selectionController = that.getController("selection");
	            that._editingController = that.getController("editing");
	            that._headerPanel = that.getView("headerPanel");
	            that._columnsController = that.getController("columns");
	            that.getController("editorFactory").focused.add(function($element) {
	                that.setupFocusedView();
	                if (that._isNeedScroll) {
	                    if ($element.is(":visible") && that._focusedView && that._focusedView.getScrollable) {
	                        that._scrollToElement($element);
	                        that._isNeedScroll = false
	                    }
	                }
	            });
	            that._focusedCellPosition = {};
	            that._dataController.changed.add(function(change) {
	                if (that._focusedCellPosition && change && "prepend" === change.changeType) {
	                    that._focusedCellPosition.rowIndex += change.items.length
	                }
	            });
	            that._initFocusedViews();
	            that._documentClickHandler = that.createAction(function(e) {
	                if (!$(e.jQueryEvent.target).closest("." + DATAGRID_ROWS_VIEW_CLASS).length) {
	                    that._resetFocusedCell()
	                }
	            });
	            that.createAction("onKeyDown");
	            $(document).on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), that._documentClickHandler)
	        }
	    },
	    _scrollToElement: function($element, offset) {
	        var scrollable = this._focusedView.getScrollable();
	        scrollable && scrollable.scrollToElement($element, offset)
	    },
	    focus: function($element) {
	        var focusView = this._getFocusedViewByElement($element);
	        if (focusView) {
	            this._focusView(focusView.view, focusView.viewIndex);
	            this._isNeedFocus = true;
	            this._isNeedScroll = true;
	            this._focus($element);
	            this._focusInteractiveElement($element)
	        }
	    },
	    getFocusedView: function() {
	        return this._focusedView
	    },
	    _getFocusedViewByElement: function($element) {
	        var condition = function(view) {
	            return $element.closest(view._$element).length
	        };
	        return this._getFocusedViewByCondition(condition)
	    },
	    _getFocusedViewByCondition: function(conditionFunction) {
	        var focusView;
	        $.each(this._focusedViews, function(index, view) {
	            if (conditionFunction(view)) {
	                focusView = {
	                    viewIndex: index,
	                    view: view
	                };
	                return false
	            }
	        });
	        return focusView
	    },
	    focusViewByName: function(viewName) {
	        var view = this._getFocusedViewByName(viewName);
	        this._focusView(view.view, view.viewIndex)
	    },
	    setupFocusedView: function() {
	        if (!commonUtils.isDefined(this._focusedView)) {
	            this.focusViewByName("rowsView")
	        }
	    },
	    _getFocusedViewByName: function(viewName) {
	        var condition = function(view) {
	            return view.name === viewName
	        };
	        return this._getFocusedViewByCondition(condition)
	    },
	    optionChanged: function(args) {
	        var that = this;
	        switch (args.name) {
	            case "useKeyboard":
	                args.handled = true;
	                break;
	            default:
	                that.callBase(args)
	        }
	    },
	    dispose: function() {
	        this.callBase();
	        this._focusedView = null;
	        this._focusedViews = null;
	        this._keyDownProcessor && this._keyDownProcessor.dispose();
	        $(document).off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler)
	    }
	});
	gridCore.registerModule("keyboardNavigation", {
	    defaultOptions: function() {
	        return {
	            useKeyboard: true
	        }
	    },
	    controllers: {
	        keyboardNavigation: exports.KeyboardNavigationController
	    },
	    extenders: {
	        views: {
	            rowsView: {
	                renderFocusState: function() {
	                    var $row, $cell, that = this,
	                        cellElements = that.getCellElements(0),
	                        keyboardNavigation = that.getController("keyboardNavigation"),
	                        oldFocusedView = keyboardNavigation._focusedView;
	                    that.element().attr("tabIndex", null);
	                    if (that.option("useKeyboard") && cellElements) {
	                        $row = cellElements.eq(0).parent();
	                        if (isGroupRow($row)) {
	                            $row.attr("tabIndex", 0)
	                        } else {
	                            keyboardNavigation._focusedView = that;
	                            for (var i = 0; i < cellElements.length; i++) {
	                                $cell = cellElements.eq(i);
	                                if (keyboardNavigation._isCellValid($cell)) {
	                                    if (isCellElement($cell)) {
	                                        $cell.attr("tabIndex", 0)
	                                    }
	                                    break
	                                }
	                            }
	                            keyboardNavigation._focusedView = oldFocusedView
	                        }
	                    }
	                },
	                renderDelayedTemplates: function() {
	                    this.callBase.apply(this, arguments);
	                    this.renderFocusState()
	                },
	                _renderCore: function(change) {
	                    this.callBase(change);
	                    this.renderFocusState()
	                }
	            }
	        },
	        controllers: {
	            editing: {
	                editCell: function(rowIndex, columnIndex) {
	                    var isCellEditing = this.callBase(rowIndex, columnIndex),
	                        keyboardNavigationController = this.getController("keyboardNavigation");
	                    if (isCellEditing) {
	                        keyboardNavigationController.setupFocusedView()
	                    }
	                    return isCellEditing
	                },
	                getFocusedCellInRow: function(rowIndex) {
	                    var keyboardNavigationController = this.getController("keyboardNavigation"),
	                        $cell = this.callBase(rowIndex);
	                    if (this.option("useKeyboard") && keyboardNavigationController._focusedCellPosition.rowIndex === rowIndex) {
	                        $cell = keyboardNavigationController._getFocusedCell() || $cell
	                    }
	                    return $cell
	                }
	            }
	        }
	    }
	});


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.summary_module.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    compileGetter = __webpack_require__(35).compileGetter,
	    errors = __webpack_require__(15),
	    gridCore = __webpack_require__(144),
	    messageLocalization = __webpack_require__(79),
	    dataSourceAdapter = __webpack_require__(153),
	    columnsView = __webpack_require__(147),
	    AggregateCalculator = __webpack_require__(286),
	    dataQuery = __webpack_require__(125),
	    dataUtils = __webpack_require__(122);
	var DATAGRID_TOTAL_FOOTER_CLASS = "dx-datagrid-total-footer",
	    DATAGRID_SUMMARY_ITEM_CLASS = "dx-datagrid-summary-item",
	    DATAGRID_TEXT_CONTENT_CLASS = "dx-datagrid-text-content",
	    DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
	    DATAGRID_GROUP_TEXT_CONTENT_CLASS = "dx-datagrid-group-text-content",
	    DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
	    DATAGRID_GROUP_FOOTER_ROW_TYPE = "groupFooter";
	var renderSummaryCell = function($cell, options) {
	        var i, summaryItem, column = options.column,
	            summaryItems = options.summaryItems,
	            $summaryItems = [];
	        if (!column.command && summaryItems) {
	            for (i = 0; i < summaryItems.length; i++) {
	                summaryItem = summaryItems[i];
	                $summaryItems.push($("<div>").css("text-align", summaryItem.alignment || column.alignment).addClass(DATAGRID_SUMMARY_ITEM_CLASS).addClass(DATAGRID_TEXT_CONTENT_CLASS).addClass(summaryItem.cssClass).toggleClass(DATAGRID_GROUP_TEXT_CONTENT_CLASS, "group" === options.rowType).text(gridCore.getSummaryText(summaryItem, options.summaryTexts)))
	            }
	            $cell.append($summaryItems)
	        }
	    },
	    getSummaryCellOptions = function(that, options) {
	        var summaryTexts = that.option("summary.texts") || {};
	        return {
	            totalItem: options.row,
	            summaryItems: options.row.summaryCells[options.columnIndex],
	            summaryTexts: summaryTexts
	        }
	    };
	var getGroupAggregates = function(data) {
	    return data.summary || data.aggregates || []
	};
	exports.FooterView = columnsView.ColumnsView.inherit(function() {
	    return {
	        _getRows: function() {
	            return this._dataController.footerItems()
	        },
	        _getCellOptions: function(options) {
	            return $.extend(this.callBase(options), getSummaryCellOptions(this, options))
	        },
	        _renderCellContent: function($cell, options) {
	            renderSummaryCell($cell, options);
	            this.callBase($cell, options)
	        },
	        _renderCore: function() {
	            var totalItem = this._dataController.footerItems()[0];
	            this.element().empty().addClass(DATAGRID_TOTAL_FOOTER_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !this.option("wordWrapEnabled"));
	            if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length) {
	                this._updateContent(this._renderTable())
	            }
	        },
	        _rowClick: function(e) {
	            var item = this._dataController.footerItems()[e.rowIndex] || {};
	            this.executeAction("onRowClick", $.extend({}, e, item))
	        },
	        _columnOptionChanged: function(e) {
	            var optionNames = e.optionNames;
	            if (e.changeTypes.grouping) {
	                return
	            }
	            if (optionNames.width || optionNames.visibleWidth) {
	                this.callBase(e)
	            }
	        },
	        _handleDataChanged: function(e) {
	            if ("refresh" === e.changeType) {
	                this.render()
	            }
	        },
	        getHeight: function() {
	            var $element = this.element();
	            return $element ? $element.outerHeight(true) : 0
	        },
	        isVisible: function() {
	            return !!this._dataController.footerItems().length
	        }
	    }
	}());
	var SummaryDataSourceAdapterExtender = function() {
	    return {
	        init: function() {
	            this.callBase.apply(this, arguments);
	            this._totalAggregates = [];
	            this._summaryGetter = $.noop
	        },
	        summaryGetter: function(summaryGetter) {
	            if (!arguments.length) {
	                return this._summaryGetter
	            }
	            if (commonUtils.isFunction(summaryGetter)) {
	                this._summaryGetter = summaryGetter
	            }
	        },
	        summary: function(summary) {
	            if (!arguments.length) {
	                return this._summaryGetter()
	            }
	            this._summaryGetter = function() {
	                return summary
	            }
	        },
	        totalAggregates: function() {
	            return this._totalAggregates
	        }
	    }
	}();
	var SummaryDataSourceAdapterClientExtender = function() {
	    var calculateAggregates = function(that, summary, data, groupLevel) {
	        var calculator;
	        if (summary) {
	            calculator = new AggregateCalculator({
	                totalAggregates: summary.totalAggregates,
	                groupAggregates: summary.groupAggregates,
	                data: data,
	                groupLevel: groupLevel
	            });
	            calculator.calculate()
	        }
	        return calculator ? calculator.totalAggregates() : []
	    };
	    var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
	        if (!items || !groups.length) {
	            return items
	        }
	        var query, group = groups[0],
	            sorts = sortByGroups[0];
	        if (group && sorts && sorts.length) {
	            query = dataQuery(items);
	            $.each(sorts, function(index) {
	                if (0 === index) {
	                    query = query.sortBy(this.selector, this.desc)
	                } else {
	                    query = query.thenBy(this.selector, this.desc)
	                }
	            });
	            query.enumerate().done(function(sortedItems) {
	                items = sortedItems
	            })
	        }
	        groups = groups.slice(1);
	        sortByGroups = sortByGroups.slice(1);
	        if (groups.length && sortByGroups.length) {
	            $.each(items, function() {
	                this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups)
	            })
	        }
	        return items
	    };
	    var sortGroupsBySummary = function(data, group, summary) {
	        var sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
	        if (sortByGroups && sortByGroups.length) {
	            return sortGroupsBySummaryCore(data, group, sortByGroups)
	        }
	        return data
	    };
	    return {
	        _customizeRemoteOperations: function(options) {
	            var summary = this.summary();
	            if (summary) {
	                if (options.remoteOperations.summary) {
	                    if (!options.isCustomLoading || options.storeLoadOptions.isLoadingAll) {
	                        if (options.storeLoadOptions.group) {
	                            if (options.remoteOperations.grouping) {
	                                options.storeLoadOptions.groupSummary = summary.groupAggregates
	                            } else {
	                                if (summary.groupAggregates.length) {
	                                    options.remoteOperations.paging = false
	                                }
	                            }
	                        }
	                        options.storeLoadOptions.totalSummary = summary.totalAggregates
	                    }
	                } else {
	                    if (summary.totalAggregates.length || summary.groupAggregates.length && options.storeLoadOptions.group) {
	                        options.remoteOperations.paging = false
	                    }
	                }
	            }
	            this.callBase.apply(this, arguments)
	        },
	        _handleDataLoadedCore: function(options) {
	            var totalAggregates, that = this,
	                groups = dataUtils.normalizeSortingInfo(options.loadOptions.group || []),
	                remoteOperations = options.remoteOperations || {},
	                summary = that.summaryGetter()(remoteOperations);
	            if (remoteOperations.summary) {
	                if (!remoteOperations.paging && !remoteOperations.grouping && groups.length && summary) {
	                    calculateAggregates(that, {
	                        groupAggregates: summary.groupAggregates
	                    }, options.data, groups.length);
	                    options.data = sortGroupsBySummary(options.data, groups, summary)
	                }
	            } else {
	                if (!remoteOperations.paging) {
	                    totalAggregates = calculateAggregates(that, summary, options.data, groups.length);
	                    options.data = sortGroupsBySummary(options.data, groups, summary);
	                    options.extra = options.extra || {};
	                    options.extra.summary = totalAggregates
	                }
	            }
	            if (!options.isCustomLoading) {
	                that._totalAggregates = options.extra && options.extra.summary || that._totalAggregates
	            }
	            that.callBase(options)
	        }
	    }
	}();
	dataSourceAdapter.extend(SummaryDataSourceAdapterExtender);
	dataSourceAdapter.extend(SummaryDataSourceAdapterClientExtender);
	exports.renderSummaryCell = renderSummaryCell;
	gridCore.registerModule("summary", {
	    defaultOptions: function() {
	        return {
	            summary: {
	                groupItems: void 0,
	                totalItems: void 0,
	                calculateCustomSummary: void 0,
	                skipEmptyValues: true,
	                texts: {
	                    sum: messageLocalization.getFormatter("dxDataGrid-summarySum"),
	                    sumOtherColumn: messageLocalization.getFormatter("dxDataGrid-summarySumOtherColumn"),
	                    min: messageLocalization.getFormatter("dxDataGrid-summaryMin"),
	                    minOtherColumn: messageLocalization.getFormatter("dxDataGrid-summaryMinOtherColumn"),
	                    max: messageLocalization.getFormatter("dxDataGrid-summaryMax"),
	                    maxOtherColumn: messageLocalization.getFormatter("dxDataGrid-summaryMaxOtherColumn"),
	                    avg: messageLocalization.getFormatter("dxDataGrid-summaryAvg"),
	                    avgOtherColumn: messageLocalization.getFormatter("dxDataGrid-summaryAvgOtherColumn"),
	                    count: messageLocalization.getFormatter("dxDataGrid-summaryCount")
	                }
	            },
	            sortByGroupSummaryInfo: void 0
	        }
	    },
	    views: {
	        footerView: exports.FooterView
	    },
	    extenders: {
	        controllers: {
	            data: function() {
	                return {
	                    _isDataColumn: function(column) {
	                        return column && (!commonUtils.isDefined(column.groupIndex) || column.showWhenGrouped)
	                    },
	                    _isGroupFooterVisible: function() {
	                        var groupItem, column, i, groupItems = this.option("summary.groupItems") || [];
	                        for (i = 0; i < groupItems.length; i++) {
	                            groupItem = groupItems[i];
	                            column = this._columnsController.columnOption(groupItem.showInColumn || groupItem.column);
	                            if (groupItem.showInGroupFooter && this._isDataColumn(column)) {
	                                return true
	                            }
	                        }
	                        return false
	                    },
	                    _processGroupItems: function(items, groupCount, options) {
	                        var result = this.callBase.apply(this, arguments);
	                        if (options) {
	                            if (void 0 === options.isGroupFooterVisible) {
	                                options.isGroupFooterVisible = this._isGroupFooterVisible()
	                            }
	                            if (options.data && options.data.items && options.isGroupFooterVisible && (options.collectContinuationItems || !options.data.isContinuationOnNextPage)) {
	                                result.push({
	                                    rowType: DATAGRID_GROUP_FOOTER_ROW_TYPE,
	                                    data: options.data,
	                                    groupIndex: options.path.length - 1,
	                                    values: []
	                                })
	                            }
	                        }
	                        return result
	                    },
	                    _processGroupItem: function(groupItem, options) {
	                        var that = this;
	                        if (!options.summaryGroupItems) {
	                            options.summaryGroupItems = that.option("summary.groupItems") || []
	                        }
	                        if ("group" === groupItem.rowType) {
	                            var groupColumnIndex = -1,
	                                afterGroupColumnIndex = -1;
	                            $.each(options.visibleColumns, function(visibleIndex) {
	                                var prevColumn = options.visibleColumns[visibleIndex - 1];
	                                if (groupItem.groupIndex === this.groupIndex) {
	                                    groupColumnIndex = this.index
	                                }
	                                if (visibleIndex > 0 && "expand" === prevColumn.command && "expand" !== this.command) {
	                                    afterGroupColumnIndex = this.index
	                                }
	                            });
	                            groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
	                                if (summaryItem.showInGroupFooter) {
	                                    return -1
	                                }
	                                if (summaryItem.alignByColumn && column && !commonUtils.isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex) {
	                                    return column.index
	                                } else {
	                                    return groupColumnIndex
	                                }
	                            })
	                        }
	                        if (groupItem.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE) {
	                            groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
	                                return summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1
	                            })
	                        }
	                        return groupItem
	                    },
	                    _calculateSummaryCells: function(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex) {
	                        var that = this,
	                            summaryCells = [],
	                            summaryCellsByColumns = {};
	                        $.each(summaryItems, function(summaryIndex, summaryItem) {
	                            var aggregate, column = that._columnsController.columnOption(summaryItem.column),
	                                showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column,
	                                columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn);
	                            if (columnIndex >= 0) {
	                                if (!summaryCellsByColumns[columnIndex]) {
	                                    summaryCellsByColumns[columnIndex] = []
	                                }
	                                aggregate = aggregates[summaryIndex];
	                                if (aggregate === aggregate) {
	                                    summaryCellsByColumns[columnIndex].push($.extend({}, summaryItem, {
	                                        value: commonUtils.isString(aggregate) && column && column.deserializeValue ? column.deserializeValue(aggregate) : aggregate,
	                                        valueFormat: !commonUtils.isDefined(summaryItem.valueFormat) ? gridCore.getFormatByDataType(column && column.dataType) : summaryItem.valueFormat,
	                                        columnCaption: column && column.index !== columnIndex ? column.caption : void 0
	                                    }))
	                                }
	                            }
	                        });
	                        if (!$.isEmptyObject(summaryCellsByColumns)) {
	                            $.each(visibleColumns, function() {
	                                summaryCells.push(summaryCellsByColumns[this.index] || [])
	                            })
	                        }
	                        return summaryCells
	                    },
	                    _getSummaryCells: function(summaryTotalItems, totalAggregates) {
	                        var that = this,
	                            columnsController = that._columnsController;
	                        return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), function(summaryItem, column) {
	                            return that._isDataColumn(column) ? column.index : -1
	                        })
	                    },
	                    _updateItemsCore: function(change) {
	                        var summaryCells, totalAggregates, that = this,
	                            dataSource = that._dataSource,
	                            summaryTotalItems = that.option("summary.totalItems");
	                        that.callBase(change);
	                        that._footerItems = [];
	                        if (dataSource && summaryTotalItems && summaryTotalItems.length) {
	                            totalAggregates = dataSource.totalAggregates();
	                            summaryCells = this._getSummaryCells(summaryTotalItems, totalAggregates);
	                            if (summaryCells.length) {
	                                that._footerItems.push({
	                                    rowType: "totalFooter",
	                                    summaryCells: summaryCells
	                                })
	                            }
	                        }
	                    },
	                    _getAggregates: function(summaryItems, remoteOperations) {
	                        var that = this,
	                            columnsController = that.getController("columns"),
	                            calculateCustomSummary = that.option("summary.calculateCustomSummary"),
	                            commonSkipEmptyValues = that.option("summary.skipEmptyValues");
	                        return $.map(summaryItems || [], function(summaryItem) {
	                            var options, column = columnsController.columnOption(summaryItem.column),
	                                calculateCellValue = column && column.calculateCellValue ? $.proxy(column, "calculateCellValue") : compileGetter(column ? column.dataField : summaryItem.column),
	                                aggregator = summaryItem.summaryType || "count",
	                                selector = summaryItem.column,
	                                skipEmptyValues = commonUtils.isDefined(summaryItem.skipEmptyValues) ? summaryItem.skipEmptyValues : commonSkipEmptyValues;
	                            if (remoteOperations) {
	                                return {
	                                    selector: summaryItem.column,
	                                    summaryType: summaryItem.summaryType
	                                }
	                            } else {
	                                if ("avg" === aggregator || "sum" === aggregator) {
	                                    selector = function(data) {
	                                        var value = calculateCellValue(data);
	                                        return commonUtils.isDefined(value) ? Number(value) : value
	                                    }
	                                } else {
	                                    selector = calculateCellValue
	                                }
	                                if ("custom" === aggregator) {
	                                    if (!calculateCustomSummary) {
	                                        errors.log("E1026");
	                                        calculateCustomSummary = function() {}
	                                    }
	                                    options = {
	                                        component: that.component,
	                                        name: summaryItem.name
	                                    };
	                                    calculateCustomSummary(options);
	                                    options.summaryProcess = "calculate";
	                                    aggregator = {
	                                        seed: function() {
	                                            options.summaryProcess = "start";
	                                            options.totalValue = void 0;
	                                            delete options.value;
	                                            calculateCustomSummary(options);
	                                            return options.totalValue
	                                        },
	                                        step: function(totalValue, value) {
	                                            options.summaryProcess = "calculate";
	                                            options.totalValue = totalValue;
	                                            options.value = value;
	                                            calculateCustomSummary(options);
	                                            return options.totalValue
	                                        },
	                                        finalize: function(totalValue) {
	                                            options.summaryProcess = "finalize";
	                                            options.totalValue = totalValue;
	                                            delete options.value;
	                                            calculateCustomSummary(options);
	                                            return options.totalValue
	                                        }
	                                    }
	                                }
	                                return {
	                                    selector: selector,
	                                    aggregator: aggregator,
	                                    skipEmptyValues: skipEmptyValues
	                                }
	                            }
	                        })
	                    },
	                    _addSortInfo: function(sortByGroups, groupColumn, selector, sortOrder) {
	                        var groupIndex;
	                        if (groupColumn) {
	                            groupIndex = groupColumn.groupIndex;
	                            sortOrder = sortOrder || groupColumn.sortOrder;
	                            if (commonUtils.isDefined(groupIndex)) {
	                                sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
	                                sortByGroups[groupIndex].push({
	                                    selector: selector,
	                                    desc: "desc" === sortOrder
	                                })
	                            }
	                        }
	                    },
	                    _findSummaryItem: function(summaryItems, name) {
	                        var summaryItemIndex = -1;
	                        var getFullName = function(summaryItem) {
	                            var summaryType = summaryItem.summaryType,
	                                column = summaryItem.column;
	                            return summaryType && column && summaryType + "_" + column
	                        };
	                        if (commonUtils.isDefined(name)) {
	                            $.each(summaryItems || [], function(index) {
	                                if (this.name === name || index === name || this.summaryType === name || this.column === name || getFullName(this) === name) {
	                                    summaryItemIndex = index;
	                                    return false
	                                }
	                            })
	                        }
	                        return summaryItemIndex
	                    },
	                    _getSummarySortByGroups: function(sortByGroupSummaryInfo, groupSummaryItems) {
	                        var that = this,
	                            columnsController = that._columnsController,
	                            groupColumns = columnsController.getGroupColumns(),
	                            sortByGroups = [];
	                        if (!groupSummaryItems || !groupSummaryItems.length) {
	                            return
	                        }
	                        $.each(sortByGroupSummaryInfo || [], function() {
	                            var sortOrder = this.sortOrder,
	                                groupColumn = this.groupColumn,
	                                summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
	                            if (summaryItemIndex < 0) {
	                                return
	                            }
	                            var selector = function(data) {
	                                return getGroupAggregates(data)[summaryItemIndex]
	                            };
	                            if (commonUtils.isDefined(groupColumn)) {
	                                groupColumn = columnsController.columnOption(groupColumn);
	                                that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
	                            } else {
	                                $.each(groupColumns, function(groupIndex, groupColumn) {
	                                    that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
	                                })
	                            }
	                        });
	                        return sortByGroups
	                    },
	                    _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
	                        var that = this,
	                            dataSourceAdapter = this.callBase(dataSource, remoteOperations);
	                        dataSourceAdapter.summaryGetter(function(currentRemoteOperations) {
	                            return that._getSummaryOptions(currentRemoteOperations || remoteOperations)
	                        });
	                        return dataSourceAdapter
	                    },
	                    _getSummaryOptions: function(remoteOperations) {
	                        var that = this,
	                            groupSummaryItems = that.option("summary.groupItems"),
	                            totalSummaryItems = that.option("summary.totalItems"),
	                            sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo"),
	                            groupAggregates = that._getAggregates(groupSummaryItems, remoteOperations && remoteOperations.grouping && remoteOperations.summary),
	                            totalAggregates = that._getAggregates(totalSummaryItems, remoteOperations && remoteOperations.summary),
	                            sortByGroups = function() {
	                                return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems)
	                            };
	                        if (groupAggregates.length || totalAggregates.length) {
	                            return {
	                                groupAggregates: groupAggregates,
	                                totalAggregates: totalAggregates,
	                                sortByGroups: sortByGroups
	                            }
	                        }
	                    },
	                    publicMethods: function() {
	                        var methods = this.callBase();
	                        methods.push("getTotalSummaryValue");
	                        return methods
	                    },
	                    getTotalSummaryValue: function(summaryItemName) {
	                        var summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName),
	                            aggregates = this._dataSource.totalAggregates();
	                        if (aggregates.length && summaryItemIndex > -1) {
	                            return aggregates[summaryItemIndex]
	                        }
	                    },
	                    optionChanged: function(args) {
	                        if ("summary" === args.name || "sortByGroupSummaryInfo" === args.name) {
	                            args.name = "dataSource"
	                        }
	                        this.callBase(args)
	                    },
	                    init: function() {
	                        this._footerItems = [];
	                        this.callBase()
	                    },
	                    footerItems: function() {
	                        return this._footerItems
	                    }
	                }
	            }()
	        },
	        views: {
	            rowsView: function() {
	                return {
	                    _createRow: function(row) {
	                        var $row = this.callBase(row);
	                        row && $row.addClass(row.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE ? DATAGRID_GROUP_FOOTER_CLASS : "");
	                        return $row
	                    },
	                    _renderCells: function($row, options) {
	                        this.callBase.apply(this, arguments);
	                        if ("group" === options.row.rowType && options.row.summaryCells && options.row.summaryCells.length) {
	                            this._renderGroupSummaryCells($row, options)
	                        }
	                    },
	                    _hasAlignByColumnSummaryItems: function(columnIndex, options) {
	                        return !commonUtils.isDefined(options.columns[columnIndex].groupIndex) && options.row.summaryCells[columnIndex].length
	                    },
	                    _getAlignByColumnCellCount: function(groupCellColSpan, options) {
	                        var columnIndex, alignByColumnCellCount = 0;
	                        for (var i = 1; i < groupCellColSpan; i++) {
	                            columnIndex = options.row.summaryCells.length - i;
	                            alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options) ? i : alignByColumnCellCount
	                        }
	                        return alignByColumnCellCount
	                    },
	                    _renderGroupSummaryCells: function($row, options) {
	                        var $groupCell = $row.children().last(),
	                            groupCellColSpan = Number($groupCell.attr("colspan")) || 1,
	                            alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
	                        this._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount)
	                    },
	                    _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
	                        if (alignByColumnCellCount > 0) {
	                            $groupCell.attr("colspan", groupCellColSpan - alignByColumnCellCount);
	                            for (var i = 0; i < alignByColumnCellCount; i++) {
	                                var columnIndex = options.columns.length - alignByColumnCellCount + i;
	                                this._renderCell($groupCell.parent(), $.extend({
	                                    column: options.columns[columnIndex],
	                                    columnIndex: this._getSummaryCellIndex(columnIndex, options.columns)
	                                }, options))
	                            }
	                        }
	                    },
	                    _getSummaryCellIndex: function(columnIndex) {
	                        return columnIndex
	                    },
	                    _getCellTemplate: function(options) {
	                        if (!options.column.command && !commonUtils.isDefined(options.column.groupIndex) && options.summaryItems && options.summaryItems.length) {
	                            return renderSummaryCell
	                        } else {
	                            return this.callBase(options)
	                        }
	                    },
	                    _getCellOptions: function(options) {
	                        var that = this,
	                            parameters = that.callBase(options);
	                        if (options.row.summaryCells) {
	                            return $.extend(parameters, getSummaryCellOptions(that, options))
	                        } else {
	                            return parameters
	                        }
	                    }
	                }
	            }()
	        }
	    }
	});


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/aggregate_calculator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    compileGetter = __webpack_require__(35).compileGetter,
	    errors = __webpack_require__(124).errors,
	    dataUtils = __webpack_require__(122);

	function depthFirstSearch(i, depth, root, callback) {
	    var j = 0;
	    if (i < depth) {
	        for (; j < root.items.length; j++) {
	            depthFirstSearch(i + 1, depth, root.items[j], callback)
	        }
	    }
	    if (i === depth) {
	        callback(root)
	    }
	}

	function map(array, callback) {
	    var i, result;
	    if ("map" in array) {
	        return array.map(callback)
	    }
	    result = new Array(array.length);
	    for (i in array) {
	        result[i] = callback(array[i], i)
	    }
	    return result
	}

	function isEmpty(x) {
	    return x !== x || "" === x || null === x || void 0 === x
	}

	function isCount(aggregator) {
	    return aggregator === dataUtils.aggregators.count
	}

	function normalizeAggregate(aggregate) {
	    var selector = compileGetter(aggregate.selector),
	        skipEmptyValues = "skipEmptyValues" in aggregate ? aggregate.skipEmptyValues : true,
	        aggregator = aggregate.aggregator;
	    if ("string" === typeof aggregator) {
	        aggregator = dataUtils.aggregators[aggregator];
	        if (!aggregator) {
	            throw errors.Error("E4001", aggregate.aggregator)
	        }
	    }
	    return {
	        selector: selector,
	        aggregator: aggregator,
	        skipEmptyValues: skipEmptyValues
	    }
	}
	module.exports = Class.inherit({
	    ctor: function(options) {
	        this._data = options.data;
	        this._groupLevel = options.groupLevel || 0;
	        this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);
	        this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);
	        this._totals = []
	    },
	    calculate: function() {
	        if (this._totalAggregates.length) {
	            this._calculateTotals(0, {
	                items: this._data
	            })
	        }
	        if (this._groupAggregates.length && this._groupLevel > 0) {
	            this._calculateGroups({
	                items: this._data
	            })
	        }
	    },
	    totalAggregates: function() {
	        return this._totals
	    },
	    _aggregate: function(aggregates, data, container) {
	        var i, j;
	        for (i = 0; i < aggregates.length; i++) {
	            if (isCount(aggregates[i].aggregator)) {
	                container[i] = (container[i] || 0) + data.items.length;
	                continue
	            }
	            for (j = 0; j < data.items.length; j++) {
	                this._accumulate(i, aggregates[i], container, data.items[j])
	            }
	        }
	    },
	    _calculateTotals: function(level, data) {
	        var i;
	        if (0 === level) {
	            this._totals = this._seed(this._totalAggregates)
	        }
	        if (level === this._groupLevel) {
	            this._aggregate(this._totalAggregates, data, this._totals)
	        } else {
	            for (i = 0; i < data.items.length; i++) {
	                this._calculateTotals(level + 1, data.items[i])
	            }
	        }
	        if (0 === level) {
	            this._totals = this._finalize(this._totalAggregates, this._totals)
	        }
	    },
	    _calculateGroups: function(root) {
	        var maxLevel = this._groupLevel,
	            currentLevel = maxLevel + 1,
	            seedFn = $.proxy(this._seed, this, this._groupAggregates),
	            stepFn = $.proxy(this._aggregate, this, this._groupAggregates),
	            finalizeFn = $.proxy(this._finalize, this, this._groupAggregates);

	        function aggregator(node) {
	            node.aggregates = seedFn();
	            if (currentLevel === maxLevel) {
	                stepFn(node, node.aggregates)
	            } else {
	                depthFirstSearch(currentLevel, maxLevel, node, function(innerNode) {
	                    stepFn(innerNode, node.aggregates)
	                })
	            }
	            node.aggregates = finalizeFn(node.aggregates)
	        }
	        while (--currentLevel > 0) {
	            depthFirstSearch(0, currentLevel, root, aggregator)
	        }
	    },
	    _seed: function(aggregates) {
	        return map(aggregates, function(aggregate) {
	            var aggregator = aggregate.aggregator,
	                seed = "seed" in aggregator ? $.isFunction(aggregator.seed) ? aggregator.seed() : aggregator.seed : NaN;
	            return seed
	        })
	    },
	    _accumulate: function(aggregateIndex, aggregate, results, item) {
	        var value = aggregate.selector(item),
	            aggregator = aggregate.aggregator,
	            skipEmptyValues = aggregate.skipEmptyValues;
	        if (skipEmptyValues && isEmpty(value)) {
	            return
	        }
	        if (results[aggregateIndex] !== results[aggregateIndex]) {
	            results[aggregateIndex] = value
	        } else {
	            results[aggregateIndex] = aggregator.step(results[aggregateIndex], value)
	        }
	    },
	    _finalize: function(aggregates, results) {
	        return map(aggregates, function(aggregate, index) {
	            var fin = aggregate.aggregator.finalize;
	            return fin ? fin(results[index]) : results[index]
	        })
	    }
	});


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.fixed_columns.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    browser = __webpack_require__(16),
	    commonUtils = __webpack_require__(8),
	    wheelEvent = __webpack_require__(75),
	    messageLocalization = __webpack_require__(79),
	    gridCore = __webpack_require__(144);
	var DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
	    DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
	    DATAGRID_FIRST_CELL_CLASS = "dx-first-cell",
	    DATAGRID_LAST_CELL_CLASS = "dx-last-cell",
	    DATAGRID_HOVER_STATE_CLASS = "dx-state-hover",
	    DATAGRID_CONTENT_FIXED_CLASS = "dx-datagrid-content-fixed",
	    DATAGRID_FIXED_COL_CLASS = "dx-col-fixed",
	    DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
	    DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
	    getTransparentColumnIndex = function(fixedColumns) {
	        var transparentColumnIndex = -1;
	        $.each(fixedColumns, function(index, column) {
	            if ("transparent" === column.command) {
	                transparentColumnIndex = index;
	                return false
	            }
	        });
	        return transparentColumnIndex
	    },
	    normalizeColumnWidths = function(fixedColumns, widths, fixedWidths) {
	        var i, fixedColumnIndex = 0;
	        if (fixedColumns && widths && fixedWidths) {
	            for (i = 0; i < fixedColumns.length; i++) {
	                if ("transparent" === fixedColumns[i].command) {
	                    fixedColumnIndex += fixedColumns[i].colspan
	                } else {
	                    if (widths[fixedColumnIndex] < fixedWidths[i]) {
	                        widths[fixedColumnIndex] = fixedWidths[i]
	                    }
	                    fixedColumnIndex++
	                }
	            }
	        }
	        return widths
	    };
	var baseFixedColumns = {
	    init: function() {
	        this.callBase();
	        this._isFixedTableRendering = false;
	        this._isFixedColumns = false
	    },
	    _createCol: function(column) {
	        return this.callBase(column).toggleClass(DATAGRID_FIXED_COL_CLASS, !!(this._isFixedTableRendering && (column.fixed || column.command && "transparent" !== column.command)))
	    },
	    _renderTable: function(options) {
	        var $fixedTable, $table, that = this,
	            fixedColumns = that.getFixedColumns();
	        that._isFixedColumns = !!fixedColumns.length;
	        $table = that.callBase(options);
	        if (that._isFixedColumns) {
	            that._isFixedTableRendering = true;
	            $fixedTable = that._createTable(fixedColumns);
	            that._renderRows($fixedTable, $.extend({}, options, {
	                columns: fixedColumns
	            }));
	            that._updateContent($fixedTable, options && options.change);
	            that._isFixedTableRendering = false
	        } else {
	            that._fixedTableElement && that._fixedTableElement.remove();
	            that._fixedTableElement = null
	        }
	        return $table
	    },
	    _createCell: function(options) {
	        var fixedColumns, prevFixedColumn, transparentColumnIndex, that = this,
	            column = options.column,
	            columnCommand = column && column.command,
	            rowType = options.rowType,
	            $cell = that.callBase.apply(that, arguments);
	        if (that._isFixedTableRendering || "filter" === rowType) {
	            fixedColumns = that.getFixedColumns();
	            transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
	            prevFixedColumn = fixedColumns[transparentColumnIndex - 1]
	        }
	        if (that._isFixedTableRendering) {
	            if ("transparent" === columnCommand) {
	                $cell.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS).toggleClass(DATAGRID_FIRST_CELL_CLASS, 0 === transparentColumnIndex || prevFixedColumn && "expand" === prevFixedColumn.command).toggleClass(DATAGRID_LAST_CELL_CLASS, fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1).html("freeSpace" !== rowType ? "&nbsp;" : "")
	            }
	        } else {
	            if ("filter" === rowType) {
	                $cell.toggleClass(DATAGRID_FIRST_CELL_CLASS, options.columnIndex === transparentColumnIndex)
	            }
	        }
	        return $cell
	    },
	    _wrapTableInScrollContainer: function() {
	        var $scrollContainer = this.callBase.apply(this, arguments);
	        if (this._isFixedTableRendering) {
	            $scrollContainer.addClass(DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS)
	        }
	        return $scrollContainer
	    },
	    _renderCellContent: function($cell, options) {
	        var columns, isEmptyCell, transparentColumnIndex, alignByFixedColumnCellCount, that = this,
	            column = options.column;
	        if (!that._isFixedTableRendering && that._isFixedColumns) {
	            isEmptyCell = column.fixed || column.command;
	            if ("group" === options.rowType && commonUtils.isDefined(column.groupIndex)) {
	                isEmptyCell = false;
	                if (options.row.summaryCells && options.row.summaryCells.length) {
	                    columns = that._columnsController.getVisibleColumns();
	                    alignByFixedColumnCellCount = that._getAlignByColumnCellCount ? that._getAlignByColumnCellCount(column.colspan, {
	                        columns: columns,
	                        row: options.row,
	                        isFixed: true
	                    }) : 0;
	                    if (alignByFixedColumnCellCount > 0) {
	                        transparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());
	                        isEmptyCell = columns.length - alignByFixedColumnCellCount < transparentColumnIndex
	                    }
	                }
	            }
	            if (isEmptyCell) {
	                $cell.html("&nbsp;").addClass(column.cssClass);
	                return
	            }
	        }
	        if ("transparent" !== column.command) {
	            that.callBase($cell, options)
	        }
	    },
	    _getCellElementsCore: function(rowIndex) {
	        var fixedColumns, fixedColumnIndex, fixedCellElements, that = this,
	            cellElements = that.callBase(rowIndex),
	            index = "columnHeadersView" === that.name ? rowIndex : void 0;
	        if (that._fixedTableElement && cellElements) {
	            fixedColumns = that.getFixedColumns(index);
	            fixedCellElements = that._getRowElements(that._fixedTableElement).eq(rowIndex).children("td");
	            $.each(fixedColumns, function(columnIndex, column) {
	                if ("transparent" === column.command) {
	                    if (fixedCellElements.eq(columnIndex).hasClass(DATAGRID_MASTER_DETAIL_CELL_CLASS)) {
	                        cellElements[columnIndex] = fixedCellElements.get(columnIndex)
	                    }
	                } else {
	                    fixedColumnIndex = that._columnsController.getVisibleIndex(column.index, index);
	                    cellElements[fixedColumnIndex] = fixedCellElements.get(columnIndex)
	                }
	            })
	        }
	        return cellElements
	    },
	    getColumnWidths: function() {
	        var fixedWidths, that = this,
	            result = that.callBase(),
	            fixedColumns = that.getFixedColumns();
	        if (that._fixedTableElement && result.length) {
	            fixedWidths = that.callBase(that._fixedTableElement)
	        }
	        return normalizeColumnWidths(fixedColumns, result, fixedWidths)
	    },
	    _getTableElement: function() {
	        var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();
	        return tableElement
	    },
	    _setTableElement: function(tableElement) {
	        if (this._isFixedTableRendering) {
	            this._fixedTableElement = tableElement.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS)
	        } else {
	            this.callBase(tableElement)
	        }
	    },
	    getColumns: function(rowIndex, $tableElement) {
	        $tableElement = $tableElement || this._getTableElement();
	        if (this._isFixedTableRendering || $tableElement && $tableElement.closest("table").parent("." + DATAGRID_CONTENT_FIXED_CLASS).length) {
	            return this.getFixedColumns(rowIndex)
	        }
	        return this.callBase(rowIndex, $tableElement)
	    },
	    getRowIndex: function($row) {
	        var $fixedTable = this._fixedTableElement;
	        if ($fixedTable && $fixedTable.find($row).length) {
	            return this._getRowElements($fixedTable).index($row)
	        }
	        return this.callBase($row)
	    },
	    getTableElements: function() {
	        var result = this.callBase.apply(this, arguments);
	        if (this._fixedTableElement) {
	            result = result.add(this._fixedTableElement)
	        }
	        return result
	    },
	    getFixedColumns: function(rowIndex) {
	        return this._columnsController.getFixedColumns(rowIndex)
	    },
	    getFixedColumnsOffset: function() {
	        var $transparentColumn, positionTransparentColumn, offset = {
	            left: 0,
	            right: 0
	        };
	        if (this._fixedTableElement) {
	            $transparentColumn = this.getTransparentColumnElement();
	            positionTransparentColumn = $transparentColumn.position();
	            offset = {
	                left: positionTransparentColumn.left,
	                right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)
	            }
	        }
	        return offset
	    },
	    getTransparentColumnElement: function() {
	        return this._fixedTableElement && this._fixedTableElement.find("." + DATAGRID_POINTER_EVENTS_NONE_CLASS).first()
	    },
	    getFixedTableElement: function() {
	        return this._fixedTableElement
	    },
	    isFixedColumns: function() {
	        return this._isFixedColumns
	    },
	    _resizeCore: function() {
	        this.callBase();
	        this.synchronizeRows()
	    },
	    setColumnWidths: function(widths) {
	        var columns;
	        this.callBase.apply(this, arguments);
	        if (this._fixedTableElement) {
	            if (widths && widths.length && !this.isScrollbarVisible(true)) {
	                columns = this._columnsController.getVisibleColumns()
	            }
	            this.callBase(widths, this._fixedTableElement, columns)
	        }
	        this.synchronizeRows()
	    },
	    _getClientHeight: function(element) {
	        var boundingClientRectElement = element.getBoundingClientRect && element.getBoundingClientRect();
	        return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight
	    },
	    synchronizeRows: function() {
	        var rowHeight, fixedRowHeight, rowIndex, heightTable, heightFixedTable, $rowElements, $fixedRowElements, that = this,
	            rowHeights = [],
	            fixedRowHeights = [];
	        if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {
	            heightTable = that._getClientHeight(that._tableElement.get(0));
	            heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));
	            $rowElements = that._getRowElements(that._tableElement);
	            $fixedRowElements = that._getRowElements(that._fixedTableElement);
	            if (heightTable !== heightFixedTable) {
	                $rowElements.css("height", "");
	                $fixedRowElements.css("height", "");
	                for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
	                    rowHeights.push(that._getClientHeight($rowElements.get(rowIndex)));
	                    fixedRowHeights.push(that._getClientHeight($fixedRowElements.get(rowIndex)))
	                }
	                for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
	                    rowHeight = rowHeights[rowIndex];
	                    fixedRowHeight = fixedRowHeights[rowIndex];
	                    if (rowHeight > fixedRowHeight) {
	                        $fixedRowElements.eq(rowIndex).css("height", rowHeight)
	                    } else {
	                        if (rowHeight < fixedRowHeight) {
	                            $rowElements.eq(rowIndex).css("height", fixedRowHeight)
	                        }
	                    }
	                }
	            }
	        }
	    }
	};
	var ColumnHeadersViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
	    _getRowVisibleColumns: function(rowIndex) {
	        if (this._isFixedTableRendering) {
	            return this.getFixedColumns(rowIndex)
	        }
	        return this.callBase(rowIndex)
	    },
	    getContextMenuItems: function(options) {
	        var onItemClick, that = this,
	            column = options.column,
	            columnFixingOptions = that.option("columnFixing"),
	            items = that.callBase(options);
	        if (options.row && "header" === options.row.rowType) {
	            if (column && column.allowFixing) {
	                onItemClick = function(params) {
	                    switch (params.itemData.value) {
	                        case "none":
	                            that._columnsController.columnOption(column.index, "fixed", false);
	                            break;
	                        case "left":
	                            that._columnsController.columnOption(column.index, {
	                                fixed: true,
	                                fixedPosition: "left"
	                            });
	                            break;
	                        case "right":
	                            that._columnsController.columnOption(column.index, {
	                                fixed: true,
	                                fixedPosition: "right"
	                            })
	                    }
	                };
	                items = items || [];
	                items.push({
	                    text: columnFixingOptions.texts.fix,
	                    beginGroup: true,
	                    items: [{
	                        text: columnFixingOptions.texts.leftPosition,
	                        value: "left",
	                        disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
	                        onItemClick: onItemClick
	                    }, {
	                        text: columnFixingOptions.texts.rightPosition,
	                        value: "right",
	                        disabled: column.fixed && "right" === column.fixedPosition,
	                        onItemClick: onItemClick
	                    }]
	                }, {
	                    text: columnFixingOptions.texts.unfix,
	                    value: "none",
	                    disabled: !column.fixed,
	                    onItemClick: onItemClick
	                })
	            }
	        }
	        return items
	    },
	    setScrollerSpacing: function(width) {
	        var that = this,
	            rtlEnabled = that.option("rtlEnabled");
	        that.callBase(width);
	        that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS).css(rtlEnabled ? {
	            paddingLeft: width
	        } : {
	            paddingRight: width
	        })
	    },
	    getFixedColumnElements: function(rowIndex) {
	        var columnElements, transparentColumnIndex, $transparentColumnElement, that = this;
	        if (commonUtils.isDefined(rowIndex)) {
	            return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children()
	        }
	        columnElements = that.getColumnElements();
	        $transparentColumnElement = that.getTransparentColumnElement();
	        if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {
	            transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());
	            columnElements.splice(transparentColumnIndex, $transparentColumnElement.get(0).colSpan, $transparentColumnElement.get(0))
	        }
	        return columnElements
	    },
	    getColumnWidths: function() {
	        var fixedWidths, that = this,
	            result = that.callBase(),
	            $fixedColumnElements = that.getFixedColumnElements(),
	            fixedColumns = that.getFixedColumns();
	        if (that._fixedTableElement) {
	            if ($fixedColumnElements && $fixedColumnElements.length) {
	                fixedWidths = that._getWidths($fixedColumnElements)
	            } else {
	                fixedWidths = that.callBase(that._fixedTableElement)
	            }
	        }
	        return normalizeColumnWidths(fixedColumns, result, fixedWidths)
	    }
	});
	var RowsViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
	    _detachHoverEvents: function() {
	        this._fixedTableElement && this._fixedTableElement.off("mouseover mouseout", ".dx-data-row");
	        this._tableElement && this._tableElement.off("mouseover mouseout", ".dx-data-row")
	    },
	    _attachHoverEvents: function() {
	        var that = this,
	            attachHoverEvent = function($table) {
	                $table.on("mouseover mouseout", ".dx-data-row", that.createAction(function(args) {
	                    var event = args.jQueryEvent,
	                        rowIndex = that.getRowIndex($(event.target).closest(".dx-row")),
	                        isHover = "mouseover" === event.type;
	                    if (rowIndex >= 0) {
	                        that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover);
	                        that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover)
	                    }
	                }))
	            };
	        if (that._fixedTableElement && that._tableElement) {
	            attachHoverEvent(that._fixedTableElement);
	            attachHoverEvent(that._tableElement)
	        }
	    },
	    _findContentElement: function() {
	        var $content, scrollable, scrollTop, that = this,
	            element = that.element();
	        if (element && that._isFixedTableRendering) {
	            $content = element.children("." + DATAGRID_CONTENT_CLASS);
	            scrollable = that.getScrollable();
	            if (!$content.length && scrollable) {
	                $content = $("<div/>").addClass(DATAGRID_CONTENT_CLASS).on("scroll", function(e) {
	                    scrollTop = $(e.target).scrollTop();
	                    if (scrollTop) {
	                        $(e.target).scrollTop(0);
	                        scrollable.scrollTo({
	                            y: that._scrollTop + scrollTop
	                        })
	                    }
	                }).on(wheelEvent.name, function(e) {
	                    if (scrollable) {
	                        scrollTop = scrollable.scrollTop();
	                        scrollable.scrollTo({
	                            y: scrollTop - e.delta
	                        });
	                        if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth()) {
	                            return false
	                        }
	                    }
	                }).appendTo(element)
	            }
	            return $content
	        }
	        return that.callBase()
	    },
	    _updateBottomLoading: function() {
	        if (!this._isFixedTableRendering) {
	            this.callBase()
	        }
	    },
	    _updateScrollable: function() {
	        this.callBase();
	        var scrollable = this.getScrollable(),
	            scrollTop = scrollable && scrollable.scrollOffset().top;
	        this._updateFixedTablePosition(-scrollTop)
	    },
	    _renderContent: function(contentElement, tableElement) {
	        if (this._isFixedTableRendering) {
	            return contentElement.empty().addClass(DATAGRID_CONTENT_CLASS + " " + DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS).append(tableElement)
	        }
	        return this.callBase(contentElement, tableElement)
	    },
	    _getGroupCellOptions: function(options) {
	        if (this._isFixedTableRendering) {
	            return this.callBase($.extend({}, options, {
	                columns: this._columnsController.getVisibleColumns()
	            }))
	        }
	        return this.callBase(options)
	    },
	    _renderGroupSummaryCells: function($row, options) {
	        if (this._isFixedTableRendering) {
	            this.callBase($row, $.extend({}, options, {
	                columns: this._columnsController.getVisibleColumns()
	            }))
	        } else {
	            this.callBase($row, options)
	        }
	    },
	    _hasAlignByColumnSummaryItems: function(columnIndex, options) {
	        var result = this.callBase.apply(this, arguments),
	            column = options.columns[columnIndex];
	        if (options.isFixed) {
	            return column.fixed && (result || "right" === column.fixedPosition) || "edit" === column.command
	        }
	        return result && !column.fixed
	    },
	    _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
	        var startColumnIndex, transparentColumnIndex, alignByFixedColumnCellCount;
	        if (this._isFixedTableRendering) {
	            options.isFixed = true;
	            alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
	            options.isFixed = false;
	            startColumnIndex = options.columns.length - alignByFixedColumnCellCount;
	            options = $.extend({}, options, {
	                columns: this.getFixedColumns()
	            });
	            transparentColumnIndex = getTransparentColumnIndex(options.columns);
	            if (startColumnIndex < transparentColumnIndex) {
	                alignByFixedColumnCellCount -= options.columns[transparentColumnIndex].colspan - 1 || 0;
	                groupCellColSpan -= options.columns[transparentColumnIndex].colspan - 1 || 0
	            } else {
	                if (alignByColumnCellCount > 0) {
	                    if (browser.mozilla) {
	                        $groupCell.css("display", "none")
	                    } else {
	                        $groupCell.css("visibility", "hidden")
	                    }
	                }
	            }
	            alignByColumnCellCount = alignByFixedColumnCellCount
	        }
	        this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount)
	    },
	    _getSummaryCellIndex: function(columnIndex, columns) {
	        var transparentColumnIndex;
	        if (this._isFixedTableRendering) {
	            transparentColumnIndex = getTransparentColumnIndex(columns);
	            if (columnIndex > transparentColumnIndex) {
	                columnIndex += columns[transparentColumnIndex].colspan - 1
	            }
	            return columnIndex
	        }
	        return this.callBase.apply(this, arguments)
	    },
	    _renderCore: function(change) {
	        this._detachHoverEvents();
	        this.callBase(change);
	        if (this.option("hoverStateEnabled") && this._isFixedColumns) {
	            this._attachHoverEvents()
	        }
	    },
	    optionChanged: function(args) {
	        var that = this;
	        that.callBase(args);
	        if ("hoverStateEnabled" === args.name && that._isFixedColumns) {
	            args.value ? this._attachHoverEvents() : this._detachHoverEvents()
	        }
	    },
	    getCellIndex: function($cell) {
	        var columns, $fixedTable = this._fixedTableElement,
	            cellIndex = 0;
	        if ($fixedTable && $fixedTable.find($cell).length) {
	            columns = this.getFixedColumns();
	            $.each(columns, function(index, column) {
	                if (index === $cell[0].cellIndex) {
	                    return false
	                }
	                if (column.colspan) {
	                    cellIndex += column.colspan;
	                    return
	                }
	                cellIndex++
	            });
	            return cellIndex
	        }
	        return this.callBase($cell)
	    },
	    _updateFixedTablePosition: function(scrollTop) {
	        if (this._fixedTableElement && this._tableElement) {
	            var editorFactory = this.getController("editorFactory"),
	                $focusedElement = editorFactory.focus();
	            this._fixedTableElement.css("top", scrollTop + this._tableElement.position().top);
	            if ($focusedElement) {
	                editorFactory.focus($focusedElement)
	            }
	        }
	    },
	    setScrollerSpacing: function(vWidth, hWidth) {
	        var styles, that = this;
	        var $fixedContent = that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS);
	        if ($fixedContent.length) {
	            styles = that.option("rtlEnabled") ? {
	                marginLeft: vWidth
	            } : {
	                marginRight: vWidth
	            };
	            styles.marginBottom = hWidth;
	            $fixedContent.css(styles)
	        }
	    },
	    _handleScroll: function(e) {
	        this._updateFixedTablePosition(-e.scrollOffset.top);
	        this.callBase(e)
	    },
	    _updateContentPosition: function() {
	        var isUpdated = this.callBase();
	        if (isUpdated) {
	            this._updateFixedTablePosition(-this._scrollTop)
	        }
	        return isUpdated
	    },
	    _afterRowPrepared: function(e) {
	        if (this._isFixedTableRendering) {
	            return
	        }
	        this.callBase(e)
	    }
	});
	var FooterViewFixedColumnsExtender = baseFixedColumns;
	gridCore.registerModule("fixedColumns", {
	    defaultOptions: function() {
	        return {
	            columnFixing: {
	                enabled: false,
	                texts: {
	                    fix: messageLocalization.format("dxDataGrid-columnFixingFix"),
	                    unfix: messageLocalization.format("dxDataGrid-columnFixingUnfix"),
	                    leftPosition: messageLocalization.format("dxDataGrid-columnFixingLeftPosition"),
	                    rightPosition: messageLocalization.format("dxDataGrid-columnFixingRightPosition")
	                }
	            }
	        }
	    },
	    extenders: {
	        views: {
	            columnHeadersView: ColumnHeadersViewFixedColumnsExtender,
	            rowsView: RowsViewFixedColumnsExtender,
	            footerView: FooterViewFixedColumnsExtender
	        },
	        controllers: function() {
	            var normalizeColumnIndicesByPoints = function(columns, fixedColumns, pointsByColumns) {
	                var transparentColumnIndex = getTransparentColumnIndex(fixedColumns),
	                    correctIndex = columns.length - fixedColumns.length;
	                $.each(pointsByColumns, function(_, point) {
	                    if (point.index > transparentColumnIndex) {
	                        point.columnIndex += correctIndex;
	                        point.index += correctIndex
	                    }
	                });
	                return pointsByColumns
	            };
	            return {
	                draggingHeader: {
	                    _generatePointsByColumns: function(options) {
	                        var pointsByColumns, visibleColumns = options.columns,
	                            targetDraggingPanel = options.targetDraggingPanel;
	                        if (targetDraggingPanel && "headers" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {
	                            if (options.sourceColumn.fixed) {
	                                if (!options.rowIndex) {
	                                    options.columnElements = targetDraggingPanel.getFixedColumnElements(0)
	                                }
	                                options.columns = targetDraggingPanel.getFixedColumns(options.rowIndex);
	                                pointsByColumns = this.callBase(options);
	                                normalizeColumnIndicesByPoints(visibleColumns, options.columns, pointsByColumns);
	                                return pointsByColumns
	                            }
	                        }
	                        return this.callBase(options)
	                    },
	                    _pointCreated: function(point, columns, location, sourceColumn) {
	                        var boundingRect, result = this.callBase.apply(this, arguments),
	                            $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
	                        if (!result && "headers" === location && $transparentColumn && $transparentColumn.length) {
	                            boundingRect = $transparentColumn.get(0).getBoundingClientRect();
	                            if (sourceColumn && sourceColumn.fixed) {
	                                return "right" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left
	                            } else {
	                                return point.x < boundingRect.left || point.x > boundingRect.right
	                            }
	                        }
	                        return result
	                    }
	                },
	                columnsResizer: {
	                    _generatePointsByColumns: function() {
	                        var that = this,
	                            columnsController = that._columnsController,
	                            columns = columnsController && that._columnsController.getVisibleColumns(),
	                            fixedColumns = columnsController && that._columnsController.getFixedColumns(),
	                            cells = that._columnHeadersView.getFixedColumnElements(),
	                            pointsByFixedColumns = [];
	                        that.callBase();
	                        if (cells && cells.length > 0) {
	                            pointsByFixedColumns = gridCore.getPointsByColumns(cells, function(point) {
	                                return that._pointCreated(point, cells.length, fixedColumns)
	                            });
	                            that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, fixedColumns, pointsByFixedColumns)
	                        }
	                    },
	                    _pointCreated: function(point, cellsLength, columns) {
	                        var currentColumn, nextColumn;
	                        if (point.index > 0 && point.index < cellsLength) {
	                            currentColumn = columns[point.columnIndex - 1] || {};
	                            nextColumn = columns[point.columnIndex] || {};
	                            if (currentColumn.fixed || nextColumn.fixed) {
	                                point.columnIndex -= 1;
	                                return !((currentColumn.allowResizing || "transparent" === currentColumn.command) && (nextColumn.allowResizing || "transparent" === nextColumn.command))
	                            }
	                        }
	                        return this.callBase.apply(this, arguments)
	                    },
	                    _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
	                        var boundingRect, $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
	                        if ($transparentColumn && $transparentColumn.length) {
	                            boundingRect = $transparentColumn.get(0).getBoundingClientRect();
	                            if (currentX <= boundingRect.left || currentX >= boundingRect.right) {
	                                return this.callBase(this._pointsByFixedColumns, currentX, deltaX)
	                            }
	                        }
	                        return this.callBase(pointsByColumns, currentX, deltaX)
	                    }
	                },
	                keyboardNavigation: {
	                    _scrollToElement: function($element) {
	                        var focusedView = this.getFocusedView();
	                        this.callBase($element, focusedView && focusedView.getFixedColumnsOffset())
	                    }
	                }
	            }
	        }()
	    }
	});


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.adaptivity.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    eventUtils = __webpack_require__(61),
	    clickEvent = __webpack_require__(65),
	    commonUtils = __webpack_require__(8),
	    equalByValue = commonUtils.equalByValue,
	    Guid = __webpack_require__(119),
	    gridCore = __webpack_require__(144),
	    Form = __webpack_require__(223),
	    gridCoreUtils = __webpack_require__(148),
	    COLUMN_VIEWS = ["columnHeadersView", "rowsView", "footerView"],
	    DATAGRID_ADAPTIVE_NAMESPACE = "dxDataGridAdaptivity",
	    DATAGRID_HIDDEN_COLUMNS_WIDTH = "adaptiveHidden",
	    DATAGRID_ADAPTIVE_ROW_TYPE = "detailAdaptive",
	    FORM_ITEM_CONTENT_CLASS = "dx-field-item-content",
	    FORM_ITEM_MODIFIED = "dx-item-modified",
	    DATAGRID_COMMAND_ADAPTIVE_CLASS = "dx-command-adaptive",
	    DATAGRID_COMMAND_ADAPTIVE_HIDDEN_CLASS = "dx-command-adaptive-hidden",
	    DATAGRID_ADAPTIVE_COLUMN_NAME = "adaptive",
	    DATAGRID_ADAPTIVE_DETAIL_ROW_CLASS = "dx-adaptive-detail-row",
	    DATAGRID_HIDDEN_COLUMN_CLASS = "dx-datagrid-hidden-column",
	    DATAGRID_ADAPTIVE_ITEM_TEXT_CLASS = "dx-adaptive-item-text",
	    DATAGRID_EDIT_MODE_ROW = "row",
	    DATAGRID_EDIT_MODE_FORM = "form",
	    DATAGRID_ADAPTIVE_COLUMN_BUTTON_CLASS = "dx-datagrid-adaptive-more";

	function getColumnId(column) {
	    return column.command ? "command:" + column.command : column.index
	}
	exports.AdaptiveColumnsController = gridCore.ViewController.inherit({
	    _isRowEditMode: function() {
	        var editMode = this._editingController.getEditMode();
	        return editMode === DATAGRID_EDIT_MODE_ROW
	    },
	    _isFormEditMode: function() {
	        var editMode = this._editingController.getEditMode();
	        return editMode === DATAGRID_EDIT_MODE_FORM
	    },
	    _isItemModified: function(item, cellOptions) {
	        var columnIndex = this._columnsController.getVisibleIndex(item.column.index),
	            rowIndex = this._dataController.getRowIndexByKey(cellOptions.key),
	            row = this._dataController.items()[rowIndex + 1];
	        return row && row.modifiedValues && commonUtils.isDefined(row.modifiedValues[columnIndex])
	    },
	    _renderFormViewTemplate: function(item, cellOptions, $container) {
	        var cellText, that = this,
	            column = item.column,
	            cellValue = column.calculateCellValue(cellOptions.data);
	        cellValue = gridCore.getDisplayValue(column, cellValue, cellOptions.data, cellOptions.rowType);
	        cellText = gridCore.formatValue(cellValue, column);
	        if (column.cellTemplate) {
	            var templateOptions = $.extend({}, cellOptions, {
	                value: cellValue,
	                text: cellText,
	                column: column
	            });
	            that._rowsView.renderTemplate($container, column.cellTemplate, templateOptions)
	        } else {
	            var container = $container.get(0);
	            if (column.encodeHtml) {
	                container.textContent = cellText
	            } else {
	                container.innerHTML = cellText
	            }
	            $container.addClass(DATAGRID_ADAPTIVE_ITEM_TEXT_CLASS);
	            if (!commonUtils.isDefined(cellText) || "" === cellText) {
	                $container.html("&nbsp;")
	            }
	            if (!that._isRowEditMode()) {
	                if (that._isItemModified(item, cellOptions)) {
	                    $container.addClass(FORM_ITEM_MODIFIED)
	                }
	            }
	        }
	    },
	    _getTemplate: function(item, cellOptions) {
	        var that = this,
	            column = item.column,
	            editingController = this.getController("editing");
	        return function(options, $container) {
	            var isItemEdited = that._isItemEdited(item);
	            if (isItemEdited || column.showEditorAlways) {
	                editingController.renderFormEditTemplate(cellOptions, item, options.component, $container, !isItemEdited)
	            } else {
	                that._renderFormViewTemplate(item, cellOptions, $container);
	                var columnIndex = that._columnsController.getVisibleIndex(column.visibleIndex);
	                that.getView("rowsView")._cellPrepared($container, $.extend({}, cellOptions, {
	                    column: column,
	                    columnIndex: columnIndex,
	                    value: cellOptions.row.values[columnIndex]
	                }))
	            }
	        }
	    },
	    _isVisibleColumnsValid: function(visibleColumns) {
	        var getCommandColumnsCount = function() {
	            var j, visibleColumn, result = 0;
	            for (j = 0; j < visibleColumns.length; j++) {
	                visibleColumn = visibleColumns[j];
	                if (visibleColumn.command) {
	                    result++
	                }
	            }
	            return result
	        };
	        if (visibleColumns < 2) {
	            return false
	        }
	        if (visibleColumns.length - getCommandColumnsCount() <= 1) {
	            return false
	        }
	        return true
	    },
	    _calculatePercentWidths: function(widths, visibleColumns) {
	        var that = this,
	            percentWidths = 0;
	        visibleColumns.forEach(function(item, index) {
	            if (widths[index] !== DATAGRID_HIDDEN_COLUMNS_WIDTH) {
	                percentWidths += that._getItemPercentWidth(item)
	            }
	        });
	        return percentWidths
	    },
	    _isPercentWidth: function(width) {
	        return commonUtils.isString(width) && "%" === width.slice(-1)
	    },
	    _getNotTruncatedColumnWidth: function(column, containerWidth, columnsCount, columnsCanFit) {
	        var colWidth, columnId = getColumnId(column),
	            widthOption = this._columnsController.columnOption(columnId, "width"),
	            bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
	        if (widthOption && "auto" !== widthOption) {
	            if (this._isPercentWidth(widthOption)) {
	                var columnFitted = column.visibleIndex < columnsCount - 1 && columnsCanFit,
	                    partialWidth = containerWidth * parseFloat(widthOption) / 100,
	                    resultWidth = columnsCanFit && partialWidth < bestFitWidth ? bestFitWidth : partialWidth;
	                colWidth = columnFitted ? this.component.element().width() * parseFloat(widthOption) / 100 : resultWidth
	            } else {
	                return widthOption
	            }
	        } else {
	            var columnAutoWidth = this.option("columnAutoWidth");
	            colWidth = columnAutoWidth || !!column.command ? bestFitWidth : containerWidth / columnsCount
	        }
	        var isTruncated = colWidth < bestFitWidth;
	        return isTruncated ? null : colWidth
	    },
	    _getItemPercentWidth: function(item) {
	        var result = 0;
	        if (item.width && this._isPercentWidth(item.width)) {
	            result = parseFloat(item.width)
	        }
	        return result
	    },
	    _getCommandColumnsWidth: function() {
	        var that = this,
	            columns = that._columnsController.getVisibleColumns(),
	            colWidth = 0;
	        $.each(columns, function(index, column) {
	            if (column.index < 0 || column.command) {
	                colWidth += that._columnsController.columnOption(getColumnId(column), "bestFitWidth") || 0
	            }
	        });
	        return colWidth
	    },
	    _isItemEdited: function(item) {
	        if (this._isFormEditMode()) {
	            return false
	        }
	        if (this._isRowEditMode()) {
	            var editRowKey = this._editingController.getEditRowKey();
	            if (equalByValue(editRowKey, this._dataController.adaptiveExpandedKey())) {
	                return true
	            }
	        } else {
	            var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1,
	                columnIndex = this._columnsController.getVisibleIndex(item.column.visibleIndex);
	            return this._editingController.isEditCell(rowIndex, columnIndex)
	        }
	    },
	    _getFormItemsByHiddenColumns: function(hiddenColumns) {
	        var items = [];
	        $.each(hiddenColumns, function(_, column) {
	            items.push({
	                column: column,
	                name: column.name,
	                dataField: column.dataField,
	                visibleIndex: column.visibleIndex
	            })
	        });
	        return items
	    },
	    _getAdaptiveColumnVisibleIndex: function(visibleColumns) {
	        var i, column;
	        for (i = 0; i < visibleColumns.length; i++) {
	            column = visibleColumns[i];
	            if (column.command === DATAGRID_ADAPTIVE_COLUMN_NAME) {
	                return i
	            }
	        }
	    },
	    _hideAdaptiveColumn: function(resultWidths, visibleColumns) {
	        var visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);
	        if (commonUtils.isDefined(visibleIndex)) {
	            resultWidths[visibleIndex] = DATAGRID_HIDDEN_COLUMNS_WIDTH;
	            this._addCssClassToColumn(DATAGRID_COMMAND_ADAPTIVE_HIDDEN_CLASS, visibleIndex)
	        }
	    },
	    _removeCssClassFromColumn: function(cssClassName) {
	        var i, view, $cells;
	        for (i = 0; i < COLUMN_VIEWS.length; i++) {
	            view = this.getView(COLUMN_VIEWS[i]);
	            if (view && view.isVisible() && view.element()) {
	                $cells = view.element().find("." + cssClassName);
	                $cells.removeClass(cssClassName)
	            }
	        }
	    },
	    _removeCssClassesFromColumns: function() {
	        this._removeCssClassFromColumn(DATAGRID_COMMAND_ADAPTIVE_HIDDEN_CLASS);
	        this._removeCssClassFromColumn(DATAGRID_HIDDEN_COLUMN_CLASS)
	    },
	    _addCssClassToColumn: function(cssClassName, visibleIndex) {
	        var $cells, i, view, rowsCount, rowIndex;
	        for (i = 0; i < COLUMN_VIEWS.length; i++) {
	            view = this.getView(COLUMN_VIEWS[i]);
	            if (view && view.isVisible()) {
	                rowsCount = view.getRowsCount();
	                for (rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
	                    $cells = view.getCellElements(rowIndex).eq(visibleIndex);
	                    $cells.addClass(cssClassName)
	                }
	            }
	        }
	    },
	    hideRedundantColumns: function(resultWidths, visibleColumns, hiddenQueue) {
	        var visibleColumn, that = this;
	        this._hiddenColumns = [];
	        if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {
	            var percentWidths, columnsCanFit, i, needHideColumn, totalWidth = 0,
	                $rootElement = that.component.element(),
	                rootElementWidth = $rootElement.width() - that._getCommandColumnsWidth(),
	                contentColumns = visibleColumns.filter(function(item) {
	                    return !item.command
	                }),
	                contentColumnCount = contentColumns.length;
	            do {
	                needHideColumn = false;
	                totalWidth = 0;
	                percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);
	                columnsCanFit = percentWidths < 100 && 0 !== percentWidths;
	                for (i = 0; i < visibleColumns.length; i++) {
	                    visibleColumn = visibleColumns[i];
	                    var columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, contentColumnCount, columnsCanFit),
	                        columnId = getColumnId(visibleColumn),
	                        widthOption = that._columnsController.columnOption(columnId, "width"),
	                        columnBestFitWidth = that._columnsController.columnOption(columnId, "bestFitWidth");
	                    if (resultWidths[i] === DATAGRID_HIDDEN_COLUMNS_WIDTH) {
	                        continue
	                    }
	                    if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {
	                        needHideColumn = true;
	                        break
	                    }
	                    if (widthOption && "auto" !== widthOption) {
	                        totalWidth += columnWidth
	                    } else {
	                        totalWidth += columnBestFitWidth || 0
	                    }
	                }
	                needHideColumn = needHideColumn || totalWidth > $rootElement.width();
	                if (needHideColumn) {
	                    var column = hiddenQueue.pop(),
	                        visibleIndex = that._columnsController.getVisibleIndex(column.index);
	                    that._addCssClassToColumn(DATAGRID_HIDDEN_COLUMN_CLASS, visibleIndex);
	                    resultWidths[visibleIndex] = DATAGRID_HIDDEN_COLUMNS_WIDTH;
	                    contentColumnCount--;
	                    this._hiddenColumns.push(column)
	                }
	            } while (needHideColumn && contentColumnCount > 1 && hiddenQueue.length);
	            if (contentColumnCount === contentColumns.length) {
	                that._hideAdaptiveColumn(resultWidths, visibleColumns)
	            }
	        } else {
	            that._hideAdaptiveColumn(resultWidths, visibleColumns)
	        }
	    },
	    getItemContentByColumnIndex: function(visibleColumnIndex) {
	        var $itemContent, i, item;
	        for (i = 0; i < this._$itemContents.length; i++) {
	            $itemContent = this._$itemContents.eq(i);
	            item = $itemContent.data("dx-form-item");
	            if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {
	                return $itemContent
	            }
	        }
	    },
	    toggleExpandAdaptiveDetailRow: function(key) {
	        if (!(this._isFormEditMode() && this._editingController.isEditing())) {
	            this.getController("data").toggleExpandAdaptiveDetailRow(key)
	        }
	    },
	    createFormByHiddenColumns: function($container, options) {
	        var that = this,
	            userFormOptions = {
	                items: that._getFormItemsByHiddenColumns(that._hiddenColumns),
	                formID: new Guid
	            };
	        this.executeAction("onAdaptiveDetailRowPreparing", {
	            formOptions: userFormOptions
	        });
	        that._$itemContents = null;
	        that._form = that._createComponent($("<div>").appendTo($container), Form, $.extend({}, userFormOptions, {
	            customizeItem: function(item) {
	                var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
	                if (column) {
	                    item.label = item.label || {};
	                    item.label.text = item.label.text || column.caption;
	                    item.column = column;
	                    item.template = that._getTemplate(item, options, $.proxy(that.updateForm, that))
	                }
	                userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item)
	            },
	            onContentReady: function(e) {
	                userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);
	                that._$itemContents = $container.find("." + FORM_ITEM_CONTENT_CLASS)
	            }
	        }))
	    },
	    hasAdaptiveDetailRowExpanded: function() {
	        return commonUtils.isDefined(this._dataController.adaptiveExpandedKey())
	    },
	    updateForm: function(hiddenColumns) {
	        if (this.hasAdaptiveDetailRowExpanded()) {
	            if (this._form && commonUtils.isDefined(this._form._contentReadyAction)) {
	                if (hiddenColumns && hiddenColumns.length) {
	                    this._form.option("items", this._getFormItemsByHiddenColumns(hiddenColumns))
	                } else {
	                    this._form.repaint()
	                }
	            }
	        }
	    },
	    updateHidingQueue: function(columns) {
	        var columnsHasHidingPriority, i, that = this,
	            hideableColumns = columns.filter(function(column) {
	                return column.visible && !column.fixed && !(commonUtils.isDefined(column.groupIndex) && column.groupIndex >= 0)
	            });
	        that._hidingColumnsQueue = [];
	        for (i = 0; i < hideableColumns.length; i++) {
	            if (commonUtils.isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {
	                columnsHasHidingPriority = true;
	                that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i]
	            }
	        }
	        if (columnsHasHidingPriority) {
	            that._hidingColumnsQueue.reverse()
	        } else {
	            if (that.option("columnHidingEnabled")) {
	                for (i = 0; i < hideableColumns.length; i++) {
	                    var visibleIndex = that._columnsController.columnOption(getColumnId(hideableColumns[i]), "visibleIndex");
	                    that._hidingColumnsQueue[visibleIndex] = hideableColumns[i]
	                }
	            }
	        }
	        that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);
	        return that._hidingColumnsQueue
	    },
	    getHiddenColumns: function() {
	        return this._hiddenColumns
	    },
	    hasHiddenColumns: function() {
	        return this._hiddenColumns.length > 0
	    },
	    getHidingColumnsQueue: function() {
	        return this._hidingColumnsQueue
	    },
	    init: function() {
	        var that = this;
	        that._columnsController = that.getController("columns");
	        that._dataController = that.getController("data");
	        that._rowsView = that.getView("rowsView");
	        that._columnsController.addCommandColumn({
	            command: DATAGRID_ADAPTIVE_COLUMN_NAME,
	            visible: false,
	            cssClass: DATAGRID_COMMAND_ADAPTIVE_CLASS,
	            width: "auto"
	        });
	        that._columnsController.columnsChanged.add(function() {
	            var isAdaptiveVisible = !!that.updateHidingQueue(that._columnsController.getColumns()).length;
	            that._columnsController.columnOption("command:adaptive", "visible", isAdaptiveVisible, true)
	        });
	        that._editingController = that.getController("editing");
	        that._hidingColumnsQueue = [];
	        that._hiddenColumns = [];
	        that.createAction("onAdaptiveDetailRowPreparing");
	        that.callBase()
	    },
	    optionChanged: function(args) {
	        if ("columnHidingEnabled" === args.name) {
	            this._columnsController.columnOption("command:adaptive", "visible", args.value)
	        }
	        this.callBase(args)
	    },
	    publicMethods: function() {
	        return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"]
	    },
	    isAdaptiveDetailRowExpanded: function(key) {
	        return this._dataController.adaptiveExpandedKey() && commonUtils.equalByValue(this._dataController.adaptiveExpandedKey(), key)
	    },
	    expandAdaptiveDetailRow: function(key) {
	        if (!this.hasAdaptiveDetailRowExpanded()) {
	            this.toggleExpandAdaptiveDetailRow(key)
	        }
	    },
	    collapseAdaptiveDetailRow: function() {
	        if (this.hasAdaptiveDetailRowExpanded()) {
	            this.toggleExpandAdaptiveDetailRow()
	        }
	    }
	});
	gridCore.registerModule("adaptivity", {
	    defaultOptions: function() {
	        return {
	            columnHidingEnabled: false,
	            onAdaptiveDetailRowPreparing: null
	        }
	    },
	    controllers: {
	        adaptiveColumns: exports.AdaptiveColumnsController
	    },
	    extenders: {
	        views: {
	            rowsView: {
	                _getCellTemplate: function(options) {
	                    var that = this,
	                        column = options.column;
	                    if (column.command === DATAGRID_ADAPTIVE_COLUMN_NAME && "groupFooter" !== options.rowType) {
	                        return function(container) {
	                            $("<span/>").addClass(DATAGRID_ADAPTIVE_COLUMN_BUTTON_CLASS).on(eventUtils.addNamespace(clickEvent.name, DATAGRID_ADAPTIVE_NAMESPACE), that.createAction(function() {
	                                that._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options.key)
	                            })).appendTo(container)
	                        }
	                    }
	                    if (options.rowType === DATAGRID_ADAPTIVE_ROW_TYPE && "detail" === column.command) {
	                        return function(container, options) {
	                            that._adaptiveColumnsController.createFormByHiddenColumns(container, options)
	                        }
	                    }
	                    return that.callBase(options)
	                },
	                _createRow: function(row) {
	                    var $row = this.callBase(row);
	                    if (row && row.rowType === DATAGRID_ADAPTIVE_ROW_TYPE && row.key === this._dataController.adaptiveExpandedKey()) {
	                        $row.addClass(DATAGRID_ADAPTIVE_DETAIL_ROW_CLASS)
	                    }
	                    return $row
	                },
	                _getColumnIndexByElement: function($element) {
	                    var $itemContent = $element.closest("." + FORM_ITEM_CONTENT_CLASS);
	                    if ($itemContent.length && $itemContent.closest(this.component.element()).length) {
	                        var formItem = $itemContent.length ? $itemContent.first().data("dx-form-item") : null;
	                        return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index)
	                    } else {
	                        return this.callBase($element)
	                    }
	                },
	                getCellElement: function(rowIndex, columnIdentifier) {
	                    var item = this._dataController.items()[rowIndex];
	                    if (item && item.rowType === DATAGRID_ADAPTIVE_ROW_TYPE) {
	                        return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier)
	                    } else {
	                        return this.callBase(rowIndex, columnIdentifier)
	                    }
	                },
	                isClickableElement: function($target) {
	                    var isClickable = this.callBase ? this.callBase($target) : false;
	                    return isClickable || !!$target.closest("." + DATAGRID_COMMAND_ADAPTIVE_CLASS).length
	                },
	                init: function() {
	                    this.callBase();
	                    this._adaptiveColumnsController = this.getController("adaptiveColumns")
	                }
	            }
	        },
	        controllers: {
	            "export": {
	                _updateColumnWidth: function(column, width) {
	                    this.callBase(column, column.visibleWidth === DATAGRID_HIDDEN_COLUMNS_WIDTH ? column.bestFitWidth : width)
	                }
	            },
	            columnsResizer: {
	                _pointCreated: function(point, cellsLength, columns) {
	                    var result = this.callBase(point, cellsLength, columns),
	                        currentColumn = columns[point.columnIndex] || {},
	                        nextColumnIndex = this._getNextColumnIndex(point.columnIndex),
	                        nextColumn = columns[nextColumnIndex] || {},
	                        hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command,
	                        hasAdaptiveHiddenWidth = currentColumn.visibleWidth === DATAGRID_HIDDEN_COLUMNS_WIDTH || hasHiddenColumnsOnly;
	                    return result || hasAdaptiveHiddenWidth
	                },
	                _getNextColumnIndex: function(currentColumnIndex) {
	                    var visibleColumns = this._columnsController.getVisibleColumns(),
	                        index = this.callBase(currentColumnIndex);
	                    while (visibleColumns[index] && visibleColumns[index].visibleWidth === DATAGRID_HIDDEN_COLUMNS_WIDTH) {
	                        index++
	                    }
	                    return index
	                }
	            },
	            draggingHeader: {
	                _pointCreated: function(point, columns, location, sourceColumn) {
	                    var result = this.callBase(point, columns, location, sourceColumn),
	                        column = columns[point.columnIndex] || {},
	                        hasAdaptiveHiddenWidth = column.visibleWidth === DATAGRID_HIDDEN_COLUMNS_WIDTH;
	                    return result || hasAdaptiveHiddenWidth
	                }
	            },
	            editing: {
	                _getFormEditItemTemplate: function(cellOptions, column) {
	                    if (this.getEditMode() !== DATAGRID_EDIT_MODE_ROW && "detailAdaptive" === cellOptions.rowType) {
	                        cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.visibleIndex);
	                        return this.getColumnTemplate(cellOptions)
	                    }
	                    return this.callBase(cellOptions, column)
	                },
	                _closeEditItem: function($targetElement) {
	                    var $itemContents = $targetElement.closest("." + FORM_ITEM_CONTENT_CLASS),
	                        rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1,
	                        formItem = $itemContents.length ? $itemContents.first().data("dx-form-item") : null,
	                        columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
	                    if (!this.isEditCell(rowIndex, columnIndex)) {
	                        this.callBase($targetElement)
	                    }
	                },
	                _beforeUpdateItems: function(rowIndices, rowIndex) {
	                    if (this.getEditMode() !== DATAGRID_EDIT_MODE_FORM && this._adaptiveController.hasHiddenColumns()) {
	                        var items = this._dataController.items(),
	                            item = items[rowIndex],
	                            oldExpandRowIndex = gridCoreUtils.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);
	                        this._isForceRowAdaptiveExpand = !this._adaptiveController.hasAdaptiveDetailRowExpanded();
	                        if (oldExpandRowIndex >= 0 && rowIndex > oldExpandRowIndex) {
	                            this._editRowIndex--
	                        }
	                        if (oldExpandRowIndex >= 0) {
	                            rowIndices.push(oldExpandRowIndex + 1)
	                        }
	                        rowIndices.push(rowIndex + 1);
	                        this._dataController.adaptiveExpandedKey(item.key)
	                    }
	                },
	                _afterInsertRow: function(options) {
	                    this.callBase(options);
	                    if (this._adaptiveController.hasHiddenColumns()) {
	                        this._adaptiveController.expandAdaptiveDetailRow(options.key);
	                        this._isForceRowAdaptiveExpand = true
	                    }
	                },
	                _collapseAdaptiveDetailRow: function() {
	                    if (this.getEditMode() === DATAGRID_EDIT_MODE_ROW && this._isForceRowAdaptiveExpand) {
	                        this._adaptiveController.collapseAdaptiveDetailRow();
	                        this._isForceRowAdaptiveExpand = false
	                    }
	                },
	                _cancelEditAdaptiveDetailRow: function() {
	                    if (this._adaptiveController.hasHiddenColumns()) {
	                        this._collapseAdaptiveDetailRow()
	                    }
	                },
	                _afterSaveEditData: function() {
	                    this.callBase();
	                    if (this.getController("validating").validate(true)) {
	                        this._cancelEditAdaptiveDetailRow()
	                    }
	                },
	                _beforeCancelEditData: function() {
	                    this.callBase();
	                    this._cancelEditAdaptiveDetailRow()
	                },
	                _beforeCloseEditCellInBatchMode: function(rowIndices) {
	                    var rowIndex, expandedKey = this._dataController._adaptiveExpandedKey;
	                    if (expandedKey) {
	                        rowIndex = gridCoreUtils.getIndexByKey(expandedKey, this._dataController.items());
	                        if (rowIndex > -1) {
	                            rowIndices.unshift(rowIndex)
	                        }
	                    }
	                },
	                editRow: function(rowIndex) {
	                    if (this.getEditMode() === DATAGRID_EDIT_MODE_FORM) {
	                        this._adaptiveController.collapseAdaptiveDetailRow()
	                    }
	                    this.callBase(rowIndex)
	                },
	                init: function() {
	                    this.callBase();
	                    this._adaptiveController = this.getController("adaptiveColumns")
	                }
	            },
	            resizing: {
	                _isNeedToCalcBestFitWidths: function(needBestFit) {
	                    return this.callBase(needBestFit) || !!this._adaptiveColumnsController.getHidingColumnsQueue().length
	                },
	                _correctColumnWidths: function(resultWidths, visibleColumns) {
	                    var hiddenColumns, adaptiveController = this._adaptiveColumnsController,
	                        oldHiddenColumns = adaptiveController.getHiddenColumns(),
	                        hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());
	                    adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);
	                    hiddenColumns = adaptiveController.getHiddenColumns();
	                    if (adaptiveController.hasAdaptiveDetailRowExpanded()) {
	                        if (oldHiddenColumns.length !== hiddenColumns.length) {
	                            adaptiveController.updateForm(hiddenColumns)
	                        }
	                    }!hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();
	                    return this.callBase(resultWidths, visibleColumns)
	                },
	                _toggleBestFitMode: function(isBestFit) {
	                    isBestFit && this._adaptiveColumnsController._removeCssClassesFromColumns();
	                    this.callBase(isBestFit)
	                },
	                init: function() {
	                    this._adaptiveColumnsController = this.getController("adaptiveColumns");
	                    this.callBase()
	                }
	            },
	            data: {
	                _processItems: function(items, changeType) {
	                    var item, expandRowIndex, that = this;
	                    items = that.callBase.apply(that, arguments);
	                    if ("loadingAll" === changeType || !commonUtils.isDefined(that._adaptiveExpandedKey)) {
	                        return items
	                    }
	                    expandRowIndex = gridCoreUtils.getIndexByKey(that._adaptiveExpandedKey, items);
	                    if (expandRowIndex >= 0) {
	                        item = items[expandRowIndex];
	                        items.splice(expandRowIndex + 1, 0, {
	                            visible: true,
	                            rowType: DATAGRID_ADAPTIVE_ROW_TYPE,
	                            key: item.key,
	                            data: item.data,
	                            modifiedValues: item.modifiedValues,
	                            inserted: item.inserted,
	                            values: item.values
	                        })
	                    } else {
	                        that._adaptiveExpandedKey = void 0
	                    }
	                    return items
	                },
	                adaptiveExpandedKey: function(value) {
	                    if (commonUtils.isDefined(value)) {
	                        this._adaptiveExpandedKey = value
	                    } else {
	                        return this._adaptiveExpandedKey
	                    }
	                },
	                toggleExpandAdaptiveDetailRow: function(key) {
	                    var that = this;
	                    var oldExpandRowIndex = gridCoreUtils.getIndexByKey(that._adaptiveExpandedKey, that._items);
	                    var newExpandRowIndex = gridCoreUtils.getIndexByKey(key, that._items);
	                    if (oldExpandRowIndex >= 0 && oldExpandRowIndex === newExpandRowIndex) {
	                        key = void 0;
	                        newExpandRowIndex = -1
	                    }
	                    that._adaptiveExpandedKey = key;
	                    if (oldExpandRowIndex >= 0) {
	                        oldExpandRowIndex++
	                    }
	                    if (newExpandRowIndex >= 0) {
	                        newExpandRowIndex++
	                    }
	                    that.updateItems({
	                        changeType: "update",
	                        rowIndices: [oldExpandRowIndex, newExpandRowIndex]
	                    })
	                },
	                init: function() {
	                    this.callBase();
	                    this._adaptiveExpandedKey = void 0
	                }
	            },
	            editorFactory: {
	                _getFocusCellSelector: function() {
	                    return this.callBase() + ", .dx-field-item > .dx-field-item-content"
	                },
	                _getTooltipsSelector: function() {
	                    return this.callBase() + ", .dx-field-item-content .dx-tooltip"
	                }
	            }
	        }
	    }
	});


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (ui/data_grid/ui.data_grid.export_controller.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    dataGridCore = __webpack_require__(144),
	    gridCoreUtils = __webpack_require__(148),
	    clientExporter = __webpack_require__(13),
	    messageLocalization = __webpack_require__(79),
	    excelExporter = clientExporter.excel,
	    Button = __webpack_require__(114),
	    List = __webpack_require__(190),
	    ContextMenu = __webpack_require__(164),
	    when = __webpack_require__(10).when;
	var DATAGRID_EXPORT_MENU_CLASS = "dx-datagrid-export-menu",
	    DATAGRID_EXPORT_BUTTON_CLASS = "dx-datagrid-export-button",
	    DATAGRID_EXPORT_ICON = "export-to",
	    DATAGRID_EXPORT_EXCEL_ICON = "exportxlsx",
	    DATAGRID_EXPORT_SELECTED_ICON = "exportselected",
	    DATAGRID_EXPORT_EXCEL_BUTTON_ICON = "export-excel-button";
	exports.DataProvider = Class.inherit({
	    _getGroupValue: function(item) {
	        var visibleIndex, groupColumn = this._options.groupColumns[item.groupIndex],
	            value = dataGridCore.getDisplayValue(groupColumn, item.values[item.groupIndex], item.data, item.rowType),
	            result = groupColumn.caption + ": " + dataGridCore.formatValue(value, groupColumn);
	        visibleIndex = this._options.getVisibleIndex(groupColumn.index);
	        if (item.summaryCells && item.summaryCells.length && item.summaryCells[visibleIndex].length) {
	            result += " " + dataGridCore.getGroupRowSummaryText(item.summaryCells[visibleIndex], this._options.summaryTexts)
	        }
	        return result
	    },
	    _correctCellIndex: function(cellIndex) {
	        var startIndex = this._options.startValueIndex,
	            endIndex = this._options.endValueIndex;
	        return cellIndex <= endIndex ? startIndex + cellIndex : null
	    },
	    _initOptions: function() {
	        var exportController = this._exportController,
	            groupColumns = exportController._columnsController.getGroupColumns(),
	            startEndIndexes = exportController._getStartEndValueIndexes(exportController._columnsController.getVisibleColumns());
	        this._options = {
	            columns: exportController._getColumns(),
	            groupColumns: groupColumns,
	            items: !!exportController._selectionOnly ? exportController._getSelectedItems() : exportController._getAllItems(),
	            getVisibleIndex: $.proxy(exportController._columnsController.getVisibleIndex, exportController._columnsController),
	            startValueIndex: startEndIndexes.startIndex,
	            endValueIndex: startEndIndexes.endIndex,
	            isHeadersVisible: exportController.option("showColumnHeaders"),
	            summaryTexts: exportController.option("summary.texts"),
	            customizeExportData: exportController.option("customizeExportData")
	        }
	    },
	    ctor: function(exportController) {
	        this._exportController = exportController
	    },
	    getColumns: function(getColumnsByAllRows) {
	        var columns = this._options.columns;
	        return getColumnsByAllRows ? columns : columns[columns.length - 1]
	    },
	    getRowsCount: function() {
	        return this._options.items.length
	    },
	    getHeaderRowCount: function() {
	        if (this.isHeadersVisible()) {
	            return this._options.columns.length - 1
	        }
	        return 0
	    },
	    isGroupRow: function(rowIndex) {
	        return rowIndex < this._options.items.length && "group" === this._options.items[rowIndex].rowType
	    },
	    getGroupLevel: function(rowIndex) {
	        var item = this._options.items[rowIndex],
	            groupIndex = item && item.groupIndex;
	        if (item && "totalFooter" === item.rowType) {
	            return 0
	        }
	        return commonUtils.isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length
	    },
	    getCellType: function(rowIndex, cellIndex) {
	        var columns = this.getColumns();
	        if (cellIndex < columns.length) {
	            var item = this._options.items.length && this._options.items[rowIndex],
	                column = columns[cellIndex];
	            if (item && "data" === item.rowType) {
	                if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !commonUtils.isDefined(column.customizeText)) {
	                    return commonUtils.isDefined(column.lookup) ? column.lookup.dataType : column.dataType
	                }
	            }
	            return "string"
	        }
	    },
	    ready: function() {
	        var options, that = this;
	        that._initOptions();
	        options = this._options;
	        return when(options.items).done(function(items) {
	            options.customizeExportData && options.customizeExportData(that.getColumns(that.getHeaderRowCount() > 1), items);
	            options.items = items
	        }).fail(function() {
	            options.items = []
	        })
	    },
	    getCellValue: function(rowIndex, cellIndex) {
	        var column, value, i, summaryItems, itemValues, columns = this.getColumns(),
	            correctedCellIndex = this._correctCellIndex(cellIndex),
	            item = this._options.items.length && this._options.items[rowIndex];
	        if (item) {
	            itemValues = item.values;
	            switch (item.rowType) {
	                case "groupFooter":
	                case "totalFooter":
	                    if (correctedCellIndex < itemValues.length) {
	                        value = itemValues[correctedCellIndex];
	                        if (commonUtils.isDefined(value)) {
	                            return dataGridCore.getSummaryText(value, this._options.summaryTexts)
	                        }
	                    }
	                    break;
	                case "group":
	                    if (cellIndex < 1) {
	                        return this._getGroupValue(item)
	                    } else {
	                        summaryItems = item.values[correctedCellIndex];
	                        if (commonUtils.isArray(summaryItems)) {
	                            value = "";
	                            for (i = 0; i < summaryItems.length; i++) {
	                                value += (i > 0 ? " \n " : "") + dataGridCore.getSummaryText(summaryItems[i], this._options.summaryTexts)
	                            }
	                            return value
	                        }
	                    }
	                    break;
	                default:
	                    column = columns[cellIndex];
	                    if (column) {
	                        value = dataGridCore.getDisplayValue(column, itemValues[correctedCellIndex], item.data, item.rowType);
	                        return !isFinite(value) || column.customizeText ? dataGridCore.formatValue(value, column) : value
	                    }
	            }
	        }
	    },
	    isHeadersVisible: function() {
	        return this._options.isHeadersVisible
	    },
	    isTotalCell: function(rowIndex, cellIndex) {
	        var items = this._options.items,
	            item = items[rowIndex],
	            correctCellIndex = this._correctCellIndex(cellIndex),
	            isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
	        return item && "groupFooter" === item.rowType || "totalFooter" === item.rowType || isSummaryAlignByColumn
	    },
	    getCellMerging: function(rowIndex, cellIndex) {
	        var columns = this._options.columns,
	            column = columns[rowIndex] && columns[rowIndex][cellIndex];
	        return column ? {
	            colspan: (column.colspan || 1) - 1,
	            rowspan: (column.rowspan || 1) - 1
	        } : {
	            colspan: 0,
	            rowspan: 0
	        }
	    },
	    getFrozenArea: function() {
	        var that = this;
	        return {
	            x: 0,
	            y: that.getHeaderRowCount()
	        }
	    }
	});
	exports.ExportController = dataGridCore.ViewController.inherit({}).include(gridCoreUtils.exportMixin).inherit({
	    _getEmptyCell: function() {
	        return {
	            caption: "",
	            colspan: 1,
	            rowspan: 1
	        }
	    },
	    _updateColumnWidth: function(column, width) {
	        column.width = width
	    },
	    _getColumns: function() {
	        var i, j, column, columns, result = [],
	            columnsController = this._columnsController,
	            rowCount = columnsController.getRowCount(),
	            columnWidths = this._headersView && this._headersView.isVisible() ? this._headersView.getColumnWidths() : this._rowsView.getColumnWidths();
	        for (i = 0; i <= rowCount; i++) {
	            result.push([]);
	            columns = columnsController.getVisibleColumns(i);
	            for (j = 0; j < columns.length; j++) {
	                column = $.extend({}, columns[j]);
	                if (!column.command) {
	                    if (i === rowCount && columnWidths && columnWidths.length) {
	                        this._updateColumnWidth(column, columnWidths[j])
	                    }
	                    result[i].push(column)
	                }
	            }
	        }
	        columns = result[rowCount];
	        result = this._prepareItems(0, result.slice(0, -1));
	        result.push(columns);
	        return result
	    },
	    _getFooterSummaryItems: function(summaryCells, isTotal) {
	        var values, itemsLength, summaryCell, j, result = [],
	            estimatedItemsCount = 1,
	            i = 0;
	        do {
	            values = [];
	            for (j = 0; j < summaryCells.length; j++) {
	                summaryCell = summaryCells[j];
	                itemsLength = summaryCell.length;
	                if (estimatedItemsCount < itemsLength) {
	                    estimatedItemsCount = itemsLength
	                }
	                values.push(summaryCell[i])
	            }
	            result.push({
	                values: values,
	                rowType: isTotal ? "totalFooter" : "groupFooter"
	            })
	        } while (i++ < estimatedItemsCount - 1);
	        return result
	    },
	    _hasSummaryGroupFooters: function() {
	        var i, groupItems = this.option("summary.groupItems");
	        if (commonUtils.isDefined(groupItems)) {
	            for (i = 0; i < groupItems.length; i++) {
	                if (groupItems[i].showInGroupFooter) {
	                    return true
	                }
	            }
	        }
	        return false
	    },
	    _getItemsWithSummaryGroupFooters: function(sourceItems) {
	        var item, i, result = [],
	            beforeGroupFooterItems = [],
	            groupFooterItems = [];
	        for (i = 0; i < sourceItems.length; i++) {
	            item = sourceItems[i];
	            if ("groupFooter" === item.rowType) {
	                groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
	                result = result.concat(beforeGroupFooterItems, groupFooterItems);
	                beforeGroupFooterItems = []
	            } else {
	                beforeGroupFooterItems.push(item)
	            }
	        }
	        return result.length ? result : beforeGroupFooterItems
	    },
	    _updateGroupValuesWithSummaryByColumn: function(sourceItems) {
	        var item, summaryCells, summaryItem, groupColumnCount, k, j, i, summaryValues = [];
	        for (i = 0; i < sourceItems.length; i++) {
	            item = sourceItems[i];
	            summaryCells = item.summaryCells;
	            if ("group" === item.rowType && summaryCells && summaryCells.length > 1) {
	                groupColumnCount = item.values.length;
	                for (j = 1; j < summaryCells.length; j++) {
	                    for (k = 0; k < summaryCells[j].length; k++) {
	                        summaryItem = summaryCells[j][k];
	                        if (summaryItem && summaryItem.alignByColumn) {
	                            if (!commonUtils.isArray(summaryValues[j - groupColumnCount])) {
	                                summaryValues[j - groupColumnCount] = []
	                            }
	                            summaryValues[j - groupColumnCount].push(summaryItem)
	                        }
	                    }
	                }
	                if (summaryValues.length > 0) {
	                    $.merge(item.values, summaryValues);
	                    summaryValues = []
	                }
	            }
	        }
	    },
	    _getAllItems: function(data) {
	        var summaryCells, summaryItems, that = this,
	            d = $.Deferred(),
	            dataController = this.getController("data"),
	            footerItems = dataController.footerItems(),
	            totalItem = footerItems.length && footerItems[0],
	            summaryTotalItems = that.option("summary.totalItems");
	        when(data).done(function(data) {
	            dataController.loadAll(data).done(function(sourceItems, totalAggregates) {
	                that._updateGroupValuesWithSummaryByColumn(sourceItems);
	                if (that._hasSummaryGroupFooters()) {
	                    sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems)
	                }
	                summaryCells = totalItem && totalItem.summaryCells;
	                if (commonUtils.isDefined(totalAggregates) && summaryTotalItems) {
	                    summaryCells = dataController._getSummaryCells(summaryTotalItems, totalAggregates)
	                }
	                summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
	                if (summaryItems) {
	                    sourceItems = sourceItems.concat(summaryItems)
	                }
	                d.resolve(sourceItems)
	            }).fail(d.reject)
	        }).fail(d.reject);
	        return d
	    },
	    _getSelectedItems: function() {
	        var selectionController = this.getController("selection"),
	            selectedRowData = selectionController.getSelectedRowsData();
	        return this._getAllItems(selectedRowData)
	    },
	    _getStartEndValueIndexes: function(visibleColumns) {
	        var i, startIndex, endIndex, visibleColumnsLength = visibleColumns.length;
	        for (i = 0; i < visibleColumnsLength; i++) {
	            if (!commonUtils.isDefined(visibleColumns[i].command)) {
	                startIndex = i;
	                break
	            }
	        }
	        for (i = visibleColumnsLength - 1; i >= 0; i--) {
	            if (!commonUtils.isDefined(visibleColumns[i].command)) {
	                endIndex = i;
	                break
	            }
	        }
	        return {
	            startIndex: startIndex,
	            endIndex: endIndex
	        }
	    },
	    init: function() {
	        this._columnsController = this.getController("columns");
	        this._rowsView = this.getView("rowsView");
	        this._headersView = this.getView("columnHeadersView");
	        this.createAction("onExporting", {
	            excludeValidators: ["disabled", "readOnly"]
	        });
	        this.createAction("onExported", {
	            excludeValidators: ["disabled", "readOnly"]
	        });
	        this.createAction("onFileSaving", {
	            excludeValidators: ["disabled", "readOnly"]
	        })
	    },
	    callbackNames: function() {
	        return ["selectionOnlyChanged"]
	    },
	    getExportFormat: function() {
	        return ["EXCEL"]
	    },
	    getDataProvider: function() {
	        return new exports.DataProvider(this)
	    },
	    exportToExcel: function(selectionOnly) {
	        var that = this,
	            excelWrapTextEnabled = this.option("export.excelWrapTextEnabled");
	        that._selectionOnly = selectionOnly;
	        clientExporter.export(that.component.getDataProvider(), {
	            fileName: that.option("export.fileName"),
	            proxyUrl: that.option("export.proxyUrl"),
	            format: "EXCEL",
	            wrapTextEnabled: commonUtils.isDefined(excelWrapTextEnabled) ? excelWrapTextEnabled : !!this.option("wordWrapEnabled"),
	            autoFilterEnabled: !!that.option("export.excelFilterEnabled"),
	            rtlEnabled: that.option("rtlEnabled"),
	            exportingAction: that.getAction("onExporting"),
	            exportedAction: that.getAction("onExported"),
	            fileSavingAction: that.getAction("onFileSaving")
	        }, excelExporter.getData)
	    },
	    publicMethods: function() {
	        return ["getDataProvider", "getExportFormat", "exportToExcel"]
	    },
	    selectionOnly: function(value) {
	        if (commonUtils.isDefined(value)) {
	            this._isSelectedRows = value;
	            this.selectionOnlyChanged.fire()
	        } else {
	            return this._isSelectedRows
	        }
	    }
	});
	dataGridCore.registerModule("export", {
	    defaultOptions: function() {
	        return {
	            "export": {
	                enabled: false,
	                fileName: "DataGrid",
	                excelFilterEnabled: false,
	                excelWrapTextEnabled: void 0,
	                proxyUrl: void 0,
	                allowExportSelectedData: false,
	                texts: {
	                    exportTo: messageLocalization.format("dxDataGrid-exportTo"),
	                    exportAll: messageLocalization.format("dxDataGrid-exportAll"),
	                    exportSelectedRows: messageLocalization.format("dxDataGrid-exportSelectedRows")
	                }
	            }
	        }
	    },
	    controllers: {
	        "export": exports.ExportController
	    },
	    extenders: {
	        controllers: {
	            editing: {
	                callbackNames: function() {
	                    var callbackList = this.callBase();
	                    return commonUtils.isDefined(callbackList) ? callbackList.push("editingChanged") : ["editingChanged"]
	                },
	                _updateEditButtons: function() {
	                    this.callBase();
	                    this.editingChanged.fire(this.hasChanges())
	                }
	            }
	        },
	        views: {
	            headerPanel: {
	                _getToolbarItems: function() {
	                    var items = this.callBase();
	                    return this._appendExportItems(items)
	                },
	                _appendExportItems: function(items) {
	                    var that = this,
	                        exportOptions = that.option("export");
	                    if (exportOptions.enabled) {
	                        var exportItems = [];
	                        if (exportOptions.allowExportSelectedData) {
	                            exportItems.push({
	                                template: function(data, index, $container) {
	                                    that._renderButton(data, $container);
	                                    that._renderExportMenu($container)
	                                },
	                                menuItemTemplate: function(data, index, $container) {
	                                    that._renderList(data, $container)
	                                },
	                                name: "exportButton",
	                                allowExportSelected: true,
	                                location: "after",
	                                locateInMenu: "auto"
	                            })
	                        } else {
	                            exportItems.push({
	                                template: function(data, index, $container) {
	                                    that._renderButton(data, $container)
	                                },
	                                menuItemTemplate: function(data, index, $container) {
	                                    that._renderButton(data, $container, true)
	                                },
	                                name: "exportButton",
	                                location: "after",
	                                locateInMenu: "auto"
	                            })
	                        }
	                        items = items.concat(exportItems);
	                        that._correctSearchPanelPosition(items)
	                    }
	                    return items
	                },
	                _renderButton: function(data, $container, withText) {
	                    var that = this,
	                        buttonOptions = that._getButtonOptions(data.allowExportSelected),
	                        $buttonContainer = that._getButtonContainer().addClass(DATAGRID_EXPORT_BUTTON_CLASS).appendTo($container);
	                    if (withText) {
	                        $container.wrapInner("<div class='dx-toolbar-item-auto-hide'></div>").parent().addClass("dx-toolbar-menu-action dx-toolbar-menu-button dx-toolbar-hidden-button");
	                        buttonOptions.text = buttonOptions.hint
	                    }
	                    that._createComponent($buttonContainer, Button, buttonOptions)
	                },
	                _renderList: function(data, $container) {
	                    var that = this,
	                        texts = that.option("export.texts"),
	                        renderFakeButton = function(data, $container, iconName) {
	                            var $icon = $("<div />").addClass("dx-icon dx-icon-" + iconName),
	                                $text = $("<span class='dx-button-text'/>").text(data.text),
	                                $content = $("<div class='dx-button-content' />").append($icon).append($text),
	                                $button = $("<div class='dx-button dx-button-has-text dx-button-has-icon dx-datagrid-toolbar-button'>").append($content),
	                                $toolbarItem = $("<div class ='dx-toolbar-item-auto-hide' />").append($button);
	                            $container.append($toolbarItem).parent().addClass("dx-toolbar-menu-custom dx-toolbar-hidden-button")
	                        },
	                        items = [{
	                            template: function(data, index, $container) {
	                                renderFakeButton(data, $container, DATAGRID_EXPORT_EXCEL_ICON)
	                            },
	                            text: texts.exportAll
	                        }, {
	                            template: function(data, index, $container) {
	                                renderFakeButton(data, $container, DATAGRID_EXPORT_SELECTED_ICON)
	                            },
	                            text: texts.exportSelectedRows,
	                            exportSelected: true
	                        }];
	                    that._createComponent($container, List, {
	                        items: items,
	                        onItemClick: function(e) {
	                            that._exportController.exportToExcel(e.itemData.exportSelected)
	                        },
	                        scrollingEnabled: false
	                    })
	                },
	                _correctSearchPanelPosition: function(items) {
	                    items.sort(function(itemA, itemB) {
	                        var result = 0;
	                        if ("searchPanel" === itemA.name || "columnChooserButton" === itemA.name && "searchPanel" !== itemB.name) {
	                            result = 1
	                        } else {
	                            if ("searchPanel" === itemB.name) {
	                                result = -1
	                            }
	                        }
	                        return result
	                    })
	                },
	                _renderExportMenu: function($buttonContainer) {
	                    var that = this,
	                        $button = $buttonContainer.find(".dx-button"),
	                        texts = that.option("export.texts"),
	                        menuItems = [{
	                            text: texts.exportAll,
	                            icon: DATAGRID_EXPORT_EXCEL_ICON
	                        }, {
	                            text: texts.exportSelectedRows,
	                            exportSelected: true,
	                            icon: DATAGRID_EXPORT_SELECTED_ICON
	                        }],
	                        $menuContainer = $("<div>").appendTo($buttonContainer);
	                    that._contextMenu = that._createComponent($menuContainer, ContextMenu, {
	                        showEvent: "dxclick",
	                        items: menuItems,
	                        cssClass: DATAGRID_EXPORT_MENU_CLASS,
	                        onItemClick: function(e) {
	                            that._exportController.exportToExcel(e.itemData.exportSelected)
	                        },
	                        target: $button,
	                        position: {
	                            at: "left bottom",
	                            my: "left top",
	                            offset: "0 3",
	                            collision: "fit",
	                            boundary: that._$parent,
	                            boundaryOffset: "1 1"
	                        }
	                    })
	                },
	                _isExportButtonVisible: function() {
	                    return this.option("export.enabled")
	                },
	                _getButtonOptions: function(allowExportSelected) {
	                    var options, that = this,
	                        texts = that.option("export.texts");
	                    if (allowExportSelected) {
	                        options = {
	                            hint: texts.exportTo,
	                            icon: DATAGRID_EXPORT_ICON
	                        }
	                    } else {
	                        options = {
	                            hint: texts.exportAll,
	                            icon: DATAGRID_EXPORT_EXCEL_BUTTON_ICON,
	                            onClick: function() {
	                                that._exportController.exportToExcel()
	                            }
	                        }
	                    }
	                    return options
	                },
	                optionChanged: function(args) {
	                    this.callBase(args);
	                    if ("export" === args.name) {
	                        args.handled = true;
	                        this._invalidate();
	                        this.updateToolbar()
	                    }
	                },
	                init: function() {
	                    var that = this;
	                    this.callBase();
	                    this._exportController = this.getController("export");
	                    this._editingController = this.getController("editing");
	                    this._editingController.editingChanged.add(function(hasChanges) {
	                        that.updateToolbarItemOption("exportButton", "disabled", hasChanges)
	                    })
	                },
	                isVisible: function() {
	                    return this.callBase() || this._isExportButtonVisible()
	                }
	            }
	        }
	    }
	});


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    registerComponent = __webpack_require__(44),
	    vizUtils = __webpack_require__(291),
	    overlapping = __webpack_require__(292).overlapping,
	    translatorsModule = __webpack_require__(343),
	    rangeModule = __webpack_require__(349),
	    LayoutManagerModule = __webpack_require__(335),
	    multiAxesSynchronizer = __webpack_require__(350),
	    AdvancedChart = __webpack_require__(351).AdvancedChart,
	    scrollBarModule = __webpack_require__(362),
	    crosshairModule = __webpack_require__(363),
	    MAX_ADJUSTMENT_ATTEMPTS = 5,
	    DEFAULT_PANE_NAME = "default",
	    DEFAULT_PANES = [{
	        name: DEFAULT_PANE_NAME,
	        border: {}
	    }],
	    _map = vizUtils.map,
	    _each = $.each,
	    _extend = $.extend,
	    _isArray = commonUtils.isArray,
	    _isDefined = commonUtils.isDefined;

	function getFirstAxisNameForPane(axes, paneName) {
	    var result;
	    for (var i = 0; i < axes.length; i++) {
	        if (axes[i].pane === paneName) {
	            result = axes[i].name;
	            break
	        }
	    }
	    if (!result) {
	        result = axes[0].name
	    }
	    return result
	}

	function hideGridsOnNonFirstValueAxisForPane(valAxes, paneName, synchronizeMultiAxes) {
	    var firstShownAxis, axesForPane = [];
	    _each(valAxes, function(_, axis) {
	        if (axis.pane === paneName) {
	            axesForPane.push(axis)
	        }
	    });
	    if (axesForPane.length > 1 && synchronizeMultiAxes) {
	        _each(axesForPane, function(_, axis) {
	            var gridOpt = axis.getOptions().grid,
	                minorGridOpt = axis.getOptions().minorGrid;
	            if (firstShownAxis && gridOpt && gridOpt.visible) {
	                gridOpt.visible = false;
	                minorGridOpt && (minorGridOpt.visible = false)
	            } else {
	                firstShownAxis = firstShownAxis ? firstShownAxis : gridOpt && gridOpt.visible
	            }
	        })
	    }
	}

	function getPaneForAxis(paneAxis, axisNameWithoutPane) {
	    var result;
	    _each(paneAxis, function(paneName, pane) {
	        _each(pane, function(axisName) {
	            if (axisNameWithoutPane === axisName) {
	                result = paneName;
	                return false
	            }
	        })
	    });
	    return result
	}

	function findAxisOptions(valueAxes, valueAxesOptions, axisName) {
	    var result, axInd;
	    for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {
	        if (valueAxesOptions[axInd].name === axisName) {
	            result = valueAxesOptions[axInd];
	            result.priority = axInd;
	            break
	        }
	    }
	    if (!result) {
	        for (axInd = 0; axInd < valueAxes.length; axInd++) {
	            if (valueAxes[axInd].name === axisName) {
	                result = valueAxes[axInd].getOptions();
	                result.priority = valueAxes[axInd].priority;
	                break
	            }
	        }
	    }
	    return result
	}

	function findAxis(paneName, axisName, axes) {
	    var axis, i;
	    for (i = 0; i < axes.length; i++) {
	        axis = axes[i];
	        if (axis.name === axisName && axis.pane === paneName) {
	            return axis
	        }
	    }
	}

	function applyClipSettings(clipRects, settings) {
	    _each(clipRects || [], function(_, c) {
	        c && c.attr(settings)
	    })
	}

	function reinitTranslators(translators) {
	    _each(translators, function(_, axisTrans) {
	        _each(axisTrans, function(_, translator) {
	            translator.arg.reinit();
	            translator.val.reinit()
	        })
	    })
	}

	function compareAxes(a, b) {
	    return a.priority - b.priority
	}

	function doesPaneExist(panes, paneName) {
	    var found = false;
	    _each(panes, function(_, pane) {
	        if (pane.name === paneName) {
	            found = true;
	            return false
	        }
	    });
	    return found
	}
	var prepareSegmentRectPoints = function(left, top, width, height, borderOptions) {
	    var maxSW = ~~((width < height ? width : height) / 2),
	        sw = borderOptions.width || 0,
	        newSW = sw < maxSW ? sw : maxSW;
	    left += newSW / 2;
	    top += newSW / 2;
	    width -= newSW;
	    height -= newSW;
	    var segmentSequence, right = left + width,
	        bottom = top + height,
	        points = [],
	        segments = [],
	        visiblyOpt = 0,
	        prevSegmentVisibility = 0;
	    var allSegment = {
	        top: [
	            [left, top],
	            [right, top]
	        ],
	        right: [
	            [right, top],
	            [right, bottom]
	        ],
	        bottom: [
	            [right, bottom],
	            [left, bottom]
	        ],
	        left: [
	            [left, bottom],
	            [left, top]
	        ]
	    };
	    _each(allSegment, function(seg) {
	        var visibility = !!borderOptions[seg];
	        visiblyOpt = 2 * visiblyOpt + ~~visibility
	    });
	    switch (visiblyOpt) {
	        case 13:
	        case 9:
	            segmentSequence = ["left", "top", "right", "bottom"];
	            break;
	        case 11:
	            segmentSequence = ["bottom", "left", "top", "right"];
	            break;
	        default:
	            segmentSequence = ["top", "right", "bottom", "left"]
	    }
	    _each(segmentSequence, function(_, seg) {
	        var segmentVisibility = !!borderOptions[seg];
	        if (!prevSegmentVisibility && segments.length) {
	            points.push(segments);
	            segments = []
	        }
	        if (segmentVisibility) {
	            _each(allSegment[seg].slice(prevSegmentVisibility), function(_, segment) {
	                segments = segments.concat(segment)
	            })
	        }
	        prevSegmentVisibility = ~~segmentVisibility
	    });
	    segments.length && points.push(segments);
	    1 === points.length && (points = points[0]);
	    return {
	        points: points,
	        pathType: 15 === visiblyOpt ? "area" : "line"
	    }
	};
	var dxChart = AdvancedChart.inherit({
	    _chartType: "chart",
	    _initCore: function() {
	        this.paneAxis = {};
	        this._panesClipRects = {};
	        this.callBase()
	    },
	    _disposeCore: function() {
	        var that = this,
	            disposeObjectsInArray = this._disposeObjectsInArray,
	            panesClipRects = that._panesClipRects;
	        that.callBase();
	        disposeObjectsInArray.call(panesClipRects, "fixed");
	        disposeObjectsInArray.call(panesClipRects, "base");
	        disposeObjectsInArray.call(panesClipRects, "wide");
	        that._panesClipRects = null
	    },
	    _correctAxes: function() {
	        this._correctValueAxes()
	    },
	    _getExtraOptions: $.noop,
	    _processSingleSeries: $.noop,
	    _groupSeries: function() {
	        var that = this,
	            panes = that.panes,
	            valAxes = that._valueAxes,
	            paneList = _map(panes, function(pane) {
	                return pane.name
	            }),
	            series = that.series,
	            paneAxis = that.paneAxis,
	            synchronizeMultiAxes = that._themeManager.getOptions("synchronizeMultiAxes"),
	            groupedSeries = that._groupsData = {
	                groups: []
	            };
	        _each(series, function(i, particularSeries) {
	            particularSeries.axis = particularSeries.axis || getFirstAxisNameForPane(valAxes, particularSeries.pane);
	            if (particularSeries.axis) {
	                paneAxis[particularSeries.pane] = paneAxis[particularSeries.pane] || {};
	                paneAxis[particularSeries.pane][particularSeries.axis] = true
	            }
	        });
	        _each(valAxes, function(_, axis) {
	            if (axis.name && axis.pane && $.inArray(axis.pane, paneList) !== -1) {
	                paneAxis[axis.pane] = paneAxis[axis.pane] || {};
	                paneAxis[axis.pane][axis.name] = true
	            }
	        });
	        that._correctValueAxes();
	        _each(paneAxis, function(paneName, pane) {
	            hideGridsOnNonFirstValueAxisForPane(valAxes, paneName, synchronizeMultiAxes);
	            _each(pane, function(axisName) {
	                var group = {
	                    series: []
	                };
	                _each(series, function(_, particularSeries) {
	                    if (particularSeries.pane === paneName && particularSeries.axis === axisName) {
	                        group.series.push(particularSeries)
	                    }
	                });
	                groupedSeries.groups.push(group);
	                group.valueAxis = findAxis(paneName, axisName, valAxes);
	                group.valueOptions = group.valueAxis.getOptions()
	            })
	        });
	        groupedSeries.argumentAxes = that._argumentAxes;
	        groupedSeries.argumentOptions = groupedSeries.argumentAxes[0].getOptions()
	    },
	    _cleanPanesClipRects: function(clipArrayName) {
	        var that = this,
	            clipArray = that._panesClipRects[clipArrayName];
	        _each(clipArray || [], function(_, clipRect) {
	            clipRect && clipRect.dispose()
	        });
	        that._panesClipRects[clipArrayName] = []
	    },
	    _createPanes: function() {
	        var defaultPane, that = this,
	            panes = that.option("panes"),
	            panesNameCounter = 0;
	        if (!panes || _isArray(panes) && !panes.length) {
	            panes = DEFAULT_PANES
	        }
	        that._cleanPanesClipRects("fixed");
	        that._cleanPanesClipRects("base");
	        that._cleanPanesClipRects("wide");
	        defaultPane = that.option("defaultPane");
	        panes = _extend(true, [], _isArray(panes) ? panes : [panes]);
	        _each(panes, function(_, pane) {
	            pane.name = !_isDefined(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name
	        });
	        if (_isDefined(defaultPane)) {
	            if (!doesPaneExist(panes, defaultPane)) {
	                that._incidentOccurred("W2101", [defaultPane]);
	                defaultPane = panes[panes.length - 1].name
	            }
	        } else {
	            defaultPane = panes[panes.length - 1].name
	        }
	        that.defaultPane = defaultPane;
	        panes = that._isRotated() ? panes.reverse() : panes;
	        return panes
	    },
	    _getAxisRenderingOptions: function() {
	        return {
	            axisType: "xyAxes",
	            drawingType: "linear"
	        }
	    },
	    _prepareAxisOptions: function(typeSelector, userOptions, rotated) {
	        return {
	            isHorizontal: "argumentAxis" === typeSelector !== rotated
	        }
	    },
	    _checkPaneName: function(seriesTheme) {
	        var paneList = _map(this.panes, function(pane) {
	            return pane.name
	        });
	        seriesTheme.pane = seriesTheme.pane || this.defaultPane;
	        return $.inArray(seriesTheme.pane, paneList) !== -1
	    },
	    _correctValueAxes: function() {
	        var that = this,
	            rotated = that._isRotated(),
	            valueAxisOptions = that.option("valueAxis") || {},
	            valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions],
	            valueAxes = that._valueAxes || [],
	            defaultAxisName = valueAxes[0].name,
	            paneAxis = that.paneAxis,
	            neededAxis = {};
	        _each(valueAxes, function(_, axis) {
	            var pane;
	            if (!axis.pane) {
	                pane = getPaneForAxis(paneAxis, axis.name);
	                if (!pane) {
	                    pane = that.defaultPane;
	                    (paneAxis[pane] = paneAxis[pane] || {})[axis.name] = true
	                }
	                axis.setPane(pane)
	            }
	        });
	        _each(that.panes, function(_, pane) {
	            var name = pane.name;
	            if (!paneAxis[name]) {
	                paneAxis[name] = {};
	                paneAxis[name][defaultAxisName] = true
	            }
	        });
	        _each(paneAxis, function(paneName, axisNames) {
	            _each(axisNames, function(axisName) {
	                var axisOptions;
	                neededAxis[axisName + "-" + paneName] = true;
	                if (!findAxis(paneName, axisName, valueAxes)) {
	                    axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);
	                    if (!axisOptions) {
	                        that._incidentOccurred("W2102", [axisName]);
	                        axisOptions = {
	                            name: axisName,
	                            priority: valueAxes.length
	                        }
	                    }
	                    valueAxes.push(that._createAxis("valueAxis", axisOptions, {
	                        pane: paneName,
	                        name: axisName
	                    }, rotated))
	                }
	            })
	        });
	        that._valueAxes = $.grep(valueAxes, function(elem) {
	            return !!neededAxis[elem.name + "-" + elem.pane]
	        }).sort(compareAxes)
	    },
	    _getSeriesForPane: function(paneName) {
	        var paneSeries = [];
	        _each(this.series, function(_, oneSeries) {
	            if (oneSeries.pane === paneName) {
	                paneSeries.push(oneSeries)
	            }
	        });
	        return paneSeries
	    },
	    _createTranslator: function(range, canvas, options) {
	        return new translatorsModule.Translator2D(range, canvas, options)
	    },
	    _createPanesBorderOptions: function() {
	        var commonBorderOptions = this._themeManager.getOptions("commonPaneSettings").border,
	            panesBorderOptions = {};
	        _each(this.panes, function(_, pane) {
	            panesBorderOptions[pane.name] = _extend(true, {}, commonBorderOptions, pane.border)
	        });
	        return panesBorderOptions
	    },
	    _createScrollBar: function() {
	        var that = this,
	            scrollBarOptions = that._themeManager.getOptions("scrollBar") || {},
	            scrollBarGroup = that._scrollBarGroup;
	        if (scrollBarOptions.visible) {
	            scrollBarOptions.rotated = that._isRotated();
	            that._scrollBar = (that._scrollBar || new scrollBarModule.ScrollBar(that._renderer, scrollBarGroup)).update(scrollBarOptions)
	        } else {
	            scrollBarGroup.linkRemove();
	            that._scrollBar && that._scrollBar.dispose();
	            that._scrollBar = null
	        }
	    },
	    _prepareToRender: function(drawOptions) {
	        var that = this,
	            panesBorderOptions = that._createPanesBorderOptions(),
	            useAggregation = that._options.useAggregation;
	        that._createPanesBackground();
	        that._appendAxesGroups();
	        that._transformed && that._resetTransform();
	        that._createTranslators(drawOptions);
	        if (useAggregation) {
	            _each(that.series, function(_, series) {
	                series.resamplePoints(that._getTranslator(series.pane, series.axis).arg, that._zoomMinArg, that._zoomMaxArg)
	            })
	        }
	        if (useAggregation || _isDefined(that._zoomMinArg) || _isDefined(that._zoomMaxArg)) {
	            that._populateBusinessRange({
	                adjustOnZoom: that._themeManager.getOptions("adjustOnZoom"),
	                minArg: that._zoomMinArg,
	                maxArg: that._zoomMaxArg,
	                notApplyMargins: that._notApplyMargins
	            });
	            that._updateTranslators()
	        }
	        return panesBorderOptions
	    },
	    _isLegendInside: function() {
	        return this._legend && "inside" === this._legend.getPosition()
	    },
	    _renderAxes: function(drawOptions, panesBorderOptions, rotated, adjustUnits) {
	        if (drawOptions && drawOptions.recreateCanvas) {
	            vizUtils.updatePanesCanvases(this.panes, this._canvas, rotated)
	        }
	        this._drawAxes(panesBorderOptions, drawOptions, adjustUnits)
	    },
	    _isRotated: function() {
	        return this._themeManager.getOptions("rotated")
	    },
	    _getLayoutTargets: function() {
	        return this.panes
	    },
	    _applyClipRects: function(panesBorderOptions) {
	        var i, that = this,
	            canvasClipRectID = that._getCanvasClipRectID();
	        that._drawPanesBorders(panesBorderOptions);
	        that._createClipRectsForPanes();
	        for (i = 0; i < that._argumentAxes.length; i++) {
	            that._argumentAxes[i].applyClipRects(that._getElementsClipRectID(that._argumentAxes[i].pane), canvasClipRectID)
	        }
	        for (i = 0; i < that._valueAxes.length; i++) {
	            that._valueAxes[i].applyClipRects(that._getElementsClipRectID(that._valueAxes[i].pane), canvasClipRectID)
	        }
	        that._fillPanesBackground()
	    },
	    _updateLegendPosition: function(drawOptions, legendHasInsidePosition) {
	        var that = this;
	        if (drawOptions.drawLegend && that._legend && legendHasInsidePosition) {
	            var panes = that.panes,
	                newCanvas = _extend({}, panes[0].canvas),
	                layoutManager = new LayoutManagerModule.LayoutManager;
	            newCanvas.right = panes[panes.length - 1].canvas.right;
	            newCanvas.bottom = panes[panes.length - 1].canvas.bottom;
	            layoutManager.setOptions({
	                width: 0,
	                height: 0
	            });
	            layoutManager.layoutElements([that._legend], newCanvas, $.noop, [{
	                canvas: newCanvas
	            }], void 0, {
	                horizontalAxes: [],
	                verticalAxes: []
	            })
	        }
	    },
	    _prepareTranslators: function(series, _, rotated) {
	        var tr = this._getTranslator(series.pane, series.axis),
	            translators = {};
	        translators[rotated ? "x" : "y"] = tr.val;
	        translators[rotated ? "y" : "x"] = tr.arg;
	        return translators
	    },
	    _applyExtraSettings: function(series) {
	        var that = this,
	            paneIndex = that._getPaneIndex(series.pane),
	            panesClipRects = that._panesClipRects,
	            wideClipRect = panesClipRects.wide[paneIndex];
	        series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, that._getPaneBorderVisibility(paneIndex))
	    },
	    _createTranslators: function(drawOptions) {
	        var translators, that = this,
	            rotated = that._isRotated();
	        if (!drawOptions.recreateCanvas) {
	            return
	        }
	        that.translators = translators = {};
	        vizUtils.updatePanesCanvases(that.panes, that._canvas, rotated);
	        _each(that.paneAxis, function(paneName, pane) {
	            translators[paneName] = translators[paneName] || {};
	            _each(pane, function(axisName) {
	                var translator = that._createTranslator(new rangeModule.Range(that._getBusinessRange(paneName, axisName).val), that._getCanvasForPane(paneName), {
	                    isHorizontal: !!rotated
	                });
	                translator.pane = paneName;
	                translator.axis = axisName;
	                translators[paneName][axisName] = {
	                    val: translator
	                }
	            })
	        });
	        _each(that._argumentAxes, function(_, axis) {
	            var translator = that._createTranslator(new rangeModule.Range(that._getBusinessRange(axis.pane).arg), that._getCanvasForPane(axis.pane), {
	                isHorizontal: !rotated
	            });
	            _each(translators[axis.pane], function(valAxis, paneAxisTranslator) {
	                paneAxisTranslator.arg = translator
	            })
	        })
	    },
	    _updateTranslators: function() {
	        var that = this;
	        _each(that.translators, function(pane, axisTrans) {
	            _each(axisTrans, function(axis, translator) {
	                translator.arg.updateBusinessRange(new rangeModule.Range(that._getBusinessRange(pane).arg));
	                delete translator.arg._originalBusinessRange;
	                translator.val.updateBusinessRange(new rangeModule.Range(that._getBusinessRange(pane, axis).val));
	                delete translator.val._originalBusinessRange
	            })
	        })
	    },
	    _getAxesForTransform: function(rotated) {
	        return {
	            verticalAxes: !rotated ? this._getValueAxes() : this._getArgumentAxes(),
	            horizontalAxes: !rotated ? this._getArgumentAxes() : this._getValueAxes()
	        }
	    },
	    _getAxisDrawingMethods: function(drawOptions, preparedOptions, isRotated) {
	        var that = this;
	        return function(adjustUnits) {
	            that._renderAxes(drawOptions, preparedOptions, isRotated, adjustUnits)
	        }
	    },
	    _reinitTranslators: function() {
	        var that = this;
	        _each(that._argumentAxes, function(_, axis) {
	            var translator = that._getTranslator(axis.pane);
	            if (translator) {
	                translator.arg.reinit();
	                axis.setTranslator(translator.arg, translator.val)
	            }
	        });
	        _each(that._valueAxes, function(_, axis) {
	            var translator = that._getTranslator(axis.pane, axis.name);
	            if (translator) {
	                translator.val.reinit();
	                axis.setTranslator(translator.val, translator.arg)
	            }
	        })
	    },
	    _saveBusinessRange: function() {
	        var savedBusinessRange = this._savedBusinessRange;
	        $.each(this.translators, function(name, pane) {
	            savedBusinessRange[name] = {};
	            $.each(pane, function(axisName, translator) {
	                savedBusinessRange[name][axisName] = {};
	                savedBusinessRange[name][axisName].arg = $.extend(true, {}, translator.arg.getBusinessRange());
	                savedBusinessRange[name][axisName].val = $.extend(true, {}, translator.val.getBusinessRange())
	            })
	        })
	    },
	    _restoreOriginalBusinessRange: function() {
	        var savedBusinessRange = this._savedBusinessRange;
	        $.each(this.translators, function(name, pane) {
	            $.each(pane, function(axisName, translator) {
	                translator.arg.updateBusinessRange($.extend(true, {}, savedBusinessRange[name][axisName].arg));
	                translator.val.updateBusinessRange($.extend(true, {}, savedBusinessRange[name][axisName].val))
	            })
	        })
	    },
	    _prepareAxesAndDraw: function(drawAxes, drawStaticAxisElements, drawOptions) {
	        var that = this,
	            i = 0,
	            layoutManager = that.layoutManager,
	            rotated = that._isRotated(),
	            adjustmentCounter = 0,
	            synchronizeMultiAxes = that._themeManager.getOptions("synchronizeMultiAxes"),
	            layoutTargets = that._getLayoutTargets(),
	            verticalAxes = rotated ? that._argumentAxes : that._valueAxes,
	            horizontalAxes = rotated ? that._valueAxes : that._argumentAxes,
	            hElements = horizontalAxes,
	            vElements = verticalAxes;
	        if (that._scrollBar) {
	            that._scrollBar.setPane(layoutTargets);
	            if (rotated) {
	                vElements = [that._scrollBar].concat(vElements)
	            } else {
	                hElements = hElements.concat([that._scrollBar])
	            }
	        }
	        do {
	            for (i = 0; i < that._argumentAxes.length; i++) {
	                that._argumentAxes[i].resetTicks()
	            }
	            for (i = 0; i < that._valueAxes.length; i++) {
	                that._valueAxes[i].resetTicks()
	            }
	            if (synchronizeMultiAxes) {
	                multiAxesSynchronizer.synchronize(that._valueAxes)
	            }
	            drawAxes(horizontalAxes);
	            layoutManager.requireAxesRedraw = false;
	            if (drawOptions.adjustAxes) {
	                layoutManager.applyHorizontalAxesLayout(hElements, layoutTargets, rotated);
	                !layoutManager.stopDrawAxes && reinitTranslators(that.translators)
	            }
	            drawAxes(verticalAxes);
	            if (drawOptions.adjustAxes && !layoutManager.stopDrawAxes) {
	                layoutManager.applyVerticalAxesLayout(vElements, layoutTargets, rotated);
	                !layoutManager.stopDrawAxes && reinitTranslators(that.translators)
	            }
	            adjustmentCounter += 1
	        } while (!layoutManager.stopDrawAxes && layoutManager.requireAxesRedraw && adjustmentCounter < MAX_ADJUSTMENT_ATTEMPTS);
	        drawStaticAxisElements(verticalAxes);
	        drawStaticAxisElements(horizontalAxes);
	        that._scrollBar && that._scrollBar.applyLayout()
	    },
	    _getPanesParameters: function() {
	        var i, that = this,
	            panes = that.panes,
	            params = [];
	        for (i = 0; i < panes.length; i++) {
	            if (that._getPaneBorderVisibility(i)) {
	                params.push({
	                    coords: panes[i].borderCoords,
	                    clipRect: that._panesClipRects.fixed[i]
	                })
	            }
	        }
	        return params
	    },
	    _createCrosshairCursor: function() {
	        var that = this,
	            options = that._themeManager.getOptions("crosshair") || {},
	            index = that._displayedArgumentAxisIndex,
	            axes = !that._isRotated() ? [
	                [that._argumentAxes[index]], that._valueAxes
	            ] : [that._valueAxes, [that._argumentAxes[index]]],
	            parameters = {
	                canvas: that._getCommonCanvas(),
	                panes: that._getPanesParameters(),
	                axes: axes
	            };
	        if (!options || !options.enabled) {
	            return
	        }
	        if (!that._crosshair) {
	            that._crosshair = new crosshairModule.Crosshair(that._renderer, options, parameters, that._crosshairCursorGroup)
	        } else {
	            that._crosshair.update(options, parameters)
	        }
	        that._crosshair.render()
	    },
	    _getCommonCanvas: function() {
	        var i, canvas, commonCanvas, panes = this.panes;
	        for (i = 0; i < panes.length; i++) {
	            canvas = panes[i].canvas;
	            if (!commonCanvas) {
	                commonCanvas = _extend({}, canvas)
	            } else {
	                commonCanvas.right = canvas.right;
	                commonCanvas.bottom = canvas.bottom
	            }
	        }
	        return commonCanvas
	    },
	    _createPanesBackground: function() {
	        var backgroundColor, rect, i, that = this,
	            defaultBackgroundColor = that._themeManager.getOptions("commonPaneSettings").backgroundColor,
	            renderer = that._renderer,
	            rects = [];
	        that._panesBackgroundGroup.clear();
	        for (i = 0; i < that.panes.length; i++) {
	            backgroundColor = that.panes[i].backgroundColor || defaultBackgroundColor;
	            if (!backgroundColor || "none" === backgroundColor) {
	                rects.push(null);
	                continue
	            }
	            rect = renderer.rect(0, 0, 0, 0).attr({
	                fill: backgroundColor,
	                "stroke-width": 0
	            }).append(that._panesBackgroundGroup);
	            rects.push(rect)
	        }
	        that.panesBackground = rects
	    },
	    _fillPanesBackground: function() {
	        var bc, that = this;
	        _each(that.panes, function(i, pane) {
	            bc = pane.borderCoords;
	            if (null !== that.panesBackground[i]) {
	                that.panesBackground[i].attr({
	                    x: bc.left,
	                    y: bc.top,
	                    width: bc.width,
	                    height: bc.height
	                })
	            }
	        })
	    },
	    _calcPaneBorderCoords: function(pane) {
	        var canvas = pane.canvas,
	            bc = pane.borderCoords = pane.borderCoords || {};
	        bc.left = canvas.left;
	        bc.top = canvas.top;
	        bc.right = canvas.width - canvas.right;
	        bc.bottom = canvas.height - canvas.bottom;
	        bc.width = Math.max(bc.right - bc.left, 0);
	        bc.height = Math.max(bc.bottom - bc.top, 0)
	    },
	    _drawPanesBorders: function(panesBorderOptions) {
	        var that = this,
	            rotated = that._isRotated();
	        that._panesBorderGroup.linkRemove().clear();
	        _each(that.panes, function(i, pane) {
	            var bc, segmentRectParams, borderOptions = panesBorderOptions[pane.name],
	                attr = {
	                    fill: "none",
	                    stroke: borderOptions.color,
	                    "stroke-opacity": borderOptions.opacity,
	                    "stroke-width": borderOptions.width,
	                    dashStyle: borderOptions.dashStyle,
	                    "stroke-linecap": "square"
	                };
	            that._calcPaneBorderCoords(pane, rotated);
	            if (!borderOptions.visible) {
	                return
	            }
	            bc = pane.borderCoords;
	            segmentRectParams = prepareSegmentRectPoints(bc.left, bc.top, bc.width, bc.height, borderOptions);
	            that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup)
	        });
	        that._panesBorderGroup.linkAppend()
	    },
	    _createClipRect: function(clipArray, index, left, top, width, height) {
	        var that = this,
	            clipRect = clipArray[index];
	        if (!clipRect) {
	            clipRect = that._renderer.clipRect(left, top, width, height);
	            clipArray[index] = clipRect
	        } else {
	            clipRect.attr({
	                x: left,
	                y: top,
	                width: width,
	                height: height
	            })
	        }
	    },
	    _createClipRectsForPanes: function() {
	        var that = this,
	            canvas = that._canvas;
	        _each(that.panes, function(i, pane) {
	            var needWideClipRect = false,
	                bc = pane.borderCoords,
	                left = bc.left,
	                top = bc.top,
	                width = bc.width,
	                height = bc.height,
	                panesClipRects = that._panesClipRects;
	            that._createClipRect(panesClipRects.fixed, i, left, top, width, height);
	            that._createClipRect(panesClipRects.base, i, left, top, width, height);
	            _each(that.series, function(_, series) {
	                if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {
	                    needWideClipRect = true
	                }
	            });
	            if (needWideClipRect) {
	                if (that._isRotated()) {
	                    top = 0;
	                    height = canvas.height
	                } else {
	                    left = 0;
	                    width = canvas.width
	                }
	                that._createClipRect(panesClipRects.wide, i, left, top, width, height)
	            } else {
	                panesClipRects.wide.push(null)
	            }
	        })
	    },
	    _getPaneIndex: function(paneName) {
	        var paneIndex;
	        _each(this.panes, function(index, pane) {
	            if (pane.name === paneName) {
	                paneIndex = index;
	                return false
	            }
	        });
	        return paneIndex
	    },
	    _getPaneBorderVisibility: function(paneIndex) {
	        var commonPaneBorderVisible = this._themeManager.getOptions("commonPaneSettings").border.visible,
	            pane = this.panes[paneIndex] || {},
	            paneBorder = pane.border || {};
	        return "visible" in paneBorder ? paneBorder.visible : commonPaneBorderVisible
	    },
	    _getElementsClipRectID: function(paneName) {
	        return this._panesClipRects.fixed[this._getPaneIndex(paneName)].id
	    },
	    _getTranslator: function(paneName, axisName) {
	        var paneTrans = this.translators[paneName],
	            foundTranslator = null;
	        if (!paneTrans) {
	            return foundTranslator
	        }
	        foundTranslator = paneTrans[axisName];
	        if (!foundTranslator) {
	            _each(paneTrans, function(axis, trans) {
	                foundTranslator = trans;
	                return false
	            });
	            foundTranslator = _extend({
	                axesTrans: paneTrans
	            }, foundTranslator)
	        }
	        return foundTranslator
	    },
	    _getCanvasForPane: function(paneName) {
	        var i, panes = this.panes,
	            panesNumber = panes.length;
	        for (i = 0; i < panesNumber; i++) {
	            if (panes[i].name === paneName) {
	                return panes[i].canvas
	            }
	        }
	    },
	    _getBusinessRange: function(paneName, axisName) {
	        var foundRange, i, ranges = this.businessRanges || [],
	            rangesNumber = ranges.length;
	        for (i = 0; i < rangesNumber; i++) {
	            if (ranges[i].val.pane === paneName && ranges[i].val.axis === axisName) {
	                foundRange = ranges[i];
	                break
	            }
	        }
	        if (!foundRange) {
	            for (i = 0; i < rangesNumber; i++) {
	                if (ranges[i].val.pane === paneName) {
	                    foundRange = ranges[i];
	                    break
	                }
	            }
	        }
	        return foundRange
	    },
	    _transformArgument: function(translate, scale) {
	        var settings, clipSettings, that = this,
	            rotated = that._isRotated(),
	            panesClipRects = that._panesClipRects;
	        if (!that._transformed) {
	            that._transformed = true;
	            that._labelsGroup.remove();
	            that._resetIsReady();
	            _each(that.series || [], function(i, s) {
	                s.applyClip()
	            })
	        }
	        if (rotated) {
	            settings = {
	                translateY: translate,
	                scaleY: scale
	            };
	            clipSettings = {
	                translateY: -translate / scale,
	                scaleY: 1 / scale
	            }
	        } else {
	            settings = {
	                translateX: translate,
	                scaleX: scale
	            };
	            clipSettings = {
	                translateX: -translate / scale,
	                scaleX: 1 / scale
	            }
	        }
	        applyClipSettings(panesClipRects.base, clipSettings);
	        applyClipSettings(panesClipRects.wide, clipSettings);
	        that._seriesGroup.attr(settings);
	        that._scrollBar && that._scrollBar.transform(-translate, scale)
	    },
	    _resetTransform: function() {
	        var that = this,
	            settings = {
	                translateX: 0,
	                translateY: 0,
	                scaleX: null,
	                scaleY: null
	            },
	            panesClipRects = that._panesClipRects;
	        applyClipSettings(panesClipRects.base, settings);
	        applyClipSettings(panesClipRects.wide, settings);
	        that._seriesGroup.attr(settings);
	        _each(that.series || [], function(i, s) {
	            s.resetClip()
	        });
	        that._transformed = false
	    },
	    _getTrackerSettings: function() {
	        var that = this,
	            themeManager = that._themeManager;
	        return _extend(this.callBase(), {
	            chart: that,
	            zoomingMode: themeManager.getOptions("zoomingMode"),
	            scrollingMode: themeManager.getOptions("scrollingMode"),
	            rotated: that._isRotated(),
	            crosshair: that._getCrosshairOptions().enabled ? that._crosshair : null
	        })
	    },
	    _resolveLabelOverlappingStack: function() {
	        var that = this,
	            isRotated = that._isRotated(),
	            shiftDirection = isRotated ? function(box, length) {
	                return {
	                    x: box.x - length,
	                    y: box.y
	                }
	            } : function(box, length) {
	                return {
	                    x: box.x,
	                    y: box.y - length
	                }
	            };
	        _each(that._getStackPoints(), function(_, stacks) {
	            _each(stacks, function(_, points) {
	                overlapping.resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, shiftDirection)
	            })
	        })
	    },
	    _getStackPoints: function() {
	        var stackPoints = {},
	            visibleSeries = this._getVisibleSeries();
	        _each(visibleSeries, function(_, singleSeries) {
	            var points = singleSeries.getPoints(),
	                stackName = singleSeries.getStackName() || null;
	            _each(points, function(_, point) {
	                var argument = point.argument;
	                if (!stackPoints[argument]) {
	                    stackPoints[argument] = {}
	                }
	                if (!stackPoints[argument][stackName]) {
	                    stackPoints[argument][stackName] = []
	                }
	                stackPoints[argument][stackName].push(point)
	            })
	        });
	        return stackPoints
	    },
	    _getCrosshairOptions: function() {
	        return this._getOption("crosshair")
	    },
	    zoomArgument: function(min, max, gesturesUsed) {
	        var bounds, zoomArg, that = this;
	        if (!_isDefined(min) && !_isDefined(max)) {
	            return
	        }
	        if (!gesturesUsed) {
	            that._eventTrigger("zoomStart")
	        }
	        zoomArg = that._argumentAxes[0].zoom(min, max, gesturesUsed);
	        that._zoomMinArg = zoomArg.min;
	        that._zoomMaxArg = zoomArg.max;
	        that._notApplyMargins = gesturesUsed;
	        that._doRender({
	            force: true,
	            drawTitle: false,
	            drawLegend: false,
	            adjustAxes: false,
	            animate: false
	        });
	        bounds = that.getVisibleArgumentBounds();
	        that._eventTrigger("zoomEnd", {
	            rangeStart: bounds.minVisible,
	            rangeEnd: bounds.maxVisible
	        })
	    },
	    _resetZoom: function() {
	        var that = this;
	        that._zoomMinArg = that._zoomMaxArg = void 0;
	        that._argumentAxes[0] && that._argumentAxes[0].resetZoom()
	    },
	    getVisibleArgumentBounds: function() {
	        var range = this._argumentAxes[0].getTranslator().getBusinessRange(),
	            isDiscrete = "discrete" === range.axisType,
	            categories = range.categories;
	        return {
	            minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,
	            maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible
	        }
	    }
	});
	registerComponent("dxChart", dxChart);
	module.exports = dxChart;
	module.exports.default = module.exports;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/utils.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _inArray = $.inArray,
	    _each = $.each,
	    _math = Math,
	    _round = _math.round,
	    _sqrt = Math.sqrt,
	    _extend = $.extend;
	var PI = Math.PI,
	    MAX_PIXEL_COUNT = 1e10,
	    PI_DIV_180 = PI / 180,
	    LN10 = Math.LN10;
	var cosFunc = Math.cos,
	    sinFunc = Math.sin,
	    abs = Math.abs,
	    log = Math.log,
	    floor = Math.floor,
	    ceil = Math.ceil,
	    max = Math.max,
	    isNaN = window.isNaN,
	    Number = window.Number,
	    NaN = window.NaN;
	var isNumber = commonUtils.isNumber,
	    isExponential = commonUtils.isExponential;
	var getPrecision = function(value) {
	    var stringFraction, startIndex, precision, stringValue = value.toString(),
	        pointIndex = stringValue.indexOf(".");
	    if (isExponential(value)) {
	        precision = getDecimalOrder(value);
	        if (precision < 0) {
	            return Math.abs(precision)
	        } else {
	            return 0
	        }
	    }
	    if (pointIndex !== -1) {
	        startIndex = pointIndex + 1;
	        stringFraction = stringValue.substring(startIndex, startIndex + 20);
	        return stringFraction.length
	    }
	    return 0
	};
	var getLog = function(value, base) {
	    if (!value) {
	        return NaN
	    }
	    return Math.log(value) / Math.log(base)
	};
	var raiseTo = function(power, base) {
	    return Math.pow(base, power)
	};
	var normalizeAngle = function(angle) {
	    return (angle % 360 + 360) % 360
	};
	var convertAngleToRendererSpace = function(angle) {
	    return 90 - angle
	};
	var degreesToRadians = function(value) {
	    return PI * value / 180
	};
	var getCosAndSin = function(angle) {
	    var angleInRadians = degreesToRadians(angle);
	    return {
	        cos: cosFunc(angleInRadians),
	        sin: sinFunc(angleInRadians)
	    }
	};
	var DECIMAL_ORDER_THRESHOLD = 1e-14;
	var getDistance = function(x1, y1, x2, y2) {
	    var diffX = x2 - x1,
	        diffY = y2 - y1;
	    return Math.sqrt(diffY * diffY + diffX * diffX)
	};
	var getDecimalOrder = function(number) {
	    var cn, n = abs(number);
	    if (!isNaN(n)) {
	        if (n > 0) {
	            n = log(n) / LN10;
	            cn = ceil(n);
	            return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
	        }
	        return 0
	    }
	    return NaN
	};
	var getAppropriateFormat = function(start, end, count) {
	    var format, order = max(getDecimalOrder(start), getDecimalOrder(end)),
	        precision = -getDecimalOrder(abs(end - start) / count);
	    if (!isNaN(order) && !isNaN(precision)) {
	        if (abs(order) <= 4) {
	            format = "fixedPoint";
	            precision < 0 && (precision = 0);
	            precision > 4 && (precision = 4)
	        } else {
	            format = "exponential";
	            precision += order - 1;
	            precision > 3 && (precision = 3)
	        }
	        return {
	            type: format,
	            precision: precision
	        }
	    }
	    return null
	};
	var getFraction = function(value) {
	    var valueString, dotIndex;
	    if (isNumber(value)) {
	        valueString = value.toString();
	        dotIndex = valueString.indexOf(".");
	        if (dotIndex >= 0) {
	            if (isExponential(value)) {
	                return valueString.substr(dotIndex + 1, valueString.indexOf("e") - dotIndex - 1)
	            } else {
	                valueString = value.toFixed(20);
	                return valueString.substr(dotIndex + 1, valueString.length - dotIndex + 1)
	            }
	        }
	    }
	    return ""
	};
	var getSignificantDigitPosition = function(value) {
	    var i, fraction = getFraction(value);
	    if (fraction) {
	        for (i = 0; i < fraction.length; i++) {
	            if ("0" !== fraction.charAt(i)) {
	                return i + 1
	            }
	        }
	    }
	    return 0
	};
	var adjustValue = function(value) {
	    var nextValue, i, fraction = getFraction(value);
	    if (fraction) {
	        for (i = 1; i <= fraction.length; i++) {
	            nextValue = roundValue(value, i);
	            if (0 !== nextValue && fraction[i - 2] && fraction[i - 1] && fraction[i - 2] === fraction[i - 1]) {
	                return nextValue
	            }
	        }
	    }
	    return value
	};
	var roundValue = function(value, precision) {
	    if (precision > 20) {
	        precision = 20
	    }
	    if (isNumber(value)) {
	        if (isExponential(value)) {
	            return Number(value.toExponential(precision))
	        } else {
	            return Number(value.toFixed(precision))
	        }
	    }
	};
	var applyPrecisionByMinDelta = function(min, delta, value) {
	    var minPrecision = getPrecision(min),
	        deltaPrecision = getPrecision(delta);
	    return roundValue(value, minPrecision < deltaPrecision ? deltaPrecision : minPrecision)
	};
	var getPower = function(value) {
	    return value.toExponential().split("e")[1]
	};

	function map(array, callback) {
	    var value, i = 0,
	        len = array.length,
	        result = [];
	    while (i < len) {
	        value = callback(array[i], i);
	        if (null !== value) {
	            result.push(value)
	        }
	        i++
	    }
	    return result
	}

	function selectByKeys(object, keys) {
	    return map(keys, function(key) {
	        return object[key] ? object[key] : null
	    })
	}

	function decreaseFields(object, keys, eachDecrease, decrease) {
	    var dec = decrease;
	    _each(keys, function(_, key) {
	        if (object[key]) {
	            object[key] -= eachDecrease;
	            dec -= eachDecrease
	        }
	    });
	    return dec
	}

	function normalizeEnum(value) {
	    return String(value).toLowerCase()
	}

	function setCanvasValues(canvas) {
	    if (canvas) {
	        canvas.originalTop = canvas.top;
	        canvas.originalBottom = canvas.bottom;
	        canvas.originalLeft = canvas.left;
	        canvas.originalRight = canvas.right
	    }
	}

	function normalizeBBoxField(value) {
	    return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0
	}

	function normalizeBBox(bBox) {
	    var xl = normalizeBBoxField(floor(bBox.x)),
	        yt = normalizeBBoxField(floor(bBox.y)),
	        xr = normalizeBBoxField(ceil(bBox.width + bBox.x)),
	        yb = normalizeBBoxField(ceil(bBox.height + bBox.y)),
	        result = {
	            x: xl,
	            y: yt,
	            width: xr - xl,
	            height: yb - yt
	        };
	    result.isEmpty = !result.x && !result.y && !result.width && !result.height;
	    return result
	}

	function rotateBBox(bBox, center, angle) {
	    var cos = Number(cosFunc(angle * PI_DIV_180).toFixed(3)),
	        sin = Number(sinFunc(angle * PI_DIV_180).toFixed(3)),
	        w2 = bBox.width / 2,
	        h2 = bBox.height / 2,
	        centerX = bBox.x + w2,
	        centerY = bBox.y + h2,
	        w2_ = abs(w2 * cos) + abs(h2 * sin),
	        h2_ = abs(w2 * sin) + abs(h2 * cos),
	        centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin,
	        centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;
	    return normalizeBBox({
	        x: centerX_ - w2_,
	        y: centerY_ - h2_,
	        width: 2 * w2_,
	        height: 2 * h2_
	    })
	}
	$.extend(exports, {
	    decreaseGaps: function(object, keys, decrease) {
	        var arrayGaps;
	        do {
	            arrayGaps = selectByKeys(object, keys);
	            arrayGaps.push(_math.ceil(decrease / arrayGaps.length));
	            decrease = decreaseFields(object, keys, _math.min.apply(null, arrayGaps), decrease)
	        } while (decrease > 0 && arrayGaps.length > 1);
	        return decrease
	    },
	    normalizeEnum: normalizeEnum,
	    parseScalar: function(value, defaultValue) {
	        return void 0 !== value ? value : defaultValue
	    },
	    enumParser: function(values) {
	        var i, ii, stored = {};
	        for (i = 0, ii = values.length; i < ii; ++i) {
	            stored[normalizeEnum(values[i])] = 1
	        }
	        return function(value, defaultValue) {
	            var _value = normalizeEnum(value);
	            return stored[_value] ? _value : defaultValue
	        }
	    },
	    patchFontOptions: function(options) {
	        var fontOptions = {};
	        _each(options || {}, function(key, value) {
	            if (/^(cursor|opacity)$/i.test(key)) {} else {
	                if ("color" === key) {
	                    key = "fill"
	                } else {
	                    key = "font-" + key
	                }
	            }
	            fontOptions[key] = value
	        });
	        return fontOptions
	    },
	    convertPolarToXY: function(centerCoords, startAngle, angle, radius) {
	        var cosSin, shiftAngle = 90;
	        angle = _isDefined(angle) ? angle + startAngle - shiftAngle : 0;
	        cosSin = getCosAndSin(angle);
	        return {
	            x: _round(centerCoords.x + radius * cosSin.cos),
	            y: _round(centerCoords.y + radius * cosSin.sin)
	        }
	    },
	    convertXYToPolar: function(centerCoords, x, y) {
	        var radius = getDistance(centerCoords.x, centerCoords.y, x, y),
	            angle = _math.atan2(y - centerCoords.y, x - centerCoords.x);
	        return {
	            phi: _round(normalizeAngle(180 * angle / _math.PI)),
	            r: _round(radius)
	        }
	    },
	    processSeriesTemplate: function(seriesTemplate, items) {
	        var series, length, data, customizeSeries = commonUtils.isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : $.noop,
	            nameField = seriesTemplate.nameField || "series",
	            generatedSeries = {},
	            seriesOrder = [],
	            i = 0;
	        for (length = items.length; i < length; i++) {
	            data = items[i];
	            if (nameField in data) {
	                series = generatedSeries[data[nameField]];
	                if (!series) {
	                    series = generatedSeries[data[nameField]] = {
	                        name: data[nameField],
	                        data: []
	                    };
	                    seriesOrder.push(series.name)
	                }
	                series.data.push(data)
	            }
	        }
	        return map(seriesOrder, function(orderedName) {
	            var group = generatedSeries[orderedName];
	            return $.extend(group, customizeSeries.call(null, group.name))
	        })
	    },
	    getCategoriesInfo: function(categories, startValue, endValue) {
	        if (!(categories && categories.length > 0)) {
	            return {}
	        }
	        startValue = _isDefined(startValue) ? startValue : categories[0];
	        endValue = _isDefined(endValue) ? endValue : categories[categories.length - 1];
	        var visibleCategories, swapBuf, hasVisibleCategories, visibleCategoriesLen, categoriesValue = map(categories, function(category) {
	                return _isDefined(category) ? category.valueOf() : null
	            }),
	            indexStartValue = _isDefined(startValue) ? _inArray(startValue.valueOf(), categoriesValue) : 0,
	            indexEndValue = _isDefined(endValue) ? _inArray(endValue.valueOf(), categoriesValue) : categories.length - 1,
	            inverted = false;
	        indexStartValue < 0 && (indexStartValue = 0);
	        indexEndValue < 0 && (indexEndValue = categories.length - 1);
	        if (indexEndValue < indexStartValue) {
	            swapBuf = indexEndValue;
	            indexEndValue = indexStartValue;
	            indexStartValue = swapBuf;
	            inverted = true
	        }
	        visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
	        visibleCategoriesLen = visibleCategories.length;
	        hasVisibleCategories = visibleCategoriesLen > 0;
	        return {
	            categories: hasVisibleCategories ? visibleCategories : null,
	            start: hasVisibleCategories ? visibleCategories[inverted ? visibleCategoriesLen - 1 : 0] : null,
	            end: hasVisibleCategories ? visibleCategories[inverted ? 0 : visibleCategoriesLen - 1] : null,
	            inverted: inverted
	        }
	    },
	    setCanvasValues: setCanvasValues,
	    updatePanesCanvases: function(panes, canvas, rotated) {
	        var weightSum = 0;
	        _each(panes, function(_, pane) {
	            pane.weight = pane.weight || 1;
	            weightSum += pane.weight
	        });
	        var distributedSpace = 0,
	            padding = panes.padding || 10,
	            paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom,
	            oneWeight = (paneSpace - padding * (panes.length - 1)) / weightSum,
	            startName = rotated ? "left" : "top",
	            endName = rotated ? "right" : "bottom";
	        _each(panes, function(_, pane) {
	            var calcLength = _round(pane.weight * oneWeight);
	            pane.canvas = pane.canvas || {};
	            _extend(pane.canvas, {
	                deltaLeft: 0,
	                deltaRight: 0,
	                deltaTop: 0,
	                deltaBottom: 0
	            }, canvas);
	            pane.canvas[startName] = canvas[startName] + distributedSpace;
	            pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
	            distributedSpace = distributedSpace + calcLength + padding;
	            setCanvasValues(pane.canvas)
	        })
	    },
	    unique: function(array) {
	        var values = {};
	        return map(array, function(item) {
	            var result = !values[item] ? item : null;
	            values[item] = true;
	            return result
	        })
	    },
	    map: map,
	    getVerticallyShiftedAngularCoords: function(bBox, dy, center) {
	        var isPositive = bBox.x + bBox.width / 2 >= center.x,
	            horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x,
	            verticalOffset1 = bBox.y - center.y,
	            verticalOffset2 = verticalOffset1 + dy,
	            horizontalOffset2 = _round(_sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2)),
	            dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;
	        return {
	            x: center.x + (isPositive ? dx : dx - bBox.width),
	            y: bBox.y + dy
	        }
	    }
	});
	exports.getPrecision = getPrecision;
	exports.getLog = getLog;
	exports.raiseTo = raiseTo;
	exports.normalizeAngle = normalizeAngle;
	exports.convertAngleToRendererSpace = convertAngleToRendererSpace;
	exports.degreesToRadians = degreesToRadians;
	exports.getCosAndSin = getCosAndSin;
	exports.getDecimalOrder = getDecimalOrder;
	exports.getAppropriateFormat = getAppropriateFormat;
	exports.getDistance = getDistance;
	exports.getFraction = getFraction;
	exports.adjustValue = adjustValue;
	exports.roundValue = roundValue;
	exports.applyPrecisionByMinDelta = applyPrecisionByMinDelta;
	exports.getSignificantDigitPosition = getSignificantDigitPosition;
	exports.getPower = getPower;
	exports.rotateBBox = rotateBBox;
	exports.normalizeBBox = normalizeBBox;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/base_chart.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    eventUtils = __webpack_require__(61),
	    BaseWidget = __webpack_require__(293),
	    legendModule = __webpack_require__(299),
	    dataValidatorModule = __webpack_require__(301),
	    seriesModule = __webpack_require__(303),
	    chartThemeManagerModule = __webpack_require__(327),
	    LayoutManagerModule = __webpack_require__(335),
	    trackerModule = __webpack_require__(336),
	    headerBlockModule = __webpack_require__(337),
	    REINIT_REFRESH_ACTION = "_reinit",
	    REINIT_DATA_SOURCE_REFRESH_ACTION = "_updateDataSource",
	    DATA_INIT_REFRESH_ACTION = "_dataInit",
	    FORCE_RENDER_REFRESH_ACTION = "_forceRender",
	    RESIZE_REFRESH_ACTION = "_resize",
	    ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION],
	    vizUtils = __webpack_require__(291),
	    _noop = $.noop,
	    _map = vizUtils.map,
	    _each = $.each,
	    _extend = $.extend,
	    _isArray = commonUtils.isArray,
	    _isDefined = commonUtils.isDefined,
	    _setCanvasValues = vizUtils.setCanvasValues,
	    DEFAULT_OPACITY = .3,
	    REINIT_REFRESH_ACTION_OPTIONS = ["adaptiveLayout", "crosshair", "equalBarWidth", "minBubbleSize", "maxBubbleSize", "barWidth", "negativesAsZeroes", "negativesAsZeros", "resolveLabelOverlapping", "seriesSelectionMode", "pointSelectionMode", "adjustOnZoom", "synchronizeMultiAxes", "zoomingMode", "scrollingMode", "useAggregation"];

	function checkHeightLabelsInCanvas(points, canvas, isRotated) {
	    var labels, label, allLabelsAreInvisible, commonLabelSize = 0,
	        canvasSize = canvas.end - canvas.start;
	    for (var i = 0; i < points.length; i++) {
	        labels = points[i].getLabels();
	        allLabelsAreInvisible = true;
	        for (var j = 0; j < labels.length; j++) {
	            label = labels[j];
	            if (label.isVisible()) {
	                commonLabelSize += label.getBoundingRect()[isRotated ? "width" : "height"];
	                allLabelsAreInvisible = false
	            }
	        }
	        if (allLabelsAreInvisible) {
	            points[i] = null
	        }
	    }
	    if (canvasSize > 0) {
	        while (commonLabelSize > canvasSize) {
	            commonLabelSize -= killSmallValues(points, isRotated)
	        }
	    }
	}

	function killSmallValues(points, isRotated) {
	    var indexOfPoint, smallestValuePoint = {
	            originalValue: 1 / 0
	        },
	        bBox = 0;
	    _each(points, function(index, point) {
	        if (point && smallestValuePoint.originalValue >= point.originalValue) {
	            smallestValuePoint = point;
	            indexOfPoint = index
	        }
	    });
	    if (null !== indexOfPoint) {
	        points[indexOfPoint].getLabels().forEach(function(label) {
	            bBox += label.getBoundingRect()[isRotated ? "width" : "height"];
	            label.hide()
	        });
	        points[indexOfPoint] = null;
	        return bBox
	    }
	    return 0
	}

	function resolveLabelOverlappingInOneDirection(points, canvas, isRotated, shiftFunction) {
	    var rollingStocks = [],
	        stubCanvas = {
	            start: isRotated ? canvas.left : canvas.top,
	            end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom
	        };
	    checkHeightLabelsInCanvas(points, stubCanvas, isRotated);
	    points.forEach(function(p) {
	        if (!p) {
	            return
	        }
	        p.getLabels().forEach(function(l) {
	            l.isVisible() && rollingStocks.push(new RollingStock(l, isRotated, shiftFunction))
	        })
	    });
	    rollingStocks.sort(function(a, b) {
	        return a.getInitialPosition() - b.getInitialPosition()
	    });
	    if (!checkStackOverlap(rollingStocks)) {
	        return
	    }
	    rollingStocks.reverse();
	    moveRollingStock(rollingStocks, stubCanvas)
	}

	function overlapRollingStock(firstRolling, secondRolling) {
	    if (!firstRolling || !secondRolling) {
	        return
	    }
	    return firstRolling.getBoundingRect().end > secondRolling.getBoundingRect().start
	}

	function checkStackOverlap(rollingStocks) {
	    var i, j, currentRollingStock, nextRollingStock, overlap;
	    for (i = 0; i < rollingStocks.length; i++) {
	        currentRollingStock = rollingStocks[i];
	        for (j = i + 1; j < rollingStocks.length; j++) {
	            nextRollingStock = rollingStocks[j];
	            if (overlapRollingStock(currentRollingStock, nextRollingStock)) {
	                currentRollingStock.toChain(nextRollingStock);
	                overlap = true;
	                rollingStocks[j] = null
	            }
	        }
	    }
	    return overlap
	}

	function moveRollingStock(rollingStocks, canvas) {
	    var i, j, currentRollingStock, nextRollingStock, currentBBox, nextBBox;
	    for (i = 0; i < rollingStocks.length; i++) {
	        currentRollingStock = rollingStocks[i];
	        if (rollingStocksIsOut(currentRollingStock, canvas)) {
	            currentBBox = currentRollingStock.getBoundingRect();
	            for (j = i + 1; j < rollingStocks.length; j++) {
	                nextRollingStock = rollingStocks[j];
	                if (!nextRollingStock) {
	                    continue
	                }
	                nextBBox = nextRollingStock.getBoundingRect();
	                if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {
	                    nextRollingStock.toChain(currentRollingStock);
	                    rollingStocks[i] = currentRollingStock = null;
	                    break
	                }
	            }
	        }
	        currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas)
	    }
	}

	function rollingStocksIsOut(rollingStock, canvas) {
	    return rollingStock && rollingStock.getBoundingRect().end > canvas.end
	}

	function RollingStock(label, isRotated, shiftFunction) {
	    var bBox = label.getBoundingRect();
	    this.labels = [label];
	    this.shiftFunction = shiftFunction;
	    this._bBox = {
	        start: isRotated ? bBox.x : bBox.y,
	        width: isRotated ? bBox.width : bBox.height,
	        end: isRotated ? bBox.x + bBox.width : bBox.y + bBox.height
	    };
	    this._initialPosition = isRotated ? bBox.x : bBox.y;
	    return this
	}
	RollingStock.prototype = {
	    toChain: function(nextRollingStock) {
	        var nextRollingStockBBox = nextRollingStock.getBoundingRect();
	        nextRollingStock.shift(nextRollingStockBBox.start - this._bBox.end);
	        this._changeBoxWidth(nextRollingStockBBox.width);
	        this.labels = this.labels.concat(nextRollingStock.labels)
	    },
	    getBoundingRect: function() {
	        return this._bBox
	    },
	    shift: function(shiftLength) {
	        var shiftFunction = this.shiftFunction;
	        _each(this.labels, function(index, label) {
	            var bBox = label.getBoundingRect(),
	                coords = shiftFunction(bBox, shiftLength);
	            label.shift(coords.x, coords.y)
	        });
	        this._bBox.end -= shiftLength;
	        this._bBox.start -= shiftLength
	    },
	    setRollingStockInCanvas: function(canvas) {
	        if (this._bBox.end > canvas.end) {
	            this.shift(this._bBox.end - canvas.end)
	        }
	    },
	    getInitialPosition: function() {
	        return this._initialPosition
	    },
	    _changeBoxWidth: function(width) {
	        this._bBox.end += width;
	        this._bBox.width += width
	    }
	};

	function getLegendFields(name) {
	    return {
	        nameField: name + "Name",
	        colorField: name + "Color",
	        indexField: name + "Index"
	    }
	}

	function getLegendSettings(legendDataField) {
	    var formatObjectFields = getLegendFields(legendDataField);
	    return {
	        getFormatObject: function(data) {
	            var res = {};
	            res[formatObjectFields.indexField] = data.id;
	            res[formatObjectFields.colorField] = data.states.normal.fill;
	            res[formatObjectFields.nameField] = data.text;
	            return res
	        },
	        textField: formatObjectFields.nameField
	    }
	}

	function setTemplateFields(data, templateData, series) {
	    _each(data, function(_, data) {
	        _each(series.getTemplateFields(), function(_, field) {
	            data[field.templateField] = data[field.originalField]
	        });
	        templateData.push(data)
	    });
	    series.updateTemplateFieldNames()
	}

	function checkOverlapping(firstRect, secondRect) {
	    return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height)
	}
	var overlapping = {
	    resolveLabelOverlappingInOneDirection: resolveLabelOverlappingInOneDirection
	};

	function suppressCommonLayout(layout) {
	    layout.forward = function(rect) {
	        return rect
	    };
	    layout.backward = _noop
	}
	var BaseChart = BaseWidget.inherit({
	    _eventsMap: {
	        onSeriesClick: {
	            name: "seriesClick"
	        },
	        onPointClick: {
	            name: "pointClick"
	        },
	        onArgumentAxisClick: {
	            name: "argumentAxisClick"
	        },
	        onLegendClick: {
	            name: "legendClick"
	        },
	        onSeriesSelectionChanged: {
	            name: "seriesSelectionChanged"
	        },
	        onPointSelectionChanged: {
	            name: "pointSelectionChanged"
	        },
	        onSeriesHoverChanged: {
	            name: "seriesHoverChanged"
	        },
	        onPointHoverChanged: {
	            name: "pointHoverChanged"
	        },
	        onDone: {
	            name: "done"
	        },
	        onZoomStart: {
	            name: "zoomStart"
	        },
	        onZoomEnd: {
	            name: "zoomEnd"
	        }
	    },
	    _rootClassPrefix: "dxc",
	    _rootClass: "dxc-chart",
	    _init: function() {
	        this._savedBusinessRange = {};
	        this.callBase.apply(this, arguments)
	    },
	    _initialChanges: ["REINIT"],
	    _themeDependentChanges: ["REFRESH_SERIES_REINIT"],
	    _createThemeManager: function() {
	        var option = this.option(),
	            themeManager = new chartThemeManagerModule.ThemeManager(option, this._chartType);
	        themeManager.setTheme(option.theme, option.rtlEnabled);
	        return themeManager
	    },
	    _initCore: function() {
	        var that = this;
	        suppressCommonLayout(that._layout);
	        that._canvasClipRect = that._renderer.clipRect();
	        that._createHtmlStructure();
	        that._headerBlock = new headerBlockModule.HeaderBlock;
	        that._createLegend();
	        that._createTracker();
	        that._needHandleRenderComplete = true;
	        that.layoutManager = new LayoutManagerModule.LayoutManager;
	        that._createScrollBar();
	        that._$element.on("contextmenu", function(event) {
	            if (eventUtils.isTouchEvent(event) || eventUtils.isPointerEvent(event)) {
	                event.preventDefault()
	            }
	        }).on("MSHoldVisual", function(event) {
	            event.preventDefault()
	        })
	    },
	    _getLayoutItems: $.noop,
	    _layoutManagerOptions: function() {
	        return this._themeManager.getOptions("adaptiveLayout")
	    },
	    _reinit: function() {
	        var that = this;
	        _setCanvasValues(that._canvas);
	        that._reinitAxes();
	        that._skipRender = true;
	        that._updateDataSource();
	        if (!that.series) {
	            that._dataSpecificInit(false)
	        }
	        that._skipRender = false;
	        that._correctAxes();
	        that._forceRender()
	    },
	    _correctAxes: _noop,
	    _createHtmlStructure: function() {
	        var that = this,
	            renderer = that._renderer,
	            root = renderer.root;
	        that._backgroundRect = renderer.rect().attr({
	            fill: "gray",
	            opacity: 1e-4
	        }).append(root);
	        that._panesBackgroundGroup = renderer.g().attr({
	            "class": "dxc-background"
	        }).append(root);
	        that._stripsGroup = renderer.g().attr({
	            "class": "dxc-strips-group"
	        }).linkOn(root, "strips");
	        that._gridGroup = renderer.g().attr({
	            "class": "dxc-grids-group"
	        }).linkOn(root, "grids");
	        that._axesGroup = renderer.g().attr({
	            "class": "dxc-axes-group"
	        }).linkOn(root, "axes");
	        that._constantLinesGroup = renderer.g().attr({
	            "class": "dxc-constant-lines-group"
	        }).linkOn(root, "constant-lines");
	        that._labelAxesGroup = renderer.g().attr({
	            "class": "dxc-strips-labels-group"
	        }).linkOn(root, "strips-labels");
	        that._panesBorderGroup = renderer.g().attr({
	            "class": "dxc-border"
	        }).linkOn(root, "border");
	        that._seriesGroup = renderer.g().attr({
	            "class": "dxc-series-group"
	        }).linkOn(root, "series");
	        that._labelsGroup = renderer.g().attr({
	            "class": "dxc-labels-group"
	        }).linkOn(root, "labels");
	        that._crosshairCursorGroup = renderer.g().attr({
	            "class": "dxc-crosshair-cursor"
	        }).linkOn(root, "crosshair");
	        that._legendGroup = renderer.g().attr({
	            "class": "dxc-legend",
	            clipId: that._getCanvasClipRectID()
	        }).linkOn(root, "legend");
	        that._scrollBarGroup = renderer.g().attr({
	            "class": "dxc-scroll-bar"
	        }).linkOn(root, "scroll-bar")
	    },
	    _disposeObjectsInArray: function(propName, fieldNames) {
	        _each(this[propName] || [], function(_, item) {
	            if (fieldNames && item) {
	                _each(fieldNames, function(_, field) {
	                    item[field] && item[field].dispose()
	                })
	            } else {
	                item && item.dispose()
	            }
	        });
	        this[propName] = null
	    },
	    _disposeCore: function() {
	        var that = this,
	            disposeObject = function(propName) {
	                if (that[propName]) {
	                    that[propName].dispose();
	                    that[propName] = null
	                }
	            },
	            unlinkGroup = function(name) {
	                that[name].linkOff()
	            },
	            disposeObjectsInArray = this._disposeObjectsInArray;
	        clearTimeout(that._delayedRedraw);
	        that._renderer.stopAllAnimations();
	        that.businessRanges = that.translators = null;
	        disposeObjectsInArray.call(that, "series");
	        disposeObject("_headerBlock");
	        disposeObject("_tracker");
	        disposeObject("_crosshair");
	        that.layoutManager = null;
	        that.paneAxis = null;
	        that._userOptions = null;
	        that._canvas = null;
	        unlinkGroup("_stripsGroup");
	        unlinkGroup("_gridGroup");
	        unlinkGroup("_axesGroup");
	        unlinkGroup("_constantLinesGroup");
	        unlinkGroup("_labelAxesGroup");
	        unlinkGroup("_panesBorderGroup");
	        unlinkGroup("_seriesGroup");
	        unlinkGroup("_labelsGroup");
	        unlinkGroup("_crosshairCursorGroup");
	        unlinkGroup("_legendGroup");
	        unlinkGroup("_scrollBarGroup");
	        disposeObject("_canvasClipRect");
	        disposeObject("_panesBackgroundGroup");
	        disposeObject("_stripsGroup");
	        disposeObject("_gridGroup");
	        disposeObject("_axesGroup");
	        disposeObject("_constantLinesGroup");
	        disposeObject("_labelAxesGroup");
	        disposeObject("_panesBorderGroup");
	        disposeObject("_seriesGroup");
	        disposeObject("_labelsGroup");
	        disposeObject("_crosshairCursorGroup");
	        disposeObject("_legendGroup");
	        disposeObject("_scrollBarGroup")
	    },
	    _getAnimationOptions: function() {
	        return this._themeManager.getOptions("animation")
	    },
	    _getDefaultSize: function() {
	        return {
	            width: 400,
	            height: 400
	        }
	    },
	    _getOption: function(name) {
	        return this._themeManager.getOptions(name)
	    },
	    _applySize: function() {
	        this._processRefreshData(RESIZE_REFRESH_ACTION)
	    },
	    _resize: function() {
	        this._doRender(this.__renderOptions || {
	            animate: false,
	            isResize: true
	        })
	    },
	    _trackerType: "ChartTracker",
	    _createTracker: function() {
	        var that = this;
	        that._tracker = new trackerModule[that._trackerType]({
	            seriesGroup: that._seriesGroup,
	            renderer: that._renderer,
	            tooltip: that._tooltip,
	            legend: that._legend,
	            eventTrigger: that._eventTrigger
	        })
	    },
	    _getTrackerSettings: function() {
	        return {
	            seriesSelectionMode: this._themeManager.getOptions("seriesSelectionMode"),
	            pointSelectionMode: this._themeManager.getOptions("pointSelectionMode")
	        }
	    },
	    _updateTracker: function(trackerCanvases) {
	        var that = this;
	        that._tracker.update(that._getTrackerSettings());
	        that._tracker.setCanvases({
	            left: 0,
	            right: that._canvas.width,
	            top: 0,
	            bottom: that._canvas.height
	        }, trackerCanvases)
	    },
	    _doRender: function(_options) {
	        var drawOptions, recreateCanvas, that = this;
	        if ( /*!that._initialized || */ that._skipRender) {
	            return
	        }
	        if (0 === that._canvas.width && 0 === that._canvas.height) {
	            return
	        }
	        that._resetIsReady();
	        drawOptions = that._prepareDrawOptions(_options);
	        recreateCanvas = drawOptions.recreateCanvas;
	        clearTimeout(that._delayedRedraw);
	        that.__originalCanvas = that._canvas;
	        that._canvas = $.extend({}, that._canvas);
	        if (recreateCanvas) {
	            that.__currentCanvas = that._canvas
	        } else {
	            that._canvas = that.__currentCanvas
	        }
	        recreateCanvas && that._updateCanvasClipRect(that._canvas);
	        that._renderer.stopAllAnimations(true);
	        _setCanvasValues(that._canvas);
	        that._cleanGroups();
	        that._renderElements(drawOptions)
	    },
	    _saveBusinessRange: _noop,
	    _renderElements: function(drawOptions) {
	        var argBusinessRange, zoomMinArg, zoomMaxArg, that = this,
	            preparedOptions = that._prepareToRender(drawOptions),
	            isRotated = that._isRotated(),
	            isLegendInside = that._isLegendInside(),
	            trackerCanvases = [],
	            layoutTargets = that._getLayoutTargets(),
	            dirtyCanvas = $.extend({}, that._canvas),
	            drawElements = [],
	            layoutCanvas = drawOptions.drawTitle && drawOptions.drawLegend && drawOptions.adjustAxes;
	        if (layoutCanvas) {
	            drawElements = that._getDrawElements(drawOptions, isLegendInside)
	        }
	        that._renderer.lock();
	        that._saveBusinessRange();
	        that.layoutManager.setOptions(that._layoutManagerOptions());
	        that.layoutManager.layoutElements(drawElements, that._canvas, that._getAxisDrawingMethods(drawOptions, preparedOptions, isRotated), layoutTargets, isRotated, that._getAxesForTransform(isRotated));
	        layoutCanvas && that._updateCanvasClipRect(dirtyCanvas);
	        that._applyClipRects(preparedOptions);
	        that._appendSeriesGroups();
	        that._createCrosshairCursor();
	        _each(layoutTargets, function() {
	            var canvas = this.canvas;
	            trackerCanvases.push({
	                left: canvas.left,
	                right: canvas.width - canvas.right,
	                top: canvas.top,
	                bottom: canvas.height - canvas.bottom
	            })
	        });
	        if (that._scrollBar) {
	            argBusinessRange = that.businessRanges[0].arg;
	            if ("discrete" === argBusinessRange.axisType && argBusinessRange.categories && argBusinessRange.categories.length <= 1) {
	                zoomMinArg = zoomMaxArg = void 0
	            } else {
	                zoomMinArg = argBusinessRange.minVisible;
	                zoomMaxArg = argBusinessRange.maxVisible
	            }
	            that._scrollBar.init(argBusinessRange, layoutTargets[0].canvas).setPosition(zoomMinArg, zoomMaxArg)
	        }
	        that._updateTracker(trackerCanvases);
	        that._updateLegendPosition(drawOptions, isLegendInside);
	        that._renderSeries(drawOptions, isRotated, isLegendInside);
	        that._renderer.unlock()
	    },
	    _createCrosshairCursor: _noop,
	    _appendSeriesGroups: function() {
	        this._seriesGroup.linkAppend();
	        this._labelsGroup.linkAppend();
	        this._appendAdditionalSeriesGroups()
	    },
	    _renderSeries: function(drawOptions, isRotated, isLegendInside) {
	        var that = this,
	            themeManager = that._themeManager,
	            resolveLabelOverlapping = themeManager.getOptions("resolveLabelOverlapping");
	        drawOptions.hideLayoutLabels = that.layoutManager.needMoreSpaceForPanesCanvas(that._getLayoutTargets(), isRotated) && !themeManager.getOptions("adaptiveLayout").keepLabels;
	        that._drawSeries(drawOptions, isRotated);
	        "none" !== resolveLabelOverlapping && that._resolveLabelOverlapping(resolveLabelOverlapping);
	        that._adjustSeries();
	        that._renderTrackers(isLegendInside);
	        that._tracker.repairTooltip();
	        that._canvas = that.__originalCanvas;
	        that._drawn();
	        that._renderCompleteHandler()
	    },
	    _drawSeries: function(drawOptions, isRotated) {
	        var i, singleSeries, that = this,
	            series = that.series,
	            seriesLength = series.length;
	        that._updateSeriesDimensions(drawOptions);
	        for (i = 0; i < seriesLength; i++) {
	            singleSeries = series[i];
	            that._applyExtraSettings(singleSeries, drawOptions);
	            singleSeries.draw(that._prepareTranslators(singleSeries, i, isRotated), drawOptions.animate && singleSeries.getPoints().length <= drawOptions.animationPointsLimit && that._renderer.animationEnabled(), drawOptions.hideLayoutLabels, that._getLegendCallBack(singleSeries))
	        }
	    },
	    _resolveLabelOverlapping: function(resolveLabelOverlapping) {
	        var func;
	        switch (resolveLabelOverlapping) {
	            case "stack":
	                func = this._resolveLabelOverlappingStack;
	                break;
	            case "hide":
	                func = this._resolveLabelOverlappingHide;
	                break;
	            case "shift":
	                func = this._resolveLabelOverlappingShift
	        }
	        $.isFunction(func) && func.call(this)
	    },
	    _getVisibleSeries: function() {
	        return $.grep(this.getAllSeries(), function(series) {
	            return series.isVisible()
	        })
	    },
	    _resolveLabelOverlappingHide: function() {
	        var currentLabel, nextLabel, currentLabelRect, nextLabelRect, i, j, points, labels = [],
	            series = this._getVisibleSeries();
	        for (i = 0; i < series.length; i++) {
	            points = series[i].getVisiblePoints();
	            for (j = 0; j < points.length; j++) {
	                labels = labels.concat(points[j].getLabels())
	            }
	        }
	        for (i = 0; i < labels.length; i++) {
	            currentLabel = labels[i];
	            currentLabelRect = currentLabel.getBoundingRect();
	            if (!currentLabel.isVisible()) {
	                continue
	            }
	            for (j = i + 1; j < labels.length; j++) {
	                nextLabel = labels[j];
	                nextLabelRect = nextLabel.getBoundingRect();
	                if (checkOverlapping(currentLabelRect, nextLabelRect)) {
	                    nextLabel.hide()
	                }
	            }
	        }
	    },
	    _cleanGroups: function() {
	        var that = this;
	        that._stripsGroup.linkRemove().clear();
	        that._gridGroup.linkRemove().clear();
	        that._axesGroup.linkRemove().clear();
	        that._constantLinesGroup.linkRemove().clear();
	        that._labelAxesGroup.linkRemove().clear();
	        that._labelsGroup.linkRemove().clear();
	        that._crosshairCursorGroup.linkRemove().clear()
	    },
	    _createLegend: function() {
	        var that = this,
	            legendSettings = getLegendSettings(that._legendDataField);
	        that._legend = new legendModule.Legend({
	            renderer: that._renderer,
	            group: that._legendGroup,
	            backgroundClass: "dxc-border",
	            itemGroupClass: "dxc-item",
	            textField: legendSettings.textField,
	            getFormatObject: legendSettings.getFormatObject
	        })
	    },
	    _updateLegend: function() {
	        var that = this,
	            themeManager = that._themeManager,
	            legendOptions = themeManager.getOptions("legend"),
	            legendData = that._getLegendData();
	        legendOptions.containerBackgroundColor = themeManager.getOptions("containerBackgroundColor");
	        legendOptions._incidentOccurred = that._incidentOccurred;
	        that._legend.update(legendData, legendOptions)
	    },
	    _prepareDrawOptions: function(drawOptions) {
	        var options, animationOptions = this._getAnimationOptions();
	        options = $.extend({}, {
	            force: false,
	            adjustAxes: true,
	            drawLegend: true,
	            drawTitle: true,
	            animate: animationOptions.enabled,
	            animationPointsLimit: animationOptions.maxPointCountSupported
	        }, drawOptions, this.__renderOptions);
	        if (!_isDefined(options.recreateCanvas)) {
	            options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle
	        }
	        return options
	    },
	    _processRefreshData: function(newRefreshAction) {
	        var currentRefreshActionPosition = $.inArray(this._currentRefreshData, ACTIONS_BY_PRIORITY),
	            newRefreshActionPosition = $.inArray(newRefreshAction, ACTIONS_BY_PRIORITY);
	        if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {
	            this._currentRefreshData = newRefreshAction
	        }
	    },
	    _getLegendData: function() {
	        return _map(this._getLegendTargets(), function(item) {
	            var legendData = item.legendData,
	                style = item.getLegendStyles,
	                opacity = style.normal.opacity;
	            if (!item.visible) {
	                if (!_isDefined(opacity) || opacity > DEFAULT_OPACITY) {
	                    opacity = DEFAULT_OPACITY
	                }
	                legendData.textOpacity = DEFAULT_OPACITY
	            }
	            legendData.states = {
	                hover: style.hover,
	                selection: style.selection,
	                normal: _extend({}, style.normal, {
	                    opacity: opacity
	                })
	            };
	            return legendData
	        })
	    },
	    _getLegendOptions: function(item) {
	        return {
	            legendData: {
	                text: item[this._legendItemTextField],
	                argument: item.argument,
	                id: item.index
	            },
	            getLegendStyles: item.getLegendStyles(),
	            visible: item.isVisible()
	        }
	    },
	    _disposeSeries: function() {
	        var that = this;
	        _each(that.series || [], function(_, series) {
	            series.dispose()
	        });
	        that.series = null;
	        _each(that.seriesFamilies || [], function(_, family) {
	            family.dispose()
	        });
	        that.seriesFamilies = null;
	        that._needHandleRenderComplete = true
	    },
	    _optionChanged: function(arg) {
	        this._themeManager.resetOptions(arg.name);
	        this.callBase.apply(this, arguments)
	    },
	    _applyChanges: function() {
	        var that = this;
	        that._themeManager.update(that._options);
	        that.callBase.apply(that, arguments);
	        that._doRefresh()
	    },
	    _optionChangesMap: {
	        animation: "ANIMATION",
	        dataSource: "DATA_SOURCE",
	        palette: "PALETTE",
	        series: "REFRESH_SERIES_DATA_INIT",
	        commonSeriesSettings: "REFRESH_SERIES_DATA_INIT",
	        containerBackgroundColor: "REFRESH_SERIES_DATA_INIT",
	        dataPrepareSettings: "REFRESH_SERIES_DATA_INIT",
	        legend: "DATA_INIT",
	        seriesTemplate: "DATA_INIT",
	        "export": "FORCE_RENDER",
	        valueAxis: "AXES_AND_PANES",
	        argumentAxis: "AXES_AND_PANES",
	        commonAxisSettings: "AXES_AND_PANES",
	        panes: "AXES_AND_PANES",
	        defaultPane: "AXES_AND_PANES",
	        rotated: "ROTATED",
	        customizePoint: "REFRESH_SERIES_REINIT",
	        customizeLabel: "REFRESH_SERIES_REINIT",
	        scrollBar: "SCROLL_BAR"
	    },
	    _customChangesOrder: ["ANIMATION", "DATA_SOURCE", "PALETTE", "REFRESH_SERIES_DATA_INIT", "DATA_INIT", "FORCE_RENDER", "AXES_AND_PANES", "ROTATED", "REFRESH_SERIES_REINIT", "SCROLL_BAR", "CHART_TOOLTIP", "REINIT"],
	    _change_ANIMATION: function() {
	        this._renderer.updateAnimationOptions(this._getAnimationOptions())
	    },
	    _change_DATA_SOURCE: function() {
	        this._needHandleRenderComplete = true;
	        this._processRefreshData(REINIT_DATA_SOURCE_REFRESH_ACTION)
	    },
	    _change_PALETTE: function() {
	        this._themeManager.updatePalette(this.option("palette"));
	        this._refreshSeries(DATA_INIT_REFRESH_ACTION)
	    },
	    _change_REFRESH_SERIES_DATA_INIT: function() {
	        this._refreshSeries(DATA_INIT_REFRESH_ACTION)
	    },
	    _change_DATA_INIT: function() {
	        this._processRefreshData(DATA_INIT_REFRESH_ACTION)
	    },
	    _change_FORCE_RENDER: function() {
	        this._processRefreshData(FORCE_RENDER_REFRESH_ACTION)
	    },
	    _change_AXES_AND_PANES: function() {
	        this._refreshSeries(REINIT_REFRESH_ACTION);
	        this.paneAxis = {}
	    },
	    _change_ROTATED: function() {
	        this._createScrollBar();
	        this._refreshSeries(REINIT_REFRESH_ACTION)
	    },
	    _change_REFRESH_SERIES_REINIT: function() {
	        this._refreshSeries(REINIT_REFRESH_ACTION)
	    },
	    _change_SCROLL_BAR: function() {
	        this._createScrollBar();
	        this._processRefreshData(FORCE_RENDER_REFRESH_ACTION)
	    },
	    _change_CHART_TOOLTIP: function() {
	        this._organizeStackPoints()
	    },
	    _change_REINIT: function() {
	        this._processRefreshData(REINIT_REFRESH_ACTION)
	    },
	    _refreshSeries: function(actionName) {
	        this._disposeSeries();
	        this._processRefreshData(actionName)
	    },
	    _doRefresh: function() {
	        var methodName = this._currentRefreshData;
	        if (methodName) {
	            this._currentRefreshData = null;
	            this._renderer.stopAllAnimations(true);
	            this[methodName]()
	        }
	    },
	    _updateCanvasClipRect: function(canvas) {
	        var width, height, that = this;
	        width = Math.max(canvas.width - canvas.left - canvas.right, 0);
	        height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);
	        that._canvasClipRect.attr({
	            x: canvas.left,
	            y: canvas.top,
	            width: width,
	            height: height
	        });
	        that._backgroundRect.attr({
	            x: canvas.left,
	            y: canvas.top,
	            width: width,
	            height: height
	        })
	    },
	    _getCanvasClipRectID: function() {
	        return this._canvasClipRect.id
	    },
	    _dataSourceChangedHandler: function() {
	        this._resetZoom();
	        this._dataInit()
	    },
	    _dataInit: function() {
	        clearTimeout(this._delayedRedraw);
	        this._dataSpecificInit(true)
	    },
	    _dataSpecificInit: function(needRedraw) {
	        var that = this;
	        that.series = that.series || that._populateSeries();
	        that._repopulateSeries();
	        that._seriesPopulatedHandlerCore();
	        that._populateBusinessRange();
	        that._collectPointsByArg();
	        that._tracker.updateSeries(that._getStoredSeries());
	        that._updateLegend();
	        needRedraw && that._forceRender()
	    },
	    _forceRender: function() {
	        this._doRender({
	            force: true
	        })
	    },
	    _repopulateSeries: function() {
	        var parsedData, that = this,
	            themeManager = that._themeManager,
	            data = that._dataSourceItems(),
	            dataValidatorOptions = themeManager.getOptions("dataPrepareSettings"),
	            seriesTemplate = themeManager.getOptions("seriesTemplate");
	        if (seriesTemplate) {
	            that._templatedSeries = vizUtils.processSeriesTemplate(seriesTemplate, data);
	            that._populateSeries();
	            delete that._templatedSeries;
	            data = that.templateData || data
	        }
	        that._groupSeries();
	        parsedData = dataValidatorModule.validateData(data, that._groupsData, that._incidentOccurred, dataValidatorOptions);
	        themeManager.resetPalette();
	        _each(that.series, function(_, singleSeries) {
	            singleSeries.updateData(parsedData[singleSeries.getArgumentField()]);
	            that._processSingleSeries(singleSeries)
	        });
	        that._organizeStackPoints()
	    },
	    _organizeStackPoints: function() {
	        var that = this,
	            themeManager = that._themeManager,
	            sharedTooltip = themeManager.getOptions("tooltip").shared,
	            stackPoints = {};
	        _each(that.series || [], function(_, singleSeries) {
	            that._resetStackPoints(singleSeries);
	            sharedTooltip && that._prepareStackPoints(singleSeries, stackPoints)
	        })
	    },
	    _renderCompleteHandler: function() {
	        var that = this,
	            allSeriesInited = true;
	        if (that._needHandleRenderComplete) {
	            _each(that.series, function(_, s) {
	                allSeriesInited = allSeriesInited && s.canRenderCompleteHandle()
	            });
	            if (allSeriesInited) {
	                that._needHandleRenderComplete = false;
	                that._eventTrigger("done", {
	                    target: that
	                })
	            }
	        }
	    },
	    _getDrawElements: function(drawOptions, legendHasInsidePosition) {
	        var legendOptions, that = this,
	            drawElements = [],
	            exportOptions = that._themeManager.getOptions("export"),
	            titleOptions = that._title.getLayoutOptions() || {},
	            headerElements = [];
	        if (that._exportMenu && exportOptions.enabled) {
	            headerElements.push(that._exportMenu);
	            drawElements.push(that._headerBlock)
	        }
	        if (drawOptions.drawTitle) {
	            "bottom" !== titleOptions.verticalAlignment && headerElements.length ? headerElements.push(that._title) : drawElements.push(that._title)
	        }
	        if (drawOptions.drawLegend && that._legend) {
	            that._legendGroup.linkAppend();
	            if (!legendHasInsidePosition) {
	                legendOptions = that._legend.getLayoutOptions();
	                if (1 === headerElements.length && "bottom" !== legendOptions.verticalAlignment && "vertical" === legendOptions.cutSide) {
	                    headerElements.push(that._legend)
	                } else {
	                    drawElements.push(that._legend)
	                }
	            }
	        }
	        if (headerElements.length) {
	            that._headerBlock.update(headerElements, that._canvas)
	        }
	        return drawElements
	    },
	    _resetZoom: _noop,
	    _dataIsReady: function() {
	        return _isDefined(this.option("dataSource")) && this._dataIsLoaded()
	    },
	    _populateSeries: function() {
	        var particularSeriesOptions, particularSeries, seriesTheme, data, i, that = this,
	            themeManager = that._themeManager,
	            hasSeriesTemplate = !!themeManager.getOptions("seriesTemplate"),
	            seriesOptions = hasSeriesTemplate ? that._templatedSeries : that.option("series"),
	            allSeriesOptions = _isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [],
	            extraOptions = that._getExtraOptions(),
	            seriesVisibilityChanged = function() {
	                that._specialProcessSeries();
	                that._populateBusinessRange();
	                that._renderer.stopAllAnimations(true);
	                that._updateLegend();
	                that._doRender({
	                    force: true
	                })
	            };
	        that._disposeSeries();
	        that.series = [];
	        that.templateData = [];
	        themeManager.resetPalette();
	        for (i = 0; i < allSeriesOptions.length; i++) {
	            particularSeriesOptions = _extend(true, {}, allSeriesOptions[i], extraOptions);
	            if (!particularSeriesOptions.name) {
	                particularSeriesOptions.name = "Series " + (i + 1).toString()
	            }
	            data = particularSeriesOptions.data;
	            particularSeriesOptions.data = null;
	            particularSeriesOptions.rotated = that._isRotated();
	            particularSeriesOptions.customizePoint = themeManager.getOptions("customizePoint");
	            particularSeriesOptions.customizeLabel = themeManager.getOptions("customizeLabel");
	            particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;
	            particularSeriesOptions.incidentOccurred = that._incidentOccurred;
	            seriesTheme = themeManager.getOptions("series", particularSeriesOptions);
	            if (!that._checkPaneName(seriesTheme)) {
	                continue
	            }
	            particularSeries = new seriesModule.Series({
	                renderer: that._renderer,
	                seriesGroup: that._seriesGroup,
	                labelsGroup: that._labelsGroup
	            }, seriesTheme);
	            if (!particularSeries.isUpdated) {
	                that._incidentOccurred("E2101", [seriesTheme.type])
	            } else {
	                particularSeries.index = that.series.length;
	                that._processSingleSeries(particularSeries);
	                that.series.push(particularSeries);
	                if (hasSeriesTemplate) {
	                    setTemplateFields(data, that.templateData, particularSeries)
	                }
	            }
	        }
	        return that.series
	    },
	    getAllSeries: function() {
	        return this.series.slice()
	    },
	    getSeriesByName: function(name) {
	        var found = null;
	        _each(this.series, function(i, singleSeries) {
	            if (singleSeries.name === name) {
	                found = singleSeries;
	                return false
	            }
	        });
	        return found
	    },
	    getSeriesByPos: function(pos) {
	        return this.series[pos]
	    },
	    clearSelection: function() {
	        this._tracker.clearSelection()
	    },
	    hideTooltip: function() {
	        this._tracker._hideTooltip()
	    },
	    render: function(renderOptions) {
	        var that = this;
	        that.__renderOptions = renderOptions;
	        that.__forceRender = renderOptions && renderOptions.force;
	        that.callBase.apply(that, arguments);
	        that.__renderOptions = that.__forceRender = null;
	        return that
	    },
	    getSize: function() {
	        var canvas = this._canvas || {};
	        return {
	            width: canvas.width,
	            height: canvas.height
	        }
	    }
	});
	_each(REINIT_REFRESH_ACTION_OPTIONS, function(_, name) {
	    BaseChart.prototype._optionChangesMap[name] = "REINIT"
	});
	exports.overlapping = overlapping;
	exports.BaseChart = BaseChart;
	BaseChart.addPlugin(__webpack_require__(338).plugin);
	BaseChart.addPlugin(__webpack_require__(339).plugin);
	BaseChart.addPlugin(__webpack_require__(340).plugin);
	BaseChart.addPlugin(__webpack_require__(341).plugin);
	BaseChart.addPlugin(__webpack_require__(342).plugin);
	var _change_TITLE = BaseChart.prototype._change_TITLE;
	BaseChart.prototype._change_TITLE = function() {
	    _change_TITLE.apply(this, arguments);
	    this._change(["FORCE_RENDER"])
	};
	var _change_TOOLTIP = BaseChart.prototype._change_TOOLTIP;
	BaseChart.prototype._change_TOOLTIP = function() {
	    _change_TOOLTIP.apply(this, arguments);
	    this._change(["CHART_TOOLTIP"])
	};


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/base_widget.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    version = __webpack_require__(12),
	    _windowResizeCallbacks = __webpack_require__(29).resizeCallbacks,
	    _stringFormat = __webpack_require__(7).format,
	    _isObject = __webpack_require__(8).isObject,
	    _Number = Number,
	    DOMComponent = __webpack_require__(28),
	    helpers = __webpack_require__(294),
	    _parseScalar = __webpack_require__(291).parseScalar,
	    errors = __webpack_require__(295),
	    _log = errors.log,
	    rendererModule = __webpack_require__(296),
	    _Layout = __webpack_require__(298),
	    OPTION_RTL_ENABLED = "rtlEnabled",
	    _option = DOMComponent.prototype.option;

	function getTrue() {
	    return true
	}

	function getFalse() {
	    return false
	}

	function areCanvasesDifferent(canvas1, canvas2) {
	    return !(canvas1.width === canvas2.width && canvas1.height === canvas2.height && canvas1.left === canvas2.left && canvas1.top === canvas2.top && canvas1.right === canvas2.right && canvas1.bottom === canvas2.bottom)
	}

	function createResizeHandler(callback) {
	    var timeout, handler = function() {
	        clearTimeout(timeout);
	        timeout = setTimeout(callback, 100)
	    };
	    handler.dispose = function() {
	        clearTimeout(timeout);
	        return this
	    };
	    return handler
	}

	function defaultOnIncidentOccurred(e) {
	    _log.apply(null, [e.target.id].concat(e.target.args || []))
	}
	var createIncidentOccurred = function(widgetName, eventTrigger) {
	    return incidentOccurred;

	    function incidentOccurred(id, args) {
	        eventTrigger("incidentOccurred", {
	            target: {
	                id: id,
	                type: "E" === id[0] ? "error" : "warning",
	                args: args,
	                text: _stringFormat.apply(null, [errors.ERROR_MESSAGES[id]].concat(args || [])),
	                widget: widgetName,
	                version: version
	            }
	        })
	    }
	};

	function pickPositiveValue(value, defaultValue) {
	    return _Number(value > 0 ? value : defaultValue || 0)
	}
	module.exports = DOMComponent.inherit({
	    _eventsMap: {
	        onIncidentOccurred: {
	            name: "incidentOccurred"
	        },
	        onDrawn: {
	            name: "drawn"
	        }
	    },
	    _getDefaultOptions: function() {
	        return $.extend(this.callBase(), {
	            onIncidentOccurred: defaultOnIncidentOccurred
	        })
	    },
	    _useLinks: true,
	    _init: function() {
	        var linkTarget, that = this;
	        that.callBase.apply(that, arguments);
	        that._changesLocker = 0;
	        that._changes = helpers.changes();
	        that._suspendChanges();
	        that._themeManager = that._createThemeManager();
	        that._themeManager.setCallback(function() {
	            that._requestChange(that._themeDependentChanges)
	        });
	        that._initRenderer();
	        linkTarget = that._useLinks && that._renderer.root;
	        linkTarget && linkTarget.enableLinks().virtualLink("core").virtualLink("peripheral");
	        that._renderVisibilityChange();
	        that._initEventTrigger();
	        that._incidentOccurred = createIncidentOccurred(that.NAME, that._eventTrigger);
	        that._layout = new _Layout;
	        linkTarget && linkTarget.linkAfter("core");
	        that._initPlugins();
	        that._initCore();
	        linkTarget && linkTarget.linkAfter();
	        that._change(that._initialChanges);
	        that._resumeChanges()
	    },
	    _initialChanges: ["LAYOUT", "RESIZE_HANDLER", "THEME"],
	    _initPlugins: function() {
	        var that = this;
	        $.each(that._plugins, function(_, plugin) {
	            plugin.init.call(that)
	        })
	    },
	    _disposePlugins: function() {
	        var that = this;
	        $.each(that._plugins.slice().reverse(), function(_, plugin) {
	            plugin.dispose.call(that)
	        })
	    },
	    _change: function(codes) {
	        this._changes.add(codes)
	    },
	    _suspendChanges: function() {
	        ++this._changesLocker
	    },
	    _resumeChanges: function() {
	        var that = this;
	        if (0 === --that._changesLocker && that._changes.count() > 0) {
	            that._renderer.lock();
	            that._applyingChanges = true;
	            that._applyChanges();
	            that._changes.reset();
	            that._applyingChanges = false;
	            that._renderer.unlock();
	            if (that._optionsQueue) {
	                that._applyQueuedOptions()
	            }
	        }
	    },
	    _applyQueuedOptions: function() {
	        var that = this,
	            queue = that._optionsQueue;
	        that._optionsQueue = null;
	        that.beginUpdate();
	        $.each(queue, function(_, args) {
	            _option.apply(that, args)
	        });
	        that.endUpdate()
	    },
	    _requestChange: function(codes) {
	        var applyingChanges = this._applyingChanges;
	        if (!applyingChanges) {
	            this._suspendChanges()
	        }
	        this._change(codes);
	        if (!applyingChanges) {
	            this._resumeChanges()
	        }
	    },
	    _applyChanges: function() {
	        var i, that = this,
	            changes = that._changes,
	            order = that._totalChangesOrder,
	            ii = order.length;
	        for (i = 0; i < ii; ++i) {
	            if (changes.has(order[i])) {
	                that["_change_" + order[i]]()
	            }
	        }
	    },
	    _optionChangesOrder: ["EVENTS", "THEME", "RENDERER", "RESIZE_HANDLER"],
	    _layoutChangesOrder: ["CONTAINER_SIZE", "LAYOUT"],
	    _customChangesOrder: [],
	    _change_EVENTS: function() {
	        this._eventTrigger.applyChanges()
	    },
	    _change_THEME: function() {
	        this._setThemeAndRtl()
	    },
	    _change_RENDERER: function() {
	        this._setRendererOptions()
	    },
	    _change_RESIZE_HANDLER: function() {
	        this._setupResizeHandler()
	    },
	    _change_CONTAINER_SIZE: function() {
	        this._updateSize()
	    },
	    _change_LAYOUT: function() {
	        this._setContentSize()
	    },
	    _themeDependentChanges: ["RENDERER"],
	    _initRenderer: function() {
	        var that = this;
	        that._canvas = that._calculateCanvas();
	        that._renderer = new rendererModule.Renderer({
	            cssClass: that._rootClassPrefix + " " + that._rootClass,
	            pathModified: that.option("pathModified"),
	            container: that._$element[0]
	        });
	        that._renderer.resize(that._canvas.width, that._canvas.height)
	    },
	    _disposeRenderer: function() {
	        this._renderer.dispose()
	    },
	    _getAnimationOptions: $.noop,
	    render: function() {
	        this._requestChange(["CONTAINER_SIZE"]);
	        this._onRender()
	    },
	    _onRender: $.noop,
	    _dispose: function() {
	        var that = this;
	        that.callBase.apply(that, arguments);
	        that._removeResizeHandler();
	        that._layout.dispose();
	        that._eventTrigger.dispose();
	        that._disposeCore();
	        that._disposePlugins();
	        that._disposeRenderer();
	        that._themeManager.dispose();
	        that._themeManager = that._renderer = that._eventTrigger = null
	    },
	    _initEventTrigger: function() {
	        var that = this;
	        that._eventTrigger = createEventTrigger(that._eventsMap, function(name) {
	            return that._createActionByOption(name)
	        })
	    },
	    _calculateCanvas: function() {
	        var that = this,
	            size = that.option("size") || {},
	            margin = that.option("margin") || {},
	            defaultCanvas = that._getDefaultSize() || {},
	            canvas = {
	                width: size.width <= 0 ? 0 : pickPositiveValue(size.width, that._$element.width() || defaultCanvas.width),
	                height: size.height <= 0 ? 0 : pickPositiveValue(size.height, that._$element.height() || defaultCanvas.height),
	                left: pickPositiveValue(margin.left, defaultCanvas.left || 0),
	                top: pickPositiveValue(margin.top, defaultCanvas.top || 0),
	                right: pickPositiveValue(margin.right, defaultCanvas.right || 0),
	                bottom: pickPositiveValue(margin.bottom, defaultCanvas.bottom || 0)
	            };
	        if (canvas.width - canvas.left - canvas.right <= 0 || canvas.height - canvas.top - canvas.bottom <= 0) {
	            canvas = {
	                width: 0,
	                height: 0
	            }
	        }
	        return canvas
	    },
	    _updateSize: function() {
	        var that = this,
	            canvas = that._calculateCanvas();
	        if (areCanvasesDifferent(that._canvas, canvas) || that.__forceRender) {
	            that._canvas = canvas;
	            that._renderer.resize(canvas.width, canvas.height);
	            that._change(["LAYOUT"])
	        }
	    },
	    _setContentSize: function() {
	        var nextRect, canvas = this._canvas,
	            layout = this._layout,
	            rect = canvas.width > 0 && canvas.height > 0 ? [canvas.left, canvas.top, canvas.width - canvas.right, canvas.height - canvas.bottom] : [0, 0, 0, 0];
	        rect = layout.forward(rect);
	        nextRect = this._applySize(rect) || rect;
	        layout.backward(nextRect)
	    },
	    _getOption: function(name, isScalar) {
	        var theme = this._themeManager.theme(name),
	            option = this.option(name);
	        return isScalar ? void 0 !== option ? option : theme : $.extend(true, {}, theme, option)
	    },
	    _setupResizeHandler: function() {
	        if (_parseScalar(this._getOption("redrawOnResize", true), true)) {
	            this._addResizeHandler()
	        } else {
	            this._removeResizeHandler()
	        }
	    },
	    _addResizeHandler: function() {
	        var that = this;
	        if (!that._resizeHandler) {
	            that._resizeHandler = createResizeHandler(function() {
	                that._requestChange(["CONTAINER_SIZE"])
	            });
	            _windowResizeCallbacks.add(that._resizeHandler)
	        }
	    },
	    _removeResizeHandler: function() {
	        if (this._resizeHandler) {
	            _windowResizeCallbacks.remove(this._resizeHandler);
	            this._resizeHandler.dispose();
	            this._resizeHandler = null
	        }
	    },
	    _onBeginUpdate: $.noop,
	    beginUpdate: function() {
	        var that = this;
	        if (that._initialized && 0 === that._updateLockCount) {
	            that._onBeginUpdate();
	            that._suspendChanges()
	        }
	        that.callBase.apply(that, arguments);
	        return that
	    },
	    endUpdate: function() {
	        var that = this,
	            initialized = that._initialized;
	        that.callBase.apply(that, arguments);
	        if (initialized && 0 === that._updateLockCount) {
	            that._resumeChanges()
	        }
	        return that
	    },
	    option: function(name) {
	        var that = this;
	        if (that._initialized && that._applyingChanges && (arguments.length > 1 || _isObject(name))) {
	            that._optionsQueue = that._optionsQueue || [];
	            that._optionsQueue.push(arguments)
	        } else {
	            return _option.apply(that, arguments)
	        }
	    },
	    _clean: $.noop,
	    _render: $.noop,
	    _optionChanged: function(arg) {
	        var that = this;
	        if (that._eventTrigger.change(arg.name)) {
	            that._change(["EVENTS"])
	        } else {
	            if (that._optionChangesMap[arg.name]) {
	                that._change([that._optionChangesMap[arg.name]])
	            } else {
	                that.callBase.apply(that, arguments)
	            }
	        }
	    },
	    _optionChangesMap: {
	        size: "CONTAINER_SIZE",
	        margin: "CONTAINER_SIZE",
	        redrawOnResize: "RESIZE_HANDLER",
	        theme: "THEME",
	        rtlEnabled: "THEME",
	        encodeHtml: "THEME"
	    },
	    _visibilityChanged: function() {
	        this.render()
	    },
	    _setThemeAndRtl: function() {
	        this._themeManager.setTheme(this.option("theme"), this.option(OPTION_RTL_ENABLED))
	    },
	    _getRendererOptions: function() {
	        return {
	            rtl: this.option(OPTION_RTL_ENABLED),
	            encodeHtml: this.option("encodeHtml"),
	            animation: this._getAnimationOptions()
	        }
	    },
	    _setRendererOptions: function() {
	        this._renderer.setOptions(this._getRendererOptions())
	    },
	    svg: function() {
	        return this._renderer.svg()
	    },
	    isReady: getFalse,
	    _dataIsReady: getTrue,
	    _resetIsReady: function() {
	        this.isReady = getFalse
	    },
	    _drawn: function() {
	        var that = this;
	        that.isReady = getFalse;
	        if (that._dataIsReady()) {
	            that._renderer.onEndAnimation(function() {
	                that.isReady = getTrue
	            })
	        }
	        that._eventTrigger("drawn", {})
	    }
	});
	helpers.replaceInherit(module.exports);

	function createEventTrigger(eventsMap, callbackGetter) {
	    var triggers = {};
	    $.each(eventsMap, function(name, info) {
	        if (info.name) {
	            createEvent(name)
	        }
	    });
	    var changes;
	    triggerEvent.change = function(name) {
	        var eventInfo = eventsMap[name];
	        if (eventInfo) {
	            (changes = changes || {})[name] = eventInfo
	        }
	        return !!eventInfo
	    };
	    triggerEvent.applyChanges = function() {
	        if (changes) {
	            $.each(changes, function(name, eventInfo) {
	                createEvent(eventInfo.newName || name)
	            });
	            changes = null
	        }
	    };
	    triggerEvent.dispose = function() {
	        eventsMap = callbackGetter = triggers = null
	    };
	    return triggerEvent;

	    function createEvent(name) {
	        var eventInfo = eventsMap[name];
	        triggers[eventInfo.name] = callbackGetter(name)
	    }

	    function triggerEvent(name, arg, complete) {
	        triggers[name](arg);
	        complete && complete()
	    }
	}


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/helpers.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var _extend = __webpack_require__(5).extend;

	function Flags() {
	    this.reset()
	}
	Flags.prototype = {
	    constructor: Flags,
	    add: function(codes) {
	        var i, ii = codes.length,
	            flags = this._flags;
	        for (i = 0; i < ii; ++i) {
	            flags[codes[i]] = 1
	        }
	        this._k += ii
	    },
	    has: function(code) {
	        return this._flags[code] > 0
	    },
	    count: function() {
	        return this._k
	    },
	    reset: function() {
	        this._flags = {};
	        this._k = 0
	    }
	};

	function combineMaps(baseMap, thisMap) {
	    return baseMap !== thisMap ? _extend({}, baseMap, thisMap) : _extend({}, baseMap)
	}

	function combineLists(baseList, thisList) {
	    return baseList !== thisList ? baseList.concat(thisList) : baseList.slice()
	}

	function buildTotalChanges(proto) {
	    proto._totalChangesOrder = proto._optionChangesOrder.concat(proto._layoutChangesOrder, proto._customChangesOrder)
	}

	function addChange(settings) {
	    var proto = this.prototype,
	        code = settings.code;
	    proto["_change_" + code] = settings.handler;
	    if (settings.isThemeDependent) {
	        proto._themeDependentChanges.push(code)
	    }
	    if (settings.option) {
	        proto._optionChangesMap[settings.option] = code
	    }(settings.isOptionChange ? proto._optionChangesOrder : proto._customChangesOrder).push(code);
	    buildTotalChanges(proto)
	}

	function addPlugin(plugin) {
	    this.prototype._plugins.push(plugin);
	    if (plugin.members) {
	        _extend(this.prototype, plugin.members)
	    }
	    if (plugin.customize) {
	        plugin.customize(this)
	    }
	}
	exports.replaceInherit = function(widget) {
	    var _inherit = widget.inherit;
	    widget.inherit = function() {
	        var proto = this.prototype,
	            plugins = proto._plugins,
	            eventsMap = proto._eventsMap,
	            initialChanges = proto._initialChanges,
	            themeDependentChanges = proto._themeDependentChanges,
	            optionChangesMap = proto._optionChangesMap,
	            optionChangesOrder = proto._optionChangesOrder,
	            layoutChangesOrder = proto._layoutChangesOrder,
	            customChangesOrder = proto._customChangesOrder,
	            result = _inherit.apply(this, arguments);
	        proto = result.prototype;
	        proto._plugins = combineLists(plugins, proto._plugins);
	        proto._eventsMap = combineMaps(eventsMap, proto._eventsMap);
	        proto._initialChanges = combineLists(initialChanges, proto._initialChanges);
	        proto._themeDependentChanges = combineLists(themeDependentChanges, proto._themeDependentChanges);
	        proto._optionChangesMap = combineMaps(optionChangesMap, proto._optionChangesMap);
	        proto._optionChangesOrder = combineLists(optionChangesOrder, proto._optionChangesOrder);
	        proto._layoutChangesOrder = combineLists(layoutChangesOrder, proto._layoutChangesOrder);
	        proto._customChangesOrder = combineLists(customChangesOrder, proto._customChangesOrder);
	        buildTotalChanges(proto);
	        result.addPlugin = addPlugin;
	        return result
	    };
	    widget.prototype._plugins = [];
	    widget.addChange = addChange;
	    widget.addPlugin = addPlugin
	};
	exports.changes = function() {
	    return new Flags
	};


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/errors_warnings.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var errorUtils = __webpack_require__(4),
	    errors = __webpack_require__(3);
	module.exports = errorUtils(errors.ERROR_MESSAGES, {
	    E2001: "Invalid data source",
	    E2002: "Axis type and data type are incompatible",
	    E2003: '"{0}" data source field contains data of unsupported type',
	    E2004: '"{0}" data source field is inconsistent',
	    E2101: "Unknown series type was specified: {0}",
	    E2102: "Ambiguity occurred between two value axes with the same name",
	    E2103: '"{0}" option must be a function',
	    E2104: "Invalid logarithm base",
	    E2105: 'Invalid value of a "{0}"',
	    E2106: "Invalid visible range",
	    E2202: "Invalid scale {0} value",
	    E2203: "The range you are trying to set is invalid",
	    W2002: "The {0} data field is absent",
	    W2003: "Tick interval is too small",
	    W2101: 'The "{0}" pane does not exist; the last pane is used by default',
	    W2102: 'Value axis with the "{0}" name was created automatically',
	    W2103: "Chart title was hidden due to container size",
	    W2104: "Legend was hidden due to container size",
	    W2105: 'Title of "{0}" axis was hidden due to container size',
	    W2106: 'Labels of "{0}" axis were hidden due to container size',
	    W2107: "Export menu was hidden due to container size",
	    W2301: "Invalid value range"
	});


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/renderers/renderer.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    getSvgMarkup = __webpack_require__(27).getSvgMarkup,
	    doc = document,
	    animation = __webpack_require__(297),
	    math = Math,
	    mathMin = math.min,
	    mathMax = math.max,
	    mathFloor = math.floor,
	    mathRound = math.round,
	    mathSin = math.sin,
	    mathCos = math.cos,
	    mathAbs = math.abs,
	    mathPI = math.PI,
	    _isDefined = commonUtils.isDefined,
	    vizUtils = __webpack_require__(291),
	    _normalizeEnum = vizUtils.normalizeEnum,
	    _normalizeBBox = vizUtils.normalizeBBox,
	    _rotateBBox = vizUtils.rotateBBox,
	    PI_DIV_180 = mathPI / 180,
	    _parseInt = parseInt,
	    SHARPING_CORRECTION = .5,
	    ARC_COORD_PREC = 5;
	var pxAddingExceptions = {
	    "column-count": true,
	    "fill-opacity": true,
	    "flex-grow": true,
	    "flex-shrink": true,
	    "font-weight": true,
	    "line-height": true,
	    opacity: true,
	    order: true,
	    orphans: true,
	    widows: true,
	    "z-index": true,
	    zoom: true
	};
	var KEY_TEXT = "text",
	    KEY_STROKE = "stroke",
	    KEY_STROKE_WIDTH = "stroke-width",
	    KEY_STROKE_OPACITY = "stroke-opacity",
	    KEY_FONT_SIZE = "font-size",
	    KEY_FONT_STYLE = "font-style",
	    KEY_FONT_WEIGHT = "font-weight",
	    KEY_TEXT_DECORATION = "text-decoration",
	    NONE = "none";
	var objectCreate = function() {
	    if (!Object.create) {
	        return function(proto) {
	            var F = function() {};
	            F.prototype = proto;
	            return new F
	        }
	    } else {
	        return function(proto) {
	            return Object.create(proto)
	        }
	    }
	}();
	var DEFAULTS = {
	    scaleX: 1,
	    scaleY: 1
	};
	var backupContainer = doc.createElement("div"),
	    backupCounter = 0;
	backupContainer.style.left = "-9999px";
	backupContainer.style.position = "absolute";

	function backupRoot(root) {
	    if (0 === backupCounter) {
	        doc.body.appendChild(backupContainer)
	    }++backupCounter;
	    root.append({
	        element: backupContainer
	    })
	}

	function restoreRoot(root, container) {
	    root.append({
	        element: container
	    });
	    --backupCounter;
	    if (0 === backupCounter) {
	        doc.body.removeChild(backupContainer)
	    }
	}
	var getNextDefsSvgId = function() {
	    var numDefsSvgElements = 1;
	    return function() {
	        return "DevExpress_" + numDefsSvgElements++
	    }
	}();

	function isObjectArgument(value) {
	    return value && "string" !== typeof value
	}

	function createElement(tagName) {
	    return doc.createElementNS("http://www.w3.org/2000/svg", tagName)
	}

	function getPatternUrl(id, pathModified) {
	    return null !== id ? "url(" + (pathModified ? window.location.href : "") + "#" + id + ")" : ""
	}

	function extend(target, source) {
	    var key;
	    for (key in source) {
	        target[key] = source[key]
	    }
	    return target
	}

	function roundValue(value, exp) {
	    value = value.toString().split("e");
	    value = mathRound(+(value[0] + "e" + (value[1] ? +value[1] + exp : exp)));
	    value = value.toString().split("e");
	    return +(value[0] + "e" + (value[1] ? +value[1] - exp : -exp))
	}
	var preserveAspectRatioMap = {
	    full: NONE,
	    lefttop: "xMinYMin",
	    leftcenter: "xMinYMid",
	    leftbottom: "xMinYMax",
	    centertop: "xMidYMin",
	    center: "xMidYMid",
	    centerbottom: "xMidYMax",
	    righttop: "xMaxYMin",
	    rightcenter: "xMaxYMid",
	    rightbottom: "xMaxYMax"
	};

	function normalizeArcParams(x, y, innerR, outerR, startAngle, endAngle) {
	    var isCircle, noArc = true,
	        angleDiff = roundValue(endAngle, 3) - roundValue(startAngle, 3);
	    if (angleDiff) {
	        if (mathAbs(angleDiff) % 360 === 0) {
	            startAngle = 0;
	            endAngle = 360;
	            isCircle = true;
	            endAngle -= .01
	        }
	        if (startAngle > 360) {
	            startAngle %= 360
	        }
	        if (endAngle > 360) {
	            endAngle %= 360
	        }
	        if (startAngle > endAngle) {
	            startAngle -= 360
	        }
	        noArc = false
	    }
	    startAngle *= PI_DIV_180;
	    endAngle *= PI_DIV_180;
	    return [x, y, mathMin(outerR, innerR), mathMax(outerR, innerR), mathCos(startAngle), mathSin(startAngle), mathCos(endAngle), mathSin(endAngle), isCircle, mathFloor(mathAbs(endAngle - startAngle) / mathPI) % 2 ? "1" : "0", noArc]
	}
	var applyEllipsis = getEllipsis(prepareLines, setNewText, removeTextSpan);
	var buildArcPath = function(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {
	    return ["M", (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), "A", outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? "M" : "L", (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), "A", innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), "Z"].join(" ")
	};

	function buildPathSegments(points, type) {
	    var list = [
	        ["M", 0, 0]
	    ];
	    switch (type) {
	        case "line":
	            list = buildLineSegments(points);
	            break;
	        case "area":
	            list = buildLineSegments(points, true);
	            break;
	        case "bezier":
	            list = buildCurveSegments(points);
	            break;
	        case "bezierarea":
	            list = buildCurveSegments(points, true)
	    }
	    return list
	}

	function buildLineSegments(points, close) {
	    return buildSegments(points, buildSimpleLineSegment, close)
	}

	function buildCurveSegments(points, close) {
	    return buildSegments(points, buildSimpleCurveSegment, close)
	}

	function buildSegments(points, buildSimpleSegment, close) {
	    var i, ii, list = [];
	    if (points[0] && points[0].length) {
	        for (i = 0, ii = points.length; i < ii; ++i) {
	            buildSimpleSegment(points[i], close, list)
	        }
	    } else {
	        buildSimpleSegment(points, close, list)
	    }
	    return list
	}

	function buildSimpleLineSegment(points, close, list) {
	    var i = 0,
	        k0 = list.length,
	        k = k0,
	        ii = (points || []).length;
	    if (ii) {
	        if (void 0 !== points[0].x) {
	            for (; i < ii;) {
	                list[k++] = ["L", points[i].x, points[i++].y]
	            }
	        } else {
	            for (; i < ii;) {
	                list[k++] = ["L", points[i++], points[i++]]
	            }
	        }
	        list[k0][0] = "M"
	    } else {
	        list[k] = ["M", 0, 0]
	    }
	    close && list.push(["Z"]);
	    return list
	}

	function buildSimpleCurveSegment(points, close, list) {
	    var i, k = list.length,
	        ii = (points || []).length;
	    if (ii) {
	        if (void 0 !== points[0].x) {
	            list[k++] = ["M", points[0].x, points[0].y];
	            for (i = 1; i < ii;) {
	                list[k++] = ["C", points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y]
	            }
	        } else {
	            list[k++] = ["M", points[0], points[1]];
	            for (i = 2; i < ii;) {
	                list[k++] = ["C", points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]]
	            }
	        }
	    } else {
	        list[k] = ["M", 0, 0]
	    }
	    close && list.push(["Z"]);
	    return list
	}

	function combinePathParam(segments) {
	    var i, segment, j, jj, d = [],
	        k = 0,
	        ii = segments.length;
	    for (i = 0; i < ii; ++i) {
	        segment = segments[i];
	        for (j = 0, jj = segment.length; j < jj; ++j) {
	            d[k++] = segment[j]
	        }
	    }
	    return d.join(" ")
	}

	function compensateSegments(oldSegments, newSegments, type) {
	    var i, originalNewSegments, oldLength = oldSegments.length,
	        newLength = newSegments.length,
	        makeEqualSegments = type.indexOf("area") !== -1 ? makeEqualAreaSegments : makeEqualLineSegments;
	    if (0 === oldLength) {
	        for (i = 0; i < newLength; i++) {
	            oldSegments.push(newSegments[i].slice(0))
	        }
	    } else {
	        if (oldLength < newLength) {
	            makeEqualSegments(oldSegments, newSegments, type)
	        } else {
	            if (oldLength > newLength) {
	                originalNewSegments = newSegments.slice(0);
	                makeEqualSegments(newSegments, oldSegments, type)
	            }
	        }
	    }
	    return originalNewSegments
	}

	function prepareConstSegment(constSeg, type) {
	    var x = constSeg[constSeg.length - 2],
	        y = constSeg[constSeg.length - 1];
	    switch (type) {
	        case "line":
	        case "area":
	            constSeg[0] = "L";
	            break;
	        case "bezier":
	        case "bezierarea":
	            constSeg[0] = "C";
	            constSeg[1] = constSeg[3] = constSeg[5] = x;
	            constSeg[2] = constSeg[4] = constSeg[6] = y
	    }
	}

	function makeEqualLineSegments(short, long, type) {
	    var constSeg = short[short.length - 1].slice(),
	        i = short.length;
	    prepareConstSegment(constSeg, type);
	    for (; i < long.length; i++) {
	        short[i] = constSeg.slice(0)
	    }
	}

	function makeEqualAreaSegments(short, long, type) {
	    var i, head, constsSeg1, constsSeg2, shortLength = short.length,
	        longLength = long.length;
	    if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {
	        i = (shortLength - 1) / 2 - 1;
	        head = short.slice(0, i + 1);
	        constsSeg1 = head[head.length - 1].slice(0);
	        constsSeg2 = short.slice(i + 1)[0].slice(0);
	        prepareConstSegment(constsSeg1, type);
	        prepareConstSegment(constsSeg2, type);
	        for (var j = i; j < (longLength - 1) / 2 - 1; j++) {
	            short.splice(j + 1, 0, constsSeg1);
	            short.splice(j + 3, 0, constsSeg2)
	        }
	    }
	}

	function baseCss(that, styles) {
	    var key, value, elemStyles = that._styles,
	        str = "";
	    styles = styles || {};
	    for (key in styles) {
	        value = styles[key];
	        if (_isDefined(value)) {
	            if ("number" === typeof value && !pxAddingExceptions[key]) {
	                value += "px"
	            }
	            elemStyles[key] = "" !== value ? value : null
	        }
	    }
	    for (key in elemStyles) {
	        value = elemStyles[key];
	        if (value) {
	            str += key + ":" + value + ";"
	        }
	    }
	    str && that.element.setAttribute("style", str);
	    return that
	}

	function baseAttr(that, attrs, inherit) {
	    attrs = attrs || {};
	    var key, value, hasTransformations, recalculateDashStyle, sw, i, settings = that._settings,
	        attributes = {},
	        elem = that.element,
	        renderer = that.renderer,
	        rtl = renderer.rtl;
	    if (!isObjectArgument(attrs)) {
	        if (attrs in settings) {
	            return settings[attrs]
	        }
	        if (attrs in DEFAULTS) {
	            return DEFAULTS[attrs]
	        }
	        return 0
	    }
	    extend(attributes, attrs);
	    for (key in attributes) {
	        value = attributes[key];
	        if (void 0 === value) {
	            continue
	        }
	        settings[key] = value;
	        if ("align" === key) {
	            key = "text-anchor";
	            value = {
	                left: rtl ? "end" : "start",
	                center: "middle",
	                right: rtl ? "start" : "end"
	            }[value] || ""
	        } else {
	            if ("dashStyle" === key) {
	                recalculateDashStyle = true;
	                continue
	            } else {
	                if (key === KEY_STROKE_WIDTH) {
	                    recalculateDashStyle = true
	                } else {
	                    if ("clipId" === key) {
	                        key = "clip-path";
	                        value = getPatternUrl(value, renderer.pathModified)
	                    } else {
	                        if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y)|sharp)$/i.test(key)) {
	                            hasTransformations = true;
	                            continue
	                        } else {
	                            if (/^(x|y|d)$/i.test(key)) {
	                                hasTransformations = true
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (null === value) {
	            elem.removeAttribute(key)
	        } else {
	            elem.setAttribute(key, value)
	        }
	    }
	    if (recalculateDashStyle && "dashStyle" in settings) {
	        value = settings.dashStyle;
	        sw = ("_originalSW" in that ? that._originalSW : settings[KEY_STROKE_WIDTH]) || 1;
	        key = "stroke-dasharray";
	        value = null === value ? "" : _normalizeEnum(value);
	        if ("" === value || "solid" === value || value === NONE) {
	            that.element.removeAttribute(key)
	        } else {
	            value = value.replace(/longdash/g, "8,3,").replace(/dash/g, "4,3,").replace(/dot/g, "1,3,").replace(/,$/, "").split(",");
	            i = value.length;
	            while (i--) {
	                value[i] = _parseInt(value[i]) * sw
	            }
	            that.element.setAttribute(key, value.join(","))
	        }
	    }
	    if (hasTransformations) {
	        that._applyTransformation()
	    }
	    return that
	}

	function createPathAttr(baseAttr) {
	    return function(attrs, inherit) {
	        var segments, that = this;
	        if (isObjectArgument(attrs)) {
	            attrs = extend({}, attrs);
	            segments = attrs.segments;
	            if ("points" in attrs) {
	                segments = buildPathSegments(attrs.points, that.type);
	                delete attrs.points
	            }
	            if (segments) {
	                attrs.d = combinePathParam(segments);
	                that.segments = segments;
	                delete attrs.segments
	            }
	        }
	        return baseAttr(that, attrs, inherit)
	    }
	}

	function createArcAttr(baseAttr, buildArcPath) {
	    return function(attrs, inherit) {
	        var x, y, innerRadius, outerRadius, startAngle, endAngle, settings = this._settings;
	        if (isObjectArgument(attrs)) {
	            attrs = extend({}, attrs);
	            if ("x" in attrs || "y" in attrs || "innerRadius" in attrs || "outerRadius" in attrs || "startAngle" in attrs || "endAngle" in attrs) {
	                settings.x = x = "x" in attrs ? attrs.x : settings.x;
	                delete attrs.x;
	                settings.y = y = "y" in attrs ? attrs.y : settings.y;
	                delete attrs.y;
	                settings.innerRadius = innerRadius = "innerRadius" in attrs ? attrs.innerRadius : settings.innerRadius;
	                delete attrs.innerRadius;
	                settings.outerRadius = outerRadius = "outerRadius" in attrs ? attrs.outerRadius : settings.outerRadius;
	                delete attrs.outerRadius;
	                settings.startAngle = startAngle = "startAngle" in attrs ? attrs.startAngle : settings.startAngle;
	                delete attrs.startAngle;
	                settings.endAngle = endAngle = "endAngle" in attrs ? attrs.endAngle : settings.endAngle;
	                delete attrs.endAngle;
	                attrs.d = buildArcPath.apply(null, normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle))
	            }
	        }
	        return baseAttr(this, attrs, inherit)
	    }
	}

	function createRectAttr(baseAttr) {
	    return function(attrs, inherit) {
	        var x, y, width, height, sw, maxSW, newSW, that = this;
	        if (isObjectArgument(attrs)) {
	            attrs = extend({}, attrs);
	            if (!inherit && (void 0 !== attrs.x || void 0 !== attrs.y || void 0 !== attrs.width || void 0 !== attrs.height || void 0 !== attrs[KEY_STROKE_WIDTH])) {
	                void 0 !== attrs.x ? x = that._originalX = attrs.x : x = that._originalX || 0;
	                void 0 !== attrs.y ? y = that._originalY = attrs.y : y = that._originalY || 0;
	                void 0 !== attrs.width ? width = that._originalWidth = attrs.width : width = that._originalWidth || 0;
	                void 0 !== attrs.height ? height = that._originalHeight = attrs.height : height = that._originalHeight || 0;
	                void 0 !== attrs[KEY_STROKE_WIDTH] ? sw = that._originalSW = attrs[KEY_STROKE_WIDTH] : sw = that._originalSW;
	                maxSW = ~~((width < height ? width : height) / 2);
	                newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;
	                attrs.x = x + newSW / 2;
	                attrs.y = y + newSW / 2;
	                attrs.width = width - newSW;
	                attrs.height = height - newSW;
	                ((sw || 0) !== newSW || !(0 === newSW && void 0 === sw)) && (attrs[KEY_STROKE_WIDTH] = newSW)
	            }
	            if ("sharp" in attrs) {
	                delete attrs.sharp
	            }
	        }
	        return baseAttr(that, attrs, inherit)
	    }
	}
	var pathAttr = createPathAttr(baseAttr),
	    arcAttr = createArcAttr(baseAttr, buildArcPath),
	    rectAttr = createRectAttr(baseAttr);

	function textAttr(attrs) {
	    var settings, isResetRequired, wasStroked, isStroked, that = this;
	    if (!isObjectArgument(attrs)) {
	        return baseAttr(that, attrs)
	    }
	    attrs = extend({}, attrs);
	    settings = that._settings;
	    wasStroked = _isDefined(settings[KEY_STROKE]) && _isDefined(settings[KEY_STROKE_WIDTH]);
	    if (void 0 !== attrs[KEY_TEXT]) {
	        settings[KEY_TEXT] = attrs[KEY_TEXT];
	        delete attrs[KEY_TEXT];
	        isResetRequired = true
	    }
	    if (void 0 !== attrs[KEY_STROKE]) {
	        settings[KEY_STROKE] = attrs[KEY_STROKE];
	        delete attrs[KEY_STROKE]
	    }
	    if (void 0 !== attrs[KEY_STROKE_WIDTH]) {
	        settings[KEY_STROKE_WIDTH] = attrs[KEY_STROKE_WIDTH];
	        delete attrs[KEY_STROKE_WIDTH]
	    }
	    if (void 0 !== attrs[KEY_STROKE_OPACITY]) {
	        settings[KEY_STROKE_OPACITY] = attrs[KEY_STROKE_OPACITY];
	        delete attrs[KEY_STROKE_OPACITY]
	    }
	    isStroked = _isDefined(settings[KEY_STROKE]) && _isDefined(settings[KEY_STROKE_WIDTH]);
	    baseAttr(that, attrs);
	    isResetRequired = isResetRequired || isStroked !== wasStroked && settings[KEY_TEXT];
	    if (isResetRequired) {
	        createTextNodes(that, settings.text, isStroked)
	    }
	    if (isResetRequired || void 0 !== attrs.x || void 0 !== attrs.y) {
	        locateTextNodes(that)
	    }
	    if (isStroked) {
	        strokeTextNodes(that)
	    }
	    return that
	}

	function textCss(styles) {
	    styles = styles || {};
	    baseCss(this, styles);
	    if (KEY_FONT_SIZE in styles) {
	        locateTextNodes(this)
	    }
	    return this
	}

	function orderHtmlTree(list, line, node, parentStyle, parentClassName) {
	    var style, realStyle, i, ii, nodes;
	    if (void 0 !== node.wholeText) {
	        list.push({
	            value: node.wholeText,
	            style: parentStyle,
	            className: parentClassName,
	            line: line,
	            height: parentStyle[KEY_FONT_SIZE] || 0
	        })
	    } else {
	        if ("BR" === node.tagName) {
	            ++line
	        } else {
	            extend(style = {}, parentStyle);
	            switch (node.tagName) {
	                case "B":
	                case "STRONG":
	                    style[KEY_FONT_WEIGHT] = "bold";
	                    break;
	                case "I":
	                case "EM":
	                    style[KEY_FONT_STYLE] = "italic";
	                    break;
	                case "U":
	                    style[KEY_TEXT_DECORATION] = "underline"
	            }
	            realStyle = node.style;
	            realStyle.color && (style.fill = realStyle.color);
	            realStyle.fontSize && (style[KEY_FONT_SIZE] = _parseInt(realStyle.fontSize, 10));
	            realStyle.fontStyle && (style[KEY_FONT_STYLE] = realStyle.fontStyle);
	            realStyle.fontWeight && (style[KEY_FONT_WEIGHT] = realStyle.fontWeight);
	            realStyle.textDecoration && (style[KEY_TEXT_DECORATION] = realStyle.textDecoration);
	            for (i = 0, nodes = node.childNodes, ii = nodes.length; i < ii; ++i) {
	                line = orderHtmlTree(list, line, nodes[i], style, node.className || parentClassName)
	            }
	        }
	    }
	    return line
	}

	function adjustLineHeights(items) {
	    var i, ii, item, currentItem = items[0];
	    for (i = 1, ii = items.length; i < ii; ++i) {
	        item = items[i];
	        if (item.line === currentItem.line) {
	            currentItem.height = mathMax(currentItem.height, item.height);
	            currentItem.inherits = currentItem.inherits || 0 === item.height;
	            item.height = NaN
	        } else {
	            currentItem = item
	        }
	    }
	}

	function removeExtraAttrs(html) {
	    var findTagAttrs = /(?:<[a-z0-9])+(?:[\s\S]*?>)/gi,
	        findStyleAttrWithValue = /(\S*\s*)=\s*(["'])(?:(?!\2).)*\2\s?/gi;
	    return html.replace(findTagAttrs, function(allTagAttrs) {
	        return allTagAttrs.replace(findStyleAttrWithValue, function(currentAttr, attrName) {
	            return "style" === attrName.toLowerCase() ? currentAttr : ""
	        })
	    })
	}

	function parseHTML(text) {
	    var items = [],
	        div = doc.createElement("div");
	    div.innerHTML = text.replace(/\r/g, "").replace(/\n/g, "<br/>");
	    orderHtmlTree(items, 0, div, {}, "");
	    adjustLineHeights(items);
	    return items
	}

	function parseMultiline(text) {
	    var texts = text.replace(/\r/g, "").split("\n"),
	        i = 0,
	        items = [];
	    for (; i < texts.length; i++) {
	        items.push({
	            value: texts[i],
	            height: 0
	        })
	    }
	    return items
	}

	function createTspans(items, element, fieldName) {
	    var i, ii, item;
	    for (i = 0, ii = items.length; i < ii; ++i) {
	        item = items[i];
	        item[fieldName] = createElement("tspan");
	        item[fieldName].appendChild(doc.createTextNode(item.value));
	        item.style && baseCss({
	            element: item[fieldName],
	            _styles: {}
	        }, item.style);
	        item.className && item[fieldName].setAttribute("class", item.className);
	        element.appendChild(item[fieldName])
	    }
	}

	function getEllipsis(prepareLines, setNewText, removeTextSpan) {
	    return function(maxWidth) {
	        var lines, requiredLength, i, ii, lineParts, j, jj, text, element = this.element,
	            width = this.getBBox().width,
	            maxLength = 0,
	            hasEllipsis = false;
	        if (maxWidth < 0) {
	            maxWidth = 0
	        }
	        if (width > maxWidth) {
	            lines = prepareLines(element, this._texts);
	            for (i = 0, ii = lines.length; i < ii; ++i) {
	                maxLength = mathMax(maxLength, lines[i].commonLength)
	            }
	            if (1 === maxLength) {
	                return false
	            }
	            requiredLength = mathFloor(maxLength * maxWidth / width);
	            for (i = 0; i < ii; ++i) {
	                lineParts = lines[i].parts;
	                for (j = 0, jj = lineParts.length; j < jj; ++j) {
	                    text = lineParts[j];
	                    if (text.startIndex <= requiredLength && text.endIndex > requiredLength) {
	                        setNewText(text, requiredLength - text.startIndex - 4);
	                        hasEllipsis = true
	                    } else {
	                        if (text.startIndex > requiredLength) {
	                            removeTextSpan(text)
	                        }
	                    }
	                }
	            }
	        }
	        return hasEllipsis
	    }
	}

	function prepareLines(element, texts) {
	    var i, ii, text, lines = [];
	    if (texts) {
	        for (i = 0, ii = texts.length; i < ii; ++i) {
	            text = texts[i];
	            if (!lines[text.line]) {
	                text.startIndex = 0;
	                text.endIndex = text.value.length;
	                lines.push({
	                    commonLength: text.value.length,
	                    parts: [text]
	                })
	            } else {
	                text.startIndex = lines[text.line].commonLength + 1;
	                text.endIndex = lines[text.line].commonLength + text.value.length;
	                lines[text.line].parts.push(text);
	                lines[text.line].commonLength += text.value.length
	            }
	        }
	    } else {
	        lines = [{
	            commonLength: element.textContent.length,
	            parts: [{
	                value: element.textContent,
	                tspan: element,
	                startIndex: 0,
	                endIndex: element.textContent.length
	            }]
	        }]
	    }
	    return lines
	}

	function setNewText(text, index) {
	    var newText = text.value.substr(0, index) + "...";
	    text.tspan.textContent = newText;
	    text.stroke && (text.stroke.textContent = newText)
	}

	function removeTextSpan(text) {
	    text.tspan.parentNode.removeChild(text.tspan);
	    text.stroke && text.stroke.parentNode.removeChild(text.stroke)
	}

	function createTextNodes(wrapper, text, isStroked) {
	    var items, parsedHtml;
	    wrapper._texts = null;
	    wrapper.clear();
	    if (null === text) {
	        return
	    }
	    text = "" + text;
	    if (!wrapper.renderer.encodeHtml && (text.indexOf("<") !== -1 || text.indexOf("&") !== -1)) {
	        parsedHtml = removeExtraAttrs(text);
	        items = parseHTML(parsedHtml)
	    } else {
	        if (text.indexOf("\n") !== -1) {
	            items = parseMultiline(text)
	        } else {
	            if (isStroked) {
	                items = [{
	                    value: text,
	                    height: 0
	                }]
	            }
	        }
	    }
	    if (items) {
	        if (items.length) {
	            wrapper._texts = items;
	            if (isStroked) {
	                createTspans(items, wrapper.element, KEY_STROKE)
	            }
	            createTspans(items, wrapper.element, "tspan")
	        }
	    } else {
	        wrapper.element.appendChild(doc.createTextNode(text))
	    }
	}

	function setTextNodeAttribute(item, name, value) {
	    item.tspan.setAttribute(name, value);
	    item.stroke && item.stroke.setAttribute(name, value)
	}

	function locateTextNodes(wrapper) {
	    if (!wrapper._texts) {
	        return
	    }
	    var i, ii, items = wrapper._texts,
	        x = wrapper._settings.x,
	        lineHeight = _parseInt(wrapper._styles[KEY_FONT_SIZE], 10) || 12,
	        item = items[0];
	    setTextNodeAttribute(item, "x", x);
	    setTextNodeAttribute(item, "y", wrapper._settings.y);
	    for (i = 1, ii = items.length; i < ii; ++i) {
	        item = items[i];
	        if (item.height >= 0) {
	            setTextNodeAttribute(item, "x", x);
	            setTextNodeAttribute(item, "dy", item.inherits ? mathMax(item.height, lineHeight) : item.height || lineHeight)
	        }
	    }
	}

	function strokeTextNodes(wrapper) {
	    if (!wrapper._texts) {
	        return
	    }
	    var tspan, i, ii, items = wrapper._texts,
	        stroke = wrapper._settings[KEY_STROKE],
	        strokeWidth = wrapper._settings[KEY_STROKE_WIDTH],
	        strokeOpacity = wrapper._settings[KEY_STROKE_OPACITY] || 1;
	    for (i = 0, ii = items.length; i < ii; ++i) {
	        tspan = items[i].stroke;
	        tspan.setAttribute(KEY_STROKE, stroke);
	        tspan.setAttribute(KEY_STROKE_WIDTH, strokeWidth);
	        tspan.setAttribute(KEY_STROKE_OPACITY, strokeOpacity);
	        tspan.setAttribute("stroke-linejoin", "round")
	    }
	}

	function baseAnimate(that, params, options, complete) {
	    options = options || {};
	    var key, value, renderer = that.renderer,
	        settings = that._settings,
	        animationParams = {};
	    var defaults = {
	        translateX: 0,
	        translateY: 0,
	        scaleX: 1,
	        scaleY: 1,
	        rotate: 0,
	        rotateX: 0,
	        rotateY: 0
	    };
	    if (complete) {
	        options.complete = complete
	    }
	    if (renderer.animationEnabled()) {
	        for (key in params) {
	            value = params[key];
	            if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
	                animationParams.transform = animationParams.transform || {
	                    from: {},
	                    to: {}
	                };
	                animationParams.transform.from[key] = key in settings ? Number(settings[key].toFixed(3)) : defaults[key];
	                animationParams.transform.to[key] = value
	            } else {
	                if ("arc" === key || "segments" === key) {
	                    animationParams[key] = value
	                } else {
	                    animationParams[key] = {
	                        from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),
	                        to: value
	                    }
	                }
	            }
	        }
	        renderer.animateElement(that, animationParams, extend(extend({}, renderer._animation), options))
	    } else {
	        options.step && options.step.call(that, 1, 1);
	        options.complete && options.complete.call(that);
	        that.attr(params)
	    }
	    return that
	}

	function pathAnimate(params, options, complete) {
	    var newSegments, endSegments, that = this,
	        curSegments = that.segments || [];
	    if (that.renderer.animationEnabled() && "points" in params) {
	        newSegments = buildPathSegments(params.points, that.type);
	        endSegments = compensateSegments(curSegments, newSegments, that.type);
	        params.segments = {
	            from: curSegments,
	            to: newSegments,
	            end: endSegments
	        };
	        delete params.points
	    }
	    return baseAnimate(that, params, options, complete)
	}

	function arcAnimate(params, options, complete) {
	    var that = this,
	        settings = that._settings,
	        arcParams = {
	            from: {},
	            to: {}
	        };
	    if (that.renderer.animationEnabled() && ("x" in params || "y" in params || "innerRadius" in params || "outerRadius" in params || "startAngle" in params || "endAngle" in params)) {
	        arcParams.from.x = settings.x || 0;
	        arcParams.from.y = settings.y || 0;
	        arcParams.from.innerRadius = settings.innerRadius || 0;
	        arcParams.from.outerRadius = settings.outerRadius || 0;
	        arcParams.from.startAngle = settings.startAngle || 0;
	        arcParams.from.endAngle = settings.endAngle || 0;
	        arcParams.to.x = "x" in params ? params.x : settings.x;
	        delete params.x;
	        arcParams.to.y = "y" in params ? params.y : settings.y;
	        delete params.y;
	        arcParams.to.innerRadius = "innerRadius" in params ? params.innerRadius : settings.innerRadius;
	        delete params.innerRadius;
	        arcParams.to.outerRadius = "outerRadius" in params ? params.outerRadius : settings.outerRadius;
	        delete params.outerRadius;
	        arcParams.to.startAngle = "startAngle" in params ? params.startAngle : settings.startAngle;
	        delete params.startAngle;
	        arcParams.to.endAngle = "endAngle" in params ? params.endAngle : settings.endAngle;
	        delete params.endAngle;
	        params.arc = arcParams
	    }
	    return baseAnimate(that, params, options, complete)
	}

	function buildLink(target, parameters) {
	    var obj = {
	        is: false,
	        name: parameters.name || parameters,
	        after: parameters.after
	    };
	    if (target) {
	        obj.to = target
	    } else {
	        obj.virtual = true
	    }
	    return obj
	}

	function SvgElement(renderer, tagName, type) {
	    var that = this;
	    that.renderer = renderer;
	    that.element = createElement(tagName);
	    that._settings = {};
	    that._styles = {};
	    if ("path" === tagName) {
	        that.type = type || "line"
	    }
	}
	exports.SvgElement = SvgElement;
	SvgElement.prototype = {
	    constructor: SvgElement,
	    _getJQElement: function() {
	        return this._$element || (this._$element = $(this.element))
	    },
	    dispose: function() {
	        this._getJQElement().remove();
	        return this
	    },
	    append: function(parent) {
	        (parent || this.renderer.root).element.appendChild(this.element);
	        return this
	    },
	    remove: function() {
	        var element = this.element;
	        element.parentNode && element.parentNode.removeChild(element);
	        return this
	    },
	    enableLinks: function() {
	        this._links = [];
	        return this
	    },
	    virtualLink: function(parameters) {
	        linkItem({
	            _link: buildLink(null, parameters)
	        }, this);
	        return this
	    },
	    linkAfter: function(name) {
	        this._linkAfter = name;
	        return this
	    },
	    linkOn: function(target, parameters) {
	        this._link = buildLink(target, parameters);
	        linkItem(this, target);
	        return this
	    },
	    linkOff: function() {
	        unlinkItem(this);
	        this._link = null;
	        return this
	    },
	    linkAppend: function() {
	        var i, next, link = this._link,
	            items = link.to._links;
	        for (i = link.i + 1;
	            (next = items[i]) && !next._link.is; ++i) {}
	        this._insert(link.to, next);
	        link.is = true;
	        return this
	    },
	    _insert: function(parent, next) {
	        parent.element.insertBefore(this.element, next ? next.element : null)
	    },
	    linkRemove: function() {
	        this.remove();
	        this._link.is = false;
	        return this
	    },
	    clear: function() {
	        this._getJQElement().empty();
	        return this
	    },
	    toBackground: function() {
	        var elem = this.element,
	            parent = elem.parentNode;
	        parent && parent.insertBefore(elem, parent.firstChild);
	        return this
	    },
	    toForeground: function() {
	        var elem = this.element,
	            parent = elem.parentNode;
	        parent && parent.appendChild(elem);
	        return this
	    },
	    attr: function(attrs, inherit) {
	        return baseAttr(this, attrs, inherit)
	    },
	    smartAttr: function(attrs) {
	        var that = this;
	        if (attrs.hatching) {
	            attrs.fill = that._hatching = that.renderer.lockHatching(attrs.fill, attrs.hatching, that._hatching);
	            attrs.hatching = null
	        } else {
	            if (that._hatching) {
	                that.renderer.releaseHatching(that._hatching);
	                that._hatching = null
	            }
	        }
	        return baseAttr(that, attrs)
	    },
	    css: function(styles) {
	        return baseCss(this, styles)
	    },
	    animate: function(params, options, complete) {
	        return baseAnimate(this, params, options, complete)
	    },
	    sharp: function(pos) {
	        return this.attr({
	            sharp: pos || true
	        })
	    },
	    _applyTransformation: function() {
	        var scaleXDefined, scaleYDefined, rotateX, rotateY, tr = this._settings,
	            transformations = [],
	            sharpMode = tr.sharp,
	            strokeOdd = tr[KEY_STROKE_WIDTH] % 2,
	            correctionX = strokeOdd && ("h" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION : 0,
	            correctionY = strokeOdd && ("v" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION : 0;
	        transformations.push("translate(" + ((tr.translateX || 0) + correctionX) + "," + ((tr.translateY || 0) + correctionY) + ")");
	        if (tr.rotate) {
	            if ("rotateX" in tr) {
	                rotateX = tr.rotateX
	            } else {
	                rotateX = tr.x
	            }
	            if ("rotateY" in tr) {
	                rotateY = tr.rotateY
	            } else {
	                rotateY = tr.y
	            }
	            transformations.push("rotate(" + tr.rotate + "," + (rotateX || 0) + "," + (rotateY || 0) + ")")
	        }
	        scaleXDefined = _isDefined(tr.scaleX);
	        scaleYDefined = _isDefined(tr.scaleY);
	        if (scaleXDefined || scaleYDefined) {
	            transformations.push("scale(" + (scaleXDefined ? tr.scaleX : 1) + "," + (scaleYDefined ? tr.scaleY : 1) + ")")
	        }
	        if (transformations.length) {
	            this.element.setAttribute("transform", transformations.join(" "))
	        }
	    },
	    move: function(x, y, animate, animOptions) {
	        var obj = {};
	        _isDefined(x) && (obj.translateX = x);
	        _isDefined(y) && (obj.translateY = y);
	        if (!animate) {
	            this.attr(obj)
	        } else {
	            this.animate(obj, animOptions)
	        }
	        return this
	    },
	    rotate: function(angle, x, y, animate, animOptions) {
	        var obj = {
	            rotate: angle || 0
	        };
	        _isDefined(x) && (obj.rotateX = x);
	        _isDefined(y) && (obj.rotateY = y);
	        if (!animate) {
	            this.attr(obj)
	        } else {
	            this.animate(obj, animOptions)
	        }
	        return this
	    },
	    getBBox: function() {
	        var bBox, elem = this.element,
	            transformation = this._settings;
	        try {
	            bBox = elem.getBBox && elem.getBBox()
	        } catch (e) {}
	        bBox = bBox || {
	            x: 0,
	            y: 0,
	            width: elem.offsetWidth || 0,
	            height: elem.offsetHeight || 0
	        };
	        if (transformation.rotate) {
	            bBox = _rotateBBox(bBox, [("rotateX" in transformation ? transformation.rotateX : transformation.x) || 0, ("rotateY" in transformation ? transformation.rotateY : transformation.y) || 0], -transformation.rotate)
	        } else {
	            bBox = _normalizeBBox(bBox)
	        }
	        return bBox
	    },
	    markup: function() {
	        return getSvgMarkup(this.element)
	    },
	    getOffset: function() {
	        return this._getJQElement().offset()
	    },
	    stopAnimation: function(disableComplete) {
	        var animation = this.animation;
	        animation && animation.stop(disableComplete);
	        return this
	    },
	    setTitle: function(text) {
	        var titleElem = createElement("title");
	        titleElem.textContent = text || "";
	        this.element.appendChild(titleElem)
	    },
	    data: function(obj, val) {
	        var key, elem = this.element;
	        if (void 0 !== val) {
	            elem[obj] = val
	        } else {
	            for (key in obj) {
	                elem[key] = obj[key]
	            }
	        }
	        return this
	    },
	    on: function() {
	        $.fn.on.apply(this._getJQElement(), arguments);
	        return this
	    },
	    off: function() {
	        $.fn.off.apply(this._getJQElement(), arguments);
	        return this
	    },
	    trigger: function() {
	        $.fn.trigger.apply(this._getJQElement(), arguments);
	        return this
	    }
	};

	function PathSvgElement(renderer, type) {
	    SvgElement.call(this, renderer, "path", type)
	}
	exports.PathSvgElement = PathSvgElement;
	PathSvgElement.prototype = objectCreate(SvgElement.prototype);
	extend(PathSvgElement.prototype, {
	    constructor: PathSvgElement,
	    attr: pathAttr,
	    animate: pathAnimate
	});

	function ArcSvgElement(renderer) {
	    SvgElement.call(this, renderer, "path", "arc")
	}
	exports.ArcSvgElement = ArcSvgElement;
	ArcSvgElement.prototype = objectCreate(SvgElement.prototype);
	extend(ArcSvgElement.prototype, {
	    constructor: ArcSvgElement,
	    attr: arcAttr,
	    animate: arcAnimate
	});

	function RectSvgElement(renderer) {
	    SvgElement.call(this, renderer, "rect")
	}
	exports.RectSvgElement = RectSvgElement;
	RectSvgElement.prototype = objectCreate(SvgElement.prototype);
	extend(RectSvgElement.prototype, {
	    constructor: RectSvgElement,
	    attr: rectAttr
	});

	function TextSvgElement(renderer) {
	    SvgElement.call(this, renderer, "text")
	}
	exports.TextSvgElement = TextSvgElement;
	TextSvgElement.prototype = objectCreate(SvgElement.prototype);
	extend(TextSvgElement.prototype, {
	    constructor: TextSvgElement,
	    attr: textAttr,
	    css: textCss,
	    applyEllipsis: applyEllipsis
	});

	function updateIndexes(items, k) {
	    var i, item;
	    for (i = k; !!(item = items[i]); ++i) {
	        item._link.i = i
	    }
	}

	function linkItem(target, container) {
	    var i, item, items = container._links,
	        key = target._link.after = target._link.after || container._linkAfter;
	    if (key) {
	        for (i = 0;
	            (item = items[i]) && item._link.name !== key; ++i) {}
	        if (item) {
	            for (++i;
	                (item = items[i]) && item._link.after === key; ++i) {}
	        }
	    } else {
	        i = items.length
	    }
	    items.splice(i, 0, target);
	    updateIndexes(items, i)
	}

	function unlinkItem(target) {
	    var i, items = target._link.to._links;
	    for (i = 0; items[i] !== target; ++i) {}
	    items.splice(i, 1);
	    updateIndexes(items, i)
	}

	function Renderer(options) {
	    var that = this;
	    that.root = that._createElement(that._rootTag, that._rootAttr).attr({
	        "class": options.cssClass
	    }).css(that._rootCss);
	    that._init();
	    that.pathModified = !!options.pathModified;
	    that._$container = $(options.container);
	    that.root.append({
	        element: options.container
	    });
	    that._locker = 0;
	    that._backed = false
	}
	exports.Renderer = Renderer;
	Renderer.prototype = {
	    constructor: Renderer,
	    _rootTag: "svg",
	    _rootAttr: {
	        xmlns: "http://www.w3.org/2000/svg",
	        "xmlns:xlink": "http://www.w3.org/1999/xlink",
	        version: "1.1",
	        fill: NONE,
	        stroke: NONE,
	        "stroke-width": 0
	    },
	    _rootCss: {
	        "line-height": "normal",
	        "-ms-user-select": NONE,
	        "-moz-user-select": NONE,
	        "-webkit-user-select": NONE,
	        "-webkit-tap-highlight-color": "rgba(0, 0, 0, 0)",
	        display: "block",
	        overflow: "hidden"
	    },
	    _init: function() {
	        var that = this;
	        that._defs = that._createElement("defs").append(that.root);
	        that._animationController = new animation.AnimationController(that.root.element);
	        that._animation = {
	            enabled: true,
	            duration: 1e3,
	            easing: "easeOutCubic"
	        }
	    },
	    setOptions: function(options) {
	        var that = this;
	        that.rtl = !!options.rtl;
	        that.encodeHtml = !!options.encodeHtml;
	        that.updateAnimationOptions(options.animation || {});
	        that.root.attr({
	            direction: that.rtl ? "rtl" : "ltr"
	        });
	        return that
	    },
	    _createElement: function(tagName, attr, type) {
	        var elem = new exports.SvgElement(this, tagName, type);
	        attr && elem.attr(attr);
	        return elem
	    },
	    lock: function() {
	        var that = this;
	        if (0 === that._locker) {
	            that._backed = !that._$container.is(":visible");
	            if (that._backed) {
	                backupRoot(that.root)
	            }
	        }++that._locker;
	        return that
	    },
	    unlock: function() {
	        var that = this;
	        --that._locker;
	        if (0 === that._locker) {
	            if (that._backed) {
	                restoreRoot(that.root, that._$container[0])
	            }
	            that._backed = false
	        }
	        return that
	    },
	    resize: function(width, height) {
	        if (width >= 0 && height >= 0) {
	            this.root.attr({
	                width: width,
	                height: height
	            })
	        }
	        return this
	    },
	    dispose: function() {
	        var key, that = this;
	        that.root.dispose();
	        that._defs.dispose();
	        that._animationController.dispose();
	        for (key in that) {
	            that[key] = null
	        }
	        return that
	    },
	    animationEnabled: function() {
	        return !!this._animation.enabled
	    },
	    updateAnimationOptions: function(newOptions) {
	        extend(this._animation, newOptions);
	        return this
	    },
	    stopAllAnimations: function(lock) {
	        this._animationController[lock ? "lock" : "stop"]();
	        return this
	    },
	    animateElement: function(element, params, options) {
	        this._animationController.animateElement(element, params, options);
	        return this
	    },
	    svg: function() {
	        return this.root.markup()
	    },
	    getRootOffset: function() {
	        return this.root.getOffset()
	    },
	    onEndAnimation: function(endAnimation) {
	        this._animationController.onEndAnimation(endAnimation)
	    },
	    rect: function(x, y, width, height) {
	        var elem = new exports.RectSvgElement(this);
	        return elem.attr({
	            x: x || 0,
	            y: y || 0,
	            width: width || 0,
	            height: height || 0
	        })
	    },
	    simpleRect: function() {
	        return this._createElement("rect")
	    },
	    circle: function(x, y, r) {
	        return this._createElement("circle", {
	            cx: x || 0,
	            cy: y || 0,
	            r: r || 0
	        })
	    },
	    g: function() {
	        return this._createElement("g")
	    },
	    image: function(x, y, w, h, href, location) {
	        var image = this._createElement("image", {
	            x: x || 0,
	            y: y || 0,
	            width: w || 0,
	            height: h || 0,
	            preserveAspectRatio: preserveAspectRatioMap[_normalizeEnum(location)] || NONE
	        });
	        image.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", href || "");
	        return image
	    },
	    path: function(points, type) {
	        var elem = new exports.PathSvgElement(this, type);
	        return elem.attr({
	            points: points || []
	        })
	    },
	    arc: function(x, y, innerRadius, outerRadius, startAngle, endAngle) {
	        var elem = new exports.ArcSvgElement(this);
	        return elem.attr({
	            x: x || 0,
	            y: y || 0,
	            innerRadius: innerRadius || 0,
	            outerRadius: outerRadius || 0,
	            startAngle: startAngle || 0,
	            endAngle: endAngle || 0
	        })
	    },
	    text: function(text, x, y) {
	        var elem = new exports.TextSvgElement(this);
	        return elem.attr({
	            text: text,
	            x: x || 0,
	            y: y || 0
	        })
	    },
	    pattern: function(color, hatching, _id) {
	        hatching = hatching || {};
	        var id, d, pattern, rect, path, that = this,
	            step = hatching.step || 6,
	            stepTo2 = step / 2,
	            stepBy15 = 1.5 * step,
	            direction = _normalizeEnum(hatching.direction);
	        if ("right" !== direction && "left" !== direction) {
	            return {
	                id: color,
	                append: function() {
	                    return this
	                },
	                clear: function() {},
	                dispose: function() {},
	                remove: function() {}
	            }
	        }
	        id = _id || getNextDefsSvgId();
	        d = "right" === direction ? "M " + stepTo2 + " " + -stepTo2 + " L " + -stepTo2 + " " + stepTo2 + " M 0 " + step + " L " + step + " 0 M " + stepBy15 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 : "M 0 0 L " + step + " " + step + " M " + -stepTo2 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 + " M " + stepTo2 + " " + -stepTo2 + " L " + stepBy15 + " " + stepTo2;
	        pattern = that._createElement("pattern", {
	            id: id,
	            width: step,
	            height: step,
	            patternUnits: "userSpaceOnUse"
	        }).append(that._defs);
	        pattern.id = getPatternUrl(id, that.pathModified);
	        rect = that.rect(0, 0, step, step).attr({
	            fill: color,
	            opacity: hatching.opacity
	        }).append(pattern);
	        path = new exports.PathSvgElement(this).attr({
	            d: d,
	            "stroke-width": hatching.width || 1,
	            stroke: color
	        }).append(pattern);
	        return pattern
	    },
	    clipRect: function(x, y, width, height) {
	        var that = this,
	            id = getNextDefsSvgId(),
	            clipPath = that._createElement("clipPath", {
	                id: id
	            }).append(that._defs),
	            rect = that.rect(x, y, width, height).append(clipPath);
	        rect.id = id;
	        rect.remove = function() {
	            throw "Not implemented"
	        };
	        rect.dispose = function() {
	            clipPath.dispose();
	            clipPath = null;
	            return this
	        };
	        return rect
	    },
	    shadowFilter: function(x, y, width, height, offsetX, offsetY, blur, color, opacity) {
	        var that = this,
	            id = getNextDefsSvgId(),
	            filter = that._createElement("filter", {
	                id: id,
	                x: x || 0,
	                y: y || 0,
	                width: width || 0,
	                height: height || 0
	            }).append(that._defs),
	            gaussianBlur = that._createElement("feGaussianBlur", {
	                "in": "SourceGraphic",
	                result: "gaussianBlurResult",
	                stdDeviation: blur || 0
	            }).append(filter),
	            offset = that._createElement("feOffset", {
	                "in": "gaussianBlurResult",
	                result: "offsetResult",
	                dx: offsetX || 0,
	                dy: offsetY || 0
	            }).append(filter),
	            flood = that._createElement("feFlood", {
	                result: "floodResult",
	                "flood-color": color || "",
	                "flood-opacity": opacity
	            }).append(filter),
	            composite = that._createElement("feComposite", {
	                "in": "floodResult",
	                in2: "offsetResult",
	                operator: "in",
	                result: "compositeResult"
	            }).append(filter),
	            finalComposite = that._createElement("feComposite", {
	                "in": "SourceGraphic",
	                in2: "compositeResult",
	                operator: "over"
	            }).append(filter);
	        filter.ref = getPatternUrl(id, that.pathModified);
	        filter.gaussianBlur = gaussianBlur;
	        filter.offset = offset;
	        filter.flood = flood;
	        filter.composite = composite;
	        filter.finalComposite = finalComposite;
	        filter.attr = function(attrs) {
	            var that = this,
	                filterAttrs = {},
	                offsetAttrs = {},
	                floodAttrs = {};
	            "x" in attrs && (filterAttrs.x = attrs.x);
	            "y" in attrs && (filterAttrs.y = attrs.y);
	            "width" in attrs && (filterAttrs.width = attrs.width);
	            "height" in attrs && (filterAttrs.height = attrs.height);
	            baseAttr(that, filterAttrs);
	            "blur" in attrs && that.gaussianBlur.attr({
	                stdDeviation: attrs.blur
	            });
	            "offsetX" in attrs && (offsetAttrs.dx = attrs.offsetX);
	            "offsetY" in attrs && (offsetAttrs.dy = attrs.offsetY);
	            that.offset.attr(offsetAttrs);
	            "color" in attrs && (floodAttrs["flood-color"] = attrs.color);
	            "opacity" in attrs && (floodAttrs["flood-opacity"] = attrs.opacity);
	            that.flood.attr(floodAttrs);
	            return that
	        };
	        return filter
	    },
	    brightFilter: function(type, slope) {
	        var that = this,
	            filterId = getNextDefsSvgId(),
	            filter = that._createElement("filter", {
	                id: filterId
	            }).append(that._defs),
	            componentTransferElement = that._createElement("feComponentTransfer").append(filter),
	            attrs = {
	                type: type,
	                slope: slope
	            };
	        filter.ref = getPatternUrl(filterId, that.pathModified);
	        that._createElement("feFuncR", attrs).append(componentTransferElement);
	        that._createElement("feFuncG", attrs).append(componentTransferElement);
	        that._createElement("feFuncB", attrs).append(componentTransferElement);
	        return filter
	    },
	    initHatching: function() {
	        var name, storage = this._hatchingStorage = this._hatchingStorage || {
	                byHash: {},
	                baseId: getNextDefsSvgId()
	            },
	            byHash = storage.byHash;
	        for (name in byHash) {
	            byHash[name].pattern.dispose()
	        }
	        storage.byHash = {};
	        storage.refToHash = {};
	        storage.nextId = 0
	    },
	    lockHatching: function(color, hatching, ref) {
	        var storageItem, pattern, storage = this._hatchingStorage,
	            hash = getHatchingHash(color, hatching);
	        if (storage.refToHash[ref] !== hash) {
	            if (ref) {
	                this.releaseHatching(ref)
	            }
	            storageItem = storage.byHash[hash];
	            if (!storageItem) {
	                pattern = this.pattern(color, hatching, storage.baseId + "-hatching-" + storage.nextId++);
	                storageItem = storage.byHash[hash] = {
	                    pattern: pattern,
	                    count: 0
	                };
	                storage.refToHash[pattern.id] = hash
	            }++storageItem.count;
	            ref = storageItem.pattern.id
	        }
	        return ref
	    },
	    releaseHatching: function(ref) {
	        var storage = this._hatchingStorage,
	            hash = storage.refToHash[ref],
	            storageItem = storage.byHash[hash];
	        if (0 === --storageItem.count) {
	            storageItem.pattern.dispose();
	            delete storage.byHash[hash];
	            delete storage.refToHash[ref]
	        }
	    }
	};

	function getHatchingHash(color, hatching) {
	    return "@" + color + "::" + hatching.step + ":" + hatching.width + ":" + hatching.opacity + ":" + hatching.direction
	}


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/renderers/animation.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var animationFrame = __webpack_require__(46),
	    noop = function() {},
	    easingFunctions = {
	        easeOutCubic: function(pos, start, end) {
	            return 1 === pos ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start
	        },
	        linear: function(pos, start, end) {
	            return 1 === pos ? end : pos * (end - start) + +start
	        }
	    };
	exports.easingFunctions = easingFunctions;
	var animationSvgStep = {
	    segments: function(elem, params, progress, easing, currentParams) {
	        var curSeg, seg, i, j, from = params.from,
	            to = params.to,
	            segments = [];
	        for (i = 0; i < from.length; i++) {
	            curSeg = from[i];
	            seg = [curSeg[0]];
	            if (curSeg.length > 1) {
	                for (j = 1; j < curSeg.length; j++) {
	                    seg.push(easing(progress, curSeg[j], to[i][j]))
	                }
	            }
	            segments.push(seg)
	        }
	        currentParams.segments = params.end && 1 === progress ? params.end : segments;
	        elem.attr({
	            segments: segments
	        })
	    },
	    arc: function(elem, params, progress, easing) {
	        var from = params.from,
	            to = params.to,
	            current = {};
	        for (var i in from) {
	            current[i] = easing(progress, from[i], to[i])
	        }
	        elem.attr(current)
	    },
	    transform: function(elem, params, progress, easing, currentParams) {
	        var from = params.from,
	            to = params.to,
	            current = {};
	        for (var i in from) {
	            current[i] = currentParams[i] = easing(progress, from[i], to[i])
	        }
	        elem.attr(current)
	    },
	    base: function(elem, params, progress, easing, currentParams, attributeName) {
	        var obj = {};
	        obj[attributeName] = currentParams[attributeName] = easing(progress, params.from, params.to);
	        elem.attr(obj)
	    },
	    _: noop,
	    complete: function(element, currentSettings) {
	        element.attr(currentSettings)
	    }
	};

	function step(now) {
	    var attrName, that = this,
	        animateStep = that._animateStep;
	    that._progress = that._calcProgress(now);
	    for (attrName in that.params) {
	        var anim = animateStep[attrName] || animateStep.base;
	        anim(that.element, that.params[attrName], that._progress, that._easing, that._currentParams, attrName)
	    }
	    that.options.step && that.options.step(that._easing(that._progress, 0, 1), that._progress);
	    if (1 === that._progress) {
	        return that.stop()
	    }
	    return true
	}

	function start(now) {
	    this._startTime = now;
	    this.tick = step;
	    return true
	}

	function Animation(element, params, options) {
	    var that = this;
	    that._progress = 0;
	    that.element = element;
	    that.params = params;
	    that.options = options;
	    that.duration = options.partitionDuration ? options.duration * options.partitionDuration : options.duration;
	    that._animateStep = options.animateStep || animationSvgStep;
	    that._easing = easingFunctions[options.easing] || easingFunctions.easeOutCubic;
	    that._currentParams = {};
	    that.tick = start
	}
	Animation.prototype = {
	    _calcProgress: function(now) {
	        return Math.min(1, (now - this._startTime) / this.duration)
	    },
	    stop: function(disableComplete) {
	        var that = this,
	            options = that.options,
	            animateStep = that._animateStep;
	        that.stop = that.tick = noop;
	        animateStep.complete && animateStep.complete(that.element, that._currentParams);
	        options.complete && !disableComplete && options.complete()
	    }
	};

	function AnimationController(element) {
	    var that = this;
	    that._animationCount = 0;
	    that._timerId = null;
	    that._animations = {};
	    that.element = element
	}
	exports.AnimationController = AnimationController;
	AnimationController.prototype = {
	    _loop: function() {
	        var an, that = this,
	            animations = that._animations,
	            activeAnimation = 0,
	            now = (new Date).getTime(),
	            endAnimation = that._endAnimation;
	        for (an in animations) {
	            if (!animations[an].tick(now)) {
	                delete animations[an]
	            }
	            activeAnimation++
	        }
	        if (0 === activeAnimation) {
	            that.stop();
	            that._endAnimationTimer = endAnimation && setTimeout(function() {
	                if (0 === that._animationCount) {
	                    endAnimation();
	                    that._endAnimation = null
	                }
	            });
	            return
	        }
	        that._timerId = animationFrame.requestAnimationFrame.call(null, function() {
	            that._loop()
	        }, that.element)
	    },
	    addAnimation: function(animation) {
	        var that = this;
	        that._animations[that._animationCount++] = animation;
	        clearTimeout(that._endAnimationTimer);
	        if (!that._timerId) {
	            clearTimeout(that._startDelay);
	            that._startDelay = setTimeout(function() {
	                that._timerId = 1;
	                that._loop()
	            }, 0)
	        }
	    },
	    animateElement: function(elem, params, options) {
	        if (elem && params && options) {
	            elem.animation && elem.animation.stop();
	            this.addAnimation(elem.animation = new Animation(elem, params, options))
	        }
	    },
	    onEndAnimation: function(endAnimation) {
	        this._animationCount ? this._endAnimation = endAnimation : endAnimation()
	    },
	    dispose: function() {
	        this.stop();
	        this.element = null
	    },
	    stop: function() {
	        var that = this;
	        that._animations = {};
	        that._animationCount = 0;
	        animationFrame.cancelAnimationFrame(that._timerId);
	        clearTimeout(that._startDelay);
	        clearTimeout(that._endAnimationTimer);
	        that._timerId = null
	    },
	    lock: function() {
	        var an, unstoppable, hasUnstoppableInAnimations, animations = this._animations;
	        for (an in animations) {
	            unstoppable = animations[an].options.unstoppable;
	            hasUnstoppableInAnimations = hasUnstoppableInAnimations || unstoppable;
	            if (!unstoppable) {
	                animations[an].stop(true);
	                delete animations[an]
	            }
	        }!hasUnstoppableInAnimations && this.stop()
	    }
	};
	exports.animationSvgStep = animationSvgStep;


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/layout.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var _normalizeEnum = __webpack_require__(291).normalizeEnum,
	    _min = Math.min,
	    _max = Math.max,
	    ALIGN_START = 0,
	    ALIGN_MIDDLE = 1,
	    ALIGN_END = 2,
	    horizontalAlignmentMap = {
	        left: ALIGN_START,
	        center: ALIGN_MIDDLE,
	        right: ALIGN_END
	    },
	    verticalAlignmentMap = {
	        top: ALIGN_START,
	        center: ALIGN_MIDDLE,
	        bottom: ALIGN_END
	    },
	    sideMap = {
	        horizontal: 0,
	        vertical: 1
	    },
	    slicersMap = {};
	slicersMap[ALIGN_START] = function(a, b, size) {
	    return [a, _min(b, a + size)]
	};
	slicersMap[ALIGN_MIDDLE] = function(a, b, size) {
	    return [_max(a, (a + b - size) / 2), _min(b, (a + b + size) / 2)]
	};
	slicersMap[ALIGN_END] = function(a, b, size) {
	    return [_max(a, b - size), b]
	};

	function pickValue(value, map, defaultValue) {
	    var val = _normalizeEnum(value);
	    return val in map ? map[val] : defaultValue
	}

	function normalizeLayoutOptions(options) {
	    var side = pickValue(options.side, sideMap, 1),
	        alignment = [pickValue(options.horizontalAlignment, horizontalAlignmentMap, ALIGN_MIDDLE), pickValue(options.verticalAlignment, verticalAlignmentMap, ALIGN_START)];
	    return {
	        side: side,
	        primary: bringToEdge(alignment[side]),
	        secondary: alignment[1 - side],
	        weak: options.weak
	    }
	}

	function bringToEdge(primary) {
	    return primary < 2 ? 0 : 2
	}

	function getConjugateSide(side) {
	    return 1 - side
	}

	function getOppositeAlignment(alignment) {
	    return 2 - alignment
	}

	function getSlice(alignment, a, b, size) {
	    return slicersMap[alignment](a, b, size)
	}

	function getShrink(alignment, size) {
	    return (alignment > 0 ? -1 : 1) * size
	}

	function processForward(item, rect) {
	    var side = item.side,
	        size = item.element.measure([rect[2] - rect[0], rect[3] - rect[1]]),
	        isValid = size[side] < rect[2 + side] - rect[side];
	    if (isValid) {
	        rect[item.primary + side] += getShrink(item.primary, size[side]);
	        item.size = size
	    }
	    return isValid
	}

	function processBackward(item, rect) {
	    var primarySide = item.side,
	        secondarySide = getConjugateSide(primarySide),
	        itemRect = [],
	        secondary = getSlice(item.secondary, rect[secondarySide], rect[2 + secondarySide], item.size[secondarySide]);
	    itemRect[primarySide] = itemRect[2 + primarySide] = rect[item.primary + primarySide];
	    itemRect[item.primary + primarySide] = rect[item.primary + primarySide] -= getShrink(item.primary, item.size[primarySide]);
	    itemRect[secondarySide] = secondary[0];
	    itemRect[2 + secondarySide] = secondary[1];
	    item.element.move(itemRect)
	}

	function Layout() {
	    this._targets = []
	}
	Layout.prototype = {
	    constructor: Layout,
	    dispose: function() {
	        this._targets = null
	    },
	    add: function(target) {
	        this._targets.push(target)
	    },
	    forward: function(targetRect) {
	        var i, rect = targetRect.slice(),
	            targets = createTargets(this._targets),
	            ii = targets.length,
	            cache = [];
	        for (i = 0; i < ii; ++i) {
	            if (processForward(targets[i], rect)) {
	                cache.push(targets[i])
	            }
	        }
	        this._cache = cache.reverse();
	        return rect
	    },
	    backward: function(targetRect) {
	        var i, rect = targetRect.slice(),
	            targets = this._cache,
	            ii = targets.length;
	        for (i = 0; i < ii; ++i) {
	            processBackward(targets[i], rect)
	        }
	        this._cache = null
	    }
	};

	function createTargets(targets) {
	    var i, layout, ii = targets.length,
	        collection = [];
	    for (i = 0; i < ii; ++i) {
	        layout = targets[i].layoutOptions();
	        if (layout) {
	            layout = normalizeLayoutOptions(layout);
	            layout.element = targets[i];
	            collection.push(layout)
	        }
	    }
	    processWeakItems(collection);
	    return collection
	}

	function processWeakItems(collection) {
	    var i, ii, j, weakItem, isProcessed = true;
	    while (isProcessed) {
	        isProcessed = false;
	        ii = collection.length;
	        for (i = 0; i < ii; ++i) {
	            if (collection[i].weak) {
	                weakItem = collection[i];
	                for (j = 0; j < ii; ++j) {
	                    if (i !== j && weakItem.side === collection[j].side && weakItem.primary === collection[j].primary) {
	                        collection[_min(i, j)] = makePair(collection[_min(i, j)], collection[_max(i, j)]);
	                        collection.splice(_max(i, j), 1);
	                        isProcessed = true;
	                        break
	                    }
	                }
	                if (isProcessed) {
	                    break
	                }
	            }
	        }
	    }
	}

	function makePair(first, second) {
	    return {
	        side: first.side,
	        primary: first.primary,
	        secondary: first.secondary === second.secondary ? first.secondary : bringToEdge(first.secondary) || bringToEdge(second.secondary),
	        element: new PairElement(first, second)
	    }
	}

	function PairElement(first, second) {
	    this._first = first;
	    this._second = second
	}
	PairElement.prototype.measure = function(targetSize) {
	    var secondSize, first = this._first,
	        second = this._second,
	        size = targetSize.slice(),
	        primarySide = first.side,
	        secondarySide = getConjugateSide(primarySide),
	        firstSize = first.element.measure(size.slice());
	    size[secondarySide] -= firstSize[secondarySide];
	    secondSize = second.element.measure(size.slice());
	    size[primarySide] = _max(firstSize[primarySide], secondSize[primarySide]);
	    if (first.secondary === second.secondary) {
	        size[secondarySide] = firstSize[secondarySide] + secondSize[secondarySide]
	    } else {
	        if (first.secondary === ALIGN_MIDDLE || second.secondary === ALIGN_MIDDLE) {
	            size[secondarySide] = targetSize[secondarySide] / 2 + (first.secondary === ALIGN_MIDDLE ? firstSize : secondSize)[secondarySide] / 2
	        } else {
	            size[secondarySide] = targetSize[secondarySide]
	        }
	    }
	    first.size = firstSize;
	    second.size = secondSize;
	    return size
	};
	PairElement.prototype.move = function(targetRect) {
	    var primary, secondary, rect, first = this._first,
	        second = this._second,
	        primarySide = first.side,
	        secondarySide = getConjugateSide(primarySide),
	        alignment = first.secondary === second.secondary ? bringToEdge(first.secondary) : first.secondary === ALIGN_MIDDLE ? getOppositeAlignment(bringToEdge(second.secondary)) : bringToEdge(first.secondary);
	    primary = getSlice(ALIGN_MIDDLE, targetRect[primarySide], targetRect[2 + primarySide], first.size[primarySide]);
	    secondary = getSlice(alignment, targetRect[secondarySide], targetRect[2 + secondarySide], first.size[secondarySide]);
	    rect = [];
	    rect[primarySide] = primary[0];
	    rect[2 + primarySide] = primary[1];
	    rect[secondarySide] = secondary[0];
	    rect[2 + secondarySide] = secondary[1];
	    first.element.move(rect);
	    primary = getSlice(ALIGN_MIDDLE, targetRect[primarySide], targetRect[2 + primarySide], second.size[primarySide]);
	    secondary = getSlice(getOppositeAlignment(alignment), targetRect[secondarySide], targetRect[2 + secondarySide], targetRect[2 + secondarySide] - targetRect[secondarySide] - first.size[secondarySide]);
	    secondary = getSlice(getOppositeAlignment(alignment), secondary[0], secondary[1], second.size[secondarySide]);
	    rect = [];
	    rect[primarySide] = primary[0];
	    rect[2 + primarySide] = primary[1];
	    rect[secondarySide] = secondary[0];
	    rect[2 + secondarySide] = secondary[1];
	    second.element.move(rect)
	};
	module.exports = Layout;


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/components/legend.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    vizUtils = __webpack_require__(291),
	    layoutElementModule = __webpack_require__(300),
	    _Number = Number,
	    _math = Math,
	    _round = _math.round,
	    _max = _math.max,
	    _min = _math.min,
	    _ceil = _math.ceil,
	    objectUtils = __webpack_require__(36),
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _isFunction = commonUtils.isFunction,
	    _enumParser = vizUtils.enumParser,
	    _normalizeEnum = vizUtils.normalizeEnum,
	    _extend = $.extend,
	    _each = $.each,
	    DEFAULT_MARGIN = 10,
	    DEFAULT_MARKER_HATCHING_WIDTH = 2,
	    DEFAULT_MARKER_HATCHING_STEP = 5,
	    CENTER = "center",
	    RIGHT = "right",
	    LEFT = "left",
	    TOP = "top",
	    BOTTOM = "bottom",
	    HORIZONTAL = "horizontal",
	    VERTICAL = "vertical",
	    INSIDE = "inside",
	    OUTSIDE = "outside",
	    NONE = "none",
	    HEIGHT = "height",
	    WIDTH = "width",
	    parseHorizontalAlignment = _enumParser([LEFT, CENTER, RIGHT]),
	    parseVerticalAlignment = _enumParser([TOP, BOTTOM]),
	    parseOrientation = _enumParser([VERTICAL, HORIZONTAL]),
	    parseItemTextPosition = _enumParser([LEFT, RIGHT, TOP, BOTTOM]),
	    parsePosition = _enumParser([OUTSIDE, INSIDE]),
	    parseItemsAlignment = _enumParser([LEFT, CENTER, RIGHT]);

	function getPattern(renderer, states, action, color) {
	    if (!states || !states[action]) {
	        return
	    }
	    var hatching, direction = states[action].hatching.direction,
	        colorFromAction = states[action].fill;
	    color = colorFromAction === NONE ? color : colorFromAction;
	    direction = !direction || direction === NONE ? RIGHT : direction;
	    hatching = _extend({}, states[action].hatching, {
	        direction: direction,
	        step: DEFAULT_MARKER_HATCHING_STEP,
	        width: DEFAULT_MARKER_HATCHING_WIDTH
	    });
	    return renderer.pattern(color, hatching)
	}

	function parseMargins(options) {
	    var margin = options.margin;
	    if (margin >= 0) {
	        margin = _Number(options.margin);
	        margin = {
	            top: margin,
	            bottom: margin,
	            left: margin,
	            right: margin
	        }
	    } else {
	        margin = {
	            top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,
	            bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,
	            left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,
	            right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN
	        }
	    }
	    options.margin = margin
	}

	function getSizeItem(options, markerSize, labelBBox) {
	    var width, height, defaultXMargin = 7,
	        defaultTopMargin = 4;
	    switch (options.itemTextPosition) {
	        case LEFT:
	        case RIGHT:
	            width = markerSize + defaultXMargin + labelBBox.width;
	            height = _max(markerSize, labelBBox.height);
	            break;
	        case TOP:
	        case BOTTOM:
	            width = _max(markerSize, labelBBox.width);
	            height = markerSize + defaultTopMargin + labelBBox.height
	    }
	    return {
	        width: width,
	        height: height
	    }
	}

	function calculateBBoxLabelAndMarker(markerBBox, labelBBox) {
	    var bBox = {};
	    bBox.left = _min(markerBBox.x, labelBBox.x);
	    bBox.top = _min(markerBBox.y, labelBBox.y);
	    bBox.right = _max(markerBBox.x + markerBBox.width, labelBBox.x + labelBBox.width);
	    bBox.bottom = _max(markerBBox.y + markerBBox.height, labelBBox.y + labelBBox.height);
	    return bBox
	}

	function applyMarkerState(id, idToIndexMap, items, stateName) {
	    var item = idToIndexMap && items[idToIndexMap[id]];
	    if (item) {
	        item.marker.attr(item.states[stateName])
	    }
	}

	function parseOptions(options, textField) {
	    if (!options) {
	        return null
	    }
	    parseMargins(options);
	    options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, RIGHT);
	    options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, options.horizontalAlignment === CENTER ? BOTTOM : TOP);
	    options.orientation = parseOrientation(options.orientation, options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);
	    options.itemTextPosition = parseItemTextPosition(options.itemTextPosition, options.orientation === HORIZONTAL ? BOTTOM : RIGHT);
	    options.position = parsePosition(options.position, OUTSIDE);
	    options.itemsAlignment = parseItemsAlignment(options.itemsAlignment, null);
	    options.hoverMode = _normalizeEnum(options.hoverMode);
	    options.customizeText = _isFunction(options.customizeText) ? options.customizeText : function() {
	        return this[textField]
	    };
	    options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : $.noop;
	    options._incidentOccurred = options._incidentOccurred || $.noop;
	    return options
	}

	function createSquareMarker(renderer, size) {
	    return renderer.rect(0, 0, size, size)
	}

	function createCircleMarker(renderer, size) {
	    return renderer.circle(size / 2, size / 2, size / 2)
	}

	function isCircle(type) {
	    return "circle" === _normalizeEnum(type)
	}

	function inRect(rect, x, y) {
	    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom
	}

	function checkLinesSize(lines, layoutOptions, countItems) {
	    var position = {
	            x: 0,
	            y: 0
	        },
	        maxMeasureLength = 0,
	        maxAltMeasureLength = 0;
	    _each(lines, function(i, line) {
	        var firstItem = line[0];
	        _each(line, function(_, item) {
	            var offset = item.offset || layoutOptions.spacing;
	            position[layoutOptions.direction] += item[layoutOptions.measure] + offset;
	            maxMeasureLength = _max(maxMeasureLength, position[layoutOptions.direction])
	        });
	        position[layoutOptions.direction] = 0;
	        position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + firstItem.altOffset || layoutOptions.altSpacing;
	        maxAltMeasureLength = _max(maxAltMeasureLength, position[layoutOptions.altDirection])
	    });
	    if (maxMeasureLength > layoutOptions.length) {
	        layoutOptions.countItem = decreaseItemCount(layoutOptions, countItems);
	        return true
	    }
	}

	function decreaseItemCount(layoutOptions, countItems) {
	    layoutOptions.altCountItem++;
	    return _ceil(countItems / layoutOptions.altCountItem)
	}

	function getLineLength(line, layoutOptions) {
	    var lineLength = 0;
	    _each(line, function(_, item) {
	        var offset = item.offset || layoutOptions.spacing;
	        lineLength += item[layoutOptions.measure] + offset
	    });
	    return lineLength
	}

	function getMaxLineLength(lines, layoutOptions) {
	    var maxLineLength = 0;
	    _each(lines, function(_, line) {
	        maxLineLength = _max(maxLineLength, getLineLength(line, layoutOptions))
	    });
	    return maxLineLength
	}

	function getInitPositionForDirection(line, layoutOptions, maxLineLength) {
	    var initPosition, lineLength = getLineLength(line, layoutOptions);
	    switch (layoutOptions.itemsAlignment) {
	        case RIGHT:
	            initPosition = maxLineLength - lineLength;
	            break;
	        case CENTER:
	            initPosition = (maxLineLength - lineLength) / 2;
	            break;
	        default:
	            initPosition = 0
	    }
	    return initPosition
	}

	function getPos(layoutOptions) {
	    switch (layoutOptions.itemTextPosition) {
	        case BOTTOM:
	            return {
	                horizontal: CENTER,
	                vertical: TOP
	            };
	        case TOP:
	            return {
	                horizontal: CENTER,
	                vertical: BOTTOM
	            };
	        case LEFT:
	            return {
	                horizontal: RIGHT,
	                vertical: CENTER
	            };
	        case RIGHT:
	            return {
	                horizontal: LEFT,
	                vertical: CENTER
	            }
	    }
	}

	function getLines(lines, layoutOptions, itemIndex) {
	    var tableLine = {};
	    if (itemIndex % layoutOptions.countItem === 0) {
	        if (layoutOptions.markerOffset) {
	            lines.push([], [])
	        } else {
	            lines.push([])
	        }
	    }
	    if (layoutOptions.markerOffset) {
	        tableLine.firstLine = lines[lines.length - 1];
	        tableLine.secondLine = lines[lines.length - 2]
	    } else {
	        tableLine.firstLine = tableLine.secondLine = lines[lines.length - 1]
	    }
	    return tableLine
	}

	function setMaxInLine(line, measure) {
	    var maxLineSize = 0;
	    _each(line, function(_, item) {
	        if (!item) {
	            return
	        }
	        maxLineSize = _max(maxLineSize, item[measure])
	    });
	    _each(line, function(_, item) {
	        if (!item) {
	            return
	        }
	        item[measure] = maxLineSize
	    })
	}

	function transpose(array) {
	    var i, j, width = array.length,
	        height = array[0].length,
	        transposeArray = [];
	    for (i = 0; i < height; i++) {
	        transposeArray[i] = [];
	        for (j = 0; j < width; j++) {
	            transposeArray[i][j] = array[j][i]
	        }
	    }
	    return transposeArray
	}

	function getAlign(position) {
	    switch (position) {
	        case TOP:
	        case BOTTOM:
	            return CENTER;
	        case LEFT:
	            return RIGHT;
	        case RIGHT:
	            return LEFT
	    }
	}
	var getMarkerCreator = function(type) {
	    return isCircle(type) ? createCircleMarker : createSquareMarker
	};
	var _Legend = exports.Legend = function(settings) {
	    var that = this;
	    that._renderer = settings.renderer;
	    that._legendGroup = settings.group;
	    that._backgroundClass = settings.backgroundClass;
	    that._itemGroupClass = settings.itemGroupClass;
	    that._textField = settings.textField;
	    that._getCustomizeObject = settings.getFormatObject;
	    that._patterns = []
	};
	var legendPrototype = _Legend.prototype = objectUtils.clone(layoutElementModule.LayoutElement.prototype);
	$.extend(legendPrototype, {
	    constructor: _Legend,
	    update: function(data, options) {
	        var that = this;
	        that._data = data;
	        that._boundingRect = {
	            width: 0,
	            height: 0,
	            x: 0,
	            y: 0
	        };
	        that._options = parseOptions(options, that._textField);
	        return that
	    },
	    draw: function(width, height) {
	        var that = this,
	            options = that._options,
	            renderer = that._renderer,
	            items = that._data;
	        this._size = {
	            width: width,
	            height: height
	        };
	        that.erase();
	        if (!(options && options.visible && items && items.length)) {
	            return that
	        }
	        that._insideLegendGroup = renderer.g().append(that._legendGroup);
	        that._createBackground();
	        that._createItems(that._getItemData());
	        that._locateElements(options);
	        that._finalUpdate(options);
	        if (that.getLayoutOptions().width > width || that.getLayoutOptions().height > height) {
	            that._options._incidentOccurred("W2104");
	            that.erase()
	        }
	        return that
	    },
	    probeDraw: function(width, height) {
	        return this.draw(width, height)
	    },
	    _createItems: function(items) {
	        var bBox, that = this,
	            options = that._options,
	            initMarkerSize = options.markerSize,
	            renderer = that._renderer,
	            i = 0,
	            maxBBoxHeight = 0,
	            createMarker = getMarkerCreator(options.markerShape || options.markerType);
	        that._markersId = {};
	        for (; i < that._patterns.length; i++) {
	            that._patterns[i].dispose()
	        }
	        that._patterns = [];
	        that._items = vizUtils.map(items, function(dataItem, i) {
	            var group = that._insideLegendGroup,
	                markerSize = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize),
	                stateOfDataItem = dataItem.states,
	                normalState = stateOfDataItem.normal,
	                normalStateFill = normalState.fill,
	                marker = createMarker(renderer, markerSize).attr({
	                    fill: normalStateFill || options.markerColor,
	                    opacity: normalState.opacity
	                }).append(group),
	                label = that._createLabel(dataItem, group),
	                hoverPattern = getPattern(renderer, stateOfDataItem, "hover", normalStateFill),
	                selectionPattern = getPattern(renderer, stateOfDataItem, "selection", normalStateFill),
	                states = {
	                    normal: {
	                        fill: normalStateFill
	                    }
	                },
	                labelBBox = label.getBBox();
	            if (hoverPattern) {
	                states.hovered = {
	                    fill: hoverPattern.id
	                };
	                that._patterns.push(hoverPattern)
	            }
	            if (selectionPattern) {
	                states.selected = {
	                    fill: selectionPattern.id
	                };
	                that._patterns.push(selectionPattern)
	            }
	            if (void 0 !== dataItem.id) {
	                that._markersId[dataItem.id] = i
	            }
	            bBox = getSizeItem(options, markerSize, labelBBox);
	            maxBBoxHeight = _max(maxBBoxHeight, bBox.height);
	            that._createHint(dataItem, label);
	            return {
	                label: label,
	                labelBBox: labelBBox,
	                group: group,
	                bBox: bBox,
	                marker: marker,
	                markerSize: markerSize,
	                tracker: {
	                    id: dataItem.id,
	                    argument: dataItem.argument
	                },
	                states: states,
	                itemTextPosition: options.itemTextPosition,
	                markerOffset: 0,
	                bBoxes: []
	            }
	        });
	        if (options.equalRowHeight) {
	            _each(that._items, function(_, item) {
	                item.bBox.height = maxBBoxHeight
	            })
	        }
	    },
	    _getItemData: function() {
	        var items = this._data;
	        if (this._options.inverted) {
	            items = items.slice().reverse()
	        }
	        return items
	    },
	    _finalUpdate: function(options) {
	        this._adjustBackgroundSettings(options);
	        this._setBoundingRect(options.margin)
	    },
	    erase: function() {
	        var that = this,
	            insideLegendGroup = that._insideLegendGroup;
	        insideLegendGroup && insideLegendGroup.dispose();
	        that._insideLegendGroup = that._x1 = that._x2 = that._y2 = that._y2 = null;
	        return that
	    },
	    _locateElements: function(locationOptions) {
	        this._moveInInitialValues();
	        this._locateRowsColumns(locationOptions)
	    },
	    _moveInInitialValues: function() {
	        var that = this;
	        that._legendGroup && that._legendGroup.move(0, 0);
	        that._background && that._background.attr({
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        })
	    },
	    applySelected: function(id) {
	        applyMarkerState(id, this._markersId, this._items, "selected");
	        return this
	    },
	    applyHover: function(id) {
	        applyMarkerState(id, this._markersId, this._items, "hovered");
	        return this
	    },
	    resetItem: function(id) {
	        applyMarkerState(id, this._markersId, this._items, "normal");
	        return this
	    },
	    _createLabel: function(data, group) {
	        var labelFormatObject = this._getCustomizeObject(data),
	            align = getAlign(this._options.itemTextPosition),
	            text = this._options.customizeText.call(labelFormatObject, labelFormatObject),
	            fontStyle = _isDefined(data.textOpacity) ? _extend({}, this._options.font, {
	                opacity: data.textOpacity
	            }) : this._options.font;
	        return this._renderer.text(text, 0, 0).css(vizUtils.patchFontOptions(fontStyle)).attr({
	            align: align
	        }).append(group)
	    },
	    _createHint: function(data, label) {
	        var labelFormatObject = this._getCustomizeObject(data),
	            text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);
	        if (_isDefined(text) && "" !== text) {
	            label.setTitle(text)
	        }
	    },
	    _createBackground: function() {
	        var that = this,
	            isInside = that._options.position === INSIDE,
	            color = that._options.backgroundColor,
	            fill = color || (isInside ? that._options.containerBackgroundColor : NONE);
	        if (that._options.border.visible || (isInside || color) && color !== NONE) {
	            that._background = that._renderer.rect(0, 0, 0, 0).attr({
	                fill: fill,
	                "class": that._backgroundClass
	            }).append(that._insideLegendGroup)
	        }
	    },
	    _locateRowsColumns: function() {
	        var lines, that = this,
	            iteration = 0,
	            layoutOptions = that._getItemsLayoutOptions(),
	            countItems = that._items.length;
	        do {
	            lines = [];
	            that._createLines(lines, layoutOptions);
	            that._alignLines(lines, layoutOptions);
	            iteration++
	        } while (checkLinesSize(lines, layoutOptions, countItems) && iteration < countItems);
	        that._applyItemPosition(lines, layoutOptions)
	    },
	    _createLines: function(lines, layoutOptions) {
	        _each(this._items, function(i, item) {
	            var firstItem, secondItem, tableLine = getLines(lines, layoutOptions, i),
	                labelBox = {
	                    width: item.labelBBox.width,
	                    height: item.labelBBox.height,
	                    element: item.label,
	                    bBox: item.labelBBox,
	                    pos: getPos(layoutOptions),
	                    itemIndex: i
	                },
	                markerBox = {
	                    width: item.markerSize,
	                    height: item.markerSize,
	                    element: item.marker,
	                    pos: {
	                        horizontal: CENTER,
	                        vertical: CENTER
	                    },
	                    bBox: {
	                        width: item.markerSize,
	                        height: item.markerSize,
	                        x: 0,
	                        y: 0
	                    },
	                    itemIndex: i
	                },
	                offsetDirection = layoutOptions.markerOffset ? "altOffset" : "offset";
	            if (layoutOptions.inverseLabelPosition) {
	                firstItem = labelBox;
	                secondItem = markerBox
	            } else {
	                firstItem = markerBox;
	                secondItem = labelBox
	            }
	            firstItem[offsetDirection] = layoutOptions.labelOffset;
	            tableLine.secondLine.push(firstItem);
	            tableLine.firstLine.push(secondItem)
	        })
	    },
	    _alignLines: function(lines, layoutOptions) {
	        var i, measure = layoutOptions.altMeasure;
	        _each(lines, processLine);
	        measure = layoutOptions.measure;
	        if (layoutOptions.itemsAlignment) {
	            if (layoutOptions.markerOffset) {
	                for (i = 0; i < lines.length;) {
	                    _each(transpose([lines[i++], lines[i++]]), processLine)
	                }
	            }
	        } else {
	            _each(transpose(lines), processLine)
	        }

	        function processLine(_, line) {
	            setMaxInLine(line, measure)
	        }
	    },
	    _applyItemPosition: function(lines, layoutOptions) {
	        var that = this,
	            position = {
	                x: 0,
	                y: 0
	            },
	            maxLineLength = getMaxLineLength(lines, layoutOptions);
	        _each(lines, function(i, line) {
	            var firstItem = line[0],
	                altOffset = firstItem.altOffset || layoutOptions.altSpacing;
	            position[layoutOptions.direction] = getInitPositionForDirection(line, layoutOptions, maxLineLength);
	            _each(line, function(_, item) {
	                var offset = item.offset || layoutOptions.spacing,
	                    wrap = new layoutElementModule.WrapperLayoutElement(item.element, item.bBox),
	                    itemBBox = new layoutElementModule.WrapperLayoutElement(null, {
	                        x: position.x,
	                        y: position.y,
	                        width: item.width,
	                        height: item.height
	                    }),
	                    itemLegend = that._items[item.itemIndex];
	                wrap.position({
	                    of: itemBBox,
	                    my: item.pos,
	                    at: item.pos
	                });
	                itemLegend.bBoxes.push(itemBBox);
	                position[layoutOptions.direction] += item[layoutOptions.measure] + offset
	            });
	            position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + altOffset
	        });
	        _each(this._items, function(_, item) {
	            var itemBBox = calculateBBoxLabelAndMarker(item.bBoxes[0].getLayoutOptions(), item.bBoxes[1].getLayoutOptions()),
	                horizontal = that._options.columnItemSpacing / 2,
	                vertical = that._options.rowItemSpacing / 2;
	            item.tracker.left = itemBBox.left - horizontal;
	            item.tracker.right = itemBBox.right + horizontal;
	            item.tracker.top = itemBBox.top - vertical;
	            item.tracker.bottom = itemBBox.bottom + vertical
	        })
	    },
	    _getItemsLayoutOptions: function() {
	        var that = this,
	            options = that._options,
	            orientation = options.orientation,
	            layoutOptions = {
	                itemsAlignment: options.itemsAlignment,
	                orientation: options.orientation
	            },
	            width = that._size.width - (that._background ? 2 * options.paddingLeftRight : 0),
	            height = that._size.height - (that._background ? 2 * options.paddingTopBottom : 0);
	        if (orientation === HORIZONTAL) {
	            layoutOptions.length = width;
	            layoutOptions.spacing = options.columnItemSpacing;
	            layoutOptions.direction = "x";
	            layoutOptions.measure = WIDTH;
	            layoutOptions.altMeasure = HEIGHT;
	            layoutOptions.altDirection = "y";
	            layoutOptions.altSpacing = options.rowItemSpacing;
	            layoutOptions.countItem = options.columnCount;
	            layoutOptions.altCountItem = options.rowCount;
	            layoutOptions.marginTextLabel = 4;
	            layoutOptions.labelOffset = 7;
	            if (options.itemTextPosition === BOTTOM || options.itemTextPosition === TOP) {
	                layoutOptions.labelOffset = 4;
	                layoutOptions.markerOffset = true
	            }
	        } else {
	            layoutOptions.length = height;
	            layoutOptions.spacing = options.rowItemSpacing;
	            layoutOptions.direction = "y";
	            layoutOptions.measure = HEIGHT;
	            layoutOptions.altMeasure = WIDTH;
	            layoutOptions.altDirection = "x";
	            layoutOptions.altSpacing = options.columnItemSpacing;
	            layoutOptions.countItem = options.rowCount;
	            layoutOptions.altCountItem = options.columnCount;
	            layoutOptions.marginTextLabel = 7;
	            layoutOptions.labelOffset = 4;
	            if (options.itemTextPosition === RIGHT || options.itemTextPosition === LEFT) {
	                layoutOptions.labelOffset = 7;
	                layoutOptions.markerOffset = true
	            }
	        }
	        if (!layoutOptions.countItem) {
	            if (layoutOptions.altCountItem) {
	                layoutOptions.countItem = _ceil(that._items.length / layoutOptions.altCountItem)
	            } else {
	                layoutOptions.countItem = that._items.length
	            }
	        }
	        if (options.itemTextPosition === TOP || options.itemTextPosition === LEFT) {
	            layoutOptions.inverseLabelPosition = true
	        }
	        layoutOptions.itemTextPosition = options.itemTextPosition;
	        layoutOptions.altCountItem = layoutOptions.altCountItem || _ceil(that._items.length / layoutOptions.countItem);
	        return layoutOptions
	    },
	    _adjustBackgroundSettings: function(locationOptions) {
	        if (!this._background) {
	            return
	        }
	        var border = locationOptions.border,
	            legendBox = this._insideLegendGroup.getBBox(),
	            backgroundSettings = {
	                x: _round(legendBox.x - locationOptions.paddingLeftRight),
	                y: _round(legendBox.y - locationOptions.paddingTopBottom),
	                width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,
	                height: _round(legendBox.height) + 2 * locationOptions.paddingTopBottom,
	                opacity: locationOptions.backgroundOpacity
	            };
	        if (border.visible && border.width && border.color && border.color !== NONE) {
	            backgroundSettings["stroke-width"] = border.width;
	            backgroundSettings.stroke = border.color;
	            backgroundSettings["stroke-opacity"] = border.opacity;
	            backgroundSettings.dashStyle = border.dashStyle;
	            backgroundSettings.rx = border.cornerRadius || 0;
	            backgroundSettings.ry = border.cornerRadius || 0
	        }
	        this._background.attr(backgroundSettings)
	    },
	    _setBoundingRect: function(margin) {
	        if (!this._insideLegendGroup) {
	            return
	        }
	        var box = this._insideLegendGroup.getBBox();
	        box.height += margin.top + margin.bottom;
	        box.width += margin.left + margin.right;
	        box.x -= margin.left;
	        box.y -= margin.top;
	        this._boundingRect = box
	    },
	    getActionCallback: function(point) {
	        var that = this;
	        if (that._options.visible) {
	            return function(act) {
	                that[act](point.index)
	            }
	        } else {
	            return $.noop
	        }
	    },
	    getLayoutOptions: function() {
	        var options = this._options,
	            boundingRect = this._insideLegendGroup ? this._boundingRect : {
	                width: 0,
	                height: 0,
	                x: 0,
	                y: 0
	            };
	        if (options) {
	            boundingRect.verticalAlignment = options.verticalAlignment;
	            boundingRect.horizontalAlignment = options.horizontalAlignment;
	            if (options.orientation === HORIZONTAL) {
	                boundingRect.cutLayoutSide = options.verticalAlignment;
	                boundingRect.cutSide = "vertical"
	            } else {
	                if (options.horizontalAlignment === CENTER) {
	                    boundingRect.cutLayoutSide = options.verticalAlignment;
	                    boundingRect.cutSide = "vertical"
	                } else {
	                    boundingRect.cutLayoutSide = options.horizontalAlignment;
	                    boundingRect.cutSide = "horizontal"
	                }
	            }
	            boundingRect.position = {
	                horizontal: options.horizontalAlignment,
	                vertical: options.verticalAlignment
	            };
	            return boundingRect
	        }
	        return null
	    },
	    shift: function(x, y) {
	        var that = this,
	            box = {};
	        if (that._insideLegendGroup) {
	            that._insideLegendGroup.attr({
	                translateX: x - that._boundingRect.x,
	                translateY: y - that._boundingRect.y
	            });
	            box = that._legendGroup.getBBox()
	        }
	        that._x1 = box.x;
	        that._y1 = box.y;
	        that._x2 = box.x + box.width;
	        that._y2 = box.y + box.height;
	        return that
	    },
	    getPosition: function() {
	        return this._options.position
	    },
	    coordsIn: function(x, y) {
	        return x >= this._x1 && x <= this._x2 && y >= this._y1 && y <= this._y2
	    },
	    getItemByCoord: function(x, y) {
	        var items = this._items,
	            legendGroup = this._insideLegendGroup;
	        x -= legendGroup.attr("translateX");
	        y -= legendGroup.attr("translateY");
	        for (var i = 0; i < items.length; i++) {
	            if (inRect(items[i].tracker, x, y)) {
	                return items[i].tracker
	            }
	        }
	        return null
	    },
	    dispose: function() {
	        var that = this;
	        that._legendGroup = that._insideLegendGroup = that._renderer = that._options = that._data = that._items = null;
	        return that
	    }
	});


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/layout_element.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _round = Math.round,
	    objectUtils = __webpack_require__(36),
	    defaultOffset = {
	        horizontal: 0,
	        vertical: 0
	    },
	    alignFactors = {
	        center: .5,
	        right: 1,
	        bottom: 1,
	        left: 0,
	        top: 0
	    };

	function LayoutElement(options) {
	    this._options = options
	}
	LayoutElement.prototype = {
	    constructor: LayoutElement,
	    position: function(options) {
	        var that = this,
	            ofBBox = options.of.getLayoutOptions(),
	            myBBox = that.getLayoutOptions(),
	            at = options.at,
	            my = options.my,
	            offset = options.offset || defaultOffset,
	            shiftX = -alignFactors[my.horizontal] * myBBox.width + ofBBox.x + alignFactors[at.horizontal] * ofBBox.width + parseInt(offset.horizontal),
	            shiftY = -alignFactors[my.vertical] * myBBox.height + ofBBox.y + alignFactors[at.vertical] * ofBBox.height + parseInt(offset.vertical);
	        that.shift(_round(shiftX), _round(shiftY))
	    },
	    getLayoutOptions: $.noop
	};

	function WrapperLayoutElement(renderElement, bBox) {
	    this._renderElement = renderElement;
	    this._cacheBBox = bBox
	}
	var wrapperLayoutElementPrototype = WrapperLayoutElement.prototype = objectUtils.clone(LayoutElement.prototype);
	wrapperLayoutElementPrototype.constructor = WrapperLayoutElement;
	wrapperLayoutElementPrototype.getLayoutOptions = function() {
	    return this._cacheBBox || this._renderElement.getBBox()
	};
	wrapperLayoutElementPrototype.shift = function(shiftX, shiftY) {
	    var bBox = this.getLayoutOptions();
	    this._renderElement.move(_round(shiftX - bBox.x), _round(shiftY - bBox.y))
	};
	exports.LayoutElement = LayoutElement;
	exports.WrapperLayoutElement = WrapperLayoutElement;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/components/data_validator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    STRING = "string",
	    NUMERIC = "numeric",
	    DATETIME = "datetime",
	    DISCRETE = "discrete",
	    SEMIDISCRETE = "semidiscrete",
	    CONTINUOUS = "continuous",
	    LOGARITHMIC = "logarithmic",
	    VALUE_TYPE = "valueType",
	    ARGUMENT_TYPE = "argumentType",
	    axisTypeParser = __webpack_require__(291).enumParser([STRING, NUMERIC, DATETIME]),
	    _getParser = __webpack_require__(302).getParser,
	    _isDefined = commonUtils.isDefined,
	    _isFunction = commonUtils.isFunction,
	    _isArray = commonUtils.isArray,
	    _isString = commonUtils.isString,
	    _isDate = commonUtils.isDate,
	    _isNumber = commonUtils.isNumber,
	    _isObject = commonUtils.isObject,
	    _each = $.each;

	function groupingValues(data, others, valueField, index) {
	    if (index >= 0) {
	        _each(data.slice(index), function(_, cell) {
	            if (_isDefined(cell[valueField])) {
	                others[valueField] += cell[valueField];
	                cell[valueField] = cell["original" + valueField] = void 0
	            }
	        })
	    }
	}

	function processGroup(_, group) {
	    group.valueType = group.valueAxisType = null;
	    _each(group.series, processSeries);
	    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)
	}

	function parseCategories(categories, parser) {
	    var newArray = [];
	    _each(categories, function(_, category) {
	        var parsedCategory = parser(category);
	        void 0 !== parsedCategory && newArray.push(parsedCategory)
	    });
	    return newArray
	}

	function parseAxisCategories(groupsData, parsers) {
	    var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories,
	        valueParser = parsers[1];
	    _each(groupsData.groups, function(_, valueGroup) {
	        var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;
	        if (categories) {
	            valueGroup.valueOptions.categories = parseCategories(categories, valueParser)
	        }
	    });
	    if (argumentCategories) {
	        groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])
	    }
	}

	function processSeries(_, series) {
	    series.updateDataType({})
	}

	function resetAxisTypes(_, axis) {
	    axis.resetTypes(ARGUMENT_TYPE)
	}

	function filterForLogAxis(val, field, incidentOccurred) {
	    if (val <= 0) {
	        incidentOccurred("E2004", [field]);
	        val = null
	    }
	    return val
	}

	function eigen(x) {
	    return x
	}

	function getType(unit, type) {
	    var result = type;
	    if (type === STRING || _isString(unit)) {
	        result = STRING
	    } else {
	        if (type === DATETIME || _isDate(unit)) {
	            result = DATETIME
	        } else {
	            if (_isNumber(unit)) {
	                result = NUMERIC
	            }
	        }
	    }
	    return result
	}

	function correctAxisType(type, axisType, hasCategories, incidentOccurred) {
	    if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {
	        incidentOccurred("E2002")
	    }
	    return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS
	}

	function validUnit(unit, field, incidentOccurred) {
	    if (unit) {
	        incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? "E2003" : "E2004", [field])
	    }
	}

	function createParserUnit(type, axisType, ignoreEmptyPoints, skipFields, incidentOccurred) {
	    var parser = type ? _getParser(type) : eigen,
	        filter = axisType === LOGARITHMIC ? filterForLogAxis : eigen;
	    return function(unit, field) {
	        var parseUnit = filter(parser(unit), field, incidentOccurred);
	        null === parseUnit && ignoreEmptyPoints && (parseUnit = void 0);
	        if (void 0 === parseUnit) {
	            skipFields[field] = (skipFields[field] || 0) + 1;
	            validUnit(unit, field, incidentOccurred)
	        }
	        return parseUnit
	    }
	}

	function prepareParsers(groupsData, skipFields, incidentOccurred) {
	    var sizeParser, valueParser, ignoreEmptyPoints, argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, false, skipFields, incidentOccurred),
	        categoryParsers = [argumentParser],
	        cache = {},
	        list = [];
	    _each(groupsData.groups, function(_, group) {
	        _each(group.series, function(_, series) {
	            ignoreEmptyPoints = series.getOptions().ignoreEmptyPoints;
	            valueParser = createParserUnit(group.valueType, group.valueAxisType, ignoreEmptyPoints, skipFields, incidentOccurred);
	            sizeParser = createParserUnit(NUMERIC, CONTINUOUS, ignoreEmptyPoints, skipFields, incidentOccurred);
	            cache[series.getArgumentField()] = argumentParser;
	            _each(series.getValueFields(), function(_, field) {
	                !categoryParsers[1] && (categoryParsers[1] = valueParser);
	                cache[field] = valueParser
	            });
	            if (series.getSizeField()) {
	                cache[series.getSizeField()] = sizeParser
	            }
	            if (series.getTagField()) {
	                cache[series.getTagField()] = eigen
	            }
	        })
	    });
	    _each(cache, function(field, parser) {
	        list.push([field, parser])
	    });
	    list.length && parseAxisCategories(groupsData, categoryParsers);
	    return list
	}

	function getParsedCell(cell, parsers) {
	    var i, field, value, ii = parsers.length,
	        obj = {};
	    for (i = 0; i < ii; ++i) {
	        field = parsers[i][0];
	        value = cell[field];
	        obj[field] = parsers[i][1](value, field);
	        obj["original" + field] = value
	    }
	    return obj
	}

	function parse(data, parsers) {
	    var i, parsedData = [],
	        ii = data.length;
	    parsedData.length = ii;
	    for (i = 0; i < ii; ++i) {
	        parsedData[i] = getParsedCell(data[i], parsers)
	    }
	    return parsedData
	}

	function findIndexByThreshold(data, valueField, threshold) {
	    var i, value, ii = data.length;
	    for (i = 0; i < ii; ++i) {
	        value = data[i][valueField];
	        if (_isDefined(value) && threshold > value) {
	            break
	        }
	    }
	    return i
	}

	function groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {
	    smallValuesGrouping = smallValuesGrouping || {};
	    var data, mode = smallValuesGrouping.mode,
	        others = {};
	    if (!mode || "none" === mode) {
	        return
	    }
	    others[argumentField] = String(smallValuesGrouping.groupName || "others");
	    others[valueField] = 0;
	    data = originalData.slice();
	    data.sort(function(a, b) {
	        var isA = _isDefined(a[valueField]) ? 1 : 0,
	            isB = _isDefined(b[valueField]) ? 1 : 0;
	        return isA && isB ? b[valueField] - a[valueField] : isB - isA
	    });
	    groupingValues(data, others, valueField, "smallValueThreshold" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);
	    others[valueField] && originalData.push(others)
	}

	function groupPieData(data, groupsData) {
	    var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0],
	        isPie = firstSeries && ("pie" === firstSeries.type || "doughnut" === firstSeries.type || "donut" === firstSeries.type);
	    if (!isPie) {
	        return
	    }
	    _each(groupsData.groups, function(_, group) {
	        _each(group.series, function(_, series) {
	            groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)
	        })
	    })
	}

	function addUniqueItemToCollection(item, collection, itemsHash) {
	    if (!itemsHash[item]) {
	        collection.push(item);
	        itemsHash[item] = true
	    }
	}

	function getUniqueArgumentFields(groupsData) {
	    var uniqueArgumentFields = [],
	        hash = {};
	    _each(groupsData.groups, function(_, group) {
	        _each(group.series, function(__, series) {
	            addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)
	        })
	    });
	    return uniqueArgumentFields
	}

	function discreteDataProcessing(data, groupsData, uniqueArgumentFields) {
	    if (groupsData.argumentAxisType !== DISCRETE) {
	        return
	    }
	    var userArgumentCategories = groupsData.argumentOptions ? groupsData.argumentOptions.categories : [],
	        categories = groupsData.categories = $.extend([], userArgumentCategories),
	        hash = {};
	    categories.length && _each(categories, function(_, currentCategory) {
	        hash[currentCategory] = true
	    });
	    _each(uniqueArgumentFields, function(_, field) {
	        _each(data, function(_, item) {
	            _isDefined(item[field]) && addUniqueItemToCollection(item[field], categories, hash)
	        })
	    })
	}

	function compareWithoutHash(argumentField) {
	    return function(a, b) {
	        var result = a[argumentField] - b[argumentField];
	        if (isNaN(result)) {
	            if (!a[argumentField]) {
	                return 1
	            }
	            if (!b[argumentField]) {
	                return -1
	            }
	            return 0
	        }
	        return result
	    }
	}

	function sortAndCollectCategories(data, groupsData, sortingMethodOption, uniqueArgumentFields) {
	    var getSortingMethod, itemsHash = {},
	        dataByArguments = {},
	        getSortMethodByType = function(sortingByHash, hash) {
	            return sortingByHash ? function(argumentField) {
	                return function(a, b) {
	                    return hash[a[argumentField]] - hash[b[argumentField]]
	                }
	            } : compareWithoutHash
	        };
	    if (_isFunction(sortingMethodOption)) {
	        data.sort(sortingMethodOption);
	        discreteDataProcessing(data, groupsData, uniqueArgumentFields)
	    } else {
	        discreteDataProcessing(data, groupsData, uniqueArgumentFields);
	        if (groupsData.categories) {
	            _each(groupsData.categories, function(index, value) {
	                itemsHash[value] = index
	            });
	            getSortingMethod = getSortMethodByType(true, itemsHash)
	        } else {
	            if (true === sortingMethodOption && groupsData.argumentType !== STRING) {
	                getSortingMethod = getSortMethodByType(false, itemsHash)
	            }
	        }
	    }
	    _each(uniqueArgumentFields, function(_, argumentField) {
	        var sortMethod, currentDataItem;
	        if (getSortingMethod) {
	            sortMethod = getSortingMethod(argumentField);
	            currentDataItem = data.slice().sort(sortMethod)
	        } else {
	            currentDataItem = data
	        }
	        dataByArguments[argumentField] = currentDataItem
	    });
	    return dataByArguments
	}

	function checkValueTypeOfGroup(group, cell) {
	    _each(group.series, function(_, series) {
	        _each(series.getValueFields(), function(_, field) {
	            group.valueType = getType(cell[field], group.valueType)
	        })
	    });
	    return group.valueType
	}

	function checkArgumentTypeOfGroup(series, cell, groupsData) {
	    _each(series, function(_, currentSeries) {
	        groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType)
	    });
	    return groupsData.argumentType
	}

	function checkType(data, groupsData, checkTypeForAllData) {
	    var groupsIndexes, groupsWithUndefinedValueType = [],
	        groupsWithUndefinedArgumentType = [],
	        argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);
	    _each(groupsData.groups, function(_, group) {
	        if (!group.series.length) {
	            return null
	        }
	        var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);
	        group.valueType = valueTypeGroup;
	        groupsData.argumentType = argumentTypeGroup;
	        !valueTypeGroup && groupsWithUndefinedValueType.push(group);
	        !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)
	    });
	    if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {
	        groupsIndexes = groupsWithUndefinedValueType.map(function(_, index) {
	            return index
	        });
	        _each(data, function(_, cell) {
	            var defineArg;
	            _each(groupsWithUndefinedValueType, function(groupIndex, group) {
	                if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {
	                    groupsIndexes.splice(groupIndex, 1)
	                }
	            });
	            if (!defineArg) {
	                _each(groupsWithUndefinedArgumentType, function(_, group) {
	                    defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)
	                })
	            }
	            if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {
	                return false
	            }
	        })
	    }
	}

	function checkAxisType(groupsData, userArgumentCategories, incidentOccurred) {
	    var argumentOptions = groupsData.argumentOptions || {},
	        argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);
	    _each(groupsData.groups, function(_, group) {
	        var valueOptions = group.valueOptions || {},
	            valueCategories = valueOptions.categories || [],
	            valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);
	        _each(group.series, function(_, series) {
	            var optionsSeries = {};
	            optionsSeries.argumentAxisType = argumentAxisType;
	            optionsSeries.valueAxisType = valueAxisType;
	            groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;
	            group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;
	            optionsSeries.argumentType = groupsData.argumentType;
	            optionsSeries.valueType = group.valueType;
	            optionsSeries.showZero = valueOptions.showZero;
	            series.updateDataType(optionsSeries)
	        });
	        group.valueAxisType = group.valueAxisType || valueAxisType;
	        if (group.valueAxis) {
	            group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);
	            group.valueAxis.validate(false)
	        }
	    });
	    groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;
	    if (groupsData.argumentAxes) {
	        _each(groupsData.argumentAxes, function(_, axis) {
	            axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);
	            axis.validate(true)
	        })
	    }
	}

	function verifyData(source, incidentOccurred) {
	    var i, ii, k, item, data = [],
	        hasError = !_isArray(source);
	    if (!hasError) {
	        for (i = 0, ii = source.length, k = 0; i < ii; ++i) {
	            item = source[i];
	            if (_isObject(item)) {
	                data[k++] = item
	            } else {
	                if (item) {
	                    hasError = true
	                }
	            }
	        }
	    }
	    if (hasError) {
	        incidentOccurred("E2001")
	    }
	    return data
	}

	function validateData(data, groupsData, incidentOccurred, options) {
	    var parsers, dataLength, dataByArgumentFields, skipFields = {},
	        argumentOptions = groupsData.argumentOptions,
	        userArgumentCategories = argumentOptions && argumentOptions.categories || [],
	        uniqueArgumentFields = getUniqueArgumentFields(groupsData);
	    data = verifyData(data, incidentOccurred);
	    groupsData.argumentType = groupsData.argumentAxisType = null;
	    _each(groupsData.groups, processGroup);
	    if (groupsData.argumentAxes) {
	        _each(groupsData.argumentAxes, resetAxisTypes)
	    }
	    checkType(data, groupsData, options.checkTypeForAllData);
	    checkAxisType(groupsData, userArgumentCategories, incidentOccurred);
	    if (options.convertToAxisDataType) {
	        parsers = prepareParsers(groupsData, skipFields, incidentOccurred);
	        data = parse(data, parsers)
	    }
	    groupPieData(data, groupsData);
	    dataByArgumentFields = sortAndCollectCategories(data, groupsData, options.sortingMethod, uniqueArgumentFields);
	    dataLength = data.length;
	    _each(skipFields, function(field, fieldValue) {
	        if (fieldValue === dataLength) {
	            incidentOccurred("W2002", [field])
	        }
	    });
	    return dataByArgumentFields
	}
	exports.validateData = validateData;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/components/parse_utils.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    isDefined = commonUtils.isDefined,
	    parsers = {
	        string: function(val) {
	            return isDefined(val) ? "" + val : val
	        },
	        numeric: function(val) {
	            if (!isDefined(val)) {
	                return val
	            }
	            var parsedVal = Number(val);
	            if (isNaN(parsedVal)) {
	                parsedVal = void 0
	            }
	            return parsedVal
	        },
	        datetime: function(val) {
	            if (!isDefined(val)) {
	                return val
	            }
	            var parsedVal, numVal = Number(val);
	            if (!isNaN(numVal)) {
	                parsedVal = new Date(numVal)
	            } else {
	                parsedVal = new Date(val)
	            }
	            if (isNaN(Number(parsedVal))) {
	                parsedVal = void 0
	            }
	            return parsedVal
	        }
	    };

	function correctValueType(type) {
	    return "numeric" === type || "datetime" === type || "string" === type ? type : ""
	}
	module.exports = {
	    correctValueType: correctValueType,
	    getParser: function(valueType) {
	        return parsers[correctValueType(valueType)] || $.noop
	    }
	};


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/base_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    seriesNS = {},
	    commonUtils = __webpack_require__(8),
	    pointModule = __webpack_require__(304),
	    _isDefined = commonUtils.isDefined,
	    vizUtils = __webpack_require__(291),
	    _map = vizUtils.map,
	    _each = $.each,
	    _extend = $.extend,
	    _isEmptyObject = $.isEmptyObject,
	    _normalizeEnum = vizUtils.normalizeEnum,
	    _Event = $.Event,
	    _noop = $.noop,
	    _inArray = $.inArray,
	    states = __webpack_require__(305).states,
	    scatterSeries = __webpack_require__(317),
	    lineSeries = __webpack_require__(319),
	    areaSeries = __webpack_require__(320),
	    barSeries = __webpack_require__(321),
	    rangeSeries = __webpack_require__(322),
	    bubbleSeries = __webpack_require__(323),
	    pieSeries = __webpack_require__(324),
	    financialSeries = __webpack_require__(325),
	    stackedSeries = __webpack_require__(326),
	    DISCRETE = "discrete",
	    SELECTED_STATE = states.selectedMark,
	    HOVER_STATE = states.hoverMark,
	    HOVER = states.hover,
	    NORMAL = states.normal,
	    SELECTION = states.selection,
	    APPLY_SELECTED = states.applySelected,
	    APPLY_HOVER = states.applyHover,
	    RESET_ITEM = states.resetItem,
	    NONE_MODE = "none",
	    INCLUDE_POINTS = "includepoints",
	    EXCLUDE_POINTS = "excludepoints",
	    NEAREST_POINT = "nearestpoint",
	    getEmptyBusinessRange = function() {
	        return {
	            arg: {},
	            val: {}
	        }
	    };

	function triggerEvent(element, event, point) {
	    element && element.trigger(event, point)
	}
	seriesNS.mixins = {
	    chart: {},
	    pie: {},
	    polar: {}
	};
	seriesNS.mixins.chart.scatter = scatterSeries.chart;
	seriesNS.mixins.polar.scatter = scatterSeries.polar;
	$.extend(seriesNS.mixins.pie, pieSeries);
	$.extend(seriesNS.mixins.chart, lineSeries.chart, areaSeries.chart, barSeries.chart, rangeSeries.chart, bubbleSeries.chart, financialSeries, stackedSeries.chart);
	$.extend(seriesNS.mixins.polar, lineSeries.polar, areaSeries.polar, barSeries.polar, rangeSeries.polar, bubbleSeries.polar, stackedSeries.polar);

	function includePointsMode(mode) {
	    return mode === INCLUDE_POINTS || "allseriespoints" === mode
	}

	function getLabelOptions(labelOptions, defaultColor) {
	    var opt = labelOptions || {},
	        labelFont = _extend({}, opt.font) || {},
	        labelBorder = opt.border || {},
	        labelConnector = opt.connector || {},
	        backgroundAttr = {
	            fill: opt.backgroundColor || defaultColor,
	            "stroke-width": labelBorder.visible ? labelBorder.width || 0 : 0,
	            stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : "none",
	            dashStyle: labelBorder.dashStyle
	        },
	        connectorAttr = {
	            stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : "none",
	            "stroke-width": labelConnector.visible ? labelConnector.width || 0 : 0
	        };
	    labelFont.color = "none" === opt.backgroundColor && "#ffffff" === _normalizeEnum(labelFont.color) && "inside" !== opt.position ? defaultColor : labelFont.color;
	    return {
	        alignment: opt.alignment,
	        format: opt.format,
	        argumentFormat: opt.argumentFormat,
	        precision: opt.precision,
	        argumentPrecision: opt.argumentPrecision,
	        percentPrecision: opt.percentPrecision,
	        customizeText: $.isFunction(opt.customizeText) ? opt.customizeText : void 0,
	        attributes: {
	            font: labelFont
	        },
	        visible: 0 !== labelFont.size ? opt.visible : false,
	        showForZeroValues: opt.showForZeroValues,
	        horizontalOffset: opt.horizontalOffset,
	        verticalOffset: opt.verticalOffset,
	        radialOffset: opt.radialOffset,
	        background: backgroundAttr,
	        position: opt.position,
	        connector: connectorAttr,
	        rotationAngle: opt.rotationAngle
	    }
	}

	function applyPointStyle(point, styleName) {
	    !point.isSelected() && !point.hasSelectedView && point.applyStyle(styleName)
	}

	function Series(renderSettings, options) {
	    var that = this;
	    that.fullState = 0;
	    that._extGroups = renderSettings;
	    that._renderer = renderSettings.renderer;
	    that._group = renderSettings.renderer.g().attr({
	        "class": "dxc-series"
	    });
	    that.updateOptions(options)
	}
	exports.Series = Series;
	exports.mixins = seriesNS.mixins;
	Series.prototype = {
	    constructor: Series,
	    _createLegendState: _noop,
	    getLegendStyles: function() {
	        return this._styles.legendStyles
	    },
	    _createStyles: function(options) {
	        var that = this,
	            mainSeriesColor = options.mainSeriesColor;
	        that._styles = {
	            normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),
	            hover: that._parseStyle(options.hoverStyle || {}, mainSeriesColor, mainSeriesColor),
	            selection: that._parseStyle(options.selectionStyle || {}, mainSeriesColor, mainSeriesColor),
	            legendStyles: {
	                normal: that._createLegendState(options, mainSeriesColor),
	                hover: that._createLegendState(options.hoverStyle || {}, mainSeriesColor),
	                selection: that._createLegendState(options.selectionStyle || {}, mainSeriesColor)
	            }
	        }
	    },
	    setClippingParams: function(baseId, wideId, forceClipping) {
	        this._paneClipRectID = baseId;
	        this._widePaneClipRectID = wideId;
	        this._forceClipping = forceClipping
	    },
	    applyClip: function() {
	        this._group.attr({
	            clipId: this._paneClipRectID
	        })
	    },
	    resetClip: function() {
	        this._group.attr({
	            clipId: null
	        })
	    },
	    getTagField: function() {
	        return this._options.tagField || "tag"
	    },
	    getValueFields: _noop,
	    getSizeField: _noop,
	    getArgumentField: _noop,
	    getPoints: function() {
	        return this._points
	    },
	    _createPoint: function(data, pointsArray, index) {
	        data.index = index;
	        var options, arg, pointByArgument, that = this,
	            point = pointsArray[index],
	            pointsByArgument = that.pointsByArgument;
	        if (that._checkData(data)) {
	            options = that._customizePoint(data) || that._getCreatingPointOptions(data);
	            if (point) {
	                point.update(data, options)
	            } else {
	                point = new pointModule.Point(that, data, options);
	                pointsArray.push(point)
	            }
	            arg = point.argument.valueOf();
	            pointByArgument = pointsByArgument[arg];
	            if (pointByArgument) {
	                pointByArgument.push(point)
	            } else {
	                pointsByArgument[arg] = [point]
	            }
	            return true
	        }
	    },
	    getRangeData: function(zoomArgs, calcIntervalFunction) {
	        return this._visible ? _extend(true, {}, this._getRangeData(zoomArgs, calcIntervalFunction)) : getEmptyBusinessRange()
	    },
	    _deleteGroup: function(groupName) {
	        var group = this[groupName];
	        if (group) {
	            group.dispose();
	            this[groupName] = null
	        }
	    },
	    _saveOldAnimationMethods: function() {
	        var that = this;
	        that._oldClearingAnimation = that._clearingAnimation;
	        that._oldUpdateElement = that._updateElement;
	        that._oldGetAffineCoordOptions = that._getAffineCoordOptions
	    },
	    _deleteOldAnimationMethods: function() {
	        this._oldClearingAnimation = null;
	        this._oldUpdateElement = null;
	        this._oldGetAffineCoordOptions = null
	    },
	    updateOptions: function(newOptions) {
	        var that = this,
	            widgetType = newOptions.widgetType,
	            oldType = that.type,
	            newType = newOptions.type;
	        that.type = newType && _normalizeEnum(newType.toString());
	        if (!that._checkType(widgetType) || that._checkPolarBarType(widgetType, newOptions)) {
	            that.dispose();
	            that.isUpdated = false;
	            return
	        }
	        if (oldType !== that.type) {
	            that._firstDrawing = true;
	            that._saveOldAnimationMethods();
	            that._resetType(oldType, widgetType);
	            that._setType(that.type, widgetType)
	        }
	        that._options = newOptions;
	        that._pointOptions = null;
	        that._deletePatterns();
	        that.name = newOptions.name;
	        that.pane = newOptions.pane;
	        that.axis = newOptions.axis;
	        that.tag = newOptions.tag;
	        that._createStyles(newOptions);
	        that._updateOptions(newOptions);
	        that._visible = newOptions.visible;
	        that.isUpdated = true;
	        that._createGroups()
	    },
	    _disposePoints: function(points) {
	        _each(points || [], function(_, p) {
	            p.dispose()
	        })
	    },
	    _correctPointsLength: function(length, points) {
	        this._disposePoints(this._oldPoints);
	        this._oldPoints = points.splice(length, points.length)
	    },
	    getErrorBarRangeCorrector: _noop,
	    updateDataType: function(settings) {
	        var that = this;
	        that.argumentType = settings.argumentType;
	        that.valueType = settings.valueType;
	        that.argumentAxisType = settings.argumentAxisType;
	        that.valueAxisType = settings.valueAxisType;
	        that.showZero = settings.showZero;
	        return that
	    },
	    getOptions: function() {
	        return this._options
	    },
	    _resetRangeData: function() {
	        this._rangeData = getEmptyBusinessRange()
	    },
	    updateData: function(data) {
	        var curPoint, that = this,
	            points = that._originalPoints || [],
	            lastPointIndex = 0,
	            options = that._options,
	            i = 0,
	            len = data.length,
	            lastPoint = null,
	            rangeCorrector = that.getErrorBarRangeCorrector();
	        that.pointsByArgument = {};
	        that._resetRangeData();
	        if (data && data.length) {
	            that._canRenderCompleteHandle = true
	        }
	        that._beginUpdateData(data);
	        while (i < len) {
	            if (that._createPoint(that._getPointData(data[i], options), points, lastPointIndex)) {
	                curPoint = points[lastPointIndex];
	                that._processRange(curPoint, lastPoint, rangeCorrector);
	                lastPoint = curPoint;
	                lastPointIndex++
	            }
	            i++
	        }
	        that._disposePoints(that._aggregatedPoints);
	        that._aggregatedPoints = null;
	        that._points = that._originalPoints = points;
	        that._correctPointsLength(lastPointIndex, points);
	        that._endUpdateData()
	    },
	    getTemplateFields: function() {
	        return this.getValueFields().concat(this.getTagField(), this.getSizeField()).map(function(field) {
	            return {
	                templateField: field + this.name,
	                originalField: field
	            }
	        }, this)
	    },
	    resamplePoints: function(argTranslator, min, max) {
	        var categories, discreteMin, discreteMax, count, tickInterval, that = this,
	            sizePoint = that._getPointSize(),
	            pointsLength = that.getAllPoints().length,
	            isDiscrete = that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE,
	            businessRange = argTranslator.getBusinessRange(),
	            minMaxDefined = _isDefined(min) && _isDefined(max);
	        if (pointsLength && pointsLength > 1) {
	            count = argTranslator.canvasLength / sizePoint;
	            count = count <= 1 ? 1 : count;
	            if (isDiscrete) {
	                if (that.argumentAxisType === DISCRETE) {
	                    categories = businessRange.categories;
	                    discreteMin = _inArray(min, categories);
	                    discreteMax = _inArray(max, categories);
	                    if (discreteMin !== -1 && discreteMax !== -1) {
	                        categories = categories.slice(discreteMin, discreteMax + 1)
	                    }
	                    pointsLength = categories.length
	                }
	                tickInterval = Math.ceil(pointsLength / count)
	            } else {
	                tickInterval = (minMaxDefined ? max - min : businessRange.maxVisible - businessRange.minVisible) / count
	            }
	            that._points = that._resample(tickInterval, min - tickInterval, max + tickInterval, minMaxDefined)
	        }
	    },
	    _removeOldSegments: function(startIndex) {
	        var that = this;
	        _each(that._graphics.splice(startIndex, that._graphics.length) || [], function(_, elem) {
	            that._removeElement(elem)
	        });
	        if (that._trackers) {
	            _each(that._trackers.splice(startIndex, that._trackers.length) || [], function(_, elem) {
	                elem.remove()
	            })
	        }
	    },
	    draw: function(translators, animationEnabled, hideLayoutLabels, legendCallback) {
	        var drawComplete, that = this;
	        if (that._oldClearingAnimation && animationEnabled && that._firstDrawing) {
	            drawComplete = function() {
	                that._draw(translators, true, hideLayoutLabels)
	            };
	            that._oldClearingAnimation(translators, drawComplete)
	        } else {
	            that._draw(translators, animationEnabled, hideLayoutLabels, legendCallback)
	        }
	    },
	    _draw: function(translators, animationEnabled, hideLayoutLabels, legendCallback) {
	        var groupForPoint, that = this,
	            points = that._points || [],
	            segment = [],
	            segmentCount = 0,
	            firstDrawing = that._firstDrawing,
	            closeSegment = points[0] && points[0].hasValue() && that._options.closed;
	        that._graphics = that._graphics || [];
	        that._prepareSeriesToDrawing();
	        if (!that._visible) {
	            animationEnabled = false;
	            that._group.remove();
	            return
	        }
	        that._appendInGroup();
	        that.translators = translators;
	        that._applyVisibleArea();
	        that._setGroupsSettings(animationEnabled, firstDrawing);
	        that._segments = [];
	        that._drawnPoints = [];
	        that._firstDrawing = points.length ? false : true;
	        groupForPoint = {
	            markers: that._markersGroup,
	            errorBars: that._errorBarGroup
	        };
	        _each(points, function(i, p) {
	            p.translate(translators);
	            if (p.hasValue()) {
	                that._drawPoint({
	                    point: p,
	                    groups: groupForPoint,
	                    hasAnimation: animationEnabled,
	                    firstDrawing: firstDrawing,
	                    legendCallback: legendCallback
	                });
	                segment.push(p)
	            } else {
	                if (segment.length) {
	                    that._drawSegment(segment, animationEnabled, segmentCount++);
	                    segment = []
	                }
	            }
	        });
	        segment.length && that._drawSegment(segment, animationEnabled, segmentCount++, closeSegment);
	        that._removeOldSegments(segmentCount);
	        that._defaultSegments = that._generateDefaultSegments();
	        hideLayoutLabels && that.hideLabels();
	        animationEnabled && that._animate(firstDrawing);
	        if (that.isSelected()) {
	            that._changeStyle(legendCallback, APPLY_SELECTED)
	        } else {
	            if (that.isHovered()) {
	                that._changeStyle(legendCallback, APPLY_HOVER)
	            }
	        }
	    },
	    _setLabelGroupSettings: function(animationEnabled) {
	        var settings = {
	            "class": "dxc-labels"
	        };
	        this._applyElementsClipRect(settings);
	        this._applyClearingSettings(settings);
	        animationEnabled && (settings.opacity = .001);
	        this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup)
	    },
	    _checkType: function(widgetType) {
	        return !!seriesNS.mixins[widgetType][this.type]
	    },
	    _checkPolarBarType: function(widgetType, options) {
	        return "polar" === widgetType && options.spiderWidget && this.type.indexOf("bar") !== -1
	    },
	    _resetType: function(seriesType, widgetType) {
	        var methodName, methods;
	        if (seriesType) {
	            methods = seriesNS.mixins[widgetType][seriesType];
	            for (methodName in methods) {
	                delete this[methodName]
	            }
	        }
	    },
	    _setType: function(seriesType, widgetType) {
	        var methodName, methods = seriesNS.mixins[widgetType][seriesType];
	        for (methodName in methods) {
	            this[methodName] = methods[methodName]
	        }
	    },
	    setSelectedState: function(state, mode, legendCallback) {
	        var that = this;
	        that.lastSelectionMode = _normalizeEnum(mode || that._options.selectionMode);
	        if (state && !that.isSelected()) {
	            that.fullState = that.fullState | SELECTED_STATE;
	            that._nearestPoint && applyPointStyle(that._nearestPoint, NORMAL);
	            that._nearestPoint = null;
	            that._changeStyle(legendCallback, APPLY_SELECTED)
	        } else {
	            if (!state && that.isSelected()) {
	                that.fullState = that.fullState & ~SELECTED_STATE;
	                if (that.isHovered()) {
	                    that._changeStyle(legendCallback, APPLY_HOVER, SELECTION)
	                } else {
	                    that._changeStyle(legendCallback, RESET_ITEM)
	                }
	            }
	        }
	    },
	    setHoverState: function(state, mode, legendCallback) {
	        var that = this;
	        that.lastHoverMode = _normalizeEnum(mode || that._options.hoverMode);
	        if (state && !that.isHovered()) {
	            that.fullState = that.fullState | HOVER_STATE;
	            !that.isSelected() && that._changeStyle(legendCallback, APPLY_HOVER)
	        } else {
	            if (!state && that.isHovered()) {
	                that._nearestPoint = null;
	                that.fullState = that.fullState & ~HOVER_STATE;
	                !that.isSelected() && that._changeStyle(legendCallback, RESET_ITEM)
	            }
	        }
	    },
	    setHoverView: function() {
	        if (this._canChangeView()) {
	            this._applyStyle(this._styles.hover);
	            return this
	        }
	        return null
	    },
	    releaseHoverView: function() {
	        this._canChangeView() && this._applyStyle(this._styles.normal)
	    },
	    isFullStackedSeries: function() {
	        return 0 === this.type.indexOf("fullstacked")
	    },
	    isStackedSeries: function() {
	        return 0 === this.type.indexOf("stacked")
	    },
	    isFinancialSeries: function() {
	        return "stock" === this.type || "candlestick" === this.type
	    },
	    _canChangeView: function() {
	        return !this.isSelected() && _normalizeEnum(this._options.hoverMode) !== NONE_MODE
	    },
	    _changeStyle: function(legendCallBack, legendAction, prevStyle) {
	        var pointStyle, that = this,
	            style = that._calcStyle(prevStyle);
	        if (style.mode === NONE_MODE) {
	            return
	        }
	        legendCallBack(legendAction);
	        if (includePointsMode(style.mode)) {
	            pointStyle = style.pointStyle;
	            _each(that._points || [], function(_, p) {
	                applyPointStyle(p, pointStyle)
	            })
	        }
	        that._applyStyle(style.series)
	    },
	    _calcStyle: function(prevStyle) {
	        var result, that = this,
	            styles = that._styles,
	            pointNormalState = false;
	        switch (that.fullState) {
	            case 0:
	                result = {
	                    pointStyle: NORMAL,
	                    mode: INCLUDE_POINTS,
	                    series: styles.normal
	                };
	                break;
	            case 1:
	                pointNormalState = prevStyle && that.lastHoverMode === EXCLUDE_POINTS || that.lastHoverMode === NEAREST_POINT && includePointsMode(that.lastSelectionMode);
	                result = {
	                    pointStyle: pointNormalState ? NORMAL : HOVER,
	                    mode: pointNormalState ? INCLUDE_POINTS : that.lastHoverMode,
	                    series: styles.hover
	                };
	                break;
	            case 2:
	                result = {
	                    pointStyle: SELECTION,
	                    mode: that.lastSelectionMode,
	                    series: styles.selection
	                };
	                break;
	            case 3:
	                pointNormalState = that.lastSelectionMode === EXCLUDE_POINTS && includePointsMode(that.lastHoverMode);
	                result = {
	                    pointStyle: pointNormalState ? NORMAL : SELECTION,
	                    mode: pointNormalState ? INCLUDE_POINTS : that.lastSelectionMode,
	                    series: styles.selection
	                }
	        }
	        return result
	    },
	    updateHover: function(x, y) {
	        var that = this,
	            currentNearestPoint = that._nearestPoint,
	            point = that.isHovered() && that.lastHoverMode === NEAREST_POINT && that.getNeighborPoint(x, y);
	        if (point !== currentNearestPoint && !that.isSelected()) {
	            currentNearestPoint && applyPointStyle(currentNearestPoint, NORMAL);
	            if (point) {
	                applyPointStyle(point, HOVER);
	                that._nearestPoint = point
	            }
	        }
	    },
	    _getMainAxisName: function() {
	        return this._options.rotated ? "X" : "Y"
	    },
	    areLabelsVisible: function() {
	        return !_isDefined(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount
	    },
	    getLabelVisibility: function() {
	        return this.areLabelsVisible() && this._options.label && this._options.label.visible
	    },
	    _customizePoint: function(pointData) {
	        var customizeObject, pointOptions, customLabelOptions, customOptions, useLabelCustomOptions, usePointCustomOptions, that = this,
	            options = that._options,
	            customizePoint = options.customizePoint,
	            customizeLabel = options.customizeLabel;
	        if (customizeLabel && customizeLabel.call) {
	            customizeObject = _extend({
	                seriesName: that.name
	            }, pointData);
	            customizeObject.series = that;
	            customLabelOptions = customizeLabel.call(customizeObject, customizeObject);
	            useLabelCustomOptions = customLabelOptions && !_isEmptyObject(customLabelOptions);
	            customLabelOptions = useLabelCustomOptions ? _extend(true, {}, options.label, customLabelOptions) : null
	        }
	        if (customizePoint && customizePoint.call) {
	            customizeObject = customizeObject || _extend({
	                seriesName: that.name
	            }, pointData);
	            customizeObject.series = that;
	            customOptions = customizePoint.call(customizeObject, customizeObject);
	            usePointCustomOptions = customOptions && !_isEmptyObject(customOptions)
	        }
	        if (useLabelCustomOptions || usePointCustomOptions) {
	            pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label, pointData);
	            pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;
	            pointOptions.styles.usePointCustomOptions = usePointCustomOptions
	        }
	        return pointOptions
	    },
	    show: function() {
	        if (!this._visible) {
	            this._changeVisibility(true)
	        }
	    },
	    hide: function() {
	        if (this._visible) {
	            this._changeVisibility(false)
	        }
	    },
	    _changeVisibility: function(visibility) {
	        var that = this;
	        that._visible = that._options.visible = visibility;
	        that._updatePointsVisibility();
	        that.hidePointTooltip();
	        that._options.visibilityChanged()
	    },
	    _updatePointsVisibility: _noop,
	    hideLabels: function() {
	        _each(this._points, function(_, point) {
	            point._label.hide()
	        })
	    },
	    _parsePointOptions: function(pointOptions, labelOptions, data) {
	        var that = this,
	            options = that._options,
	            styles = that._createPointStyles(pointOptions, data),
	            parsedOptions = _extend(true, {}, pointOptions, {
	                type: options.type,
	                tag: that.tag,
	                rotated: options.rotated,
	                styles: styles,
	                widgetType: options.widgetType,
	                visibilityChanged: options.visibilityChanged
	            });
	        parsedOptions.label = getLabelOptions(labelOptions, styles.normal.fill);
	        if (that.areErrorBarsVisible()) {
	            parsedOptions.errorBars = options.valueErrorBar
	        }
	        return parsedOptions
	    },
	    _preparePointOptions: function(customOptions) {
	        var point = this._getOptionsForPoint();
	        return customOptions ? _extend(true, {}, point, customOptions) : point
	    },
	    _getMarkerGroupOptions: function() {
	        return _extend(false, {}, this._getOptionsForPoint(), {
	            hoverStyle: {},
	            selectionStyle: {}
	        })
	    },
	    _resample: function(ticksInterval, min, max, isDefinedMinMax) {
	        var pointData, minTick, that = this,
	            fusionPoints = [],
	            nowIndexTicks = 0,
	            lastPointIndex = 0,
	            state = 0,
	            originalPoints = that.getAllPoints();

	        function addFirstFusionPoint(point) {
	            fusionPoints.push(point);
	            minTick = point.argument;
	            if (isDefinedMinMax) {
	                if (point.argument < min) {
	                    state = 1
	                } else {
	                    if (point.argument > max) {
	                        state = 2
	                    } else {
	                        state = 0
	                    }
	                }
	            }
	        }
	        if (that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE) {
	            return _map(originalPoints, function(point, index) {
	                if (index % ticksInterval === 0) {
	                    return point
	                }
	                point.setInvisibility();
	                return null
	            })
	        }
	        that._aggregatedPoints = that._aggregatedPoints || [];
	        _each(originalPoints, function(_, point) {
	            point.setInvisibility();
	            if (!fusionPoints.length) {
	                addFirstFusionPoint(point)
	            } else {
	                if (!state && Math.abs(minTick - point.argument) < ticksInterval) {
	                    fusionPoints.push(point)
	                } else {
	                    if (!(1 === state && point.argument < min) && !(2 === state && point.argument > max)) {
	                        pointData = that._fusionPoints(fusionPoints, minTick, nowIndexTicks);
	                        nowIndexTicks++;
	                        if (that._createPoint(pointData, that._aggregatedPoints, lastPointIndex)) {
	                            lastPointIndex++
	                        }
	                        fusionPoints = [];
	                        addFirstFusionPoint(point)
	                    }
	                }
	            }
	        });
	        if (fusionPoints.length) {
	            pointData = that._fusionPoints(fusionPoints, minTick, nowIndexTicks);
	            if (that._createPoint(pointData, that._aggregatedPoints, lastPointIndex)) {
	                lastPointIndex++
	            }
	        }
	        that._correctPointsLength(lastPointIndex, that._aggregatedPoints);
	        that._endUpdateData();
	        return that._aggregatedPoints
	    },
	    canRenderCompleteHandle: function() {
	        var result = this._canRenderCompleteHandle;
	        delete this._canRenderCompleteHandle;
	        return !!result
	    },
	    isHovered: function() {
	        return !!(1 & this.fullState)
	    },
	    isSelected: function() {
	        return !!(2 & this.fullState)
	    },
	    isVisible: function() {
	        return this._visible
	    },
	    getAllPoints: function() {
	        return (this._originalPoints || []).slice()
	    },
	    getPointByPos: function(pos) {
	        return (this._points || [])[pos]
	    },
	    getVisiblePoints: function() {
	        return (this._drawnPoints || []).slice()
	    },
	    setPointHoverState: function(data) {
	        var point = data.point;
	        if (data.setState) {
	            point.fullState |= HOVER_STATE
	        }
	        if (!(this.isSelected() && includePointsMode(this.lastSelectionMode)) && !point.isSelected() && !point.hasSelectedView) {
	            point.applyStyle(HOVER)
	        }
	    },
	    releasePointHoverState: function(data) {
	        var that = this,
	            point = data.point;
	        if (data.setState) {
	            point.fullState &= ~HOVER_STATE
	        }
	        if (!(that.isSelected() && includePointsMode(that.lastSelectionMode)) && !point.isSelected() && !point.hasSelectedView) {
	            if (!(that.isHovered() && includePointsMode(that.lastHoverMode)) || that.isSelected() && that.lastSelectionMode === EXCLUDE_POINTS) {
	                point.applyStyle(NORMAL)
	            }
	        }
	        point.releaseHoverState()
	    },
	    setPointSelectedState: function(data) {
	        var point = data.point;
	        if (data.setState) {
	            point.fullState |= SELECTED_STATE
	        } else {
	            point.hasSelectedView = true
	        }
	        point.applyStyle(SELECTION)
	    },
	    releasePointSelectedState: function(data) {
	        var pointStyle, that = this,
	            point = data.point;
	        if (data.setState) {
	            point.fullState &= ~SELECTED_STATE
	        } else {
	            point.hasSelectedView = false
	        }
	        if (that.isHovered() && includePointsMode(that.lastHoverMode) || point.isHovered()) {
	            pointStyle = HOVER
	        } else {
	            if (that.isSelected() && includePointsMode(that.lastSelectionMode)) {
	                pointStyle = SELECTION
	            } else {
	                pointStyle = NORMAL
	            }
	        }
	        point.applyStyle(pointStyle)
	    },
	    selectPoint: function(point) {
	        triggerEvent(this._extGroups.seriesGroup, new _Event("selectpoint"), point)
	    },
	    deselectPoint: function(point) {
	        triggerEvent(this._extGroups.seriesGroup, new _Event("deselectpoint"), point)
	    },
	    showPointTooltip: function(point) {
	        triggerEvent(this._extGroups.seriesGroup, new _Event("showpointtooltip"), point)
	    },
	    hidePointTooltip: function(point) {
	        triggerEvent(this._extGroups.seriesGroup, new _Event("hidepointtooltip"), point)
	    },
	    select: function() {
	        var that = this;
	        triggerEvent(that._extGroups.seriesGroup, new _Event("selectseries", {
	            target: that
	        }), that._options.selectionMode);
	        that._group.toForeground()
	    },
	    clearSelection: function() {
	        var that = this;
	        triggerEvent(that._extGroups.seriesGroup, new _Event("deselectseries", {
	            target: that
	        }), that._options.selectionMode)
	    },
	    getPointsByArg: function(arg) {
	        return this.pointsByArgument[arg.valueOf()] || []
	    },
	    _deletePoints: function() {
	        var that = this;
	        that._disposePoints(that._originalPoints);
	        that._disposePoints(that._aggregatedPoints);
	        that._disposePoints(that._oldPoints);
	        that._points = that._oldPoints = that._aggregatedPoints = that._originalPoints = that._drawnPoints = null
	    },
	    _deletePatterns: function() {
	        _each(this._patterns || [], function(_, pattern) {
	            pattern && pattern.dispose()
	        });
	        this._patterns = []
	    },
	    _deleteTrackers: function() {
	        var that = this;
	        _each(that._trackers || [], function(_, tracker) {
	            tracker.remove()
	        });
	        that._trackersGroup && that._trackersGroup.dispose();
	        that._trackers = that._trackersGroup = null
	    },
	    dispose: function() {
	        var that = this;
	        that._deletePoints();
	        that._group.dispose();
	        that._labelsGroup && that._labelsGroup.dispose();
	        that._errorBarGroup && that._errorBarGroup.dispose();
	        that._deletePatterns();
	        that._deleteTrackers();
	        that._group = that._extGroups = that._markersGroup = that._elementsGroup = that._bordersGroup = that._labelsGroup = that._errorBarGroup = that._graphics = that._rangeData = that._renderer = that.translators = that._styles = that._options = that._pointOptions = that._drawnPoints = that._aggregatedPoints = that.pointsByArgument = that._segments = that._prevSeries = that._patterns = null
	    },
	    correctPosition: _noop,
	    drawTrackers: _noop,
	    getNeighborPoint: _noop,
	    areErrorBarsVisible: _noop,
	    getColor: function() {
	        return this.getLegendStyles().normal.fill
	    },
	    getOpacity: function() {
	        return this._options.opacity
	    },
	    getStackName: function() {
	        return "stackedbar" === this.type || "fullstackedbar" === this.type ? this._stackName : null
	    },
	    getPointByCoord: function(x, y) {
	        var point = this.getNeighborPoint(x, y);
	        return point && point.coordsIn(x, y) ? point : null
	    }
	};


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/base_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    mixins = {},
	    statesConsts = __webpack_require__(305).states,
	    symbolPoint = __webpack_require__(306),
	    barPoint = __webpack_require__(309),
	    bubblePoint = __webpack_require__(310),
	    piePoint = __webpack_require__(311),
	    rangeSymbolPoint = __webpack_require__(312),
	    rangeBarPoint = __webpack_require__(313),
	    candlestickPoint = __webpack_require__(314),
	    stockPoint = __webpack_require__(315),
	    polarPoints = __webpack_require__(316),
	    _each = $.each,
	    _extend = $.extend,
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _noop = $.noop,
	    SYMBOL_POINT = "symbolPoint",
	    POLAR_SYMBOL_POINT = "polarSymbolPoint",
	    BAR_POINT = "barPoint",
	    POLAR_BAR_POINT = "polarBarPoint",
	    PIE_POINT = "piePoint",
	    pointTypes = {
	        chart: {
	            scatter: SYMBOL_POINT,
	            line: SYMBOL_POINT,
	            spline: SYMBOL_POINT,
	            stepline: SYMBOL_POINT,
	            stackedline: SYMBOL_POINT,
	            fullstackedline: SYMBOL_POINT,
	            stackedspline: SYMBOL_POINT,
	            fullstackedspline: SYMBOL_POINT,
	            stackedsplinearea: SYMBOL_POINT,
	            fullstackedsplinearea: SYMBOL_POINT,
	            area: SYMBOL_POINT,
	            splinearea: SYMBOL_POINT,
	            steparea: SYMBOL_POINT,
	            stackedarea: SYMBOL_POINT,
	            fullstackedarea: SYMBOL_POINT,
	            rangearea: "rangeSymbolPoint",
	            bar: BAR_POINT,
	            stackedbar: BAR_POINT,
	            fullstackedbar: BAR_POINT,
	            rangebar: "rangeBarPoint",
	            bubble: "bubblePoint",
	            stock: "stockPoint",
	            candlestick: "candlestickPoint"
	        },
	        pie: {
	            pie: PIE_POINT,
	            doughnut: PIE_POINT,
	            donut: PIE_POINT
	        },
	        polar: {
	            scatter: POLAR_SYMBOL_POINT,
	            line: POLAR_SYMBOL_POINT,
	            area: POLAR_SYMBOL_POINT,
	            bar: POLAR_BAR_POINT,
	            stackedbar: POLAR_BAR_POINT
	        }
	    };

	function Point(series, dataItem, options) {
	    this.fullState = statesConsts.normalMark;
	    this.series = series;
	    this.update(dataItem, options);
	    this._emptySettings = {
	        fill: null,
	        stroke: null,
	        dashStyle: null
	    }
	}
	exports.Point = Point;
	mixins.symbolPoint = symbolPoint;
	mixins.barPoint = barPoint;
	mixins.bubblePoint = bubblePoint;
	mixins.piePoint = piePoint;
	mixins.rangeSymbolPoint = rangeSymbolPoint;
	mixins.rangeBarPoint = rangeBarPoint;
	mixins.candlestickPoint = candlestickPoint;
	mixins.stockPoint = stockPoint;
	mixins.polarSymbolPoint = polarPoints.polarSymbolPoint;
	mixins.polarBarPoint = polarPoints.polarBarPoint;
	Point.prototype = {
	    constructor: Point,
	    getColor: function() {
	        return this._styles.normal.fill || this.series.getColor()
	    },
	    _getStyle: function() {
	        return this._styles[this._currentStyle || "normal"]
	    },
	    update: function(dataItem, options) {
	        this.updateOptions(options);
	        this.updateData(dataItem)
	    },
	    updateData: function(dataItem) {
	        var that = this;
	        that.argument = that.initialArgument = that.originalArgument = dataItem.argument;
	        that.tag = dataItem.tag;
	        that.index = dataItem.index;
	        that.lowError = dataItem.lowError;
	        that.highError = dataItem.highError;
	        that._updateData(dataItem);
	        !that.hasValue() && that.setInvisibility();
	        that._fillStyle();
	        that._updateLabelData()
	    },
	    deleteMarker: function() {
	        var that = this;
	        if (that.graphic) {
	            that.graphic.dispose()
	        }
	        that.graphic = null
	    },
	    _drawErrorBar: _noop,
	    draw: function(renderer, groups, animationEnabled, firstDrawing) {
	        var that = this;
	        if (that._needDeletingOnDraw) {
	            that.deleteMarker();
	            that._needDeletingOnDraw = false
	        }
	        if (that._needClearingOnDraw) {
	            that.clearMarker();
	            that._needClearingOnDraw = false
	        }
	        if (!that._hasGraphic()) {
	            that._getMarkerVisibility() && that._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing)
	        } else {
	            that._updateMarker(animationEnabled, void 0, groups.markers)
	        }
	        that._drawLabel();
	        that._drawErrorBar(renderer, groups.errorBars, animationEnabled);
	        return that
	    },
	    applyStyle: function(style) {
	        var that = this;
	        that._currentStyle = style;
	        if (that.graphic) {
	            if ("normal" === style) {
	                if (that.isHovered()) {
	                    that.applyStyle("hover");
	                    return
	                }
	                that.clearMarker()
	            } else {
	                that.graphic.toForeground()
	            }
	            that._updateMarker(true, that._styles[style])
	        }
	        return that
	    },
	    releaseHoverState: function() {
	        var that = this;
	        if (that.graphic && !that.isSelected()) {
	            that.graphic.toBackground()
	        }
	    },
	    select: function() {
	        this.series.selectPoint(this)
	    },
	    clearSelection: function() {
	        this.series.deselectPoint(this)
	    },
	    showTooltip: function() {
	        this.series.showPointTooltip(this)
	    },
	    hideTooltip: function() {
	        this.series.hidePointTooltip(this)
	    },
	    _checkLabelsChanging: function(oldType, newType) {
	        var isNewRange = ~newType.indexOf("range"),
	            isOldRange = ~oldType.indexOf("range");
	        return isOldRange && !isNewRange || !isOldRange && isNewRange
	    },
	    updateOptions: function(newOptions) {
	        if (!newOptions) {
	            return
	        }
	        var that = this,
	            oldOptions = that._options,
	            widgetType = newOptions.widgetType,
	            oldType = oldOptions && oldOptions.type,
	            newType = newOptions.type,
	            newPointTypeMixin = pointTypes[widgetType][newType];
	        if (oldType !== newType) {
	            that._needDeletingOnDraw = true;
	            that._needClearingOnDraw = false;
	            if (oldType) {
	                that._checkLabelsChanging(oldType, newType) && that.deleteLabel();
	                that._resetType(mixins[pointTypes[oldType]])
	            }
	            that._setType(mixins[newPointTypeMixin])
	        } else {
	            that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);
	            that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions)
	        }
	        that._options = newOptions;
	        that._fillStyle();
	        that._updateLabelOptions(newPointTypeMixin)
	    },
	    translate: function(translators) {
	        var that = this;
	        that.translators = translators || that.translators;
	        that.translators && that.hasValue() && that._translate(that.translators)
	    },
	    _checkCustomize: function(oldOptions, newOptions) {
	        return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions
	    },
	    _getCustomLabelVisibility: function() {
	        return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null
	    },
	    getBoundingRect: function() {
	        return this._getGraphicBBox()
	    },
	    _resetType: function(methods) {
	        for (var methodName in methods) {
	            delete this[methodName]
	        }
	    },
	    _setType: function(methods) {
	        for (var methodName in methods) {
	            this[methodName] = methods[methodName]
	        }
	    },
	    isInVisibleArea: function() {
	        return this.inVisibleArea
	    },
	    isSelected: function() {
	        return !!(this.fullState & statesConsts.selectedMark)
	    },
	    isHovered: function() {
	        return !!(this.fullState & statesConsts.hoverMark)
	    },
	    getOptions: function() {
	        return this._options
	    },
	    animate: function(complete, settings, partitionDuration) {
	        if (!this.graphic) {
	            complete && complete();
	            return
	        }
	        this.graphic.animate(settings, {
	            partitionDuration: partitionDuration
	        }, complete)
	    },
	    getCoords: function(min) {
	        var that = this;
	        if (!min) {
	            return {
	                x: that.x,
	                y: that.y
	            }
	        }
	        if (!that._options.rotated) {
	            return {
	                x: that.x,
	                y: that.minY
	            }
	        }
	        return {
	            x: that.minX,
	            y: that.y
	        }
	    },
	    getDefaultCoords: function() {
	        var that = this;
	        return !that._options.rotated ? {
	            x: that.x,
	            y: that.defaultY
	        } : {
	            x: that.defaultX,
	            y: that.y
	        }
	    },
	    _getVisibleArea: function() {
	        return this.series._visibleArea
	    },
	    _calculateVisibility: function(x, y, width, height) {
	        var visibleAreaX, visibleAreaY, that = this,
	            rotated = that._options.rotated;
	        if (that.translators) {
	            visibleAreaX = that.translators.x.getCanvasVisibleArea();
	            visibleAreaY = that.translators.y.getCanvasVisibleArea();
	            if (visibleAreaX.min > x + (width || 0) || visibleAreaX.max < x || visibleAreaY.min > y + (height || 0) || visibleAreaY.max < y || rotated && _isDefined(width) && 0 !== width && (visibleAreaX.min === x + width || visibleAreaX.max === x) || !rotated && _isDefined(height) && 0 !== height && (visibleAreaY.min === y + height || visibleAreaY.max === y)) {
	                that.inVisibleArea = false
	            } else {
	                that.inVisibleArea = true
	            }
	        }
	    },
	    hasValue: function() {
	        return null !== this.value && null !== this.minValue
	    },
	    correctPosition: _noop,
	    correctRadius: _noop,
	    correctLabelRadius: _noop,
	    getCrosshairData: _noop,
	    getPointRadius: _noop,
	    _populatePointShape: _noop,
	    _checkSymbol: _noop,
	    getMarkerCoords: _noop,
	    hide: _noop,
	    show: _noop,
	    hideMarker: _noop,
	    setInvisibility: _noop,
	    clearVisibility: _noop,
	    isVisible: _noop,
	    resetCorrection: _noop,
	    correctValue: _noop,
	    resetValue: _noop,
	    setPercentValue: _noop,
	    correctCoordinates: _noop,
	    coordsIn: _noop,
	    getTooltipParams: _noop,
	    setLabelEllipsis: _noop,
	    setLabelTrackerData: _noop,
	    updateLabelCoord: _noop,
	    drawLabel: _noop,
	    correctLabelPosition: _noop,
	    setMaxLabelLength: _noop,
	    dispose: function() {
	        var that = this;
	        that.deleteMarker();
	        that.deleteLabel();
	        that._errorBar && this._errorBar.dispose();
	        that._options = that._styles = that.series = that.translators = that._errorBar = null
	    },
	    getTooltipFormatObject: function(tooltip) {
	        var that = this,
	            tooltipFormatObject = that._getFormatObject(tooltip),
	            sharedTooltipValuesArray = [],
	            tooltipStackPointsFormatObject = [];
	        if (that.stackPoints) {
	            _each(that.stackPoints, function(_, point) {
	                if (!point.isVisible()) {
	                    return
	                }
	                var formatObject = point._getFormatObject(tooltip);
	                tooltipStackPointsFormatObject.push(formatObject);
	                sharedTooltipValuesArray.push(formatObject.seriesName + ": " + formatObject.valueText)
	            });
	            _extend(tooltipFormatObject, {
	                points: tooltipStackPointsFormatObject,
	                valueText: sharedTooltipValuesArray.join("\n"),
	                stackName: that.stackPoints.stackName
	            })
	        }
	        return tooltipFormatObject
	    },
	    setHole: function(holeValue, position) {
	        var that = this,
	            minValue = isFinite(that.minValue) ? that.minValue : 0;
	        if (_isDefined(holeValue)) {
	            if ("left" === position) {
	                that.leftHole = that.value - holeValue;
	                that.minLeftHole = minValue - holeValue
	            } else {
	                that.rightHole = that.value - holeValue;
	                that.minRightHole = minValue - holeValue
	            }
	        }
	    },
	    resetHoles: function() {
	        this.leftHole = null;
	        this.minLeftHole = null;
	        this.rightHole = null;
	        this.minRightHole = null
	    },
	    getLabel: function() {
	        return this._label
	    },
	    getLabels: function() {
	        return [this._label]
	    }
	};


/***/ },
/* 305 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (viz/components/consts.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	module.exports = {
	    events: {
	        mouseover: "mouseover",
	        mouseout: "mouseout",
	        mousemove: "mousemove",
	        touchstart: "touchstart",
	        touchmove: "touchmove",
	        touchend: "touchend",
	        mousedown: "mousedown",
	        mouseup: "mouseup",
	        click: "click",
	        selectSeries: "selectseries",
	        deselectSeries: "deselectseries",
	        selectPoint: "selectpoint",
	        deselectPoint: "deselectpoint",
	        showPointTooltip: "showpointtooltip",
	        hidePointTooltip: "hidepointtooltip"
	    },
	    states: {
	        hover: "hover",
	        normal: "normal",
	        selection: "selection",
	        normalMark: 0,
	        hoverMark: 1,
	        selectedMark: 2,
	        applyHover: "applyHover",
	        applySelected: "applySelected",
	        resetItem: "resetItem"
	    },
	    pieLabelIndent: 30,
	    pieLabelSpacing: 10,
	    pieSeriesSpacing: 4
	};


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/symbol_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    labelModule = __webpack_require__(307),
	    _extend = $.extend,
	    _isDefined = commonUtils.isDefined,
	    _normalizeEnum = __webpack_require__(291).normalizeEnum,
	    _math = Math,
	    _round = _math.round,
	    _floor = _math.floor,
	    _ceil = _math.ceil,
	    DEFAULT_IMAGE_WIDTH = 20,
	    DEFAULT_IMAGE_HEIGHT = 20,
	    LABEL_OFFSET = 10,
	    CANVAS_POSITION_DEFAULT = "canvas_position_default";

	function getSquareMarkerCoords(radius) {
	    return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius]
	}

	function getPolygonMarkerCoords(radius) {
	    var r = _ceil(radius);
	    return [-r, 0, 0, -r, r, 0, 0, r, -r, 0]
	}

	function getCrossMarkerCoords(radius) {
	    var r = _ceil(radius),
	        floorHalfRadius = _floor(r / 2),
	        ceilHalfRadius = _ceil(r / 2);
	    return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0]
	}

	function getTriangleDownMarkerCoords(radius) {
	    return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius]
	}

	function getTriangleUpMarkerCoords(radius) {
	    return [-radius, radius, radius, radius, 0, -radius, -radius, radius]
	}
	module.exports = {
	    deleteLabel: function() {
	        this._label.dispose();
	        this._label = null
	    },
	    _hasGraphic: function() {
	        return this.graphic
	    },
	    clearVisibility: function() {
	        var that = this,
	            graphic = that.graphic;
	        if (graphic && graphic.attr("visibility")) {
	            graphic.attr({
	                visibility: null
	            })
	        }
	        that._label.clearVisibility()
	    },
	    isVisible: function() {
	        return this.inVisibleArea && this.series.isVisible()
	    },
	    setInvisibility: function() {
	        var that = this,
	            graphic = that.graphic;
	        if (graphic && "hidden" !== graphic.attr("visibility")) {
	            graphic.attr({
	                visibility: "hidden"
	            })
	        }
	        that._errorBar && that._errorBar.attr({
	            visibility: "hidden"
	        });
	        that._label.hide()
	    },
	    clearMarker: function() {
	        var graphic = this.graphic;
	        graphic && graphic.attr(this._emptySettings)
	    },
	    _createLabel: function() {
	        this._label = new labelModule.Label({
	            renderer: this.series._renderer,
	            labelsGroup: this.series._labelsGroup,
	            point: this
	        })
	    },
	    _updateLabelData: function() {
	        this._label.setData(this._getLabelFormatObject())
	    },
	    _updateLabelOptions: function() {
	        !this._label && this._createLabel();
	        this._label.setOptions(this._options.label)
	    },
	    _checkImage: function(image) {
	        return _isDefined(image) && ("string" === typeof image || _isDefined(image.url))
	    },
	    _fillStyle: function() {
	        this._styles = this._options.styles
	    },
	    _checkSymbol: function(oldOptions, newOptions) {
	        var oldSymbol = oldOptions.symbol,
	            newSymbol = newOptions.symbol,
	            symbolChanged = "circle" === oldSymbol && "circle" !== newSymbol || "circle" !== oldSymbol && "circle" === newSymbol,
	            imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);
	        return !!(symbolChanged || imageChanged)
	    },
	    _populatePointShape: function(symbol, radius) {
	        switch (symbol) {
	            case "square":
	                return getSquareMarkerCoords(radius);
	            case "polygon":
	                return getPolygonMarkerCoords(radius);
	            case "triangle":
	            case "triangleDown":
	                return getTriangleDownMarkerCoords(radius);
	            case "triangleUp":
	                return getTriangleUpMarkerCoords(radius);
	            case "cross":
	                return getCrossMarkerCoords(radius)
	        }
	    },
	    correctValue: function(correction) {
	        var that = this;
	        if (that.hasValue()) {
	            that.value = that.initialValue + correction;
	            that.minValue = correction;
	            that.translate()
	        }
	    },
	    resetCorrection: function() {
	        this.value = this.initialValue;
	        this.minValue = CANVAS_POSITION_DEFAULT
	    },
	    resetValue: function() {
	        var that = this;
	        if (that.hasValue()) {
	            that.value = that.initialValue = 0;
	            that.minValue = 0;
	            that.translate();
	            that._label.setDataField("value", that.value)
	        }
	    },
	    _getTranslates: function(animationEnabled) {
	        var translateX = this.x,
	            translateY = this.y;
	        if (animationEnabled) {
	            if (this._options.rotated) {
	                translateX = this.defaultX
	            } else {
	                translateY = this.defaultY
	            }
	        }
	        return {
	            x: translateX,
	            y: translateY
	        }
	    },
	    _createImageMarker: function(renderer, settings, options) {
	        var width = options.width || DEFAULT_IMAGE_WIDTH,
	            height = options.height || DEFAULT_IMAGE_HEIGHT;
	        return renderer.image(-_round(.5 * width), -_round(.5 * height), width, height, options.url ? options.url.toString() : options.toString(), "center").attr({
	            translateX: settings.translateX,
	            translateY: settings.translateY,
	            visibility: settings.visibility
	        })
	    },
	    _createSymbolMarker: function(renderer, pointSettings) {
	        var marker, symbol = this._options.symbol;
	        if ("circle" === symbol) {
	            delete pointSettings.points;
	            marker = renderer.circle().attr(pointSettings)
	        } else {
	            if ("square" === symbol || "polygon" === symbol || "triangle" === symbol || "triangleDown" === symbol || "triangleUp" === symbol || "cross" === symbol) {
	                marker = renderer.path([], "area").attr(pointSettings).sharp()
	            }
	        }
	        return marker
	    },
	    _createMarker: function(renderer, group, image, settings) {
	        var that = this,
	            marker = that._checkImage(image) ? that._createImageMarker(renderer, settings, image) : that._createSymbolMarker(renderer, settings);
	        if (marker) {
	            marker.data({
	                "chart-data-point": that
	            }).append(group)
	        }
	        return marker
	    },
	    _getSymbolBBox: function(x, y, r) {
	        return {
	            x: x - r,
	            y: y - r,
	            width: 2 * r,
	            height: 2 * r
	        }
	    },
	    _getImageBBox: function(x, y) {
	        var image = this._options.image,
	            width = image.width || DEFAULT_IMAGE_WIDTH,
	            height = image.height || DEFAULT_IMAGE_HEIGHT;
	        return {
	            x: x - _round(width / 2),
	            y: y - _round(height / 2),
	            width: width,
	            height: height
	        }
	    },
	    _getGraphicBBox: function() {
	        var bBox, that = this,
	            options = that._options,
	            x = that.x,
	            y = that.y;
	        if (options.visible) {
	            bBox = that._checkImage(options.image) ? that._getImageBBox(x, y) : that._getSymbolBBox(x, y, options.styles.normal.r)
	        } else {
	            bBox = {
	                x: x,
	                y: y,
	                width: 0,
	                height: 0
	            }
	        }
	        return bBox
	    },
	    _isLabelInsidePoint: $.noop,
	    _getShiftLabelCoords: function(label) {
	        var coord = this._addLabelAlignmentAndOffset(label, this._getLabelCoords(label));
	        return this._checkLabelPosition(label, coord)
	    },
	    _drawLabel: function() {
	        var that = this,
	            customVisibility = that._getCustomLabelVisibility(),
	            label = that._label;
	        if (that._showForZeroValues() && that.hasValue() && false !== customVisibility && (that.series.getLabelVisibility() || customVisibility)) {
	            label.show()
	        } else {
	            label.hide()
	        }
	    },
	    correctLabelPosition: function(label) {
	        var coord, that = this;
	        if (!that._isLabelInsidePoint(label)) {
	            coord = that._getShiftLabelCoords(label);
	            label.setFigureToDrawConnector(that._getLabelConnector(label.pointPosition));
	            label.shift(_round(coord.x), _round(coord.y))
	        }
	    },
	    _showForZeroValues: function() {
	        return true
	    },
	    _getLabelConnector: function(pointPosition) {
	        var bBox = this._getGraphicBBox(pointPosition),
	            w2 = bBox.width / 2,
	            h2 = bBox.height / 2;
	        return {
	            x: bBox.x + w2,
	            y: bBox.y + h2,
	            r: this._options.visible ? Math.max(w2, h2) : 0
	        }
	    },
	    _getPositionFromLocation: function() {
	        return {
	            x: this.x,
	            y: this.y
	        }
	    },
	    _isPointInVisibleArea: function(visibleArea, graphicBBox) {
	        return visibleArea.minX <= graphicBBox.x + graphicBBox.width && visibleArea.maxX >= graphicBBox.x && visibleArea.minY <= graphicBBox.y + graphicBBox.height && visibleArea.maxY >= graphicBBox.y
	    },
	    _checkLabelPosition: function(label, coord) {
	        var that = this,
	            visibleArea = that._getVisibleArea(),
	            labelBBox = label.getBoundingRect(),
	            graphicBBox = that._getGraphicBBox(label.pointPosition),
	            offset = LABEL_OFFSET;
	        if (that._isPointInVisibleArea(visibleArea, graphicBBox)) {
	            if (!that._options.rotated) {
	                if (visibleArea.minX > coord.x) {
	                    coord.x = visibleArea.minX
	                }
	                if (visibleArea.maxX < coord.x + labelBBox.width) {
	                    coord.x = visibleArea.maxX - labelBBox.width
	                }
	                if (visibleArea.minY > coord.y) {
	                    coord.y = graphicBBox.y + graphicBBox.height + offset
	                }
	                if (visibleArea.maxY < coord.y + labelBBox.height) {
	                    coord.y = graphicBBox.y - labelBBox.height - offset
	                }
	            } else {
	                if (visibleArea.minX > coord.x) {
	                    coord.x = graphicBBox.x + graphicBBox.width + offset
	                }
	                if (visibleArea.maxX < coord.x + labelBBox.width) {
	                    coord.x = graphicBBox.x - offset - labelBBox.width
	                }
	                if (visibleArea.minY > coord.y) {
	                    coord.y = visibleArea.minY
	                }
	                if (visibleArea.maxY < coord.y + labelBBox.height) {
	                    coord.y = visibleArea.maxY - labelBBox.height
	                }
	            }
	        }
	        return coord
	    },
	    _addLabelAlignmentAndOffset: function(label, coord) {
	        var labelBBox = label.getBoundingRect(),
	            labelOptions = label.getLayoutOptions();
	        if (!this._options.rotated) {
	            if ("left" === labelOptions.alignment) {
	                coord.x += labelBBox.width / 2
	            } else {
	                if ("right" === labelOptions.alignment) {
	                    coord.x -= labelBBox.width / 2
	                }
	            }
	        }
	        coord.x += labelOptions.horizontalOffset;
	        coord.y += labelOptions.verticalOffset;
	        return coord
	    },
	    _getLabelCoords: function(label) {
	        return this._getLabelCoordOfPosition(label, this._getLabelPosition(label.pointPosition))
	    },
	    _getLabelCoordOfPosition: function(label, position) {
	        var that = this,
	            labelBBox = label.getBoundingRect(),
	            graphicBBox = that._getGraphicBBox(label.pointPosition),
	            offset = LABEL_OFFSET,
	            centerY = graphicBBox.height / 2 - labelBBox.height / 2,
	            centerX = graphicBBox.width / 2 - labelBBox.width / 2,
	            x = graphicBBox.x,
	            y = graphicBBox.y;
	        switch (position) {
	            case "left":
	                x -= labelBBox.width + offset;
	                y += centerY;
	                break;
	            case "right":
	                x += graphicBBox.width + offset;
	                y += centerY;
	                break;
	            case "top":
	                x += centerX;
	                y -= labelBBox.height + offset;
	                break;
	            case "bottom":
	                x += centerX;
	                y += graphicBBox.height + offset;
	                break;
	            case "inside":
	                x += centerX;
	                y += centerY
	        }
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _drawMarker: function(renderer, group, animationEnabled) {
	        var that = this,
	            options = that._options,
	            translates = that._getTranslates(animationEnabled),
	            style = that._getStyle();
	        that.graphic = that._createMarker(renderer, group, options.image, _extend({
	            translateX: translates.x,
	            translateY: translates.y,
	            points: that._populatePointShape(options.symbol, style.r)
	        }, style))
	    },
	    _getErrorBarSettings: function() {
	        return {
	            visibility: "visible"
	        }
	    },
	    _drawErrorBar: function(renderer, group) {
	        if (!this._options.errorBars) {
	            return
	        }
	        var settings, that = this,
	            options = that._options,
	            errorBarOptions = options.errorBars,
	            points = [],
	            pos = that._errorBarPos,
	            high = that._highErrorCoord,
	            low = that._lowErrorCoord,
	            displayMode = _normalizeEnum(errorBarOptions.displayMode),
	            isHighDisplayMode = "high" === displayMode,
	            isLowDisplayMode = "low" === displayMode,
	            edgeLength = _floor(parseInt(errorBarOptions.edgeLength) / 2),
	            highErrorOnly = (isHighDisplayMode || !_isDefined(low)) && _isDefined(high) && !isLowDisplayMode,
	            lowErrorOnly = (isLowDisplayMode || !_isDefined(high)) && _isDefined(low) && !isHighDisplayMode;
	        highErrorOnly && (low = that._baseErrorBarPos);
	        lowErrorOnly && (high = that._baseErrorBarPos);
	        if ("none" !== displayMode && _isDefined(high) && _isDefined(low) && _isDefined(pos)) {
	            !lowErrorOnly && points.push([pos - edgeLength, high, pos + edgeLength, high]);
	            points.push([pos, high, pos, low]);
	            !highErrorOnly && points.push([pos + edgeLength, low, pos - edgeLength, low]);
	            options.rotated && $.each(points, function(_, p) {
	                p.reverse()
	            });
	            settings = that._getErrorBarSettings(errorBarOptions);
	            if (!that._errorBar) {
	                that._errorBar = renderer.path(points, "line").attr(settings).append(group)
	            } else {
	                settings.points = points;
	                that._errorBar.attr(settings)
	            }
	        } else {
	            that._errorBar && that._errorBar.attr({
	                visibility: "hidden"
	            })
	        }
	    },
	    getTooltipParams: function() {
	        var that = this,
	            graphic = that.graphic;
	        return {
	            x: that.x,
	            y: that.y,
	            offset: graphic ? graphic.getBBox().height / 2 : 0
	        }
	    },
	    setPercentValue: function(total, fullStacked, leftHoleTotal, rightHoleTotal) {
	        var that = this,
	            valuePercent = that.value / total || 0,
	            minValuePercent = that.minValue / total || 0,
	            percent = valuePercent - minValuePercent;
	        that._label.setDataField("percent", percent);
	        that._label.setDataField("total", total);
	        if (that.series.isFullStackedSeries() && that.hasValue()) {
	            if (that.leftHole) {
	                that.leftHole /= total - leftHoleTotal;
	                that.minLeftHole /= total - leftHoleTotal
	            }
	            if (that.rightHole) {
	                that.rightHole /= total - rightHoleTotal;
	                that.minRightHole /= total - rightHoleTotal
	            }
	            that.value = valuePercent;
	            that.minValue = !minValuePercent ? that.minValue : minValuePercent;
	            that.translate()
	        }
	    },
	    _storeTrackerR: function() {
	        var minTrackerSize, that = this,
	            navigator = window.navigator,
	            r = that._options.styles.normal.r;
	        minTrackerSize = "ontouchstart" in window || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;
	        that._options.trackerR = r < minTrackerSize ? minTrackerSize : r;
	        return that._options.trackerR
	    },
	    _translateErrorBars: function(valueTranslator) {
	        var that = this,
	            options = that._options,
	            rotated = options.rotated,
	            errorBars = options.errorBars;
	        if (!errorBars) {
	            return
	        }
	        _isDefined(that.lowError) && (that._lowErrorCoord = valueTranslator.translate(that.lowError));
	        _isDefined(that.highError) && (that._highErrorCoord = valueTranslator.translate(that.highError));
	        that._errorBarPos = _floor(rotated ? that.vy : that.vx);
	        that._baseErrorBarPos = "stdDeviation" === errorBars.type ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : rotated ? that.vx : that.vy
	    },
	    _translate: function(translators) {
	        var valueTranslator, that = this;
	        if (that._options.rotated) {
	            valueTranslator = translators.x;
	            that.vx = that.x = valueTranslator.translate(that.value);
	            that.vy = that.y = translators.y.translate(that.argument);
	            that.minX = valueTranslator.translate(that.minValue);
	            that.defaultX = valueTranslator.translate(CANVAS_POSITION_DEFAULT);
	            that._translateErrorBars(valueTranslator)
	        } else {
	            valueTranslator = translators.y;
	            that.vy = that.y = valueTranslator.translate(that.value);
	            that.vx = that.x = translators.x.translate(that.argument);
	            that.minY = valueTranslator.translate(that.minValue);
	            that.defaultY = valueTranslator.translate(CANVAS_POSITION_DEFAULT);
	            that._translateErrorBars(valueTranslator)
	        }
	        that._calculateVisibility(that.x, that.y)
	    },
	    _updateData: function(data) {
	        var that = this;
	        that.value = that.initialValue = that.originalValue = data.value;
	        that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT
	    },
	    _getImageSettings: function(image) {
	        return {
	            href: image.url || image.toString(),
	            width: image.width || DEFAULT_IMAGE_WIDTH,
	            height: image.height || DEFAULT_IMAGE_HEIGHT
	        }
	    },
	    getCrosshairData: function() {
	        var that = this,
	            r = that._options.rotated,
	            value = that.value,
	            argument = that.argument;
	        return {
	            x: that.vx,
	            y: that.vy,
	            xValue: r ? value : argument,
	            yValue: r ? argument : value,
	            axis: that.series.axis
	        }
	    },
	    getPointRadius: function() {
	        var extraSpace, style = this._getStyle(),
	            options = this._options,
	            r = style.r,
	            symbol = options.symbol,
	            isSquare = "square" === symbol,
	            isTriangle = "triangle" === symbol || "triangleDown" === symbol || "triangleUp" === symbol;
	        if (options.visible && !options.image && r) {
	            extraSpace = style["stroke-width"] / 2;
	            return (isSquare || isTriangle ? 1.4 * r : r) + extraSpace
	        }
	        return 0
	    },
	    _updateMarker: function(animationEnabled, style) {
	        var settings, that = this,
	            options = that._options,
	            image = options.image,
	            visibility = !that.isVisible() ? {
	                visibility: "hidden"
	            } : {};
	        style = style || that._getStyle();
	        if (that._checkImage(image)) {
	            settings = _extend({}, {
	                visibility: style.visibility
	            }, visibility, that._getImageSettings(image))
	        } else {
	            settings = _extend({}, style, visibility, {
	                points: that._populatePointShape(options.symbol, style.r)
	            })
	        }
	        if (!animationEnabled) {
	            settings.translateX = that.x;
	            settings.translateY = that.y
	        }
	        that.graphic.attr(settings).sharp()
	    },
	    _getLabelFormatObject: function() {
	        var that = this;
	        return {
	            argument: that.initialArgument,
	            value: that.initialValue,
	            originalArgument: that.originalArgument,
	            originalValue: that.originalValue,
	            seriesName: that.series.name,
	            lowErrorValue: that.lowError,
	            highErrorValue: that.highError,
	            point: that
	        }
	    },
	    _getLabelPosition: function() {
	        var rotated = this._options.rotated;
	        if (this.initialValue > 0) {
	            return rotated ? "right" : "top"
	        } else {
	            return rotated ? "left" : "bottom"
	        }
	    },
	    _getFormatObject: function(tooltip) {
	        var that = this,
	            labelFormatObject = that._label.getData();
	        return _extend({}, labelFormatObject, {
	            argumentText: tooltip.formatValue(that.initialArgument, "argument"),
	            valueText: tooltip.formatValue(that.initialValue)
	        }, _isDefined(labelFormatObject.percent) ? {
	            percentText: tooltip.formatValue(labelFormatObject.percent, "percent")
	        } : {}, _isDefined(labelFormatObject.total) ? {
	            totalText: tooltip.formatValue(labelFormatObject.total)
	        } : {})
	    },
	    _getMarkerVisibility: function() {
	        return this._options.visible
	    },
	    coordsIn: function(x, y) {
	        var trackerRadius = this._storeTrackerR();
	        return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius
	    }
	};


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/label.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _format = __webpack_require__(308),
	    vizUtils = __webpack_require__(291),
	    _degreesToRadians = vizUtils.degreesToRadians,
	    _patchFontOptions = vizUtils.patchFontOptions,
	    _round = Math.round,
	    _getCosAndSin = vizUtils.getCosAndSin,
	    _rotateBBox = vizUtils.rotateBBox,
	    LABEL_BACKGROUND_PADDING_X = 8,
	    LABEL_BACKGROUND_PADDING_Y = 4;

	function getClosestCoord(point, coords) {
	    var closestCoord, closestDistance = 1 / 0;
	    $.each(coords, function(_, coord) {
	        var x = point[0] - coord[0],
	            y = point[1] - coord[1],
	            distance = x * x + y * y;
	        if (distance < closestDistance) {
	            closestDistance = distance;
	            closestCoord = coord
	        }
	    });
	    return closestCoord
	}
	var barPointStrategy = {
	    isLabelInside: function(labelPoint, figure) {
	        return labelPoint.x >= figure.x && labelPoint.x <= figure.x + figure.width && labelPoint.y >= figure.y && labelPoint.y <= figure.y + figure.height
	    },
	    prepareLabelPoints: function(points) {
	        return points
	    },
	    getFigureCenter: function(figure) {
	        return [figure.x + figure.width / 2, figure.y + figure.height / 2]
	    },
	    findFigurePoint: function(figure, labelPoint) {
	        var figureCenter = barPointStrategy.getFigureCenter(figure),
	            point = getClosestCoord(labelPoint, [
	                [figure.x, figureCenter[1]],
	                [figureCenter[0], figure.y + figure.height],
	                [figure.x + figure.width, figureCenter[1]],
	                [figureCenter[0], figure.y]
	            ]);
	        return [_round(point[0]), _round(point[1])]
	    }
	};
	var symbolPointStrategy = {
	    isLabelInside: function() {
	        return false
	    },
	    prepareLabelPoints: barPointStrategy.prepareLabelPoints,
	    getFigureCenter: function(figure) {
	        return [figure.x, figure.y]
	    },
	    findFigurePoint: function(figure, labelPoint) {
	        var angle = Math.atan2(figure.y - labelPoint[1], labelPoint[0] - figure.x);
	        return [_round(figure.x + figure.r * Math.cos(angle)), _round(figure.y - figure.r * Math.sin(angle))]
	    }
	};
	var piePointStrategy = {
	    isLabelInside: function(_0, _1, isOutside) {
	        return !isOutside
	    },
	    prepareLabelPoints: function(points, center, angle) {
	        var rotatedPoints = [],
	            x0 = center[0],
	            y0 = center[1],
	            cosSin = _getCosAndSin(angle || 0);
	        $.each(points, function(_, point) {
	            rotatedPoints.push([_round((point[0] - x0) * cosSin.cos + (point[1] - y0) * cosSin.sin + x0), _round(-(point[0] - x0) * cosSin.sin + (point[1] - y0) * cosSin.cos + y0)])
	        });
	        return rotatedPoints
	    },
	    getFigureCenter: symbolPointStrategy.getFigureCenter,
	    findFigurePoint: function(figure, labelPoint) {
	        var x = figure.x + (figure.y - labelPoint[1]) / Math.tan(_degreesToRadians(figure.angle)),
	            point = [figure.x, figure.y];
	        if (figure.x <= x && x <= labelPoint[0] || figure.x >= x && x >= labelPoint[0]) {
	            point.push(_round(x), labelPoint[1])
	        }
	        return point
	    }
	};

	function selectStrategy(figure) {
	    return void 0 !== figure.angle && piePointStrategy || void 0 !== figure.r && symbolPointStrategy || barPointStrategy
	}

	function disposeItem(obj, field) {
	    obj[field] && obj[field].dispose();
	    obj[field] = null
	}

	function checkBackground(background) {
	    return background && (background.fill && "none" !== background.fill || background["stroke-width"] > 0 && background.stroke && "none" !== background.stroke)
	}

	function checkConnector(connector) {
	    return connector && connector["stroke-width"] > 0 && connector.stroke && "none" !== connector.stroke
	}

	function formatText(data, options) {
	    data.valueText = _format(data.value, options);
	    data.argumentText = _format(data.argument, {
	        format: options.argumentFormat,
	        precision: options.argumentPrecision
	    });
	    if (void 0 !== data.percent) {
	        data.percentText = _format(data.percent, {
	            format: {
	                type: "percent",
	                precision: options.format && options.format.percentPrecision || options.percentPrecision
	            }
	        })
	    }
	    if (void 0 !== data.total) {
	        data.totalText = _format(data.total, options)
	    }
	    if (void 0 !== data.openValue) {
	        data.openValueText = _format(data.openValue, options)
	    }
	    if (void 0 !== data.closeValue) {
	        data.closeValueText = _format(data.closeValue, options)
	    }
	    if (void 0 !== data.lowValue) {
	        data.lowValueText = _format(data.lowValue, options)
	    }
	    if (void 0 !== data.highValue) {
	        data.highValueText = _format(data.highValue, options)
	    }
	    if (void 0 !== data.reductionValue) {
	        data.reductionValueText = _format(data.reductionValue, options)
	    }
	    return options.customizeText ? options.customizeText.call(data, data) : data.valueText
	}

	function Label(renderSettings) {
	    this._renderer = renderSettings.renderer;
	    this._container = renderSettings.labelsGroup;
	    this._point = renderSettings.point
	}
	Label.prototype = {
	    constructor: Label,
	    _setVisibility: function(value, state) {
	        this._group && this._group.attr({
	            visibility: value
	        });
	        this._visible = state
	    },
	    clearVisibility: function() {
	        this._setVisibility(null, true)
	    },
	    hide: function() {
	        this._setVisibility("hidden", false)
	    },
	    show: function() {
	        var that = this;
	        if (that._point.hasValue()) {
	            that._draw();
	            that._point.correctLabelPosition(that)
	        }
	    },
	    isVisible: function() {
	        return this._visible
	    },
	    setColor: function(color) {
	        this._color = color
	    },
	    setOptions: function(options) {
	        this._options = options
	    },
	    setData: function(data) {
	        this._data = data
	    },
	    setDataField: function(fieldName, fieldValue) {
	        this._data = this._data || {};
	        this._data[fieldName] = fieldValue
	    },
	    getData: function() {
	        return this._data
	    },
	    setFigureToDrawConnector: function(figure) {
	        this._figure = figure
	    },
	    dispose: function() {
	        var that = this;
	        disposeItem(that, "_group");
	        that._data = that._options = that._textContent = that._visible = that._insideGroup = that._text = that._background = that._connector = that._figure = null
	    },
	    _draw: function() {
	        var that = this,
	            renderer = that._renderer,
	            container = that._container,
	            options = that._options || {},
	            text = that._textContent = formatText(that._data, that._options) || null;
	        that.clearVisibility();
	        if (text) {
	            if (!that._group) {
	                that._group = renderer.g().append(container);
	                that._insideGroup = renderer.g().append(that._group);
	                that._text = renderer.text("", 0, 0).append(that._insideGroup)
	            }
	            that._text.css(options.attributes ? _patchFontOptions(options.attributes.font) : {});
	            if (checkBackground(options.background)) {
	                that._background = that._background || renderer.rect().append(that._insideGroup).toBackground();
	                that._background.attr(options.background);
	                that._color && that._background.attr({
	                    fill: that._color
	                })
	            } else {
	                disposeItem(that, "_background")
	            }
	            if (checkConnector(options.connector)) {
	                that._connector = that._connector || renderer.path([], "line").sharp().append(that._group).toBackground();
	                that._connector.attr(options.connector);
	                that._color && that._connector.attr({
	                    stroke: that._color
	                })
	            } else {
	                disposeItem(that, "_connector")
	            }
	            that._text.attr({
	                text: text
	            });
	            that._updateBackground(that._text.getBBox());
	            that._setVisibility("visible", true)
	        } else {
	            that.hide()
	        }
	        return that
	    },
	    _updateBackground: function(bBox) {
	        var that = this;
	        that._textSize = [bBox.width, bBox.height];
	        if (that._background) {
	            bBox.x -= LABEL_BACKGROUND_PADDING_X;
	            bBox.y -= LABEL_BACKGROUND_PADDING_Y;
	            bBox.width += 2 * LABEL_BACKGROUND_PADDING_X;
	            bBox.height += 2 * LABEL_BACKGROUND_PADDING_Y;
	            that._background.attr(bBox)
	        }
	        if (that._options.rotationAngle) {
	            that._insideGroup.rotate(that._options.rotationAngle, bBox.x + bBox.width / 2, bBox.y + bBox.height / 2);
	            bBox = _rotateBBox(bBox, [bBox.x + bBox.width / 2, bBox.y + bBox.height / 2], -that._options.rotationAngle)
	        }
	        that._bBox = bBox
	    },
	    _getConnectorPoints: function() {
	        var labelPoint, figurePoint, xc, yc, that = this,
	            figure = that._figure,
	            strategy = selectStrategy(figure),
	            bBox = that.getBoundingRect(),
	            points = [];
	        if (!strategy.isLabelInside(bBox, figure, "inside" !== that._options.position)) {
	            xc = bBox.x + bBox.width / 2;
	            yc = bBox.y + bBox.height / 2;
	            points = strategy.prepareLabelPoints([
	                [xc, yc - that._textSize[1] / 2],
	                [xc + that._textSize[0] / 2, yc],
	                [xc, yc + that._textSize[1] / 2],
	                [xc - that._textSize[0] / 2, yc]
	            ], [xc, yc], -that._options.rotationAngle || 0);
	            labelPoint = getClosestCoord(strategy.getFigureCenter(figure), points);
	            labelPoint = [_round(labelPoint[0]), _round(labelPoint[1])];
	            figurePoint = strategy.findFigurePoint(figure, labelPoint);
	            points = figurePoint.concat(labelPoint)
	        }
	        return points
	    },
	    fit: function(maxWidth) {
	        this._text && this._text.applyEllipsis(maxWidth);
	        this._updateBackground(this._text.getBBox())
	    },
	    setTrackerData: function(point) {
	        this._text.data({
	            "chart-data-point": point
	        });
	        this._background && this._background.data({
	            "chart-data-point": point
	        })
	    },
	    shift: function(x, y) {
	        var that = this;
	        if (that._textContent) {
	            that._insideGroup.attr({
	                translateX: that._x = _round(x - that._bBox.x),
	                translateY: that._y = _round(y - that._bBox.y)
	            });
	            if (that._connector) {
	                that._connector.attr({
	                    points: that._getConnectorPoints()
	                })
	            }
	        }
	        return that
	    },
	    getBoundingRect: function() {
	        var bBox = this._bBox;
	        return this._textContent ? {
	            x: bBox.x + this._x,
	            y: bBox.y + this._y,
	            width: bBox.width,
	            height: bBox.height
	        } : {}
	    },
	    getLayoutOptions: function() {
	        var options = this._options;
	        return {
	            alignment: options.alignment,
	            background: checkBackground(options.background),
	            horizontalOffset: options.horizontalOffset,
	            verticalOffset: options.verticalOffset,
	            radialOffset: options.radialOffset,
	            position: options.position
	        }
	    }
	};
	exports.Label = Label;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/format.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var _format = __webpack_require__(54).format;
	module.exports = function(value, options) {
	    return _format(value, options.format, options.precision)
	};


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/bar_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _extend = $.extend,
	    _math = Math,
	    _floor = _math.floor,
	    _abs = _math.abs,
	    _min = _math.min,
	    symbolPoint = __webpack_require__(306),
	    CANVAS_POSITION_DEFAULT = "canvas_position_default",
	    DEFAULT_BAR_TRACKER_SIZE = 9,
	    CORRECTING_BAR_TRACKER_VALUE = 4,
	    RIGHT = "right",
	    LEFT = "left",
	    TOP = "top",
	    BOTTOM = "bottom";
	module.exports = _extend({}, symbolPoint, {
	    correctCoordinates: function(correctOptions) {
	        var correction = _floor(correctOptions.offset - correctOptions.width / 2),
	            rotated = this._options.rotated,
	            valueSelector = rotated ? "height" : "width",
	            correctionSelector = (rotated ? "y" : "x") + "Correction";
	        this[valueSelector] = correctOptions.width;
	        this[correctionSelector] = correction
	    },
	    _getGraphicBBox: function() {
	        var that = this,
	            bBox = {};
	        bBox.x = that.x;
	        bBox.y = that.y;
	        bBox.width = that.width;
	        bBox.height = that.height;
	        return bBox
	    },
	    _getLabelConnector: function(location) {
	        return this._getGraphicBBox(location)
	    },
	    _getLabelPosition: function() {
	        var position, that = this,
	            translators = that.translators,
	            initialValue = that.initialValue,
	            invertX = translators.x.getBusinessRange().invert,
	            invertY = translators.y.getBusinessRange().invert,
	            isDiscreteValue = "discrete" === that.series.valueAxisType,
	            isFullStacked = that.series.isFullStackedSeries(),
	            notVerticalInverted = !isDiscreteValue && (initialValue >= 0 && !invertY || initialValue < 0 && invertY) || isDiscreteValue && !invertY || isFullStacked,
	            notHorizontalInverted = !isDiscreteValue && (initialValue >= 0 && !invertX || initialValue < 0 && invertX) || isDiscreteValue && !invertX || isFullStacked;
	        if (!that._options.rotated) {
	            position = notVerticalInverted ? TOP : BOTTOM
	        } else {
	            position = notHorizontalInverted ? RIGHT : LEFT
	        }
	        return position
	    },
	    _getLabelCoords: function(label) {
	        var coords, that = this;
	        if (0 === that.initialValue && that.series.isFullStackedSeries()) {
	            if (!this._options.rotated) {
	                coords = that._getLabelCoordOfPosition(label, TOP)
	            } else {
	                coords = that._getLabelCoordOfPosition(label, RIGHT)
	            }
	        } else {
	            if ("inside" === label.getLayoutOptions().position) {
	                coords = that._getLabelCoordOfPosition(label, "inside")
	            } else {
	                coords = symbolPoint._getLabelCoords.call(this, label)
	            }
	        }
	        return coords
	    },
	    _checkLabelPosition: function(label, coord) {
	        var that = this,
	            visibleArea = that._getVisibleArea();
	        if (that._isPointInVisibleArea(visibleArea, that._getGraphicBBox())) {
	            return that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
	        }
	        return coord
	    },
	    _isLabelInsidePoint: function(label) {
	        var that = this,
	            graphicBBox = that._getGraphicBBox(),
	            labelBBox = label.getBoundingRect();
	        if (that._options.resolveLabelsOverlapping && "inside" === label.getLayoutOptions().position) {
	            if (labelBBox.width > graphicBBox.width || labelBBox.height > graphicBBox.height) {
	                label.hide();
	                return true
	            }
	        }
	        return false
	    },
	    _moveLabelOnCanvas: function(coord, visibleArea, labelBBox) {
	        var x = coord.x,
	            y = coord.y;
	        if (visibleArea.minX > x) {
	            x = visibleArea.minX
	        }
	        if (visibleArea.maxX < x + labelBBox.width) {
	            x = visibleArea.maxX - labelBBox.width
	        }
	        if (visibleArea.minY > y) {
	            y = visibleArea.minY
	        }
	        if (visibleArea.maxY < y + labelBBox.height) {
	            y = visibleArea.maxY - labelBBox.height
	        }
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _showForZeroValues: function() {
	        return this._options.label.showForZeroValues || this.initialValue
	    },
	    _drawMarker: function(renderer, group, animationEnabled) {
	        var that = this,
	            style = that._getStyle(),
	            x = that.x,
	            y = that.y,
	            width = that.width,
	            height = that.height,
	            r = that._options.cornerRadius;
	        if (animationEnabled) {
	            if (that._options.rotated) {
	                width = 0;
	                x = that.defaultX
	            } else {
	                height = 0;
	                y = that.defaultY
	            }
	        }
	        that.graphic = renderer.rect(x, y, width, height).attr({
	            rx: r,
	            ry: r
	        }).attr(style).data({
	            "chart-data-point": that
	        }).append(group)
	    },
	    _getSettingsForTracker: function() {
	        var that = this,
	            y = that.y,
	            height = that.height,
	            x = that.x,
	            width = that.width;
	        if (that._options.rotated) {
	            if (1 === width) {
	                width = DEFAULT_BAR_TRACKER_SIZE;
	                x -= CORRECTING_BAR_TRACKER_VALUE
	            }
	        } else {
	            if (1 === height) {
	                height = DEFAULT_BAR_TRACKER_SIZE;
	                y -= CORRECTING_BAR_TRACKER_VALUE
	            }
	        }
	        return {
	            x: x,
	            y: y,
	            width: width,
	            height: height
	        }
	    },
	    getGraphicSettings: function() {
	        var graphic = this.graphic;
	        return {
	            x: graphic.attr("x"),
	            y: graphic.attr("y"),
	            height: graphic.attr("height"),
	            width: graphic.attr("width")
	        }
	    },
	    _getEdgeTooltipParams: function(x, y, width, height) {
	        var xCoord, yCoord, isPositive = this.value >= 0,
	            invertedY = this.translators.y.getBusinessRange().invert,
	            invertedX = this.translators.x.getBusinessRange().invert;
	        if (this._options.rotated) {
	            yCoord = y + height / 2;
	            if (invertedX) {
	                xCoord = isPositive ? x : x + width
	            } else {
	                xCoord = isPositive ? x + width : x
	            }
	        } else {
	            xCoord = x + width / 2;
	            if (invertedY) {
	                yCoord = isPositive ? y + height : y
	            } else {
	                yCoord = isPositive ? y : y + height
	            }
	        }
	        return {
	            x: xCoord,
	            y: yCoord,
	            offset: 0
	        }
	    },
	    getTooltipParams: function(location) {
	        var x = this.x,
	            y = this.y,
	            width = this.width,
	            height = this.height;
	        return "edge" === location ? this._getEdgeTooltipParams(x, y, width, height) : {
	            x: x + width / 2,
	            y: y + height / 2,
	            offset: 0
	        }
	    },
	    _truncateCoord: function(coord, minBounce, maxBounce) {
	        if (coord < minBounce) {
	            return minBounce
	        }
	        if (coord > maxBounce) {
	            return maxBounce
	        }
	        return coord
	    },
	    _translateErrorBars: function(valueTranslator, argVisibleArea) {
	        symbolPoint._translateErrorBars.call(this, valueTranslator);
	        if (this._errorBarPos < argVisibleArea.min || this._errorBarPos > argVisibleArea.max) {
	            this._errorBarPos = void 0
	        }
	    },
	    _translate: function(translators) {
	        var arg, minArg, val, minVal, that = this,
	            rotated = that._options.rotated,
	            valAxis = rotated ? "x" : "y",
	            argAxis = rotated ? "y" : "x",
	            valIntervalName = rotated ? "width" : "height",
	            argIntervalName = rotated ? "height" : "width",
	            argTranslator = translators[argAxis],
	            valTranslator = translators[valAxis],
	            argVisibleArea = argTranslator.getCanvasVisibleArea(),
	            valVisibleArea = valTranslator.getCanvasVisibleArea();
	        arg = minArg = argTranslator.translate(that.argument) + (that[argAxis + "Correction"] || 0);
	        val = valTranslator.translate(that.value);
	        minVal = valTranslator.translate(that.minValue);
	        that["v" + valAxis] = val;
	        that["v" + argAxis] = arg + that[argIntervalName] / 2;
	        that[valIntervalName] = _abs(val - minVal);
	        that._calculateVisibility(rotated ? _min(val, minVal) : _min(arg, minArg), rotated ? _min(arg, minArg) : _min(val, minVal), that.width, that.height);
	        val = that._truncateCoord(val, valVisibleArea.min, valVisibleArea.max);
	        minVal = that._truncateCoord(minVal, valVisibleArea.min, valVisibleArea.max);
	        that[argAxis] = arg;
	        that["min" + argAxis.toUpperCase()] = minArg;
	        that[valIntervalName] = _abs(val - minVal);
	        that[valAxis] = _min(val, minVal) + (that[valAxis + "Correction"] || 0);
	        that["min" + valAxis.toUpperCase()] = minVal + (that[valAxis + "Correction"] || 0);
	        that["default" + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);
	        that._translateErrorBars(valTranslator, argVisibleArea);
	        if (that.inVisibleArea) {
	            if (that[argAxis] < argVisibleArea.min) {
	                that[argIntervalName] = that[argIntervalName] - (argVisibleArea.min - that[argAxis]);
	                that[argAxis] = argVisibleArea.min;
	                that["min" + argAxis.toUpperCase()] = argVisibleArea.min
	            }
	            if (that[argAxis] + that[argIntervalName] > argVisibleArea.max) {
	                that[argIntervalName] = argVisibleArea.max - that[argAxis]
	            }
	        }
	    },
	    _updateMarker: function(animationEnabled, style) {
	        this.graphic.attr(_extend({}, style || this._getStyle(), !animationEnabled ? this.getMarkerCoords() : {}))
	    },
	    getMarkerCoords: function() {
	        return {
	            x: this.x,
	            y: this.y,
	            width: this.width,
	            height: this.height
	        }
	    },
	    coordsIn: function(x, y) {
	        var that = this;
	        return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height
	    }
	});


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/bubble_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    symbolPoint = __webpack_require__(306),
	    _extend = $.extend,
	    MIN_BUBBLE_HEIGHT = 20;
	module.exports = _extend({}, symbolPoint, {
	    correctCoordinates: function(diameter) {
	        this.bubbleSize = diameter / 2
	    },
	    _drawMarker: function(renderer, group, animationEnabled) {
	        var that = this,
	            attr = _extend({
	                translateX: that.x,
	                translateY: that.y
	            }, that._getStyle());
	        that.graphic = renderer.circle(0, 0, animationEnabled ? 0 : that.bubbleSize).attr(attr).data({
	            "chart-data-point": that
	        }).append(group)
	    },
	    getTooltipParams: function(location) {
	        var height, that = this,
	            graphic = that.graphic;
	        if (!graphic) {
	            return
	        }
	        height = graphic.getBBox().height;
	        return {
	            x: that.x,
	            y: height < MIN_BUBBLE_HEIGHT || "edge" === location ? this.y - height / 2 : this.y,
	            offset: 0
	        }
	    },
	    _getLabelFormatObject: function() {
	        var formatObject = symbolPoint._getLabelFormatObject.call(this);
	        formatObject.size = this.initialSize;
	        return formatObject
	    },
	    _updateData: function(data) {
	        symbolPoint._updateData.call(this, data);
	        this.size = this.initialSize = data.size
	    },
	    _getGraphicBBox: function() {
	        var that = this;
	        return that._getSymbolBBox(that.x, that.y, that.bubbleSize)
	    },
	    _updateMarker: function(animationEnabled, style) {
	        var that = this;
	        style = style || that._getStyle();
	        if (!animationEnabled) {
	            style = $.extend({
	                r: that.bubbleSize,
	                translateX: that.x,
	                translateY: that.y
	            }, style)
	        }
	        that.graphic.attr(style)
	    },
	    _getFormatObject: function(tooltip) {
	        var formatObject = symbolPoint._getFormatObject.call(this, tooltip);
	        formatObject.sizeText = tooltip.formatValue(this.initialSize);
	        return formatObject
	    },
	    _storeTrackerR: function() {
	        return this.bubbleSize
	    },
	    _getLabelCoords: function(label) {
	        var coords;
	        if ("inside" === label.getLayoutOptions().position) {
	            coords = this._getLabelCoordOfPosition(label, "inside")
	        } else {
	            coords = symbolPoint._getLabelCoords.call(this, label)
	        }
	        return coords
	    }
	});


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/pie_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    CONNECTOR_LENGTH = 20,
	    symbolPoint = __webpack_require__(306),
	    _extend = $.extend,
	    _round = Math.round,
	    _sqrt = Math.sqrt,
	    _acos = Math.acos,
	    DEG = 180 / Math.PI,
	    _abs = Math.abs,
	    vizUtils = __webpack_require__(291),
	    _normalizeAngle = vizUtils.normalizeAngle,
	    _getCosAndSin = vizUtils.getCosAndSin,
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    getVerticallyShiftedAngularCoords = vizUtils.getVerticallyShiftedAngularCoords,
	    INDENT_FROM_PIE = __webpack_require__(305).pieLabelIndent;
	module.exports = _extend({}, symbolPoint, {
	    _updateData: function(data) {
	        var that = this;
	        symbolPoint._updateData.call(this, data);
	        that._visible = true;
	        that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : 0
	    },
	    animate: function(complete, duration, step) {
	        var that = this;
	        that.graphic.animate({
	            x: that.centerX,
	            y: that.centerY,
	            outerRadius: that.radiusOuter,
	            innerRadius: that.radiusInner,
	            startAngle: that.toAngle,
	            endAngle: that.fromAngle
	        }, {
	            partitionDuration: duration,
	            step: step
	        }, complete)
	    },
	    correctPosition: function(correction) {
	        var that = this;
	        that.correctRadius(correction);
	        that.correctLabelRadius(correction.radiusOuter);
	        that.centerX = correction.centerX;
	        that.centerY = correction.centerY
	    },
	    correctRadius: function(correction) {
	        this.radiusInner = correction.radiusInner;
	        this.radiusOuter = correction.radiusOuter
	    },
	    correctLabelRadius: function(radiusLabels) {
	        this.radiusLabels = radiusLabels
	    },
	    correctValue: function(correction, percent, base) {
	        var that = this;
	        that.value = (base || that.initialValue) + correction;
	        that.minValue = correction;
	        that.percent = percent;
	        that._label.setDataField("percent", percent)
	    },
	    setMaxLabelLength: function(maxLabelLength) {
	        this._maxLabelLength = maxLabelLength
	    },
	    _updateLabelData: function() {
	        this._label.setData(this._getLabelFormatObject())
	    },
	    _getShiftLabelCoords: function() {
	        var that = this,
	            bBox = that._label.getBoundingRect(),
	            coord = that._getLabelCoords(that._label),
	            visibleArea = that._getVisibleArea();
	        if (that._isLabelDrawingWithoutPoints) {
	            return that._checkLabelPosition(coord, bBox, visibleArea)
	        } else {
	            return that._getLabelExtraCoord(coord, that._checkVerticalLabelPosition(coord, bBox, visibleArea), bBox)
	        }
	    },
	    _getLabelPosition: function(options) {
	        return options.position
	    },
	    _getLabelCoords: function(label) {
	        var rad, x, that = this,
	            bBox = label.getBoundingRect(),
	            options = label.getLayoutOptions(),
	            angleFunctions = _getCosAndSin(that.middleAngle),
	            position = that._getLabelPosition(options),
	            radiusInner = that.radiusInner,
	            radiusOuter = that.radiusOuter,
	            radiusLabels = that.radiusLabels;
	        if ("inside" === position) {
	            rad = radiusInner + (radiusOuter - radiusInner) / 2 + options.radialOffset;
	            x = that.centerX + rad * angleFunctions.cos - bBox.width / 2
	        } else {
	            rad = radiusLabels + options.radialOffset + INDENT_FROM_PIE;
	            if (angleFunctions.cos > .1) {
	                x = that.centerX + rad * angleFunctions.cos
	            } else {
	                if (angleFunctions.cos < -.1) {
	                    x = that.centerX + rad * angleFunctions.cos - bBox.width
	                } else {
	                    x = that.centerX + rad * angleFunctions.cos - bBox.width / 2
	                }
	            }
	        }
	        return {
	            x: x,
	            y: _round(that.centerY - rad * angleFunctions.sin - bBox.height / 2)
	        }
	    },
	    _getColumnsCoord: function(coord) {
	        var x, that = this,
	            label = that._label,
	            bBox = label.getBoundingRect(),
	            options = label.getLayoutOptions(),
	            rad = that.radiusLabels + options.radialOffset,
	            visibleArea = that._getVisibleArea(),
	            rightBorderX = visibleArea.maxX - bBox.width,
	            leftBorderX = visibleArea.minX,
	            angleOfPoint = _normalizeAngle(that.middleAngle);
	        if ("columns" !== options.position) {
	            return coord
	        }
	        rad += CONNECTOR_LENGTH;
	        if (angleOfPoint < 90 || angleOfPoint >= 270) {
	            x = that._maxLabelLength ? that.centerX + rad + that._maxLabelLength - bBox.width : rightBorderX;
	            x = x > rightBorderX ? rightBorderX : x
	        } else {
	            x = that._maxLabelLength ? that.centerX - rad - that._maxLabelLength : leftBorderX;
	            x = x < leftBorderX ? leftBorderX : x
	        }
	        coord.x = x;
	        return coord
	    },
	    drawLabel: function(translators) {
	        this.translate(translators);
	        this._isLabelDrawingWithoutPoints = true;
	        this._drawLabel();
	        this._isLabelDrawingWithoutPoints = false
	    },
	    updateLabelCoord: function() {
	        var that = this,
	            bBox = that._label.getBoundingRect(),
	            coord = that._getColumnsCoord(bBox);
	        coord = that._checkHorizontalLabelPosition(coord, bBox, that._getVisibleArea());
	        that._label.shift(_round(coord.x), _round(bBox.y))
	    },
	    _checkVerticalLabelPosition: function(coord, box, visibleArea) {
	        var x = coord.x,
	            y = coord.y;
	        if (coord.y + box.height > visibleArea.maxY) {
	            y = visibleArea.maxY - box.height
	        } else {
	            if (coord.y < visibleArea.minY) {
	                y = visibleArea.minY
	            }
	        }
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _getLabelExtraCoord: function(coord, shiftCoord, box) {
	        return coord.y !== shiftCoord.y ? getVerticallyShiftedAngularCoords({
	            x: coord.x,
	            y: coord.y,
	            width: box.width,
	            height: box.height
	        }, shiftCoord.y - coord.y, {
	            x: this.centerX,
	            y: this.centerY
	        }) : coord
	    },
	    _checkHorizontalLabelPosition: function(coord, box, visibleArea) {
	        var x = coord.x,
	            y = coord.y;
	        if (coord.x + box.width > visibleArea.maxX) {
	            x = visibleArea.maxX - box.width
	        } else {
	            if (coord.x < visibleArea.minX) {
	                x = visibleArea.minX
	            }
	        }
	        return {
	            x: x,
	            y: y
	        }
	    },
	    setLabelEllipsis: function() {
	        var that = this,
	            bBox = that._label.getBoundingRect(),
	            coord = that._checkHorizontalLabelPosition(bBox, bBox, that._getVisibleArea());
	        that._label.fit(bBox.width - _abs(coord.x - bBox.x))
	    },
	    setLabelTrackerData: function() {
	        this._label.setTrackerData(this)
	    },
	    _checkLabelPosition: function(coord, bBox, visibleArea) {
	        coord = this._checkHorizontalLabelPosition(coord, bBox, visibleArea);
	        return this._checkVerticalLabelPosition(coord, bBox, visibleArea)
	    },
	    _getLabelConnector: function() {
	        var that = this,
	            rad = that.radiusOuter,
	            seriesStyle = that._options.styles.normal,
	            strokeWidthBy2 = seriesStyle["stroke-width"] / 2,
	            borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2),
	            angleFunctions = _getCosAndSin(_round(that.middleAngle));
	        return {
	            x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),
	            y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin),
	            angle: that.middleAngle
	        }
	    },
	    _drawMarker: function(renderer, group, animationEnabled, firstDrawing) {
	        var that = this,
	            radiusOuter = that.radiusOuter,
	            radiusInner = that.radiusInner,
	            fromAngle = that.fromAngle,
	            toAngle = that.toAngle;
	        if (animationEnabled) {
	            radiusInner = radiusOuter = 0;
	            if (!firstDrawing) {
	                fromAngle = toAngle = that.shiftedAngle
	            }
	        }
	        that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({
	            "stroke-linejoin": "round"
	        }).attr(that._getStyle()).data({
	            "chart-data-point": that
	        }).sharp().append(group)
	    },
	    getTooltipParams: function() {
	        var that = this,
	            angleFunctions = _getCosAndSin(that.middleAngle),
	            radiusInner = that.radiusInner,
	            radiusOuter = that.radiusOuter;
	        return {
	            x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,
	            y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,
	            offset: 0
	        }
	    },
	    _translate: function(translator) {
	        var that = this,
	            angle = that.shiftedAngle || 0,
	            value = that.value,
	            minValue = that.minValue;
	        that.fromAngle = translator.translate(minValue) + angle;
	        that.toAngle = translator.translate(value) + angle;
	        that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;
	        if (!that.isVisible()) {
	            that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle
	        }
	    },
	    _getMarkerVisibility: function() {
	        return true
	    },
	    _updateMarker: function(animationEnabled, style) {
	        var that = this;
	        style = style || that._getStyle();
	        if (!animationEnabled) {
	            style = _extend({
	                x: that.centerX,
	                y: that.centerY,
	                outerRadius: that.radiusOuter,
	                innerRadius: that.radiusInner,
	                startAngle: that.toAngle,
	                endAngle: that.fromAngle
	            }, style)
	        }
	        that.graphic.attr(style).sharp()
	    },
	    getLegendStyles: function() {
	        return this._styles.legendStyles
	    },
	    isInVisibleArea: function() {
	        return true
	    },
	    hide: function() {
	        var that = this;
	        if (that._visible) {
	            that._visible = false;
	            that.hideTooltip();
	            that._options.visibilityChanged(that)
	        }
	    },
	    show: function() {
	        var that = this;
	        if (!that._visible) {
	            that._visible = true;
	            that._options.visibilityChanged(that)
	        }
	    },
	    setInvisibility: function() {
	        this._label.hide()
	    },
	    isVisible: function() {
	        return this._visible
	    },
	    _getFormatObject: function(tooltip) {
	        var formatObject = symbolPoint._getFormatObject.call(this, tooltip),
	            percent = this.percent;
	        formatObject.percent = percent;
	        formatObject.percentText = tooltip.formatValue(percent, "percent");
	        return formatObject
	    },
	    getColor: function() {
	        return this._styles.normal.fill
	    },
	    coordsIn: function(x, y) {
	        var angle, that = this,
	            lx = x - that.centerX,
	            ly = y - that.centerY,
	            r = _sqrt(lx * lx + ly * ly),
	            fromAngle = that.fromAngle % 360,
	            toAngle = that.toAngle % 360;
	        if (r < that.radiusInner || r > that.radiusOuter || 0 === r) {
	            return false
	        }
	        angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);
	        if (angle < 0) {
	            angle += 360
	        }
	        if (fromAngle === toAngle && _abs(that.toAngle - that.fromAngle) > 1e-4) {
	            return true
	        } else {
	            return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle)
	        }
	    }
	});


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/range_symbol_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    labelModule = __webpack_require__(307),
	    symbolPoint = __webpack_require__(306),
	    _extend = $.extend,
	    _isDefined = commonUtils.isDefined,
	    _math = Math,
	    _abs = _math.abs,
	    _min = _math.min,
	    _max = _math.max,
	    _round = _math.round,
	    DEFAULT_IMAGE_WIDTH = 20,
	    DEFAULT_IMAGE_HEIGHT = 20;
	module.exports = _extend({}, symbolPoint, {
	    deleteLabel: function() {
	        var that = this;
	        that._topLabel.dispose();
	        that._topLabel = null;
	        that._bottomLabel.dispose();
	        that._bottomLabel = null
	    },
	    hideMarker: function(type) {
	        var graphic = this.graphic,
	            marker = graphic && graphic[type + "Marker"],
	            label = this["_" + type + "Label"];
	        if (marker && "hidden" !== marker.attr("visibility")) {
	            marker.attr({
	                visibility: "hidden"
	            })
	        }
	        label.hide()
	    },
	    setInvisibility: function() {
	        this.hideMarker("top");
	        this.hideMarker("bottom")
	    },
	    clearVisibility: function() {
	        var that = this,
	            graphic = that.graphic,
	            topMarker = graphic && graphic.topMarker,
	            bottomMarker = graphic && graphic.bottomMarker;
	        if (topMarker && topMarker.attr("visibility")) {
	            topMarker.attr({
	                visibility: null
	            })
	        }
	        if (bottomMarker && bottomMarker.attr("visibility")) {
	            bottomMarker.attr({
	                visibility: null
	            })
	        }
	        that._topLabel.clearVisibility();
	        that._bottomLabel.clearVisibility()
	    },
	    clearMarker: function() {
	        var that = this,
	            graphic = that.graphic,
	            topMarker = graphic && graphic.topMarker,
	            bottomMarker = graphic && graphic.bottomMarker,
	            emptySettings = that._emptySettings;
	        topMarker && topMarker.attr(emptySettings);
	        bottomMarker && bottomMarker.attr(emptySettings)
	    },
	    _getLabelPosition: function(markerType) {
	        var position, labelsInside = "inside" === this._options.label.position;
	        if (!this._options.rotated) {
	            position = "top" === markerType ^ labelsInside ? "top" : "bottom"
	        } else {
	            position = "top" === markerType ^ labelsInside ? "right" : "left"
	        }
	        return position
	    },
	    _getLabelMinFormatObject: function() {
	        var that = this;
	        return {
	            index: 0,
	            argument: that.initialArgument,
	            value: that.initialMinValue,
	            seriesName: that.series.name,
	            originalValue: that.originalMinValue,
	            originalArgument: that.originalArgument,
	            point: that
	        }
	    },
	    _updateLabelData: function() {
	        var maxFormatObject = this._getLabelFormatObject();
	        maxFormatObject.index = 1;
	        this._topLabel.setData(maxFormatObject);
	        this._bottomLabel.setData(this._getLabelMinFormatObject())
	    },
	    _updateLabelOptions: function() {
	        var that = this,
	            options = this._options.label;
	        (!that._topLabel || !that._bottomLabel) && that._createLabel();
	        that._topLabel.setOptions(options);
	        that._bottomLabel.setOptions(options)
	    },
	    _createLabel: function() {
	        var options = {
	            renderer: this.series._renderer,
	            labelsGroup: this.series._labelsGroup,
	            point: this
	        };
	        this._topLabel = new labelModule.Label(options);
	        this._bottomLabel = new labelModule.Label(options)
	    },
	    _getGraphicBBox: function(location) {
	        var bBox, options = this._options,
	            images = this._getImage(options.image),
	            image = "top" === location ? this._checkImage(images.top) : this._checkImage(images.bottom),
	            coord = this._getPositionFromLocation(location);
	        if (options.visible) {
	            bBox = image ? this._getImageBBox(coord.x, coord.y) : this._getSymbolBBox(coord.x, coord.y, options.styles.normal.r)
	        } else {
	            bBox = {
	                x: coord.x,
	                y: coord.y,
	                width: 0,
	                height: 0
	            }
	        }
	        return bBox
	    },
	    _getPositionFromLocation: function(location) {
	        var x, y, isTop = "top" === location;
	        if (!this._options.rotated) {
	            x = this.x;
	            y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY)
	        } else {
	            x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);
	            y = this.y
	        }
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _checkOverlay: function(bottomCoord, topCoord, topValue) {
	        return bottomCoord < topCoord + topValue
	    },
	    _getOverlayCorrections: function(type, topCoords, bottomCoords) {
	        var isVertical = "vertical" === type,
	            coordSelector = isVertical ? "y" : "x",
	            valueSelector = isVertical ? "height" : "width",
	            visibleArea = this.translators[coordSelector].getCanvasVisibleArea(),
	            minBound = visibleArea.min,
	            maxBound = visibleArea.max,
	            delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2),
	            coord1 = topCoords[coordSelector] - delta,
	            coord2 = bottomCoords[coordSelector] + delta;
	        if (coord1 < minBound) {
	            delta = minBound - topCoords[coordSelector];
	            coord1 += delta;
	            coord2 += delta
	        } else {
	            if (coord2 + bottomCoords[valueSelector] > maxBound) {
	                delta = -(bottomCoords[coordSelector] + bottomCoords[valueSelector] - maxBound);
	                coord1 += delta;
	                coord2 += delta
	            }
	        }
	        return {
	            coord1: coord1,
	            coord2: coord2
	        }
	    },
	    _checkLabelsOverlay: function(topLocation) {
	        var that = this,
	            topCoords = that._topLabel.getBoundingRect(),
	            bottomCoords = that._bottomLabel.getBoundingRect(),
	            corrections = {};
	        if (!that._options.rotated) {
	            if ("top" === topLocation) {
	                if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {
	                    corrections = this._getOverlayCorrections("vertical", topCoords, bottomCoords);
	                    that._topLabel.shift(topCoords.x, corrections.coord1);
	                    that._bottomLabel.shift(bottomCoords.x, corrections.coord2)
	                }
	            } else {
	                if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {
	                    corrections = this._getOverlayCorrections("vertical", bottomCoords, topCoords);
	                    that._topLabel.shift(topCoords.x, corrections.coord2);
	                    that._bottomLabel.shift(bottomCoords.x, corrections.coord1)
	                }
	            }
	        } else {
	            if ("top" === topLocation) {
	                if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {
	                    corrections = this._getOverlayCorrections("horizontal", bottomCoords, topCoords);
	                    that._topLabel.shift(corrections.coord2, topCoords.y);
	                    that._bottomLabel.shift(corrections.coord1, bottomCoords.y)
	                }
	            } else {
	                if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {
	                    corrections = this._getOverlayCorrections("horizontal", topCoords, bottomCoords);
	                    that._topLabel.shift(corrections.coord1, topCoords.y);
	                    that._bottomLabel.shift(corrections.coord2, bottomCoords.y)
	                }
	            }
	        }
	    },
	    _drawLabel: function() {
	        var that = this,
	            labels = [],
	            notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY,
	            customVisibility = that._getCustomLabelVisibility(),
	            topLabel = that._topLabel,
	            bottomLabel = that._bottomLabel;
	        topLabel.pointPosition = notInverted ? "top" : "bottom";
	        bottomLabel.pointPosition = notInverted ? "bottom" : "top";
	        if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue() && false !== customVisibility) {
	            false !== that.visibleTopMarker && labels.push(topLabel);
	            false !== that.visibleBottomMarker && labels.push(bottomLabel);
	            $.each(labels, function(_, label) {
	                label.show()
	            });
	            that._checkLabelsOverlay(that._topLabel.pointPosition)
	        } else {
	            topLabel.hide();
	            bottomLabel.hide()
	        }
	    },
	    _getImage: function(imageOption) {
	        var image = {};
	        if (_isDefined(imageOption)) {
	            if ("string" === typeof imageOption) {
	                image.top = image.bottom = imageOption
	            } else {
	                image.top = {
	                    url: "string" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,
	                    width: "number" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,
	                    height: "number" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint
	                };
	                image.bottom = {
	                    url: "string" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,
	                    width: "number" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,
	                    height: "number" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint
	                }
	            }
	        }
	        return image
	    },
	    _checkSymbol: function(oldOptions, newOptions) {
	        var that = this,
	            oldSymbol = oldOptions.symbol,
	            newSymbol = newOptions.symbol,
	            symbolChanged = "circle" === oldSymbol && "circle" !== newSymbol || "circle" !== oldSymbol && "circle" === newSymbol,
	            oldImages = that._getImage(oldOptions.image),
	            newImages = that._getImage(newOptions.image),
	            topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top),
	            bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);
	        return symbolChanged || topImageChanged || bottomImageChanged
	    },
	    _getSettingsForTwoMarkers: function(style) {
	        var that = this,
	            options = that._options,
	            settings = {},
	            x = options.rotated ? _min(that.x, that.minX) : that.x,
	            y = options.rotated ? that.y : _min(that.y, that.minY),
	            radius = style.r,
	            points = that._populatePointShape(options.symbol, radius);
	        settings.top = _extend({
	            translateX: x + that.width,
	            translateY: y,
	            r: radius
	        }, style);
	        settings.bottom = _extend({
	            translateX: x,
	            translateY: y + that.height,
	            r: radius
	        }, style);
	        if (points) {
	            settings.top.points = settings.bottom.points = points
	        }
	        return settings
	    },
	    _hasGraphic: function() {
	        return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker
	    },
	    _drawOneMarker: function(renderer, markerType, imageSettings, settings) {
	        var that = this,
	            graphic = that.graphic;
	        if (graphic[markerType]) {
	            that._updateOneMarker(markerType, settings)
	        } else {
	            graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings)
	        }
	    },
	    _drawMarker: function(renderer, group, animationEnabled, firstDrawing, style) {
	        var that = this,
	            settings = that._getSettingsForTwoMarkers(style || that._getStyle()),
	            image = that._getImage(that._options.image);
	        if (that._checkImage(image.top)) {
	            settings.top = that._getImageSettings(settings.top, image.top)
	        }
	        if (that._checkImage(image.bottom)) {
	            settings.bottom = that._getImageSettings(settings.bottom, image.bottom)
	        }
	        that.graphic = that.graphic || renderer.g().append(group);
	        that.visibleTopMarker && that._drawOneMarker(renderer, "topMarker", image.top, settings.top);
	        that.visibleBottomMarker && that._drawOneMarker(renderer, "bottomMarker", image.bottom, settings.bottom)
	    },
	    _getSettingsForTracker: function(radius) {
	        var that = this,
	            rotated = that._options.rotated;
	        return {
	            translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,
	            translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,
	            width: that.width + 2 * radius,
	            height: that.height + 2 * radius
	        }
	    },
	    isInVisibleArea: function() {
	        var notVisibleByArg, notVisibleByVal, tmp, visibleArgArea, visibleValArea, that = this,
	            rotated = that._options.rotated,
	            argument = !rotated ? that.x : that.y,
	            maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x),
	            minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x),
	            translators = that.translators,
	            visibleTopMarker = true,
	            visibleBottomMarker = true,
	            visibleRangeArea = true;
	        if (translators) {
	            visibleArgArea = translators[!rotated ? "x" : "y"].getCanvasVisibleArea();
	            visibleValArea = translators[!rotated ? "y" : "x"].getCanvasVisibleArea();
	            notVisibleByArg = visibleArgArea.max < argument || visibleArgArea.min > argument;
	            notVisibleByVal = visibleValArea.min > minValue && visibleValArea.min > maxValue || visibleValArea.max < minValue && visibleValArea.max < maxValue;
	            if (notVisibleByArg || notVisibleByVal) {
	                visibleTopMarker = visibleBottomMarker = visibleRangeArea = false
	            } else {
	                visibleTopMarker = visibleValArea.min <= minValue && visibleValArea.max > minValue;
	                visibleBottomMarker = visibleValArea.min < maxValue && visibleValArea.max >= maxValue;
	                if (rotated) {
	                    tmp = visibleTopMarker;
	                    visibleTopMarker = visibleBottomMarker;
	                    visibleBottomMarker = tmp
	                }
	            }
	        }
	        that.visibleTopMarker = visibleTopMarker;
	        that.visibleBottomMarker = visibleBottomMarker;
	        return visibleRangeArea
	    },
	    getTooltipParams: function() {
	        var x, y, min, max, minValue, that = this,
	            translators = that.translators,
	            visibleAreaX = translators.x.getCanvasVisibleArea(),
	            visibleAreaY = translators.y.getCanvasVisibleArea();
	        if (!that._options.rotated) {
	            minValue = _min(that.y, that.minY);
	            x = that.x;
	            min = visibleAreaY.min > minValue ? visibleAreaY.min : minValue;
	            max = visibleAreaY.max < minValue + that.height ? visibleAreaY.max : minValue + that.height;
	            y = min + (max - min) / 2
	        } else {
	            minValue = _min(that.x, that.minX);
	            y = that.y;
	            min = visibleAreaX.min > minValue ? visibleAreaX.min : minValue;
	            max = visibleAreaX.max < minValue + that.width ? visibleAreaX.max : minValue + that.width;
	            x = min + (max - min) / 2
	        }
	        return {
	            x: x,
	            y: y,
	            offset: 0
	        }
	    },
	    _translate: function(translators) {
	        var that = this,
	            rotated = that._options.rotated;
	        that.minX = that.minY = translators.y.translate(that.minValue);
	        symbolPoint._translate.call(that, translators);
	        that.height = rotated ? 0 : _abs(that.minY - that.y);
	        that.width = rotated ? _abs(that.x - that.minX) : 0
	    },
	    _updateData: function(data) {
	        var that = this;
	        symbolPoint._updateData.call(that, data);
	        that.minValue = that.initialMinValue = that.originalMinValue = data.minValue
	    },
	    _getImageSettings: function(settings, image) {
	        return {
	            href: image.url || image.toString(),
	            width: image.width || DEFAULT_IMAGE_WIDTH,
	            height: image.height || DEFAULT_IMAGE_HEIGHT,
	            translateX: settings.translateX,
	            translateY: settings.translateY
	        }
	    },
	    getCrosshairData: function(x, y) {
	        var that = this,
	            rotated = that._options.rotated,
	            minX = that.minX,
	            minY = that.minY,
	            vx = that.vx,
	            vy = that.vy,
	            value = that.value,
	            minValue = that.minValue,
	            argument = that.argument,
	            coords = {
	                axis: that.series.axis,
	                x: vx,
	                y: vy,
	                yValue: value,
	                xValue: argument
	            };
	        if (rotated) {
	            coords.yValue = argument;
	            if (_abs(vx - x) < _abs(minX - x)) {
	                coords.xValue = value
	            } else {
	                coords.x = minX;
	                coords.xValue = minValue
	            }
	        } else {
	            if (_abs(vy - y) >= _abs(minY - y)) {
	                coords.y = minY;
	                coords.yValue = minValue
	            }
	        }
	        return coords
	    },
	    _updateOneMarker: function(markerType, settings) {
	        this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings)
	    },
	    _updateMarker: function(animationEnabled, style) {
	        this._drawMarker(void 0, void 0, false, false, style)
	    },
	    _getFormatObject: function(tooltip) {
	        var that = this,
	            initialMinValue = that.initialMinValue,
	            initialValue = that.initialValue,
	            initialArgument = that.initialArgument,
	            minValue = tooltip.formatValue(initialMinValue),
	            value = tooltip.formatValue(initialValue);
	        return {
	            argument: initialArgument,
	            argumentText: tooltip.formatValue(initialArgument, "argument"),
	            valueText: minValue + " - " + value,
	            rangeValue1Text: minValue,
	            rangeValue2Text: value,
	            rangeValue1: initialMinValue,
	            rangeValue2: initialValue,
	            seriesName: that.series.name,
	            point: that,
	            originalMinValue: that.originalMinValue,
	            originalValue: that.originalValue,
	            originalArgument: that.originalArgument
	        }
	    },
	    getLabel: function() {
	        return [this._topLabel, this._bottomLabel]
	    },
	    getLabels: function() {
	        return [this._topLabel, this._bottomLabel]
	    },
	    getBoundingRect: $.noop,
	    coordsIn: function(x, y) {
	        var trackerRadius = this._storeTrackerR(),
	            xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius,
	            yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;
	        if (this._options.rotated) {
	            return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius)
	        } else {
	            return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius)
	        }
	    }
	});


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/range_bar_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    barPoint = __webpack_require__(309),
	    rangeSymbolPointMethods = __webpack_require__(312),
	    _extend = $.extend;
	module.exports = _extend({}, barPoint, {
	    deleteLabel: rangeSymbolPointMethods.deleteLabel,
	    _getFormatObject: rangeSymbolPointMethods._getFormatObject,
	    clearVisibility: function() {
	        var graphic = this.graphic;
	        if (graphic && graphic.attr("visibility")) {
	            graphic.attr({
	                visibility: null
	            })
	        }
	        this._topLabel.clearVisibility();
	        this._bottomLabel.clearVisibility()
	    },
	    setInvisibility: function() {
	        var graphic = this.graphic;
	        if (graphic && "hidden" !== graphic.attr("visibility")) {
	            graphic.attr({
	                visibility: "hidden"
	            })
	        }
	        this._topLabel.hide();
	        this._bottomLabel.hide()
	    },
	    getTooltipParams: function(location) {
	        var x, y, that = this,
	            edgeLocation = "edge" === location;
	        if (that._options.rotated) {
	            x = edgeLocation ? that.x + that.width : that.x + that.width / 2;
	            y = that.y + that.height / 2
	        } else {
	            x = that.x + that.width / 2;
	            y = edgeLocation ? that.y : that.y + that.height / 2
	        }
	        return {
	            x: x,
	            y: y,
	            offset: 0
	        }
	    },
	    _translate: function(translator) {
	        var that = this,
	            barMethods = barPoint;
	        barMethods._translate.call(that, translator);
	        if (that._options.rotated) {
	            that.width = that.width || 1
	        } else {
	            that.height = that.height || 1
	        }
	    },
	    _updateData: rangeSymbolPointMethods._updateData,
	    _getLabelPosition: rangeSymbolPointMethods._getLabelPosition,
	    _getLabelMinFormatObject: rangeSymbolPointMethods._getLabelMinFormatObject,
	    _updateLabelData: rangeSymbolPointMethods._updateLabelData,
	    _updateLabelOptions: rangeSymbolPointMethods._updateLabelOptions,
	    getCrosshairData: rangeSymbolPointMethods.getCrosshairData,
	    _createLabel: rangeSymbolPointMethods._createLabel,
	    _checkOverlay: rangeSymbolPointMethods._checkOverlay,
	    _checkLabelsOverlay: rangeSymbolPointMethods._checkLabelsOverlay,
	    _getOverlayCorrections: rangeSymbolPointMethods._getOverlayCorrections,
	    _drawLabel: rangeSymbolPointMethods._drawLabel,
	    _getLabelCoords: rangeSymbolPointMethods._getLabelCoords,
	    _getGraphicBBox: function(location) {
	        var isTop = "top" === location,
	            bBox = barPoint._getGraphicBBox.call(this);
	        if (!this._options.rotated) {
	            bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
	            bBox.height = 0
	        } else {
	            bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
	            bBox.width = 0
	        }
	        return bBox
	    },
	    getLabel: rangeSymbolPointMethods.getLabel,
	    getLabels: rangeSymbolPointMethods.getLabels,
	    getBoundingRect: $.noop
	});


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/candlestick_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    symbolPoint = __webpack_require__(306),
	    barPoint = __webpack_require__(309),
	    _isNumeric = $.isNumeric,
	    _extend = $.extend,
	    _math = Math,
	    _abs = _math.abs,
	    _min = _math.min,
	    _max = _math.max,
	    _round = _math.round,
	    DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;
	module.exports = _extend({}, barPoint, {
	    _getContinuousPoints: function(minValueName, maxValueName) {
	        var points, that = this,
	            x = that.x,
	            createPoint = that._options.rotated ? function(x, y) {
	                return [y, x]
	            } : function(x, y) {
	                return [x, y]
	            },
	            width = that.width,
	            min = that[minValueName],
	            max = that[maxValueName];
	        if (min === max) {
	            points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY))
	        } else {
	            points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max))
	        }
	        return points
	    },
	    _getCategoryPoints: function(y) {
	        var that = this,
	            x = that.x,
	            createPoint = that._options.rotated ? function(x, y) {
	                return [y, x]
	            } : function(x, y) {
	                return [x, y]
	            };
	        return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y))
	    },
	    _getPoints: function() {
	        var points, minValueName, maxValueName, that = this,
	            openValue = that.openValue,
	            closeValue = that.closeValue;
	        if (_isNumeric(openValue) && _isNumeric(closeValue)) {
	            minValueName = openValue > closeValue ? "closeY" : "openY";
	            maxValueName = openValue > closeValue ? "openY" : "closeY";
	            points = that._getContinuousPoints(minValueName, maxValueName)
	        } else {
	            if (openValue === closeValue) {
	                points = [that.x, that.highY, that.x, that.lowY]
	            } else {
	                points = that._getCategoryPoints(_isNumeric(openValue) ? that.openY : that.closeY)
	            }
	        }
	        return points
	    },
	    getColor: function() {
	        var that = this;
	        return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor()
	    },
	    _drawMarkerInGroup: function(group, attributes, renderer) {
	        var that = this;
	        that.graphic = renderer.path(that._getPoints(), "area").attr({
	            "stroke-linecap": "square"
	        }).attr(attributes).data({
	            "chart-data-point": that
	        }).sharp().append(group)
	    },
	    _fillStyle: function() {
	        var that = this,
	            styles = that._options.styles;
	        if (that._isReduction && that._isPositive) {
	            that._styles = styles.reductionPositive
	        } else {
	            if (that._isReduction) {
	                that._styles = styles.reduction
	            } else {
	                if (that._isPositive) {
	                    that._styles = styles.positive
	                } else {
	                    that._styles = styles
	                }
	            }
	        }
	    },
	    _getMinTrackerWidth: function() {
	        return 2 + 2 * this._styles.normal["stroke-width"]
	    },
	    correctCoordinates: function(correctOptions) {
	        var minWidth = this._getMinTrackerWidth(),
	            maxWidth = 10,
	            width = correctOptions.width;
	        width = width < minWidth ? minWidth : width > maxWidth ? maxWidth : width;
	        this.width = width + width % 2;
	        this.xCorrection = correctOptions.offset
	    },
	    _getMarkerGroup: function(group) {
	        var markerGroup, that = this;
	        if (that._isReduction && that._isPositive) {
	            markerGroup = group.reductionPositiveMarkersGroup
	        } else {
	            if (that._isReduction) {
	                markerGroup = group.reductionMarkersGroup
	            } else {
	                if (that._isPositive) {
	                    markerGroup = group.defaultPositiveMarkersGroup
	                } else {
	                    markerGroup = group.defaultMarkersGroup
	                }
	            }
	        }
	        return markerGroup
	    },
	    _drawMarker: function(renderer, group) {
	        this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer)
	    },
	    _getSettingsForTracker: function() {
	        var x, y, width, height, that = this,
	            highY = that.highY,
	            lowY = that.lowY,
	            rotated = that._options.rotated;
	        if (highY === lowY) {
	            highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;
	            lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN
	        }
	        if (rotated) {
	            x = _min(lowY, highY);
	            y = that.x - that.width / 2;
	            width = _abs(lowY - highY);
	            height = that.width
	        } else {
	            x = that.x - that.width / 2;
	            y = _min(lowY, highY);
	            width = that.width;
	            height = _abs(lowY - highY)
	        }
	        return {
	            x: x,
	            y: y,
	            width: width,
	            height: height
	        }
	    },
	    _getGraphicBBox: function() {
	        var that = this,
	            rotated = that._options.rotated,
	            x = that.x,
	            width = that.width,
	            lowY = that.lowY,
	            highY = that.highY;
	        return {
	            x: !rotated ? x - _round(width / 2) : lowY,
	            y: !rotated ? highY : x - _round(width / 2),
	            width: !rotated ? width : highY - lowY,
	            height: !rotated ? lowY - highY : width
	        }
	    },
	    getTooltipParams: function(location) {
	        var that = this;
	        if (that.graphic) {
	            var x, y, min, max, minValue = _min(that.lowY, that.highY),
	                maxValue = _max(that.lowY, that.highY),
	                visibleAreaX = that.translators.x.getCanvasVisibleArea(),
	                visibleAreaY = that.translators.y.getCanvasVisibleArea(),
	                edgeLocation = "edge" === location;
	            if (!that._options.rotated) {
	                min = _max(visibleAreaY.min, minValue);
	                max = _min(visibleAreaY.max, maxValue);
	                x = that.x;
	                y = edgeLocation ? min : min + (max - min) / 2
	            } else {
	                min = _max(visibleAreaX.min, minValue);
	                max = _min(visibleAreaX.max, maxValue);
	                y = that.x;
	                x = edgeLocation ? max : min + (max - min) / 2
	            }
	            return {
	                x: x,
	                y: y,
	                offset: 0
	            }
	        }
	    },
	    hasValue: function() {
	        return null !== this.highValue && null !== this.lowValue
	    },
	    _translate: function() {
	        var centerValue, that = this,
	            rotated = that._options.rotated,
	            translators = that.translators,
	            argTranslator = rotated ? translators.y : translators.x,
	            valTranslator = rotated ? translators.x : translators.y;
	        that.vx = that.vy = that.x = argTranslator.translate(that.argument) + (that.xCorrection || 0);
	        that.openY = null !== that.openValue ? valTranslator.translate(that.openValue) : null;
	        that.highY = valTranslator.translate(that.highValue);
	        that.lowY = valTranslator.translate(that.lowValue);
	        that.closeY = null !== that.closeValue ? valTranslator.translate(that.closeValue) : null;
	        centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;
	        that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x)
	    },
	    getCrosshairData: function(x, y) {
	        var yValue, coords, that = this,
	            rotated = that._options.rotated,
	            origY = rotated ? x : y,
	            argument = that.argument,
	            coord = "low";
	        if (_abs(that.lowY - origY) < _abs(that.closeY - origY)) {
	            yValue = that.lowY
	        } else {
	            yValue = that.closeY;
	            coord = "close"
	        }
	        if (_abs(yValue - origY) >= _abs(that.openY - origY)) {
	            yValue = that.openY;
	            coord = "open"
	        }
	        if (_abs(yValue - origY) >= _abs(that.highY - origY)) {
	            yValue = that.highY;
	            coord = "high"
	        }
	        if (rotated) {
	            coords = {
	                y: that.vy,
	                x: yValue,
	                xValue: that[coord + "Value"],
	                yValue: argument
	            }
	        } else {
	            coords = {
	                x: that.vx,
	                y: yValue,
	                xValue: argument,
	                yValue: that[coord + "Value"]
	            }
	        }
	        coords.axis = that.series.axis;
	        return coords
	    },
	    _updateData: function(data) {
	        var that = this,
	            label = that._label,
	            reductionColor = this._options.reduction.color;
	        that.value = that.initialValue = data.reductionValue;
	        that.originalValue = data.value;
	        that.lowValue = that.originalLowValue = data.lowValue;
	        that.highValue = that.originalHighValue = data.highValue;
	        that.openValue = that.originalOpenValue = data.openValue;
	        that.closeValue = that.originalCloseValue = data.closeValue;
	        that._isPositive = data.openValue < data.closeValue;
	        that._isReduction = data.isReduction;
	        if (that._isReduction) {
	            label.setColor(reductionColor)
	        }
	    },
	    _updateMarker: function(animationEnabled, style, group) {
	        var that = this,
	            graphic = that.graphic;
	        graphic.attr({
	            points: that._getPoints()
	        }).attr(style || that._getStyle()).sharp();
	        group && graphic.append(that._getMarkerGroup(group))
	    },
	    _getLabelFormatObject: function() {
	        var that = this;
	        return {
	            openValue: that.openValue,
	            highValue: that.highValue,
	            lowValue: that.lowValue,
	            closeValue: that.closeValue,
	            reductionValue: that.initialValue,
	            argument: that.initialArgument,
	            value: that.initialValue,
	            seriesName: that.series.name,
	            originalOpenValue: that.originalOpenValue,
	            originalCloseValue: that.originalCloseValue,
	            originalLowValue: that.originalLowValue,
	            originalHighValue: that.originalHighValue,
	            originalArgument: that.originalArgument,
	            point: that
	        }
	    },
	    _getFormatObject: function(tooltip) {
	        var that = this,
	            highValue = tooltip.formatValue(that.highValue),
	            openValue = tooltip.formatValue(that.openValue),
	            closeValue = tooltip.formatValue(that.closeValue),
	            lowValue = tooltip.formatValue(that.lowValue),
	            symbolMethods = symbolPoint,
	            formatObject = symbolMethods._getFormatObject.call(that, tooltip);
	        return _extend({}, formatObject, {
	            valueText: "h: " + highValue + ("" !== openValue ? " o: " + openValue : "") + ("" !== closeValue ? " c: " + closeValue : "") + " l: " + lowValue,
	            highValueText: highValue,
	            openValueText: openValue,
	            closeValueText: closeValue,
	            lowValueText: lowValue
	        })
	    }
	});


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/stock_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    candlestickPoint = __webpack_require__(314),
	    _extend = $.extend,
	    _isNumeric = $.isNumeric;
	module.exports = _extend({}, candlestickPoint, {
	    _getPoints: function() {
	        var points, that = this,
	            createPoint = that._options.rotated ? function(x, y) {
	                return [y, x]
	            } : function(x, y) {
	                return [x, y]
	            },
	            openYExist = _isNumeric(that.openY),
	            closeYExist = _isNumeric(that.closeY),
	            x = that.x,
	            width = that.width;
	        points = [].concat(createPoint(x, that.highY));
	        openYExist && (points = points.concat(createPoint(x, that.openY)));
	        openYExist && (points = points.concat(createPoint(x - width / 2, that.openY)));
	        openYExist && (points = points.concat(createPoint(x, that.openY)));
	        closeYExist && (points = points.concat(createPoint(x, that.closeY)));
	        closeYExist && (points = points.concat(createPoint(x + width / 2, that.closeY)));
	        closeYExist && (points = points.concat(createPoint(x, that.closeY)));
	        points = points.concat(createPoint(x, that.lowY));
	        return points
	    },
	    _drawMarkerInGroup: function(group, attributes, renderer) {
	        this.graphic = renderer.path(this._getPoints(), "line").attr({
	            "stroke-linecap": "square"
	        }).attr(attributes).data({
	            "chart-data-point": this
	        }).sharp().append(group)
	    },
	    _getMinTrackerWidth: function() {
	        var width = 2 + this._styles.normal["stroke-width"];
	        return width + width % 2
	    }
	});


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/points/polar_point.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _extend = $.extend,
	    commonUtils = __webpack_require__(8),
	    symbolPoint = __webpack_require__(306),
	    barPoint = __webpack_require__(309),
	    piePoint = __webpack_require__(311),
	    isDefined = commonUtils.isDefined,
	    vizUtils = __webpack_require__(291),
	    normalizeAngle = vizUtils.normalizeAngle,
	    _math = Math,
	    _max = _math.max,
	    ERROR_BARS_ANGLE_OFFSET = 90,
	    CANVAS_POSITION_START = "canvas_position_start",
	    CANVAS_POSITION_TOP = "canvas_position_top",
	    CANVAS_POSITION_END = "canvas_position_end",
	    CANVAS_POSITION_DEFAULT = "canvas_position_default";
	exports.polarSymbolPoint = _extend({}, symbolPoint, {
	    _getLabelCoords: piePoint._getLabelCoords,
	    _moveLabelOnCanvas: barPoint._moveLabelOnCanvas,
	    _getLabelPosition: function() {
	        return "outside"
	    },
	    _translate: function(translator) {
	        var that = this,
	            coord = translator.translate(that.argument, that.value),
	            center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
	        that.vx = normalizeAngle(coord.angle);
	        that.vy = that.radiusOuter = that.radiusLabels = coord.radius;
	        that.radius = coord.radius;
	        that.middleAngle = -coord.angle;
	        that.angle = -coord.angle;
	        that.x = coord.x;
	        that.y = coord.y;
	        that.defaultX = that.centerX = center.x;
	        that.defaultY = that.centerY = center.y;
	        that._translateErrorBars(translator);
	        that.inVisibleArea = true
	    },
	    _translateErrorBars: function(translator) {
	        var that = this,
	            errorBars = that._options.errorBars;
	        if (!errorBars) {
	            return
	        }
	        isDefined(that.lowError) && (that._lowErrorCoord = that.centerY - translator.translate(that.argument, that.lowError).radius);
	        isDefined(that.highError) && (that._highErrorCoord = that.centerY - translator.translate(that.argument, that.highError).radius);
	        that._errorBarPos = that.centerX;
	        that._baseErrorBarPos = "stdDeviation" === errorBars.type ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that.centerY - that.radius
	    },
	    _getTranslates: function(animationEnabled) {
	        return animationEnabled ? this.getDefaultCoords() : {
	            x: this.x,
	            y: this.y
	        }
	    },
	    getDefaultCoords: function() {
	        var cosSin = vizUtils.getCosAndSin(-this.angle),
	            radius = this.translators.translate(CANVAS_POSITION_START, CANVAS_POSITION_DEFAULT).radius,
	            x = this.defaultX + radius * cosSin.cos,
	            y = this.defaultY + radius * cosSin.sin;
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _addLabelAlignmentAndOffset: function(label, coord) {
	        return coord
	    },
	    _checkLabelPosition: function(label, coord) {
	        var that = this,
	            visibleArea = that._getVisibleArea(),
	            graphicBBox = that._getGraphicBBox();
	        if (that._isPointInVisibleArea(visibleArea, graphicBBox)) {
	            coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
	        }
	        return coord
	    },
	    _getErrorBarSettings: function(errorBarOptions, animationEnabled) {
	        var settings = symbolPoint._getErrorBarSettings.call(this, errorBarOptions, animationEnabled);
	        settings.rotate = ERROR_BARS_ANGLE_OFFSET - this.angle;
	        settings.rotateX = this.centerX;
	        settings.rotateY = this.centerY;
	        return settings
	    },
	    getCoords: function(min) {
	        return min ? this.getDefaultCoords() : {
	            x: this.x,
	            y: this.y
	        }
	    }
	});
	exports.polarBarPoint = _extend({}, barPoint, {
	    _translateErrorBars: exports.polarSymbolPoint._translateErrorBars,
	    _getErrorBarSettings: exports.polarSymbolPoint._getErrorBarSettings,
	    _moveLabelOnCanvas: barPoint._moveLabelOnCanvas,
	    _getLabelCoords: piePoint._getLabelCoords,
	    _getLabelConnector: piePoint._getLabelConnector,
	    getTooltipParams: piePoint.getTooltipParams,
	    _getLabelPosition: piePoint._getLabelPosition,
	    _translate: function(translator) {
	        var that = this,
	            maxRadius = translator.translate(CANVAS_POSITION_TOP, CANVAS_POSITION_END).radius;
	        that.radiusInner = translator.translate(that.argument, that.minValue).radius;
	        exports.polarSymbolPoint._translate.call(that, translator);
	        if (null === that.radiusInner) {
	            that.radiusInner = that.radius = maxRadius
	        } else {
	            if (null === that.radius) {
	                this.radius = this.value >= 0 ? maxRadius : 0
	            }
	        }
	        that.radiusOuter = that.radiusLabels = _max(that.radiusInner, that.radius);
	        that.radiusInner = that.defaultRadius = _math.min(that.radiusInner, that.radius);
	        that.middleAngle = that.angle = -normalizeAngle(that.middleAngleCorrection - that.angle)
	    },
	    _checkVisibility: function(translator) {
	        return translator.checkVisibility(this.radius, this.radiusInner)
	    },
	    getMarkerCoords: function() {
	        return {
	            x: this.centerX,
	            y: this.centerY,
	            outerRadius: this.radiusOuter,
	            innerRadius: this.defaultRadius,
	            startAngle: this.middleAngle - this.interval / 2,
	            endAngle: this.middleAngle + this.interval / 2
	        }
	    },
	    _drawMarker: function(renderer, group, animationEnabled) {
	        var that = this,
	            styles = that._getStyle(),
	            coords = that.getMarkerCoords(),
	            innerRadius = coords.innerRadius,
	            outerRadius = coords.outerRadius,
	            start = that.translators.translate(that.argument, CANVAS_POSITION_DEFAULT),
	            x = coords.x,
	            y = coords.y;
	        if (animationEnabled) {
	            innerRadius = 0;
	            outerRadius = 0;
	            x = start.x;
	            y = start.y
	        }
	        that.graphic = renderer.arc(x, y, innerRadius, outerRadius, coords.startAngle, coords.endAngle).attr(styles).data({
	            "chart-data-point": that
	        }).append(group)
	    },
	    _checkLabelPosition: function(label, coord) {
	        var that = this,
	            visibleArea = that._getVisibleArea(),
	            angleFunctions = vizUtils.getCosAndSin(that.middleAngle),
	            x = that.centerX + that.defaultRadius * angleFunctions.cos,
	            y = that.centerY - that.defaultRadius * angleFunctions.sin;
	        if (x > visibleArea.minX && x < visibleArea.maxX && y > visibleArea.minY && y < visibleArea.maxY) {
	            coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect())
	        }
	        return coord
	    },
	    _addLabelAlignmentAndOffset: function(label, coord) {
	        return coord
	    },
	    correctCoordinates: function(correctOptions) {
	        this.middleAngleCorrection = correctOptions.offset;
	        this.interval = correctOptions.width
	    },
	    coordsIn: function(x, y) {
	        var val = this.translators.untranslate(x, y),
	            coords = this.getMarkerCoords(),
	            isBetweenAngles = coords.startAngle < coords.endAngle ? -val.phi >= coords.startAngle && -val.phi <= coords.endAngle : -val.phi <= coords.startAngle && -val.phi >= coords.endAngle;
	        return val.r >= coords.innerRadius && val.r <= coords.outerRadius && isBetweenAngles
	    }
	});


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/scatter_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    rangeCalculator = __webpack_require__(318),
	    _each = $.each,
	    _extend = $.extend,
	    _noop = $.noop,
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _isString = commonUtils.isString,
	    vizUtils = __webpack_require__(291),
	    _map = vizUtils.map,
	    _normalizeEnum = vizUtils.normalizeEnum,
	    math = Math,
	    _floor = math.floor,
	    _abs = math.abs,
	    _sqrt = math.sqrt,
	    _min = math.min,
	    _max = math.max,
	    DEFAULT_SYMBOL_POINT_SIZE = 2,
	    DEFAULT_TRACKER_WIDTH = 12,
	    DEFAULT_DURATION = 400,
	    HIGH_ERROR = "highError",
	    LOW_ERROR = "lowError",
	    ORIGINAL = "original",
	    VARIANCE = "variance",
	    STANDARD_DEVIATION = "stddeviation",
	    STANDARD_ERROR = "stderror",
	    PERCENT = "percent",
	    FIXED = "fixed",
	    UNDEFINED = "undefined",
	    DISCRETE = "discrete",
	    LOGARITHMIC = "logarithmic",
	    DATETIME = "datetime";
	exports.chart = {};
	exports.polar = {};

	function sum(array) {
	    var result = 0;
	    _each(array, function(_, value) {
	        result += value
	    });
	    return result
	}

	function isErrorBarTypeCorrect(type) {
	    return $.inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR]) !== -1
	}

	function variance(array, expectedValue) {
	    return sum(_map(array, function(value) {
	        return (value - expectedValue) * (value - expectedValue)
	    })) / array.length
	}
	var baseScatterMethods = {
	    _defaultDuration: DEFAULT_DURATION,
	    _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,
	    _applyStyle: _noop,
	    _updateOptions: _noop,
	    _parseStyle: _noop,
	    _prepareSegment: _noop,
	    _drawSegment: _noop,
	    _generateDefaultSegments: _noop,
	    _prepareSeriesToDrawing: function() {
	        var that = this;
	        that._deleteOldAnimationMethods();
	        that._disposePoints(that._oldPoints);
	        that._oldPoints = null
	    },
	    _appendInGroup: function() {
	        this._group.append(this._extGroups.seriesGroup)
	    },
	    _createLegendState: function(styleOptions, defaultColor) {
	        return {
	            fill: styleOptions.color || defaultColor,
	            hatching: styleOptions.hatching
	        }
	    },
	    updateTemplateFieldNames: function() {
	        var that = this,
	            options = that._options;
	        options.valueField = that.getValueFields()[0] + that.name;
	        options.tagField = that.getTagField() + that.name
	    },
	    _applyElementsClipRect: function(settings) {
	        settings.clipId = this._paneClipRectID
	    },
	    _applyMarkerClipRect: function(settings) {
	        settings.clipId = this._forceClipping ? this._paneClipRectID : null
	    },
	    _createGroup: function(groupName, parent, target, settings) {
	        var group = parent[groupName] = parent[groupName] || this._renderer.g();
	        target && group.append(target);
	        settings && group.attr(settings)
	    },
	    _applyClearingSettings: function(settings) {
	        settings.opacity = null;
	        settings.scale = null;
	        if (this._options.rotated) {
	            settings.translateX = null
	        } else {
	            settings.translateY = null
	        }
	    },
	    _createGroups: function() {
	        var that = this;
	        that._createGroup("_markersGroup", that, that._group);
	        that._createGroup("_labelsGroup", that)
	    },
	    _setMarkerGroupSettings: function() {
	        var that = this,
	            settings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
	        settings.class = "dxc-markers";
	        settings.opacity = 1;
	        that._applyMarkerClipRect(settings);
	        that._markersGroup.attr(settings)
	    },
	    _applyVisibleArea: function() {
	        var that = this,
	            visibleX = that.translators.x.getCanvasVisibleArea(),
	            visibleY = that.translators.y.getCanvasVisibleArea();
	        that._visibleArea = {
	            minX: visibleX.min,
	            maxX: visibleX.max,
	            minY: visibleY.min,
	            maxY: visibleY.max
	        }
	    },
	    areErrorBarsVisible: function() {
	        var errorBarOptions = this._options.valueErrorBar;
	        return errorBarOptions && this._errorBarsEnabled() && "none" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField))
	    },
	    _createErrorBarGroup: function(animationEnabled) {
	        var settings, that = this,
	            errorBarOptions = that._options.valueErrorBar;
	        if (that.areErrorBarsVisible()) {
	            settings = {
	                "class": "dxc-error-bars",
	                stroke: errorBarOptions.color,
	                "stroke-width": errorBarOptions.lineWidth,
	                opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,
	                "stroke-linecap": "square",
	                sharp: true,
	                clipId: that._forceClipping ? that._paneClipRectID : that._widePaneClipRectID
	            };
	            that._createGroup("_errorBarGroup", that, that._group, settings)
	        }
	    },
	    _setGroupsSettings: function(animationEnabled) {
	        var that = this;
	        that._setMarkerGroupSettings();
	        that._setLabelGroupSettings(animationEnabled);
	        that._createErrorBarGroup(animationEnabled)
	    },
	    _getCreatingPointOptions: function() {
	        var defaultPointOptions, normalStyle, that = this,
	            creatingPointOptions = that._predefinedPointOptions;
	        if (!creatingPointOptions) {
	            defaultPointOptions = that._getPointOptions();
	            that._predefinedPointOptions = creatingPointOptions = _extend(true, {
	                styles: {}
	            }, defaultPointOptions);
	            normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};
	            creatingPointOptions.styles = creatingPointOptions.styles || {};
	            creatingPointOptions.styles.normal = {
	                "stroke-width": normalStyle["stroke-width"],
	                r: normalStyle.r,
	                opacity: normalStyle.opacity
	            }
	        }
	        return creatingPointOptions
	    },
	    _getPointOptions: function() {
	        return this._parsePointOptions(this._preparePointOptions(), this._options.label)
	    },
	    _getOptionsForPoint: function() {
	        return this._options.point
	    },
	    _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
	        var border = style.border || {};
	        return {
	            fill: style.color || defaultColor,
	            stroke: border.color || defaultBorderColor,
	            "stroke-width": border.visible ? border.width : 0,
	            r: style.size / 2 + (border.visible && 0 !== style.size ? ~~(border.width / 2) || 0 : 0)
	        }
	    },
	    _createPointStyles: function(pointOptions) {
	        var that = this,
	            mainPointColor = pointOptions.color || that._options.mainSeriesColor,
	            containerColor = that._options.containerBackgroundColor,
	            normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);
	        normalStyle.visibility = pointOptions.visible ? "visible" : "hidden";
	        return {
	            normal: normalStyle,
	            hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor),
	            selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor)
	        }
	    },
	    _checkData: function(data) {
	        return _isDefined(data.argument) && void 0 !== data.value
	    },
	    getErrorBarRangeCorrector: function() {
	        var mode, func;
	        if (this.areErrorBarsVisible()) {
	            mode = _normalizeEnum(this._options.valueErrorBar.displayMode);
	            func = function(point) {
	                var lowError = point.lowError,
	                    highError = point.highError;
	                switch (mode) {
	                    case "low":
	                        return [lowError];
	                    case "high":
	                        return [highError];
	                    case "none":
	                        return [];
	                    default:
	                        return [lowError, highError]
	                }
	            }
	        }
	        return func
	    },
	    _processRange: function(point, prevPoint, errorBarCorrector) {
	        rangeCalculator.processRange(this, point, prevPoint, errorBarCorrector)
	    },
	    _getRangeData: function(zoomArgs, calcIntervalFunction) {
	        rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction);
	        rangeCalculator.addLabelPaddings(this);
	        return this._rangeData
	    },
	    _getPointData: function(data, options) {
	        var pointData = {
	            value: data[options.valueField || "val"],
	            argument: data[options.argumentField || "arg"],
	            tag: data[options.tagField || "tag"]
	        };
	        this._fillErrorBars(data, pointData, options);
	        return pointData
	    },
	    _errorBarsEnabled: function() {
	        return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME
	    },
	    _fillErrorBars: function(data, pointData, options) {
	        var errorBars = options.valueErrorBar;
	        if (this.areErrorBarsVisible()) {
	            pointData.lowError = data[errorBars.lowValueField || LOW_ERROR];
	            pointData.highError = data[errorBars.highValueField || HIGH_ERROR]
	        }
	    },
	    _drawPoint: function(options) {
	        var point = options.point;
	        if (point.isInVisibleArea()) {
	            point.clearVisibility();
	            point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);
	            this._drawnPoints.push(point)
	        } else {
	            point.setInvisibility()
	        }
	    },
	    _clearingAnimation: function(translators, drawComplete) {
	        var that = this,
	            params = {
	                opacity: .001
	            },
	            options = {
	                duration: that._defaultDuration,
	                partitionDuration: .5
	            };
	        that._labelsGroup && that._labelsGroup.animate(params, options, function() {
	            that._markersGroup && that._markersGroup.animate(params, options, drawComplete)
	        })
	    },
	    _animateComplete: function() {
	        var that = this,
	            animationSettings = {
	                duration: that._defaultDuration
	            };
	        that._labelsGroup && that._labelsGroup.animate({
	            opacity: 1
	        }, animationSettings);
	        that._errorBarGroup && that._errorBarGroup.animate({
	            opacity: that._options.valueErrorBar.opacity || 1
	        }, animationSettings)
	    },
	    _animate: function() {
	        var that = this,
	            lastPointIndex = that._drawnPoints.length - 1;
	        _each(that._drawnPoints || [], function(i, p) {
	            p.animate(i === lastPointIndex ? function() {
	                that._animateComplete()
	            } : void 0, {
	                translateX: p.x,
	                translateY: p.y
	            })
	        })
	    },
	    _getPointSize: function() {
	        return this._options.point.visible ? this._options.point.size : DEFAULT_SYMBOL_POINT_SIZE
	    },
	    _calcMedianValue: function(fusionPoints, valueField) {
	        var result, allValue = _map(fusionPoints, function(point) {
	            return _isDefined(point[valueField]) ? point[valueField] : null
	        });
	        allValue.sort(function(a, b) {
	            return a - b
	        });
	        result = allValue[_floor(allValue.length / 2)];
	        return _isDefined(result) ? result : null
	    },
	    _calcErrorBarValues: function(fusionPoints) {
	        if (!fusionPoints.length) {
	            return {}
	        }
	        var lowError, highError, lowValue = fusionPoints[0].lowError,
	            highValue = fusionPoints[0].highError,
	            i = 1,
	            length = fusionPoints.length;
	        for (i; i < length; i++) {
	            lowError = fusionPoints[i].lowError;
	            highError = fusionPoints[i].highError;
	            if (_isDefined(lowError) && _isDefined(highError)) {
	                lowValue = _min(lowError, lowValue);
	                highValue = _max(highError, highValue)
	            }
	        }
	        return {
	            low: lowValue,
	            high: highValue
	        }
	    },
	    _fusionPoints: function(fusionPoints, tick, index) {
	        var errorBarValues = this._calcErrorBarValues(fusionPoints);
	        return {
	            value: this._calcMedianValue(fusionPoints, "value"),
	            argument: tick,
	            tag: null,
	            index: index,
	            seriesName: this.name,
	            lowError: errorBarValues.low,
	            highError: errorBarValues.high
	        }
	    },
	    _endUpdateData: function() {
	        delete this._predefinedPointOptions
	    },
	    getArgumentField: function() {
	        return this._options.argumentField || "arg"
	    },
	    getValueFields: function() {
	        var lowValueField, highValueField, options = this._options,
	            errorBarsOptions = options.valueErrorBar,
	            valueFields = [options.valueField || "val"];
	        if (errorBarsOptions) {
	            lowValueField = errorBarsOptions.lowValueField;
	            highValueField = errorBarsOptions.highValueField;
	            _isString(lowValueField) && valueFields.push(lowValueField);
	            _isString(highValueField) && valueFields.push(highValueField)
	        }
	        return valueFields
	    },
	    _calculateErrorBars: function(data) {
	        if (!this.areErrorBarsVisible()) {
	            return
	        }
	        var value, valueArray, valueArrayLength, meanValue, processDataItem, that = this,
	            options = that._options,
	            errorBarsOptions = options.valueErrorBar,
	            errorBarType = _normalizeEnum(errorBarsOptions.type),
	            floatErrorValue = parseFloat(errorBarsOptions.value),
	            valueField = that.getValueFields()[0],
	            lowValueField = errorBarsOptions.lowValueField || LOW_ERROR,
	            highValueField = errorBarsOptions.highValueField || HIGH_ERROR,
	            addSubError = function(_i, item) {
	                value = item[valueField];
	                item[lowValueField] = value - floatErrorValue;
	                item[highValueField] = value + floatErrorValue
	            };
	        switch (errorBarType) {
	            case FIXED:
	                processDataItem = addSubError;
	                break;
	            case PERCENT:
	                processDataItem = function(_, item) {
	                    value = item[valueField];
	                    var error = value * floatErrorValue / 100;
	                    item[lowValueField] = value - error;
	                    item[highValueField] = value + error
	                };
	                break;
	            case UNDEFINED:
	                processDataItem = function(_, item) {
	                    item[lowValueField] = item[ORIGINAL + lowValueField];
	                    item[highValueField] = item[ORIGINAL + highValueField]
	                };
	                break;
	            default:
	                valueArray = _map(data, function(item) {
	                    return _isDefined(item[valueField]) ? item[valueField] : null
	                });
	                valueArrayLength = valueArray.length;
	                floatErrorValue = floatErrorValue || 1;
	                switch (errorBarType) {
	                    case VARIANCE:
	                        floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;
	                        processDataItem = addSubError;
	                        break;
	                    case STANDARD_DEVIATION:
	                        meanValue = sum(valueArray) / valueArrayLength;
	                        floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;
	                        processDataItem = function(_, item) {
	                            item[lowValueField] = meanValue - floatErrorValue;
	                            item[highValueField] = meanValue + floatErrorValue
	                        };
	                        break;
	                    case STANDARD_ERROR:
	                        floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;
	                        processDataItem = addSubError
	                }
	        }
	        processDataItem && _each(data, processDataItem)
	    },
	    _beginUpdateData: function(data) {
	        this._calculateErrorBars(data)
	    }
	};
	exports.chart = _extend({}, baseScatterMethods, {
	    drawTrackers: function() {
	        var trackers, trackersGroup, that = this,
	            segments = that._segments || [],
	            rotated = that._options.rotated,
	            cat = [];
	        if (!that.isVisible()) {
	            return
	        }
	        if (segments.length) {
	            trackers = that._trackers = that._trackers || [];
	            trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({
	                fill: "gray",
	                opacity: .001,
	                stroke: "gray",
	                "class": "dxc-trackers"
	            })).attr({
	                clipId: this._paneClipRectID || null
	            }).append(that._group);
	            _each(segments, function(i, segment) {
	                if (!trackers[i]) {
	                    trackers[i] = that._drawTrackerElement(segment).data({
	                        "chart-data-series": that
	                    }).append(trackersGroup)
	                } else {
	                    that._updateTrackerElement(segment, trackers[i])
	                }
	            })
	        }
	        that._trackersTranslator = cat;
	        _each(that.getVisiblePoints(), function(_, p) {
	            var pointCoord = parseInt(rotated ? p.vy : p.vx);
	            if (!cat[pointCoord]) {
	                cat[pointCoord] = p
	            } else {
	                $.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p]
	            }
	        })
	    },
	    getNeighborPoint: function(x, y) {
	        var minDistance, pCoord = this._options.rotated ? y : x,
	            nCoord = pCoord,
	            cat = this._trackersTranslator,
	            point = null,
	            oppositeCoord = this._options.rotated ? x : y,
	            oppositeCoordName = this._options.rotated ? "vx" : "vy";
	        if (this.isVisible() && cat) {
	            point = cat[pCoord];
	            do {
	                point = cat[nCoord] || cat[pCoord];
	                pCoord--;
	                nCoord++
	            } while ((pCoord >= 0 || nCoord < cat.length) && !point);
	            if ($.isArray(point)) {
	                minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);
	                _each(point, function(i, p) {
	                    var distance = _abs(p[oppositeCoordName] - oppositeCoord);
	                    if (minDistance >= distance) {
	                        minDistance = distance;
	                        point = p
	                    }
	                })
	            }
	        }
	        return point
	    }
	});
	exports.polar = _extend({}, baseScatterMethods, {
	    drawTrackers: function() {
	        exports.chart.drawTrackers.call(this);
	        var index, cat = this._trackersTranslator;
	        if (!this.isVisible()) {
	            return
	        }
	        _each(cat, function(i, category) {
	            if (category) {
	                index = i;
	                return false
	            }
	        });
	        cat[index + 360] = cat[index]
	    },
	    getNeighborPoint: function(x, y) {
	        var pos = this.translators.untranslate(x, y);
	        return exports.chart.getNeighborPoint.call(this, pos.phi, pos.r)
	    },
	    _applyVisibleArea: function() {
	        var that = this,
	            canvas = that.translators.canvas;
	        that._visibleArea = {
	            minX: canvas.left,
	            maxX: canvas.width - canvas.right,
	            minY: canvas.top,
	            maxY: canvas.height - canvas.bottom
	        }
	    }
	});


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/helpers/range_data_calculator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _math = Math,
	    _abs = _math.abs,
	    _min = _math.min,
	    _max = _math.max,
	    _each = $.each,
	    _isEmptyObject = $.isEmptyObject,
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _isFinite = isFinite,
	    unique = __webpack_require__(291).unique,
	    MIN_VISIBLE = "minVisible",
	    MAX_VISIBLE = "maxVisible",
	    DISCRETE = "discrete";

	function _truncateValue(data, value) {
	    var min = data.min,
	        max = data.max;
	    data.min = value < min || !_isDefined(min) ? value : min;
	    data.max = value > max || !_isDefined(max) ? value : max
	}

	function _processValue(series, type, value, prevValue, calcInterval) {
	    var interval, isDiscrete = ("arg" === type ? series.argumentAxisType : series.valueAxisType) === DISCRETE,
	        data = series._rangeData[type],
	        minInterval = data.interval;
	    if (isDiscrete) {
	        data.categories = data.categories || [];
	        data.categories.push(value)
	    } else {
	        if (!isDiscrete) {
	            _truncateValue(data, value);
	            if ("arg" === type) {
	                interval = (_isDefined(prevValue) ? _abs(calcInterval ? calcInterval(value, prevValue) : value - prevValue) : interval) || minInterval;
	                data.interval = _isDefined(interval) && (interval < minInterval || !_isDefined(minInterval)) ? interval : minInterval
	            }
	        }
	    }
	}

	function _addToVisibleRange(series, value) {
	    var data = series._rangeData.val,
	        isDiscrete = series.valueAxisType === DISCRETE;
	    if (!isDiscrete) {
	        if (value < data.minVisible || !_isDefined(data.minVisible)) {
	            data.minVisible = value
	        }
	        if (value > data.maxVisible || !_isDefined(data.maxVisible)) {
	            data.maxVisible = value
	        }
	    }
	}

	function _processRangeValue(series, val, minVal) {
	    var data = series._rangeData.val;
	    if (series.valueAxisType === DISCRETE) {
	        data.categories = data.categories || [];
	        data.categories.push(val, minVal)
	    } else {
	        _truncateValue(data, val);
	        _truncateValue(data, minVal)
	    }
	}

	function _processZoomArgument(series, zoomArgs, isDiscrete) {
	    var minArg, maxArg, data = series._rangeData.arg;
	    if (isDiscrete) {
	        data.minVisible = zoomArgs.minArg;
	        data.maxVisible = zoomArgs.maxArg;
	        return
	    }
	    minArg = zoomArgs.minArg < zoomArgs.maxArg ? zoomArgs.minArg : zoomArgs.maxArg;
	    maxArg = zoomArgs.maxArg > zoomArgs.minArg ? zoomArgs.maxArg : zoomArgs.minArg;
	    data.min = minArg < data.min ? minArg : data.min;
	    data.max = maxArg > data.max ? maxArg : data.max;
	    data.minVisible = minArg;
	    data.maxVisible = maxArg
	}

	function _correctZoomValue(series, zoomArgs) {
	    var minVal, maxVal;
	    if (_isDefined(zoomArgs.minVal) && _isDefined(zoomArgs.maxVal)) {
	        minVal = zoomArgs.minVal < zoomArgs.maxVal ? zoomArgs.minVal : zoomArgs.maxVal;
	        maxVal = zoomArgs.maxVal > zoomArgs.minVal ? zoomArgs.maxVal : zoomArgs.minVal
	    }
	    if (_isDefined(zoomArgs.minVal)) {
	        series._rangeData.val.min = minVal < series._rangeData.val.min ? minVal : series._rangeData.val.min;
	        series._rangeData.val.minVisible = minVal
	    }
	    if (_isDefined(zoomArgs.maxVal)) {
	        series._rangeData.val.max = maxVal > series._rangeData.val.max ? maxVal : series._rangeData.val.max;
	        series._rangeData.val.maxVisible = maxVal
	    }
	}

	function _processZoomValue(series, zoomArgs) {
	    var lastVisibleIndex, adjustOnZoom = zoomArgs.adjustOnZoom,
	        points = series._points || [],
	        prevPointAdded = false,
	        rangeData = series._rangeData,
	        errorBarCorrector = series.getErrorBarRangeCorrector();
	    _each(points, function(index, point) {
	        var arg = point.argument,
	            prevPoint = index > 0 ? points[index - 1] : null;
	        if (adjustOnZoom && series.argumentAxisType !== DISCRETE && arg >= rangeData.arg.minVisible && arg <= rangeData.arg.maxVisible) {
	            if (!prevPointAdded) {
	                if (prevPoint && prevPoint.hasValue()) {
	                    _addToVisibleRange(series, prevPoint.value);
	                    _correctMinMaxByErrorBar(rangeData.val, prevPoint, errorBarCorrector, MIN_VISIBLE, MAX_VISIBLE)
	                }
	                prevPointAdded = true
	            }
	            if (point.hasValue()) {
	                _addToVisibleRange(series, point.value);
	                _correctMinMaxByErrorBar(rangeData.val, point, errorBarCorrector, MIN_VISIBLE, MAX_VISIBLE)
	            }
	            lastVisibleIndex = index
	        }
	    });
	    if (_isDefined(lastVisibleIndex) && lastVisibleIndex < points.length - 1 && points[lastVisibleIndex + 1].hasValue()) {
	        _addToVisibleRange(series, points[lastVisibleIndex + 1].value)
	    }
	    _correctZoomValue(series, zoomArgs)
	}

	function _processZoomRangeValue(series, zoomArgs, maxValueName, minValueName) {
	    var lastVisibleIndex, adjustOnZoom = zoomArgs.adjustOnZoom,
	        points = series._points || [],
	        argRangeData = series._rangeData.arg,
	        prevPointAdded = false;
	    _each(points, function(index, point) {
	        var arg = point.argument,
	            prevPoint = index > 0 ? points[index - 1] : null;
	        if (adjustOnZoom && series.argumentAxisType !== DISCRETE && arg >= argRangeData.minVisible && arg <= argRangeData.maxVisible) {
	            if (!prevPointAdded) {
	                if (prevPoint && prevPoint.hasValue()) {
	                    _addToVisibleRange(series, prevPoint[maxValueName]);
	                    _addToVisibleRange(series, prevPoint[minValueName])
	                }
	                prevPointAdded = true
	            }
	            if (point.hasValue()) {
	                _addToVisibleRange(series, point[maxValueName]);
	                _addToVisibleRange(series, point[minValueName])
	            }
	            lastVisibleIndex = index
	        }
	    });
	    if (_isDefined(lastVisibleIndex) && lastVisibleIndex < points.length - 1 && points[lastVisibleIndex + 1].hasValue()) {
	        _addToVisibleRange(series, points[lastVisibleIndex + 1].value)
	    }
	    _correctZoomValue(series, zoomArgs)
	}

	function _processNewInterval(series, calcInterval) {
	    var data = series._rangeData,
	        points = series._points || [],
	        isArgumentAxisDiscrete = series.argumentAxisType === DISCRETE;
	    delete data.arg.interval;
	    _each(points, function(index, point) {
	        var arg = point.argument,
	            prevPoint = index > 0 ? points[index - 1] : null,
	            prevArg = prevPoint && prevPoint.argument;
	        !isArgumentAxisDiscrete && _processValue(series, "arg", arg, prevArg, calcInterval)
	    })
	}

	function _fillRangeData(series) {
	    var data = series._rangeData;
	    data.val.categories && (data.val.categories = unique(data.val.categories));
	    data.arg.axisType = series.argumentAxisType;
	    data.arg.dataType = series.argumentType;
	    data.val.axisType = series.valueAxisType;
	    data.val.dataType = series.valueType
	}

	function processTwoValues(series, point, prevPoint, highValueName, lowValueName) {
	    var val = point[highValueName],
	        minVal = point[lowValueName],
	        arg = point.argument,
	        prevVal = prevPoint && prevPoint[highValueName],
	        prevMinVal = prevPoint && prevPoint[lowValueName],
	        prevArg = prevPoint && prevPoint.argument;
	    point.hasValue() && _processRangeValue(series, val, minVal, prevVal, prevMinVal);
	    _processValue(series, "arg", arg, prevArg)
	}

	function calculateRangeMinValue(series, zoomArgs) {
	    var data = series._rangeData.val,
	        minVisible = data[MIN_VISIBLE],
	        maxVisible = data[MAX_VISIBLE];
	    zoomArgs = zoomArgs || {};
	    if (data) {
	        if ("logarithmic" !== series.valueAxisType && "datetime" !== series.valueType && false !== series.showZero) {
	            data[MIN_VISIBLE] = minVisible > (zoomArgs.minVal || 0) ? zoomArgs.minVal || 0 : minVisible;
	            data[MAX_VISIBLE] = maxVisible < (zoomArgs.maxVal || 0) ? zoomArgs.maxVal || 0 : maxVisible;
	            data.min = data.min > 0 ? 0 : data.min;
	            data.max = data.max < 0 ? 0 : data.max
	        }
	    }
	}

	function processFullStackedRange(series) {
	    var data = series._rangeData.val,
	        isRangeEmpty = _isEmptyObject(data);
	    data.percentStick = true;
	    if (!isRangeEmpty) {
	        data.min = data.min > 0 ? 0 : data.min;
	        data.max = data.max < 0 ? 0 : data.max
	    }
	}

	function _correctMinMaxByErrorBar(data, point, getMinMaxCorrector, minSelector, maxSelector) {
	    if (!getMinMaxCorrector) {
	        return
	    }
	    var correctionData = getMinMaxCorrector(point),
	        minError = _min.apply(void 0, correctionData),
	        maxError = _max.apply(void 0, correctionData);
	    if (_isFinite(minError) && data[minSelector] > minError) {
	        data[minSelector] = minError
	    }
	    if (_isFinite(maxError) && data[maxSelector] < maxError) {
	        data[maxSelector] = maxError
	    }
	}

	function processRange(series, point, prevPoint, getMinMaxCorrector) {
	    var val = point.value,
	        arg = point.argument,
	        prevVal = prevPoint && prevPoint.value,
	        prevArg = prevPoint && prevPoint.argument;
	    point.hasValue() && _processValue(series, "val", val, prevVal);
	    _processValue(series, "arg", arg, prevArg);
	    _correctMinMaxByErrorBar(series._rangeData.val, point, getMinMaxCorrector, "min", "max")
	}

	function addLabelPaddings(series) {
	    var valueData, labelOptions = series.getOptions().label;
	    if (series.areLabelsVisible() && labelOptions && labelOptions.visible && "inside" !== labelOptions.position) {
	        valueData = series._rangeData.val;
	        if (valueData.min < 0) {
	            valueData.minSpaceCorrection = true
	        }
	        if (valueData.max > 0) {
	            valueData.maxSpaceCorrection = true
	        }
	    }
	}

	function addRangeSeriesLabelPaddings(series) {
	    var data = series._rangeData.val;
	    if (series.areLabelsVisible() && series._options.label.visible && "inside" !== series._options.label.position) {
	        data.minSpaceCorrection = data.maxSpaceCorrection = true
	    }
	}

	function calculateRangeData(series, zoomArgs, calcIntervalFunction, maxValueName, minValueName) {
	    var valueData = series._rangeData.val,
	        isRangeSeries = !!maxValueName && !!minValueName,
	        isDiscrete = series.argumentAxisType === DISCRETE;
	    if (zoomArgs && _isDefined(zoomArgs.minArg) && _isDefined(zoomArgs.maxArg)) {
	        if (!isDiscrete) {
	            valueData[MIN_VISIBLE] = zoomArgs.minVal;
	            valueData[MAX_VISIBLE] = zoomArgs.maxVal
	        }
	        _processZoomArgument(series, zoomArgs, isDiscrete);
	        if (isRangeSeries) {
	            _processZoomRangeValue(series, zoomArgs, maxValueName, minValueName)
	        } else {
	            _processZoomValue(series, zoomArgs)
	        }
	    } else {
	        if (!zoomArgs && calcIntervalFunction) {
	            _processNewInterval(series, calcIntervalFunction)
	        }
	    }
	    _fillRangeData(series)
	}
	module.exports = {
	    processRange: processRange,
	    calculateRangeData: calculateRangeData,
	    addLabelPaddings: addLabelPaddings,
	    addRangeSeriesLabelPaddings: addRangeSeriesLabelPaddings,
	    processFullStackedRange: processFullStackedRange,
	    calculateRangeMinValue: calculateRangeMinValue,
	    processTwoValues: processTwoValues
	};


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/line_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    series = __webpack_require__(317),
	    chartScatterSeries = series.chart,
	    polarScatterSeries = series.polar,
	    objectUtils = __webpack_require__(36),
	    vizUtils = __webpack_require__(291),
	    normalizeAngle = vizUtils.normalizeAngle,
	    CANVAS_POSITION_START = "canvas_position_start",
	    CANVAS_POSITION_TOP = "canvas_position_top",
	    DISCRETE = "discrete",
	    _map = vizUtils.map,
	    _extend = $.extend,
	    _each = $.each;
	exports.chart = {};
	exports.polar = {};

	function clonePoint(point, newX, newY, newAngle) {
	    var p = objectUtils.clone(point);
	    p.x = newX;
	    p.y = newY;
	    p.angle = newAngle;
	    return p
	}

	function getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {
	    var correctAngle = point.angle + nextStepAngle,
	        cosSin = vizUtils.getCosAndSin(correctAngle),
	        x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos,
	        y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;
	    return clonePoint(prevPoint, x, y, correctAngle)
	}
	var lineMethods = {
	    _applyGroupSettings: function(style, settings, group) {
	        var that = this;
	        settings = _extend(settings, style);
	        that._applyElementsClipRect(settings);
	        group.attr(settings)
	    },
	    _setGroupsSettings: function(animationEnabled) {
	        var that = this,
	            style = that._styles.normal;
	        that._applyGroupSettings(style.elements, {
	            "class": "dxc-elements"
	        }, that._elementsGroup);
	        that._bordersGroup && that._applyGroupSettings(style.border, {
	            "class": "dxc-borders"
	        }, that._bordersGroup);
	        chartScatterSeries._setGroupsSettings.call(that, animationEnabled);
	        animationEnabled && that._markersGroup && that._markersGroup.attr({
	            opacity: .001
	        })
	    },
	    _createGroups: function() {
	        var that = this;
	        that._createGroup("_elementsGroup", that, that._group);
	        that._areBordersVisible() && that._createGroup("_bordersGroup", that, that._group);
	        chartScatterSeries._createGroups.call(that)
	    },
	    _areBordersVisible: function() {
	        return false
	    },
	    _getDefaultSegment: function(segment) {
	        return {
	            line: _map(segment.line || [], function(pt) {
	                return pt.getDefaultCoords()
	            })
	        }
	    },
	    _prepareSegment: function(points) {
	        return {
	            line: points
	        }
	    },
	    _parseLineOptions: function(options, defaultColor) {
	        return {
	            stroke: options.color || defaultColor,
	            "stroke-width": options.width,
	            dashStyle: options.dashStyle || "solid"
	        }
	    },
	    _parseStyle: function(options, defaultColor) {
	        return {
	            elements: this._parseLineOptions(options, defaultColor)
	        }
	    },
	    _applyStyle: function(style) {
	        var that = this;
	        that._elementsGroup && that._elementsGroup.attr(style.elements);
	        _each(that._graphics || [], function(_, graphic) {
	            graphic.line && graphic.line.attr({
	                "stroke-width": style.elements["stroke-width"]
	            }).sharp()
	        })
	    },
	    _drawElement: function(segment, group) {
	        return {
	            line: this._createMainElement(segment.line, {
	                "stroke-width": this._styles.normal.elements["stroke-width"]
	            }).append(group)
	        }
	    },
	    _removeElement: function(element) {
	        element.line.remove()
	    },
	    _generateDefaultSegments: function() {
	        var that = this;
	        return _map(that._segments || [], function(segment) {
	            return that._getDefaultSegment(segment)
	        })
	    },
	    _updateElement: function(element, segment, animate, animateParams, complete) {
	        var params = {
	                points: segment.line
	            },
	            lineElement = element.line;
	        animate ? lineElement.animate(params, animateParams, complete) : lineElement.attr(params)
	    },
	    _clearingAnimation: function(translator, drawComplete) {
	        var that = this,
	            lastIndex = that._graphics.length - 1,
	            settings = {
	                opacity: .001
	            },
	            options = {
	                duration: that._defaultDuration,
	                partitionDuration: .5
	            };
	        that._labelsGroup && that._labelsGroup.animate(settings, options, function() {
	            that._markersGroup && that._markersGroup.animate(settings, options, function() {
	                _each(that._defaultSegments || [], function(i, segment) {
	                    that._oldUpdateElement(that._graphics[i], segment, true, {
	                        partitionDuration: .5
	                    }, i === lastIndex ? drawComplete : void 0)
	                })
	            })
	        })
	    },
	    _animateComplete: function() {
	        var that = this;
	        chartScatterSeries._animateComplete.call(this);
	        that._markersGroup && that._markersGroup.animate({
	            opacity: 1
	        }, {
	            duration: that._defaultDuration
	        })
	    },
	    _animate: function() {
	        var that = this,
	            lastIndex = that._graphics.length - 1;
	        _each(that._graphics || [], function(i, elem) {
	            that._updateElement(elem, that._segments[i], true, {
	                complete: i === lastIndex ? function() {
	                    that._animateComplete()
	                } : void 0
	            })
	        })
	    },
	    _drawPoint: function(options) {
	        chartScatterSeries._drawPoint.call(this, {
	            point: options.point,
	            groups: options.groups
	        })
	    },
	    _createMainElement: function(points, settings) {
	        return this._renderer.path(points, "line").attr(settings).sharp()
	    },
	    _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {
	        var that = this,
	            segment = that._prepareSegment(points, that._options.rotated, lastSegment);
	        that._segments.push(segment);
	        if (!that._graphics[segmentCount]) {
	            that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup)
	        } else {
	            if (!animationEnabled) {
	                that._updateElement(that._graphics[segmentCount], segment)
	            }
	        }
	    },
	    _getTrackerSettings: function() {
	        var that = this,
	            defaultTrackerWidth = that._defaultTrackerWidth,
	            strokeWidthFromElements = that._styles.normal.elements["stroke-width"];
	        return {
	            "stroke-width": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,
	            fill: "none"
	        }
	    },
	    _getMainPointsFromSegment: function(segment) {
	        return segment.line
	    },
	    _drawTrackerElement: function(segment) {
	        return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))
	    },
	    _updateTrackerElement: function(segment, element) {
	        var settings = this._getTrackerSettings(segment);
	        settings.points = this._getMainPointsFromSegment(segment);
	        element.attr(settings)
	    }
	};
	exports.chart.line = _extend({}, chartScatterSeries, lineMethods);
	exports.chart.stepline = _extend({}, exports.chart.line, {
	    _calculateStepLinePoints: function(points) {
	        var segment = [];
	        _each(points, function(i, pt) {
	            var stepY, point;
	            if (!i) {
	                segment.push(pt);
	                return
	            }
	            stepY = segment[segment.length - 1].y;
	            if (stepY !== pt.y) {
	                point = objectUtils.clone(pt);
	                point.y = stepY;
	                segment.push(point)
	            }
	            segment.push(pt)
	        });
	        return segment
	    },
	    _prepareSegment: function(points) {
	        return exports.chart.line._prepareSegment(this._calculateStepLinePoints(points))
	    }
	});
	exports.chart.spline = _extend({}, exports.chart.line, {
	    _calculateBezierPoints: function(src, rotated) {
	        var bezierPoints = [],
	            pointsCopy = src,
	            checkExtremum = function(otherPointCoord, pointCoord, controlCoord) {
	                return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord
	            };
	        if (1 !== pointsCopy.length) {
	            _each(pointsCopy, function(i, curPoint) {
	                var leftControlX, leftControlY, rightControlX, rightControlY, prevPoint, nextPoint, xCur, yCur, x1, x2, y1, y2, curIsExtremum, leftPoint, rightPoint, a, b, c, xc, yc, shift, lambda = .5;
	                if (!i) {
	                    bezierPoints.push(curPoint);
	                    bezierPoints.push(curPoint);
	                    return
	                }
	                prevPoint = pointsCopy[i - 1];
	                if (i < pointsCopy.length - 1) {
	                    nextPoint = pointsCopy[i + 1];
	                    xCur = curPoint.x;
	                    yCur = curPoint.y;
	                    x1 = prevPoint.x;
	                    x2 = nextPoint.x;
	                    y1 = prevPoint.y;
	                    y2 = nextPoint.y;
	                    curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
	                    if (curIsExtremum) {
	                        if (!rotated) {
	                            rightControlY = leftControlY = yCur;
	                            rightControlX = (xCur + nextPoint.x) / 2;
	                            leftControlX = (xCur + prevPoint.x) / 2
	                        } else {
	                            rightControlX = leftControlX = xCur;
	                            rightControlY = (yCur + nextPoint.y) / 2;
	                            leftControlY = (yCur + prevPoint.y) / 2
	                        }
	                    } else {
	                        a = y2 - y1;
	                        b = x1 - x2;
	                        c = y1 * x2 - x1 * y2;
	                        if (!rotated) {
	                            xc = xCur;
	                            yc = -1 * (a * xc + c) / b;
	                            shift = yc - yCur || 0;
	                            y1 -= shift;
	                            y2 -= shift
	                        } else {
	                            yc = yCur;
	                            xc = -1 * (b * yc + c) / a;
	                            shift = xc - xCur || 0;
	                            x1 -= shift;
	                            x2 -= shift
	                        }
	                        rightControlX = (xCur + lambda * x2) / (1 + lambda);
	                        rightControlY = (yCur + lambda * y2) / (1 + lambda);
	                        leftControlX = (xCur + lambda * x1) / (1 + lambda);
	                        leftControlY = (yCur + lambda * y1) / (1 + lambda)
	                    }
	                    if (!rotated) {
	                        leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);
	                        rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY)
	                    } else {
	                        leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);
	                        rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX)
	                    }
	                    leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
	                    rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
	                    bezierPoints.push(leftPoint, curPoint, rightPoint)
	                } else {
	                    bezierPoints.push(curPoint, curPoint);
	                    return
	                }
	            })
	        } else {
	            bezierPoints.push(pointsCopy[0])
	        }
	        return bezierPoints
	    },
	    _prepareSegment: function(points, rotated) {
	        return exports.chart.line._prepareSegment(this._calculateBezierPoints(points, rotated))
	    },
	    _createMainElement: function(points, settings) {
	        return this._renderer.path(points, "bezier").attr(settings).sharp()
	    }
	});
	exports.polar.line = _extend({}, polarScatterSeries, lineMethods, {
	    _prepareSegment: function(points, rotated, lastSegment) {
	        var i, preparedPoints = [],
	            centerPoint = this.translators.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
	        lastSegment && this._closeSegment(points);
	        if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {
	            for (i = 1; i < points.length; i++) {
	                preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint))
	            }
	            if (!preparedPoints.length) {
	                preparedPoints = points
	            }
	        } else {
	            return exports.chart.line._prepareSegment.apply(this, arguments)
	        }
	        return {
	            line: preparedPoints
	        }
	    },
	    _getRemainingAngle: function(angle) {
	        var normAngle = normalizeAngle(angle);
	        return angle >= 0 ? 360 - normAngle : -normAngle
	    },
	    _closeSegment: function(points) {
	        var point, differenceAngle;
	        if (this._segments.length) {
	            point = this._segments[0].line[0]
	        } else {
	            point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)
	        }
	        if (points[points.length - 1].angle !== point.angle) {
	            if (normalizeAngle(Math.round(points[points.length - 1].angle)) === normalizeAngle(Math.round(point.angle))) {
	                point.angle = points[points.length - 1].angle
	            } else {
	                differenceAngle = points[points.length - 1].angle - point.angle;
	                point.angle = points[points.length - 1].angle + this._getRemainingAngle(differenceAngle)
	            }
	            points.push(point)
	        }
	    },
	    _getTangentPoints: function(point, prevPoint, centerPoint) {
	        var i, tangentPoints = [],
	            betweenAngle = Math.round(prevPoint.angle - point.angle),
	            tan = (prevPoint.radius - point.radius) / betweenAngle;
	        if (0 === betweenAngle) {
	            tangentPoints = [prevPoint, point]
	        } else {
	            if (betweenAngle > 0) {
	                for (i = betweenAngle; i >= 0; i--) {
	                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))
	                }
	            } else {
	                for (i = 0; i >= betweenAngle; i--) {
	                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))
	                }
	            }
	        }
	        return tangentPoints
	    }
	});


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/area_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    objectUtils = __webpack_require__(36),
	    commonUtils = __webpack_require__(8),
	    rangeCalculator = __webpack_require__(318),
	    scatterSeries = __webpack_require__(317).chart,
	    lineSeries = __webpack_require__(319),
	    chartLineSeries = lineSeries.chart.line,
	    polarLineSeries = lineSeries.polar.line,
	    _map = __webpack_require__(291).map,
	    _extend = $.extend;
	exports.chart = {};
	exports.polar = {};
	var baseAreaMethods = {
	    _createBorderElement: chartLineSeries._createMainElement,
	    _createLegendState: function(styleOptions, defaultColor) {
	        var legendState = scatterSeries._createLegendState.call(this, styleOptions, defaultColor);
	        legendState.opacity = styleOptions.opacity;
	        return legendState
	    },
	    _getRangeData: function(zoomArgs, calcIntervalFunction) {
	        rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction);
	        rangeCalculator.addLabelPaddings(this);
	        rangeCalculator.calculateRangeMinValue(this, zoomArgs);
	        return this._rangeData
	    },
	    _getDefaultSegment: function(segment) {
	        var defaultSegment = chartLineSeries._getDefaultSegment(segment);
	        defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());
	        return defaultSegment
	    },
	    _updateElement: function(element, segment, animate, animateParams, complete) {
	        var lineParams = {
	                points: segment.line
	            },
	            areaParams = {
	                points: segment.area
	            },
	            borderElement = element.line;
	        if (animate) {
	            borderElement && borderElement.animate(lineParams, animateParams);
	            element.area.animate(areaParams, animateParams, complete)
	        } else {
	            borderElement && borderElement.attr(lineParams);
	            element.area.attr(areaParams)
	        }
	    },
	    _removeElement: function(element) {
	        element.line && element.line.remove();
	        element.area.remove()
	    },
	    _drawElement: function(segment) {
	        return {
	            line: this._bordersGroup && this._createBorderElement(segment.line, {
	                "stroke-width": this._styles.normal.border["stroke-width"]
	            }).append(this._bordersGroup),
	            area: this._createMainElement(segment.area).append(this._elementsGroup)
	        }
	    },
	    _applyStyle: function(style) {
	        var that = this;
	        that._elementsGroup && that._elementsGroup.attr(style.elements);
	        that._bordersGroup && that._bordersGroup.attr(style.border);
	        $.each(that._graphics || [], function(_, graphic) {
	            graphic.line && graphic.line.attr({
	                "stroke-width": style.border["stroke-width"]
	            }).sharp()
	        })
	    },
	    _createPattern: function(color, hatching) {
	        if (hatching && commonUtils.isObject(hatching)) {
	            var pattern = this._renderer.pattern(color, hatching);
	            this._patterns.push(pattern);
	            return pattern.id
	        }
	        return color
	    },
	    _parseStyle: function(options, defaultColor, defaultBorderColor) {
	        var borderOptions = options.border || {},
	            borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);
	        borderStyle["stroke-width"] = borderOptions.visible ? borderStyle["stroke-width"] : 0;
	        return {
	            border: borderStyle,
	            elements: {
	                stroke: "none",
	                fill: this._createPattern(options.color || defaultColor, options.hatching),
	                opacity: options.opacity
	            }
	        }
	    },
	    _areBordersVisible: function() {
	        var options = this._options;
	        return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible
	    },
	    _createMainElement: function(points, settings) {
	        return this._renderer.path(points, "area").attr(settings)
	    },
	    _getTrackerSettings: function(segment) {
	        return {
	            "stroke-width": segment.singlePointSegment ? this._defaultTrackerWidth : 0
	        }
	    },
	    _getMainPointsFromSegment: function(segment) {
	        return segment.area
	    }
	};
	exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {
	    _prepareSegment: function(points, rotated) {
	        var processedPoints = this._processSinglePointsAreaSegment(points, rotated);
	        return {
	            line: processedPoints,
	            area: _map(processedPoints, function(pt) {
	                return pt.getCoords()
	            }).concat(_map(processedPoints.slice().reverse(), function(pt) {
	                return pt.getCoords(true)
	            })),
	            singlePointSegment: processedPoints !== points
	        }
	    },
	    _processSinglePointsAreaSegment: function(points, rotated) {
	        if (1 === points.length) {
	            var p = points[0],
	                p1 = objectUtils.clone(p);
	            p1[rotated ? "y" : "x"] += 1;
	            p1.argument = null;
	            return [p, p1]
	        }
	        return points
	    }
	});
	exports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {
	    _prepareSegment: function(points, rotated, lastSegment) {
	        lastSegment && polarLineSeries._closeSegment.call(this, points);
	        var preparedPoints = exports.chart.area._prepareSegment.call(this, points);
	        return preparedPoints
	    },
	    _processSinglePointsAreaSegment: function(points) {
	        return lineSeries.polar.line._prepareSegment.call(this, points).line
	    }
	});
	exports.chart.steparea = _extend({}, exports.chart.area, {
	    _prepareSegment: function(points, rotated) {
	        points = exports.chart.area._processSinglePointsAreaSegment(points, rotated);
	        return exports.chart.area._prepareSegment.call(this, lineSeries.chart.stepline._calculateStepLinePoints(points))
	    }
	});
	exports.chart.splinearea = _extend({}, exports.chart.area, {
	    _areaPointsToSplineAreaPoints: function(areaPoints) {
	        var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1],
	            middlePoint = areaPoints[areaPoints.length / 2];
	        areaPoints.splice(areaPoints.length / 2, 0, {
	            x: previousMiddlePoint.x,
	            y: previousMiddlePoint.y
	        }, {
	            x: middlePoint.x,
	            y: middlePoint.y
	        })
	    },
	    _prepareSegment: function(points, rotated) {
	        var areaSeries = exports.chart.area,
	            processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated),
	            areaSegment = areaSeries._prepareSegment.call(this, lineSeries.chart.spline._calculateBezierPoints(processedPoints, rotated));
	        this._areaPointsToSplineAreaPoints(areaSegment.area);
	        areaSegment.singlePointSegment = processedPoints !== points;
	        return areaSegment
	    },
	    _getDefaultSegment: function(segment) {
	        var areaDefaultSegment = exports.chart.area._getDefaultSegment(segment);
	        this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);
	        return areaDefaultSegment
	    },
	    _createMainElement: function(points, settings) {
	        return this._renderer.path(points, "bezierarea").attr(settings)
	    },
	    _createBorderElement: lineSeries.chart.spline._createMainElement
	});


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/bar_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    scatterSeries = __webpack_require__(317),
	    areaSeries = __webpack_require__(320).chart.area,
	    chartSeries = scatterSeries.chart,
	    polarSeries = scatterSeries.polar,
	    _extend = $.extend,
	    _each = $.each,
	    DEFAULT_BAR_POINT_SIZE = 3;
	exports.chart = {};
	exports.polar = {};
	var baseBarSeriesMethods = {
	    _createPattern: areaSeries._createPattern,
	    _updateOptions: function(options) {
	        this._stackName = "axis_" + (options.axis || "default") + "_stack_" + (options.stack || "default")
	    },
	    _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
	        var color = this._createPattern(style.color || defaultColor, style.hatching),
	            base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);
	        base.fill = color;
	        base.dashStyle = style.border && style.border.dashStyle || "solid";
	        delete base.r;
	        return base
	    },
	    _applyMarkerClipRect: function(settings) {
	        settings.clipId = null
	    },
	    _clearingAnimation: function(translators, drawComplete) {
	        var that = this,
	            settings = that._oldGetAffineCoordOptions(translators) || that._getAffineCoordOptions(translators);
	        that._labelsGroup && that._labelsGroup.animate({
	            opacity: .001
	        }, {
	            duration: that._defaultDuration,
	            partitionDuration: .5
	        }, function() {
	            that._markersGroup.animate(settings, {
	                partitionDuration: .5
	            }, function() {
	                that._markersGroup.attr({
	                    scaleX: null,
	                    scaleY: null,
	                    translateX: 0,
	                    translateY: 0
	                });
	                drawComplete()
	            })
	        })
	    },
	    _setGroupsSettings: function(animationEnabled, firstDrawing) {
	        var that = this,
	            settings = {};
	        chartSeries._setGroupsSettings.apply(that, arguments);
	        if (animationEnabled && firstDrawing) {
	            settings = this._getAffineCoordOptions(that.translators, true)
	        } else {
	            if (!animationEnabled) {
	                settings = {
	                    scaleX: 1,
	                    scaleY: 1,
	                    translateX: 0,
	                    translateY: 0
	                }
	            }
	        }
	        that._markersGroup.attr(settings)
	    },
	    _drawPoint: function(options) {
	        options.hasAnimation = options.hasAnimation && !options.firstDrawing;
	        options.firstDrawing = false;
	        chartSeries._drawPoint.call(this, options)
	    },
	    _getMainColor: function() {
	        return this._options.mainSeriesColor
	    },
	    _createPointStyles: function(pointOptions) {
	        var that = this,
	            mainColor = pointOptions.color || that._getMainColor();
	        return {
	            normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
	            hover: that._parsePointStyle(pointOptions.hoverStyle || {}, mainColor, mainColor),
	            selection: that._parsePointStyle(pointOptions.selectionStyle || {}, mainColor, mainColor)
	        }
	    },
	    _updatePointsVisibility: function() {
	        var visibility = this._options.visible;
	        $.each(this._points, function(_, point) {
	            point._options.visible = visibility
	        })
	    },
	    _getOptionsForPoint: function() {
	        return this._options
	    },
	    _animate: function(firstDrawing) {
	        var that = this,
	            complete = function() {
	                that._animateComplete()
	            },
	            animateFunc = function(drawnPoints, complete) {
	                var lastPointIndex = drawnPoints.length - 1;
	                _each(drawnPoints || [], function(i, point) {
	                    point.animate(i === lastPointIndex ? complete : void 0, point.getMarkerCoords())
	                })
	            };
	        that._animatePoints(firstDrawing, complete, animateFunc)
	    },
	    _getPointSize: function() {
	        return DEFAULT_BAR_POINT_SIZE
	    },
	    _beginUpdateData: function(data) {
	        chartSeries._beginUpdateData.call(this, data);
	        this._deletePatterns()
	    }
	};
	exports.chart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {
	    _getAffineCoordOptions: function(translators) {
	        var rotated = this._options.rotated,
	            direction = rotated ? "x" : "y",
	            settings = {
	                scaleX: rotated ? .001 : 1,
	                scaleY: rotated ? 1 : .001
	            };
	        settings["translate" + direction.toUpperCase()] = translators[direction].translate("canvas_position_default");
	        return settings
	    },
	    _getRangeData: function() {
	        var rangeData = areaSeries._getRangeData.apply(this, arguments);
	        rangeData.arg.stick = false;
	        return rangeData
	    },
	    _animatePoints: function(firstDrawing, complete, animateFunc) {
	        var that = this;
	        that._markersGroup.animate({
	            scaleX: 1,
	            scaleY: 1,
	            translateY: 0,
	            translateX: 0
	        }, void 0, complete);
	        if (!firstDrawing) {
	            animateFunc(that._drawnPoints, complete)
	        }
	    }
	});
	exports.polar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {
	    _animatePoints: function(firstDrawing, complete, animateFunc) {
	        animateFunc(this._drawnPoints, complete)
	    },
	    _setGroupsSettings: chartSeries._setGroupsSettings,
	    _drawPoint: function(point, groups, animationEnabled) {
	        chartSeries._drawPoint.call(this, point, groups, animationEnabled)
	    },
	    _parsePointStyle: function(style) {
	        var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);
	        base.opacity = style.opacity;
	        return base
	    },
	    _createGroups: chartSeries._createGroups,
	    _setMarkerGroupSettings: function() {
	        var groupSettings, that = this,
	            markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
	        markersSettings.class = "dxc-markers";
	        that._applyMarkerClipRect(markersSettings);
	        groupSettings = _extend({}, markersSettings);
	        delete groupSettings.opacity;
	        that._markersGroup.attr(groupSettings)
	    },
	    _createLegendState: areaSeries._createLegendState,
	    _getRangeData: areaSeries._getRangeData
	});


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/range_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    _extend = $.extend,
	    _isDefined = commonUtils.isDefined,
	    _map = __webpack_require__(291).map,
	    _noop = $.noop,
	    rangeCalculator = __webpack_require__(318),
	    scatterSeries = __webpack_require__(317).chart,
	    barSeries = __webpack_require__(321).chart.bar,
	    areaSeries = __webpack_require__(320).chart.area;
	exports.chart = {};
	var baseRangeSeries = {
	    _beginUpdateData: _noop,
	    areErrorBarsVisible: _noop,
	    _createErrorBarGroup: _noop,
	    _checkData: function(data) {
	        return _isDefined(data.argument) && void 0 !== data.value && void 0 !== data.minValue
	    },
	    updateTemplateFieldNames: function() {
	        var that = this,
	            options = that._options,
	            valueFields = that.getValueFields(),
	            name = that.name;
	        options.rangeValue1Field = valueFields[0] + name;
	        options.rangeValue2Field = valueFields[1] + name;
	        options.tagField = that.getTagField() + name
	    },
	    _processRange: function(point, prevPoint) {
	        rangeCalculator.processTwoValues(this, point, prevPoint, "value", "minValue")
	    },
	    _getRangeData: function(zoomArgs, calcIntervalFunction) {
	        rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction, "value", "minValue");
	        rangeCalculator.addRangeSeriesLabelPaddings(this);
	        return this._rangeData
	    },
	    _getPointData: function(data, options) {
	        return {
	            tag: data[options.tagField || "tag"],
	            minValue: data[options.rangeValue1Field || "val1"],
	            value: data[options.rangeValue2Field || "val2"],
	            argument: data[options.argumentField || "arg"]
	        }
	    },
	    _fusionPoints: function(fusionPoints, tick) {
	        var calcMedianValue = scatterSeries._calcMedianValue,
	            value = calcMedianValue.call(this, fusionPoints, "value"),
	            minValue = calcMedianValue.call(this, fusionPoints, "minValue");
	        if (null === value || null === minValue) {
	            value = minValue = null
	        }
	        return {
	            minValue: minValue,
	            value: value,
	            argument: tick,
	            tag: null
	        }
	    },
	    getValueFields: function() {
	        return [this._options.rangeValue1Field || "val1", this._options.rangeValue2Field || "val2"]
	    }
	};
	exports.chart.rangebar = _extend({}, barSeries, baseRangeSeries);
	exports.chart.rangearea = _extend({}, areaSeries, {
	    _drawPoint: function(options) {
	        var point = options.point;
	        if (point.isInVisibleArea()) {
	            point.clearVisibility();
	            point.draw(this._renderer, options.groups);
	            this._drawnPoints.push(point);
	            if (!point.visibleTopMarker) {
	                point.hideMarker("top")
	            }
	            if (!point.visibleBottomMarker) {
	                point.hideMarker("bottom")
	            }
	        } else {
	            point.setInvisibility()
	        }
	    },
	    _prepareSegment: function(points, rotated) {
	        var processedPoints = this._processSinglePointsAreaSegment(points, rotated),
	            processedMinPointsCoords = _map(processedPoints, function(pt) {
	                return pt.getCoords(true)
	            });
	        return {
	            line: processedPoints,
	            bottomLine: processedMinPointsCoords,
	            area: _map(processedPoints, function(pt) {
	                return pt.getCoords()
	            }).concat(processedMinPointsCoords.slice().reverse()),
	            singlePointSegment: processedPoints !== points
	        }
	    },
	    _getDefaultSegment: function(segment) {
	        var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);
	        defaultSegment.bottomLine = defaultSegment.line;
	        return defaultSegment
	    },
	    _removeElement: function(element) {
	        areaSeries._removeElement.call(this, element);
	        element.bottomLine && element.bottomLine.remove()
	    },
	    _drawElement: function(segment, group) {
	        var that = this,
	            drawnElement = areaSeries._drawElement.call(that, segment, group);
	        drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {
	            "stroke-width": that._styles.normal.border["stroke-width"]
	        }).append(that._bordersGroup);
	        return drawnElement
	    },
	    _applyStyle: function(style) {
	        var that = this,
	            elementsGroup = that._elementsGroup,
	            bordersGroup = that._bordersGroup;
	        elementsGroup && elementsGroup.attr(style.elements);
	        bordersGroup && bordersGroup.attr(style.border);
	        $.each(that._graphics || [], function(_, graphic) {
	            graphic.line && graphic.line.attr({
	                "stroke-width": style.border["stroke-width"]
	            });
	            graphic.bottomLine && graphic.bottomLine.attr({
	                "stroke-width": style.border["stroke-width"]
	            })
	        })
	    },
	    _updateElement: function(element, segment, animate, animateParams, complete) {
	        areaSeries._updateElement.call(this, element, segment, animate, animateParams, complete);
	        var bottomLineParams = {
	                points: segment.bottomLine
	            },
	            bottomBorderElement = element.bottomLine;
	        if (bottomBorderElement) {
	            animate ? bottomBorderElement.animate(bottomLineParams, animateParams) : bottomBorderElement.attr(bottomLineParams)
	        }
	    }
	}, baseRangeSeries);


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/bubble_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    lineSeries = __webpack_require__(319).chart.line,
	    scatterSeries = __webpack_require__(317).chart,
	    areaSeries = __webpack_require__(320).chart.area,
	    barSeries = __webpack_require__(321),
	    chartBarSeries = barSeries.chart.bar,
	    polarBarSeries = barSeries.polar.bar,
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _extend = $.extend,
	    _each = $.each,
	    _noop = $.noop;
	exports.chart = {};
	exports.chart.bubble = _extend({}, scatterSeries, {
	    _fillErrorBars: _noop,
	    getErrorBarRangeCorrector: _noop,
	    _calculateErrorBars: _noop,
	    _getMainColor: chartBarSeries._getMainColor,
	    _createPointStyles: chartBarSeries._createPointStyles,
	    _createPattern: chartBarSeries._createPattern,
	    _updatePointsVisibility: chartBarSeries._updatePointsVisibility,
	    _getOptionsForPoint: chartBarSeries._getOptionsForPoint,
	    _applyMarkerClipRect: lineSeries._applyElementsClipRect,
	    _parsePointStyle: polarBarSeries._parsePointStyle,
	    _createLegendState: areaSeries._createLegendState,
	    _setMarkerGroupSettings: polarBarSeries._setMarkerGroupSettings,
	    areErrorBarsVisible: _noop,
	    _createErrorBarGroup: _noop,
	    _checkData: function(data) {
	        return _isDefined(data.argument) && _isDefined(data.size) && void 0 !== data.value
	    },
	    _getPointData: function(data, options) {
	        var pointData = scatterSeries._getPointData.call(this, data, options);
	        pointData.size = data[options.sizeField || "size"];
	        return pointData
	    },
	    _fusionPoints: function(fusionPoints, tick) {
	        var calcMedianValue = scatterSeries._calcMedianValue;
	        return {
	            size: calcMedianValue.call(this, fusionPoints, "size"),
	            value: calcMedianValue.call(this, fusionPoints, "value"),
	            argument: tick,
	            tag: null
	        }
	    },
	    getValueFields: function() {
	        return [this._options.valueField || "val"]
	    },
	    getSizeField: function() {
	        return this._options.sizeField || "size"
	    },
	    updateTemplateFieldNames: function() {
	        var that = this,
	            options = that._options,
	            name = that.name;
	        options.valueField = that.getValueFields()[0] + name;
	        options.sizeField = that.getSizeField() + name;
	        options.tagField = that.getTagField() + name
	    },
	    _clearingAnimation: function(translators, drawComplete) {
	        var that = this,
	            partitionDuration = .5,
	            lastPointIndex = that._drawnPoints.length - 1,
	            labelsGroup = that._labelsGroup;
	        labelsGroup && labelsGroup.animate({
	            opacity: .001
	        }, {
	            duration: that._defaultDuration,
	            partitionDuration: partitionDuration
	        }, function() {
	            _each(that._drawnPoints || [], function(i, p) {
	                p.animate(i === lastPointIndex ? drawComplete : void 0, {
	                    r: 0
	                }, partitionDuration)
	            })
	        })
	    },
	    _animate: function() {
	        var that = this,
	            lastPointIndex = that._drawnPoints.length - 1,
	            labelsGroup = that._labelsGroup,
	            labelAnimFunc = function() {
	                labelsGroup && labelsGroup.animate({
	                    opacity: 1
	                }, {
	                    duration: that._defaultDuration
	                })
	            };
	        _each(that._drawnPoints || [], function(i, p) {
	            p.animate(i === lastPointIndex ? labelAnimFunc : void 0, {
	                r: p.bubbleSize,
	                translateX: p.x,
	                translateY: p.y
	            })
	        })
	    },
	    _beginUpdateData: chartBarSeries._beginUpdateData
	});


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/pie_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    scatterSeries = __webpack_require__(317),
	    vizUtils = __webpack_require__(291),
	    chartScatterSeries = scatterSeries.chart,
	    barSeries = __webpack_require__(321).chart.bar,
	    _extend = $.extend,
	    _each = $.each,
	    _noop = $.noop,
	    _map = vizUtils.map,
	    _isFinite = isFinite,
	    _max = Math.max,
	    INSIDE = "inside";
	exports.pie = _extend({}, barSeries, {
	    _setGroupsSettings: chartScatterSeries._setGroupsSettings,
	    _createErrorBarGroup: _noop,
	    _drawPoint: function(options) {
	        var point = options.point,
	            legendCallback = options.legendCallback;
	        chartScatterSeries._drawPoint.call(this, options);
	        !point.isVisible() && point.setInvisibility();
	        legendCallback && point.isSelected() && legendCallback(point)("applySelected")
	    },
	    adjustLabels: function() {
	        var maxLabelLength, that = this,
	            points = that._points || [],
	            labelsBBoxes = [];
	        _each(points, function(_, point) {
	            if (point._label.isVisible()) {
	                point.setLabelTrackerData();
	                if (point._label.getLayoutOptions().position !== INSIDE) {
	                    point.setLabelEllipsis();
	                    labelsBBoxes.push(point._label.getBoundingRect().width)
	                }
	            }
	        });
	        if (labelsBBoxes.length) {
	            maxLabelLength = _max.apply(null, labelsBBoxes)
	        }
	        _each(points, function(_, point) {
	            if (point._label.isVisible() && point._label.getLayoutOptions().position !== INSIDE) {
	                point.setMaxLabelLength(maxLabelLength);
	                point.updateLabelCoord()
	            }
	        })
	    },
	    _processRange: _noop,
	    _applyElementsClipRect: _noop,
	    getColor: _noop,
	    areErrorBarsVisible: _noop,
	    _prepareSeriesToDrawing: _noop,
	    _endUpdateData: function() {
	        this._arrayArguments = {};
	        chartScatterSeries._prepareSeriesToDrawing.call(this)
	    },
	    drawLabelsWOPoints: function(translators) {
	        var that = this,
	            options = that._options,
	            points = that._points || [];
	        if (options.label.position === INSIDE) {
	            return false
	        }
	        that._labelsGroup.append(that._extGroups.labelsGroup);
	        _each(points, function(_, point) {
	            point.drawLabel(translators)
	        });
	        return true
	    },
	    _getCreatingPointOptions: function(data) {
	        return this._getPointOptions(data)
	    },
	    _updateOptions: function(options) {
	        this.labelSpace = 0;
	        this.innerRadius = "pie" === this.type ? 0 : options.innerRadius
	    },
	    _checkData: function(data) {
	        var base = barSeries._checkData(data);
	        return this._options.paintNullPoints ? base : base && null !== data.value
	    },
	    _createGroups: chartScatterSeries._createGroups,
	    _setMarkerGroupSettings: function() {
	        var that = this;
	        that._markersGroup.attr({
	            "class": "dxc-markers"
	        })
	    },
	    _getMainColor: function(data) {
	        var that = this,
	            arr = that._arrayArguments || {},
	            argument = data.argument;
	        arr[argument] = ++arr[argument] || 0;
	        that._arrayArguments = arr;
	        return that._options.mainSeriesColor(argument, arr[argument])
	    },
	    _getPointOptions: function(data) {
	        return this._parsePointOptions(this._preparePointOptions(), this._options.label, data)
	    },
	    _getRangeData: function() {
	        return this._rangeData
	    },
	    _getArrangeTotal: function(points) {
	        var total = 0;
	        _each(points, function(_, point) {
	            if (point.isVisible()) {
	                total += point.initialValue
	            }
	        });
	        return total
	    },
	    _createPointStyles: function(pointOptions, data) {
	        var that = this,
	            mainColor = pointOptions.color || that._getMainColor(data);
	        return {
	            normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
	            hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),
	            selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),
	            legendStyles: {
	                normal: that._createLegendState(pointOptions, mainColor),
	                hover: that._createLegendState(pointOptions.hoverStyle, mainColor),
	                selection: that._createLegendState(pointOptions.selectionStyle, mainColor)
	            }
	        }
	    },
	    _getArrangeMinShownValue: function(points, total) {
	        var minSegmentSize = this._options.minSegmentSize,
	            totalMinSegmentSize = 0,
	            totalNotMinValues = 0;
	        total = total || points.length;
	        _each(points, function(_, point) {
	            if (point.isVisible()) {
	                if (point.initialValue < minSegmentSize * total / 360) {
	                    totalMinSegmentSize += minSegmentSize
	                } else {
	                    totalNotMinValues += point.initialValue
	                }
	            }
	        });
	        return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0
	    },
	    _applyArrangeCorrection: function(points, minShownValue, total) {
	        var percent, options = this._options,
	            isClockWise = "anticlockwise" !== options.segmentsDirection,
	            shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0,
	            minSegmentSize = options.minSegmentSize,
	            correction = 0,
	            zeroTotalCorrection = 0;
	        if (0 === total) {
	            total = points.filter(function(el) {
	                return el.isVisible()
	            }).length;
	            zeroTotalCorrection = 1
	        }
	        _each(isClockWise ? points : points.concat([]).reverse(), function(_, point) {
	            var updatedZeroValue, val = point.isVisible() ? zeroTotalCorrection || point.initialValue : 0;
	            if (minSegmentSize && point.isVisible() && val < minShownValue) {
	                updatedZeroValue = minShownValue
	            }
	            percent = val / total;
	            point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));
	            point.shiftedAngle = shiftedAngle;
	            correction += updatedZeroValue || val
	        });
	        this._rangeData = {
	            val: {
	                min: 0,
	                max: correction
	            }
	        }
	    },
	    arrangePoints: function() {
	        var minShownValue, total, points, that = this,
	            originalPoints = that._originalPoints || [],
	            minSegmentSize = that._options.minSegmentSize,
	            isAllPointsNegative = true,
	            i = 0,
	            len = originalPoints.length;
	        while (i < len && isAllPointsNegative) {
	            isAllPointsNegative = originalPoints[i].value <= 0;
	            i++
	        }
	        points = that._originalPoints = that._points = _map(originalPoints, function(point) {
	            if (null === point.value || !isAllPointsNegative && point.value < 0) {
	                point.dispose();
	                return null
	            } else {
	                return point
	            }
	        });
	        total = that._getArrangeTotal(points);
	        if (minSegmentSize) {
	            minShownValue = this._getArrangeMinShownValue(points, total)
	        }
	        that._applyArrangeCorrection(points, minShownValue, total)
	    },
	    correctPosition: function(correction) {
	        _each(this._points, function(_, point) {
	            point.correctPosition(correction)
	        });
	        this.setVisibleArea(correction.canvas)
	    },
	    correctRadius: function(correction) {
	        _each(this._points, function(_, point) {
	            point.correctRadius(correction)
	        })
	    },
	    correctLabelRadius: function(labelRadius) {
	        _each(this._points, function(_, point) {
	            point.correctLabelRadius(labelRadius)
	        })
	    },
	    setVisibleArea: function(canvas) {
	        this._visibleArea = {
	            minX: canvas.left,
	            maxX: canvas.width - canvas.right,
	            minY: canvas.top,
	            maxY: canvas.height - canvas.bottom
	        }
	    },
	    _applyVisibleArea: _noop,
	    _animate: function(firstDrawing) {
	        var that = this,
	            index = 0,
	            timeThreshold = .2,
	            points = that._points,
	            pointsCount = points && points.length,
	            duration = 1 / (timeThreshold * (pointsCount - 1) + 1),
	            completeFunc = function() {
	                that._animateComplete()
	            },
	            animateP = function() {
	                points[index] && points[index].animate(index === pointsCount - 1 ? completeFunc : void 0, duration, stepFunc);
	                index++
	            },
	            stepFunc = function(_, progress) {
	                if (progress >= timeThreshold) {
	                    this.step = null;
	                    animateP()
	                }
	            };
	        if (firstDrawing) {
	            animateP()
	        } else {
	            $.each(points, function(i, p) {
	                p.animate(i === pointsCount - 1 ? completeFunc : void 0)
	            })
	        }
	    },
	    getVisiblePoints: function() {
	        return _map(this._points, function(p) {
	            return p.isVisible() ? p : null
	        })
	    },
	    _beginUpdateData: function() {
	        this._deletePatterns()
	    }
	});
	exports.doughnut = exports.donut = exports.pie;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/financial_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    scatterSeries = __webpack_require__(317).chart,
	    barSeries = __webpack_require__(321).chart.bar,
	    rangeCalculator = __webpack_require__(318),
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _normalizeEnum = __webpack_require__(291).normalizeEnum,
	    _extend = $.extend,
	    _each = $.each,
	    _noop = $.noop,
	    DEFAULT_FINANCIAL_POINT_SIZE = 10;
	exports.stock = _extend({}, scatterSeries, {
	    _animate: _noop,
	    _applyMarkerClipRect: function(settings) {
	        settings.clipId = this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID
	    },
	    _updatePointsVisibility: barSeries._updatePointsVisibility,
	    _getOptionsForPoint: barSeries._getOptionsForPoint,
	    getErrorBarRangeCorrector: _noop,
	    _createErrorBarGroup: _noop,
	    areErrorBarsVisible: _noop,
	    _createGroups: scatterSeries._createGroups,
	    _setMarkerGroupSettings: function() {
	        var that = this,
	            markersGroup = that._markersGroup,
	            styles = that._createPointStyles(that._getMarkerGroupOptions()),
	            defaultStyle = _extend(styles.normal, {
	                "class": "default-markers"
	            }),
	            defaultPositiveStyle = _extend(styles.positive.normal, {
	                "class": "default-positive-markers"
	            }),
	            reductionStyle = _extend(styles.reduction.normal, {
	                "class": "reduction-markers"
	            }),
	            reductionPositiveStyle = _extend(styles.reductionPositive.normal, {
	                "class": "reduction-positive-markers"
	            }),
	            markerSettings = {
	                "class": "dxc-markers"
	            };
	        that._applyMarkerClipRect(markerSettings);
	        markersGroup.attr(markerSettings);
	        that._createGroup("defaultMarkersGroup", markersGroup, markersGroup, defaultStyle);
	        that._createGroup("reductionMarkersGroup", markersGroup, markersGroup, reductionStyle);
	        that._createGroup("defaultPositiveMarkersGroup", markersGroup, markersGroup, defaultPositiveStyle);
	        that._createGroup("reductionPositiveMarkersGroup", markersGroup, markersGroup, reductionPositiveStyle)
	    },
	    _setGroupsSettings: function() {
	        scatterSeries._setGroupsSettings.call(this, false)
	    },
	    _clearingAnimation: function(translators, drawComplete) {
	        drawComplete()
	    },
	    _getCreatingPointOptions: function() {
	        var defaultPointOptions, that = this,
	            creatingPointOptions = that._predefinedPointOptions;
	        if (!creatingPointOptions) {
	            defaultPointOptions = this._getPointOptions();
	            that._predefinedPointOptions = creatingPointOptions = _extend(true, {
	                styles: {}
	            }, defaultPointOptions);
	            creatingPointOptions.styles.normal = creatingPointOptions.styles.positive.normal = creatingPointOptions.styles.reduction.normal = creatingPointOptions.styles.reductionPositive.normal = {
	                "stroke-width": defaultPointOptions.styles && defaultPointOptions.styles.normal && defaultPointOptions.styles.normal["stroke-width"]
	            }
	        }
	        return creatingPointOptions
	    },
	    _checkData: function(data) {
	        return _isDefined(data.argument) && void 0 !== data.highValue && void 0 !== data.lowValue && void 0 !== data.openValue && void 0 !== data.closeValue
	    },
	    _processRange: function(point, prevPoint) {
	        rangeCalculator.processTwoValues(this, point, prevPoint, "highValue", "lowValue")
	    },
	    _getRangeData: function(zoomArgs, calcIntervalFunction) {
	        rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction, "highValue", "lowValue");
	        rangeCalculator.addRangeSeriesLabelPaddings(this);
	        return this._rangeData
	    },
	    _getPointData: function(data, options) {
	        var level, reductionValue, that = this,
	            openValueField = options.openValueField || "open",
	            closeValueField = options.closeValueField || "close",
	            highValueField = options.highValueField || "high",
	            lowValueField = options.lowValueField || "low";
	        that.level = options.reduction.level;
	        switch (_normalizeEnum(that.level)) {
	            case "open":
	                level = openValueField;
	                break;
	            case "high":
	                level = highValueField;
	                break;
	            case "low":
	                level = lowValueField;
	                break;
	            default:
	                level = closeValueField;
	                that.level = "close"
	        }
	        reductionValue = data[level];
	        return {
	            argument: data[options.argumentField || "date"],
	            highValue: data[highValueField],
	            lowValue: data[lowValueField],
	            closeValue: data[closeValueField],
	            openValue: data[openValueField],
	            reductionValue: reductionValue,
	            tag: data[options.tagField || "tag"],
	            isReduction: that._checkReduction(reductionValue)
	        }
	    },
	    _parsePointStyle: function(style, defaultColor, innerColor) {
	        return {
	            stroke: style.color || defaultColor,
	            "stroke-width": style.width,
	            fill: style.color || innerColor
	        }
	    },
	    updateTemplateFieldNames: function() {
	        var that = this,
	            options = that._options,
	            valueFields = that.getValueFields(),
	            name = that.name;
	        options.openValueField = valueFields[0] + name;
	        options.highValueField = valueFields[1] + name;
	        options.lowValueField = valueFields[2] + name;
	        options.closeValueField = valueFields[3] + name;
	        options.tagField = that.getTagField() + name
	    },
	    _getDefaultStyle: function(options) {
	        var that = this,
	            mainPointColor = options.color || that._options.mainSeriesColor;
	        return {
	            normal: that._parsePointStyle(options, mainPointColor, mainPointColor),
	            hover: that._parsePointStyle(options.hoverStyle, mainPointColor, mainPointColor),
	            selection: that._parsePointStyle(options.selectionStyle, mainPointColor, mainPointColor)
	        }
	    },
	    _getReductionStyle: function(options) {
	        var that = this,
	            reductionColor = options.reduction.color;
	        return {
	            normal: that._parsePointStyle({
	                color: reductionColor,
	                width: options.width,
	                hatching: options.hatching
	            }, reductionColor, reductionColor),
	            hover: that._parsePointStyle(options.hoverStyle, reductionColor, reductionColor),
	            selection: that._parsePointStyle(options.selectionStyle, reductionColor, reductionColor)
	        }
	    },
	    _createPointStyles: function(pointOptions) {
	        var positiveStyle, reductionStyle, reductionPositiveStyle, that = this,
	            innerColor = that._options.innerColor,
	            styles = that._getDefaultStyle(pointOptions);
	        positiveStyle = _extend(true, {}, styles);
	        reductionStyle = that._getReductionStyle(pointOptions);
	        reductionPositiveStyle = _extend(true, {}, reductionStyle);
	        positiveStyle.normal.fill = positiveStyle.hover.fill = positiveStyle.selection.fill = innerColor;
	        reductionPositiveStyle.normal.fill = reductionPositiveStyle.hover.fill = reductionPositiveStyle.selection.fill = innerColor;
	        styles.positive = positiveStyle;
	        styles.reduction = reductionStyle;
	        styles.reductionPositive = reductionPositiveStyle;
	        return styles
	    },
	    _endUpdateData: function() {
	        delete this.prevLevelValue;
	        delete this._predefinedPointOptions
	    },
	    _checkReduction: function(value) {
	        var that = this,
	            result = false;
	        if (null !== value) {
	            if (_isDefined(that.prevLevelValue)) {
	                result = value < that.prevLevelValue
	            }
	            that.prevLevelValue = value
	        }
	        return result
	    },
	    _fusionPoints: function(fusionPoints, tick) {
	        var reductionLevel, openValue, closeValue, fusedPointData = {},
	            highValue = -(1 / 0),
	            lowValue = +(1 / 0);
	        if (!fusionPoints.length) {
	            return {}
	        }
	        _each(fusionPoints, function(_, point) {
	            if (!point.hasValue()) {
	                return
	            }
	            highValue = Math.max(highValue, point.highValue);
	            lowValue = Math.min(lowValue, point.lowValue);
	            openValue = void 0 !== openValue ? openValue : point.openValue;
	            closeValue = void 0 !== point.closeValue ? point.closeValue : closeValue
	        });
	        fusedPointData.argument = tick;
	        fusedPointData.openValue = openValue;
	        fusedPointData.closeValue = closeValue;
	        fusedPointData.highValue = highValue;
	        fusedPointData.lowValue = lowValue;
	        fusedPointData.tag = null;
	        switch (_normalizeEnum(this.level)) {
	            case "open":
	                reductionLevel = openValue;
	                break;
	            case "high":
	                reductionLevel = highValue;
	                break;
	            case "low":
	                reductionLevel = lowValue;
	                break;
	            default:
	                reductionLevel = closeValue
	        }
	        fusedPointData.reductionValue = reductionLevel;
	        fusedPointData.isReduction = this._checkReduction(reductionLevel);
	        return fusedPointData
	    },
	    _getPointSize: function() {
	        return DEFAULT_FINANCIAL_POINT_SIZE
	    },
	    getValueFields: function() {
	        var options = this._options;
	        return [options.openValueField || "open", options.highValueField || "high", options.lowValueField || "low", options.closeValueField || "close"]
	    },
	    getArgumentField: function() {
	        return this._options.argumentField || "date"
	    },
	    _beginUpdateData: _noop
	});
	exports.candlestick = _extend({}, exports.stock, {
	    _createPattern: barSeries._createPattern,
	    _beginUpdateData: barSeries._beginUpdateData,
	    _parsePointStyle: function(style, defaultColor, innerColor) {
	        var color = this._createPattern(style.color || innerColor, style.hatching),
	            base = exports.stock._parsePointStyle.call(this, style, defaultColor, color);
	        base.fill = color;
	        return base
	    }
	});


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/series/stacked_series.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    areaSeries = __webpack_require__(320).chart,
	    chartAreaSeries = areaSeries.area,
	    barSeries = __webpack_require__(321),
	    chartBarSeries = barSeries.chart.bar,
	    lineSeries = __webpack_require__(319).chart,
	    rangeCalculator = __webpack_require__(318),
	    _extend = $.extend,
	    vizUtils = __webpack_require__(291),
	    objectUtils = __webpack_require__(36),
	    _noop = $.noop,
	    baseStackedSeries = {
	        _processRange: _noop,
	        getErrorBarRangeCorrector: _noop,
	        _fillErrorBars: _noop,
	        _calculateErrorBars: _noop,
	        _processStackedRange: function() {
	            var prevPoint, that = this;
	            that._resetRangeData();
	            $.each(that.getAllPoints(), function(i, p) {
	                rangeCalculator.processRange(that, p, prevPoint);
	                prevPoint = p
	            })
	        },
	        _getRangeData: function() {
	            this._processStackedRange();
	            return chartAreaSeries._getRangeData.apply(this, arguments)
	        }
	    },
	    baseFullStackedSeries = _extend({}, baseStackedSeries, {
	        _getRangeData: function(zoomArgs, calcIntervalFunction) {
	            var that = this;
	            that._processStackedRange();
	            rangeCalculator.calculateRangeData(that, zoomArgs, calcIntervalFunction);
	            rangeCalculator.addLabelPaddings(that);
	            rangeCalculator.processFullStackedRange(that);
	            rangeCalculator.calculateRangeMinValue(that, zoomArgs);
	            return that._rangeData
	        },
	        isFullStackedSeries: function() {
	            return true
	        }
	    });
	exports.chart = {};
	exports.polar = {};
	exports.chart.stackedline = _extend({}, lineSeries.line, baseStackedSeries, {
	    _getRangeData: function() {
	        this._processStackedRange();
	        return lineSeries.line._getRangeData.apply(this, arguments)
	    }
	});
	exports.chart.stackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {
	    _getRangeData: exports.chart.stackedline._getRangeData
	});
	exports.chart.fullstackedline = _extend({}, lineSeries.line, baseFullStackedSeries, {
	    _getRangeData: function(zoomArgs, calcIntervalFunction) {
	        var that = this;
	        that._processStackedRange();
	        rangeCalculator.calculateRangeData(that, zoomArgs, calcIntervalFunction);
	        rangeCalculator.addLabelPaddings(that);
	        rangeCalculator.processFullStackedRange(that);
	        return that._rangeData
	    }
	});
	exports.chart.fullstackedspline = _extend({}, lineSeries.spline, baseFullStackedSeries, {
	    _getRangeData: exports.chart.fullstackedline._getRangeData
	});
	exports.chart.stackedbar = _extend({}, chartBarSeries, baseStackedSeries, {
	    _getRangeData: function() {
	        this._processStackedRange();
	        return chartBarSeries._getRangeData.apply(this, arguments)
	    }
	});
	exports.chart.fullstackedbar = _extend({}, chartBarSeries, baseFullStackedSeries, {
	    _getRangeData: function() {
	        var rangeData = baseFullStackedSeries._getRangeData.apply(this, arguments);
	        rangeData.arg.stick = false;
	        return rangeData
	    }
	});

	function clonePoint(point, value, minValue, position) {
	    point = objectUtils.clone(point);
	    point.value = value;
	    point.minValue = minValue;
	    point.translate();
	    point.argument = point.argument + position;
	    return point
	}

	function preparePointsForStackedAreaSegment(points) {
	    var p, array, i = 0,
	        result = [],
	        len = points.length;
	    while (i < len) {
	        p = points[i];
	        array = [p];
	        if (p.leftHole) {
	            array = [clonePoint(p, p.leftHole, p.minLeftHole, "left"), p]
	        }
	        if (p.rightHole) {
	            array.push(clonePoint(p, p.rightHole, p.minRightHole, "right"))
	        }
	        result.push(array);
	        i++
	    }
	    return [].concat.apply([], result)
	}
	exports.chart.stackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {
	    _prepareSegment: function(points, rotated) {
	        return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points, this._prevSeries), rotated)
	    },
	    _appendInGroup: function() {
	        this._group.append(this._extGroups.seriesGroup).toBackground()
	    }
	});

	function getPointsByArgFromPrevSeries(prevSeries, argument) {
	    var result;
	    while (!result && prevSeries) {
	        result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument];
	        prevSeries = prevSeries._prevSeries
	    }
	    return result
	}
	exports.chart.stackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {
	    _prepareSegment: function(points, rotated) {
	        var areaSegment, that = this;
	        points = preparePointsForStackedAreaSegment(points, that._prevSeries);
	        if (!this._prevSeries || 1 === points.length) {
	            areaSegment = areaSeries.splinearea._prepareSegment.call(this, points, rotated)
	        } else {
	            var forwardPoints = lineSeries.spline._calculateBezierPoints(points, rotated),
	                backwardPoints = vizUtils.map(points, function(p) {
	                    var point = p.getCoords(true);
	                    point.argument = p.argument;
	                    return point
	                }),
	                prevSeriesForwardPoints = [],
	                pointByArg = {},
	                i = 0,
	                len = that._prevSeries._segments.length;
	            while (i < len) {
	                prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);
	                i++
	            }
	            $.each(prevSeriesForwardPoints, function(_, p) {
	                if (null !== p.argument) {
	                    var argument = p.argument.valueOf();
	                    if (!pointByArg[argument]) {
	                        pointByArg[argument] = [p]
	                    } else {
	                        pointByArg[argument].push(p)
	                    }
	                }
	            });
	            that._prevSeries._segmentByArg = pointByArg;
	            backwardPoints = lineSeries.spline._calculateBezierPoints(backwardPoints, rotated);
	            $.each(backwardPoints, function(i, p) {
	                var prevSeriesPoints, argument = p.argument.valueOf();
	                if (i % 3 === 0) {
	                    prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);
	                    if (prevSeriesPoints) {
	                        backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);
	                        backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p)
	                    }
	                }
	            });
	            areaSegment = {
	                line: forwardPoints,
	                area: forwardPoints.concat(backwardPoints.reverse())
	            };
	            that._areaPointsToSplineAreaPoints(areaSegment.area)
	        }
	        return areaSegment
	    },
	    _appendInGroup: exports.chart.stackedarea._appendInGroup
	});
	exports.chart.fullstackedarea = _extend({}, chartAreaSeries, baseFullStackedSeries, {
	    _prepareSegment: exports.chart.stackedarea._prepareSegment,
	    _appendInGroup: exports.chart.stackedarea._appendInGroup
	});
	exports.chart.fullstackedsplinearea = _extend({}, areaSeries.splinearea, baseFullStackedSeries, {
	    _prepareSegment: exports.chart.stackedsplinearea._prepareSegment,
	    _appendInGroup: exports.chart.stackedarea._appendInGroup
	});
	exports.polar.stackedbar = _extend({}, barSeries.polar.bar, baseStackedSeries, {
	    _getRangeData: function() {
	        this._processStackedRange();
	        return barSeries.polar.bar._getRangeData.apply(this, arguments)
	    }
	});


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/components/chart_theme_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    BaseThemeManager = __webpack_require__(328).BaseThemeManager,
	    _isString = commonUtils.isString,
	    _isDefined = commonUtils.isDefined,
	    _normalizeEnum = __webpack_require__(291).normalizeEnum,
	    FONT = "font",
	    COMMON_AXIS_SETTINGS = "commonAxisSettings",
	    PIE_FONT_FIELDS = ["legend." + FONT, "title." + FONT, "title.subtitle." + FONT, "tooltip." + FONT, "loadingIndicator." + FONT, "export." + FONT, "commonSeriesSettings.label." + FONT],
	    POLAR_FONT_FIELDS = PIE_FONT_FIELDS.concat([COMMON_AXIS_SETTINGS + ".label." + FONT, COMMON_AXIS_SETTINGS + ".title." + FONT]),
	    CHART_FONT_FIELDS = POLAR_FONT_FIELDS.concat(["crosshair.label." + FONT]),
	    chartToFontFieldsMap = {
	        pie: PIE_FONT_FIELDS,
	        chart: CHART_FONT_FIELDS,
	        polar: POLAR_FONT_FIELDS
	    };
	var ThemeManager = BaseThemeManager.inherit(function() {
	    var ctor = function(options, themeGroupName) {
	        var that = this;
	        that.callBase.apply(that, arguments);
	        options = options || {};
	        that._userOptions = options;
	        that._mergeAxisTitleOptions = [];
	        that._multiPieColors = {};
	        that._themeSection = themeGroupName;
	        that._fontFields = chartToFontFieldsMap[themeGroupName];
	        that._callback = $.noop
	    };
	    var dispose = function() {
	        var that = this;
	        that.palette && that.palette.dispose();
	        that.palette = that._userOptions = that._mergedSettings = that._multiPieColors = null;
	        return that.callBase.apply(that, arguments)
	    };
	    var resetPalette = function() {
	        this.palette.reset();
	        this._multiPieColors = {}
	    };
	    var updatePalette = function(palette) {
	        this.palette = this.createPalette(palette, {
	            useHighlight: true
	        })
	    };
	    var processTitleOptions = function(options) {
	        return _isString(options) ? {
	            text: options
	        } : options
	    };
	    var processAxisOptions = function(axisOptions) {
	        if (!axisOptions) {
	            return
	        }
	        axisOptions = $.extend(true, {}, axisOptions);
	        axisOptions.title = processTitleOptions(axisOptions.title);
	        if ("logarithmic" === axisOptions.type && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !$.isNumeric(axisOptions.logarithmBase)) {
	            axisOptions.logarithmBase = void 0;
	            axisOptions.logarithmBaseError = true
	        }
	        if (axisOptions.label) {
	            if (axisOptions.label.alignment) {
	                axisOptions.label.userAlignment = true
	            }
	            if (_isString(axisOptions.label.overlappingBehavior)) {
	                axisOptions.label.overlappingBehavior = {
	                    mode: axisOptions.label.overlappingBehavior
	                }
	            }
	            if (!axisOptions.label.overlappingBehavior || !axisOptions.label.overlappingBehavior.mode) {
	                axisOptions.label.overlappingBehavior = axisOptions.label.overlappingBehavior || {}
	            }
	        }
	        return axisOptions
	    };
	    var applyParticularAxisOptions = function(name, userOptions, rotated) {
	        var theme = this._theme,
	            position = !(rotated ^ "valueAxis" === name) ? "horizontalAxis" : "verticalAxis",
	            commonAxisSettings = processAxisOptions(this._userOptions.commonAxisSettings, name);
	        return $.extend(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processAxisOptions(userOptions, name))
	    };
	    var mergeOptions = function(name, userOptions) {
	        userOptions = userOptions || this._userOptions[name];
	        var theme = this._theme[name],
	            result = this._mergedSettings[name];
	        if (result) {
	            return result
	        }
	        if ($.isPlainObject(theme) && $.isPlainObject(userOptions)) {
	            result = $.extend(true, {}, theme, userOptions)
	        } else {
	            result = _isDefined(userOptions) ? userOptions : theme
	        }
	        this._mergedSettings[name] = result;
	        return result
	    };
	    var applyParticularTheme = {
	        base: mergeOptions,
	        argumentAxis: applyParticularAxisOptions,
	        valueAxisRangeSelector: function() {
	            return mergeOptions.call(this, "valueAxis")
	        },
	        valueAxis: applyParticularAxisOptions,
	        series: function(name, userOptions) {
	            var settings, mainSeriesColor, seriesVisibility, that = this,
	                theme = that._theme,
	                userCommonSettings = that._userOptions.commonSeriesSettings || {},
	                themeCommonSettings = theme.commonSeriesSettings,
	                widgetType = that._themeSection.split(".").slice(-1)[0],
	                type = _normalizeEnum(userOptions.type || userCommonSettings.type || themeCommonSettings.type || "pie" === widgetType && theme.type),
	                palette = that.palette,
	                isBar = ~type.indexOf("bar"),
	                isLine = ~type.indexOf("line"),
	                isArea = ~type.indexOf("area"),
	                isBubble = "bubble" === type,
	                resolveLabelsOverlapping = that.getOptions("resolveLabelsOverlapping"),
	                resolveLabelOverlapping = that.getOptions("resolveLabelOverlapping"),
	                containerBackgroundColor = that.getOptions("containerBackgroundColor");
	            if (isBar || isBubble) {
	                userOptions = $.extend(true, {}, userCommonSettings, userCommonSettings[type], userOptions);
	                seriesVisibility = userOptions.visible;
	                userCommonSettings = {
	                    type: {}
	                };
	                $.extend(true, userOptions, userOptions.point);
	                userOptions.visible = seriesVisibility
	            }
	            settings = $.extend(true, {}, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);
	            settings.type = type;
	            settings.widgetType = widgetType;
	            settings.containerBackgroundColor = containerBackgroundColor;
	            if ("pie" !== widgetType) {
	                mainSeriesColor = settings.color || palette.getNextColor()
	            } else {
	                mainSeriesColor = function(argument, index) {
	                    var cat = argument + index;
	                    if (!that._multiPieColors[cat]) {
	                        that._multiPieColors[cat] = palette.getNextColor()
	                    }
	                    return that._multiPieColors[cat]
	                }
	            }
	            settings.mainSeriesColor = mainSeriesColor;
	            settings.resolveLabelOverlapping = resolveLabelOverlapping;
	            settings.resolveLabelsOverlapping = resolveLabelsOverlapping;
	            if (settings.label && (isLine || isArea && "rangearea" !== type || "scatter" === type)) {
	                settings.label.position = "outside"
	            }
	            return settings
	        },
	        animation: function(name) {
	            var userOptions = this._userOptions[name];
	            userOptions = $.isPlainObject(userOptions) ? userOptions : _isDefined(userOptions) ? {
	                enabled: !!userOptions
	            } : {};
	            return mergeOptions.call(this, name, userOptions)
	        }
	    };
	    return {
	        _themeSection: "chart",
	        ctor: ctor,
	        dispose: dispose,
	        resetPalette: resetPalette,
	        getOptions: function(name) {
	            return (applyParticularTheme[name] || applyParticularTheme.base).apply(this, arguments)
	        },
	        refresh: function() {
	            this._mergedSettings = {};
	            return this.callBase.apply(this, arguments)
	        },
	        _initializeTheme: function() {
	            var that = this;
	            that.callBase.apply(that, arguments);
	            that.updatePalette(that.getOptions("palette"))
	        },
	        resetOptions: function(name) {
	            this._mergedSettings[name] = null
	        },
	        update: function(options) {
	            this._userOptions = options
	        },
	        updatePalette: updatePalette
	    }
	}());
	exports.ThemeManager = ThemeManager;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/base_theme_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    Class = __webpack_require__(18),
	    commonUtils = __webpack_require__(8),
	    paletteModule = __webpack_require__(329),
	    _isString = commonUtils.isString,
	    _parseScalar = __webpack_require__(291).parseScalar,
	    themeModule = __webpack_require__(330),
	    _findTheme = themeModule.findTheme,
	    _addCacheItem = themeModule.addCacheItem,
	    _removeCacheItem = themeModule.removeCacheItem,
	    _extend = $.extend,
	    _each = $.each;
	__webpack_require__(331);
	__webpack_require__(332);
	__webpack_require__(333);
	__webpack_require__(334);

	function getThemePart(theme, path) {
	    var _theme = theme;
	    path && _each(path.split("."), function(_, pathItem) {
	        return _theme = _theme[pathItem]
	    });
	    return _theme
	}
	exports.BaseThemeManager = Class.inherit({
	    ctor: function() {
	        _addCacheItem(this)
	    },
	    dispose: function() {
	        var that = this;
	        _removeCacheItem(that);
	        that._callback = that._theme = that._font = null;
	        return that
	    },
	    setCallback: function(callback) {
	        this._callback = callback;
	        return this
	    },
	    setTheme: function(theme, rtl) {
	        this._current = theme;
	        this._rtl = rtl;
	        return this.refresh()
	    },
	    refresh: function() {
	        var that = this,
	            current = that._current || {},
	            theme = _findTheme(current.name || current);
	        that._themeName = theme.name;
	        that._defaultPalette = theme.defaultPalette;
	        that._font = _extend({}, theme.font, current.font);
	        that._themeSection && _each(that._themeSection.split("."), function(_, path) {
	            theme = _extend(true, {}, theme[path])
	        });
	        that._theme = _extend(true, {}, theme, _isString(current) ? {} : current);
	        that._initializeTheme();
	        if (_parseScalar(that._rtl, that._theme.rtlEnabled)) {
	            _extend(true, that._theme, that._theme._rtl)
	        }
	        that._callback();
	        return that
	    },
	    theme: function(path) {
	        return getThemePart(this._theme, path)
	    },
	    themeName: function() {
	        return this._themeName
	    },
	    createPalette: function(palette, options) {
	        return new paletteModule.Palette(palette || this._defaultPalette, options)
	    },
	    createDiscretePalette: function(palette, count) {
	        return new paletteModule.DiscretePalette(palette || this._defaultPalette, count)
	    },
	    createGradientPalette: function(palette) {
	        return new paletteModule.GradientPalette(palette || this._defaultPalette)
	    },
	    _initializeTheme: function() {
	        var that = this;
	        _each(that._fontFields || [], function(_, path) {
	            that._initializeFont(getThemePart(that._theme, path))
	        })
	    },
	    _initializeFont: function(font) {
	        _extend(font, this._font, _extend({}, font))
	    }
	});


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/palette.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    vizUtils = __webpack_require__(291),
	    _floor = Math.floor,
	    _ceil = Math.ceil,
	    _Color = __webpack_require__(24),
	    commonUtils = __webpack_require__(8),
	    _isArray = commonUtils.isArray,
	    _isString = commonUtils.isString,
	    _extend = $.extend,
	    _normalizeEnum = vizUtils.normalizeEnum,
	    HIGHLIGHTING_STEP = 50,
	    DEFAULT = "default",
	    currentPaletteName = DEFAULT;
	var palettes = {
	    "default": {
	        simpleSet: ["#5f8b95", "#ba4d51", "#af8a53", "#955f71", "#859666", "#7e688c"],
	        indicatingSet: ["#a3b97c", "#e1b676", "#ec7f83"],
	        gradientSet: ["#5f8b95", "#ba4d51"]
	    },
	    "harmony light": {
	        simpleSet: ["#fcb65e", "#679ec5", "#ad79ce", "#7abd5c", "#e18e92", "#b6d623", "#b7abea", "#85dbd5"],
	        indicatingSet: ["#b6d623", "#fcb65e", "#e18e92"],
	        gradientSet: ["#7abd5c", "#fcb65e"]
	    },
	    "soft pastel": {
	        simpleSet: ["#60a69f", "#78b6d9", "#6682bb", "#a37182", "#eeba69", "#90ba58", "#456c68", "#7565a4"],
	        indicatingSet: ["#90ba58", "#eeba69", "#a37182"],
	        gradientSet: ["#78b6d9", "#eeba69"]
	    },
	    pastel: {
	        simpleSet: ["#bb7862", "#70b3a1", "#bb626a", "#057d85", "#ab394b", "#dac599", "#153459", "#b1d2c6"],
	        indicatingSet: ["#70b3a1", "#dac599", "#bb626a"],
	        gradientSet: ["#bb7862", "#70b3a1"]
	    },
	    bright: {
	        simpleSet: ["#70c92f", "#f8ca00", "#bd1550", "#e97f02", "#9d419c", "#7e4452", "#9ab57e", "#36a3a6"],
	        indicatingSet: ["#70c92f", "#f8ca00", "#bd1550"],
	        gradientSet: ["#e97f02", "#f8ca00"]
	    },
	    soft: {
	        simpleSet: ["#cbc87b", "#9ab57e", "#e55253", "#7e4452", "#e8c267", "#565077", "#6babac", "#ad6082"],
	        indicatingSet: ["#9ab57e", "#e8c267", "#e55253"],
	        gradientSet: ["#9ab57e", "#e8c267"]
	    },
	    ocean: {
	        simpleSet: ["#75c099", "#acc371", "#378a8a", "#5fa26a", "#064970", "#38c5d2", "#00a7c6", "#6f84bb"],
	        indicatingSet: ["#c8e394", "#7bc59d", "#397c8b"],
	        gradientSet: ["#acc371", "#38c5d2"]
	    },
	    vintage: {
	        simpleSet: ["#dea484", "#efc59c", "#cb715e", "#eb9692", "#a85c4c", "#f2c0b5", "#c96374", "#dd956c"],
	        indicatingSet: ["#ffe5c6", "#f4bb9d", "#e57660"],
	        gradientSet: ["#efc59c", "#cb715e"]
	    },
	    violet: {
	        simpleSet: ["#d1a1d1", "#eeacc5", "#7b5685", "#7e7cad", "#a13d73", "#5b41ab", "#e287e2", "#689cc1"],
	        indicatingSet: ["#d8e2f6", "#d0b2da", "#d56a8a"],
	        gradientSet: ["#eeacc5", "#7b5685"]
	    }
	};

	function currentPalette(name) {
	    if (void 0 === name) {
	        return currentPaletteName
	    } else {
	        name = _normalizeEnum(name);
	        currentPaletteName = name in palettes ? name : DEFAULT
	    }
	}

	function getPalette(palette, parameters) {
	    var result, type = parameters && parameters.type;
	    if (_isArray(palette)) {
	        return palette.slice(0)
	    } else {
	        if (_isString(palette)) {
	            result = palettes[_normalizeEnum(palette)]
	        }
	        if (!result) {
	            result = palettes[currentPaletteName]
	        }
	    }
	    result = result || null;
	    return type ? result ? result[type].slice(0) : result : result
	}

	function registerPalette(name, palette) {
	    var paletteName, item = {};
	    if (_isArray(palette)) {
	        item.simpleSet = palette.slice(0)
	    } else {
	        if (palette) {
	            item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : void 0;
	            item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : void 0;
	            item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : void 0
	        }
	    }
	    if (item.simpleSet || item.indicatingSet || item.gradientSet) {
	        paletteName = _normalizeEnum(name);
	        _extend(palettes[paletteName] = palettes[paletteName] || {}, item)
	    }
	}

	function RingBuf(buf) {
	    var ind = 0;
	    this.next = function() {
	        var res = buf[ind++];
	        if (ind === buf.length) {
	            this.reset()
	        }
	        return res
	    };
	    this.reset = function() {
	        ind = 0
	    }
	}

	function Palette(palette, parameters) {
	    parameters = parameters || {};
	    var stepHighlight = parameters.useHighlight ? HIGHLIGHTING_STEP : 0;
	    this._originalPalette = getPalette(palette, {
	        type: parameters.type || "simpleSet"
	    });
	    this._paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
	    this._resetPalette()
	}
	Palette.prototype = {
	    constructor: Palette,
	    dispose: function() {
	        this._originalPalette = this._palette = this._paletteSteps = null
	    },
	    getNextColor: function() {
	        var that = this;
	        if (that._currentColor >= that._palette.length) {
	            that._resetPalette()
	        }
	        return that._palette[that._currentColor++]
	    },
	    _resetPalette: function() {
	        var that = this,
	            step = that._paletteSteps.next();
	        that._palette = step ? getAlteredPalette(that._originalPalette, step) : that._originalPalette.slice(0);
	        that._currentColor = 0
	    },
	    reset: function() {
	        this._paletteSteps.reset();
	        this._resetPalette();
	        return this
	    }
	};

	function getAlteredPalette(originalPalette, step) {
	    var i, palette = [],
	        ii = originalPalette.length;
	    for (i = 0; i < ii; ++i) {
	        palette.push(getNewColor(originalPalette[i], step))
	    }
	    return palette
	}

	function getNewColor(currentColor, step) {
	    var newColor = new _Color(currentColor).alter(step),
	        lightness = getLightness(newColor);
	    if (lightness > 200 || lightness < 55) {
	        newColor = new _Color(currentColor).alter(-step / 2)
	    }
	    return newColor.toHex()
	}

	function getLightness(color) {
	    return .3 * color.r + .59 * color.g + .11 * color.b
	}

	function DiscretePalette(source, size) {
	    var palette = size > 0 ? createDiscreteColors(getPalette(source, {
	        type: "gradientSet"
	    }), size) : [];
	    this.getColor = function(index) {
	        return palette[index] || null
	    }
	}

	function createDiscreteColors(source, count) {
	    var i, colorCount = count - 1,
	        sourceCount = source.length - 1,
	        colors = [],
	        gradient = [];

	    function addColor(pos) {
	        var k = sourceCount * pos,
	            kl = _floor(k),
	            kr = _ceil(k);
	        gradient.push(colors[kl].blend(colors[kr], k - kl).toHex())
	    }
	    for (i = 0; i <= sourceCount; ++i) {
	        colors.push(new _Color(source[i]))
	    }
	    if (colorCount > 0) {
	        for (i = 0; i <= colorCount; ++i) {
	            addColor(i / colorCount)
	        }
	    } else {
	        addColor(.5)
	    }
	    return gradient
	}

	function GradientPalette(source) {
	    var palette = getPalette(source, {
	            type: "gradientSet"
	        }),
	        color1 = new _Color(palette[0]),
	        color2 = new _Color(palette[1]);
	    this.getColor = function(ratio) {
	        return 0 <= ratio && ratio <= 1 ? color1.blend(color2, ratio).toHex() : null
	    }
	}
	_extend(exports, {
	    Palette: Palette,
	    DiscretePalette: DiscretePalette,
	    GradientPalette: GradientPalette,
	    registerPalette: registerPalette,
	    getPalette: getPalette,
	    currentPalette: currentPalette
	});


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/themes.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    vizUtils = __webpack_require__(291),
	    themes = {},
	    themesMapping = {},
	    themesSchemeMapping = {},
	    _extend = $.extend,
	    _each = $.each,
	    _normalizeEnum = vizUtils.normalizeEnum,
	    currentThemeName = null,
	    nextCacheUid = 0,
	    widgetsCache = {};

	function findTheme(themeName) {
	    var name = _normalizeEnum(themeName);
	    return themes[name] || themes[themesMapping[name] || currentThemeName]
	}

	function findThemeNameByName(name, scheme) {
	    return themesMapping[name + "." + scheme] || themesSchemeMapping[name + "." + scheme] || themesMapping[name]
	}

	function findThemeNameByPlatform(platform, version, scheme) {
	    return findThemeNameByName(platform + version, scheme) || findThemeNameByName(platform, scheme)
	}

	function currentTheme(themeName, colorScheme) {
	    if (!arguments.length) {
	        return currentThemeName
	    }
	    var scheme = _normalizeEnum(colorScheme);
	    currentThemeName = (themeName && themeName.platform ? findThemeNameByPlatform(_normalizeEnum(themeName.platform), themeName.version, scheme) : findThemeNameByName(_normalizeEnum(themeName), scheme)) || currentThemeName;
	    return this
	}

	function getThemeInfo(themeName, splitter) {
	    var k = themeName.indexOf(splitter);
	    return k > 0 ? {
	        name: themeName.substring(0, k),
	        scheme: themeName.substring(k + 1)
	    } : null
	}

	function registerThemeName(themeName, targetThemeName) {
	    var themeInfo = getThemeInfo(themeName, ".") || getThemeInfo(themeName, "-") || {
	            name: themeName
	        },
	        name = themeInfo.name,
	        scheme = themeInfo.scheme;
	    if (scheme) {
	        themesMapping[name] = themesMapping[name] || targetThemeName;
	        themesMapping[name + "." + scheme] = themesMapping[name + "-" + scheme] = targetThemeName
	    } else {
	        themesMapping[name] = targetThemeName
	    }
	}

	function registerTheme(theme, baseThemeName) {
	    var themeName = _normalizeEnum(theme && theme.name);
	    if (themeName) {
	        registerThemeName(themeName, themeName);
	        themes[themeName] = _extend(true, {}, findTheme(baseThemeName), patchTheme(theme))
	    }
	}

	function registerThemeAlias(alias, theme) {
	    registerThemeName(_normalizeEnum(alias), _normalizeEnum(theme))
	}

	function registerThemeSchemeAlias(from, to) {
	    themesSchemeMapping[from] = to
	}

	function mergeScalar(target, field, source, sourceValue) {
	    var _value = source ? source[field] : sourceValue;
	    if (void 0 !== _value && void 0 === target[field]) {
	        target[field] = _value
	    }
	}

	function mergeObject(target, field, source, sourceValue) {
	    var _value = source ? source[field] : sourceValue;
	    if (void 0 !== _value) {
	        target[field] = _extend(true, {}, _value, target[field])
	    }
	}

	function patchTheme(theme) {
	    theme = _extend(true, {
	        loadingIndicator: {
	            font: {}
	        },
	        "export": {
	            font: {}
	        },
	        legend: {
	            font: {},
	            border: {}
	        },
	        title: {
	            font: {}
	        },
	        tooltip: {
	            font: {}
	        },
	        "chart:common": {},
	        "chart:common:axis": {
	            grid: {},
	            minorGrid: {},
	            tick: {},
	            minorTick: {},
	            title: {
	                font: {}
	            },
	            label: {
	                font: {}
	            }
	        },
	        chart: {
	            commonSeriesSettings: {
	                candlestick: {}
	            }
	        },
	        pie: {},
	        polar: {},
	        gauge: {
	            scale: {
	                tick: {},
	                minorTick: {},
	                label: {
	                    font: {}
	                }
	            }
	        },
	        barGauge: {},
	        map: {
	            background: {}
	        },
	        treeMap: {
	            tile: {
	                selectionStyle: {
	                    border: {}
	                }
	            },
	            group: {
	                border: {},
	                selectionStyle: {
	                    border: {}
	                },
	                label: {
	                    font: {}
	                }
	            }
	        },
	        rangeSelector: {
	            scale: {
	                tick: {},
	                minorTick: {},
	                label: {
	                    font: {}
	                }
	            },
	            chart: {}
	        },
	        sparkline: {},
	        bullet: {}
	    }, theme);
	    mergeScalar(theme.loadingIndicator, "backgroundColor", theme);
	    mergeScalar(theme.chart.commonSeriesSettings.candlestick, "innerColor", null, theme.backgroundColor);
	    mergeScalar(theme.map.background, "color", null, theme.backgroundColor);
	    mergeScalar(theme.title.font, "color", null, theme.primaryTitleColor);
	    mergeObject(theme.title, "subtitle", null, theme.title);
	    mergeScalar(theme.legend.font, "color", null, theme.secondaryTitleColor);
	    mergeScalar(theme.legend.border, "color", null, theme.axisColor);
	    patchAxes(theme);
	    _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "rangeSelector", "sparkline", "bullet"], function(_, section) {
	        mergeScalar(theme[section], "redrawOnResize", theme);
	        mergeScalar(theme[section], "containerBackgroundColor", null, theme.backgroundColor);
	        mergeObject(theme[section], "tooltip", theme)
	    });
	    _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "rangeSelector"], function(_, section) {
	        mergeObject(theme[section], "loadingIndicator", theme);
	        mergeObject(theme[section], "export", theme);
	        mergeObject(theme[section], "legend", theme);
	        mergeObject(theme[section], "title", theme)
	    });
	    _each(["chart", "pie", "polar"], function(_, section) {
	        mergeObject(theme, section, null, theme["chart:common"])
	    });
	    _each(["chart", "polar"], function(_, section) {
	        theme[section] = theme[section] || {};
	        mergeObject(theme[section], "commonAxisSettings", null, theme["chart:common:axis"])
	    });
	    mergeObject(theme.rangeSelector.chart, "commonSeriesSettings", theme.chart);
	    mergeObject(theme.rangeSelector.chart, "dataPrepareSettings", theme.chart);
	    mergeScalar(theme.treeMap.group.border, "color", null, theme.axisColor);
	    mergeScalar(theme.treeMap.tile.selectionStyle.border, "color", null, theme.primaryTitleColor);
	    mergeScalar(theme.treeMap.group.selectionStyle.border, "color", null, theme.primaryTitleColor);
	    mergeScalar(theme.treeMap.group.label.font, "color", null, theme.secondaryTitleColor);
	    mergeScalar(theme.map.legend, "backgroundColor", theme);
	    patchMapLayers(theme);
	    return theme
	}

	function patchAxes(theme) {
	    var commonAxisSettings = theme["chart:common:axis"],
	        colorFieldName = "color";
	    _each([commonAxisSettings, commonAxisSettings.grid, commonAxisSettings.minorGrid, commonAxisSettings.tick, commonAxisSettings.minorTick], function(_, obj) {
	        mergeScalar(obj, colorFieldName, null, theme.axisColor)
	    });
	    mergeScalar(commonAxisSettings.title.font, colorFieldName, null, theme.secondaryTitleColor);
	    mergeScalar(commonAxisSettings.label.font, colorFieldName, null, theme.axisLabelColor);
	    mergeScalar(theme.gauge.scale.label.font, colorFieldName, null, theme.axisLabelColor);
	    mergeScalar(theme.gauge.scale.tick, colorFieldName, null, theme.backgroundColor);
	    mergeScalar(theme.gauge.scale.minorTick, colorFieldName, null, theme.backgroundColor);
	    mergeScalar(theme.rangeSelector.scale.tick, colorFieldName, null, theme.axisColor);
	    mergeScalar(theme.rangeSelector.scale.minorTick, colorFieldName, null, theme.axisColor);
	    mergeScalar(theme.rangeSelector.scale.label.font, colorFieldName, null, theme.axisLabelColor)
	}

	function patchMapLayers(theme) {
	    var map = theme.map;
	    _each(["area", "line", "marker"], function(_, section) {
	        mergeObject(map, "layer:" + section, null, map.layer)
	    });
	    _each(["dot", "bubble", "pie", "image"], function(_, section) {
	        mergeObject(map, "layer:marker:" + section, null, map["layer:marker"])
	    })
	}

	function addCacheItem(target) {
	    var cacheUid = ++nextCacheUid;
	    target._cache = cacheUid;
	    widgetsCache[cacheUid] = target
	}

	function removeCacheItem(target) {
	    delete widgetsCache[target._cache]
	}

	function refreshAll() {
	    _each(widgetsCache, function() {
	        this.refresh()
	    });
	    return this
	}
	_extend(exports, {
	    currentTheme: currentTheme,
	    registerTheme: registerTheme,
	    findTheme: findTheme,
	    registerThemeAlias: registerThemeAlias,
	    registerThemeSchemeAlias: registerThemeSchemeAlias,
	    refreshAll: refreshAll,
	    addCacheItem: addCacheItem,
	    removeCacheItem: removeCacheItem
	});


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/default.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var WHITE = "#ffffff",
	    BLACK = "#000000",
	    LIGHT_GREY = "#d3d3d3",
	    GREY_GREEN = "#303030",
	    SOME_GREY = "#2b2b2b",
	    RED = "#ff0000",
	    PRIMARY_TITLE_COLOR = "#232323",
	    SECONDARY_TITLE_COLOR = "#767676",
	    CONTRAST_ACTIVE = "#cf00da",
	    MARKER_COLOR = "#f8ca00",
	    TARGET_COLOR = "#8e8e8e",
	    POSITIVE_COLOR = "#b8b8b8",
	    LINE_COLOR = "#c7c7c7",
	    AREA_LAYER_COLOR = "#686868",
	    RANGE_COLOR = "#b5b5b5",
	    NONE = "none",
	    SOLID = "solid",
	    TOP = "top",
	    RIGHT = "right",
	    BOTTOM = "bottom",
	    LEFT = "left",
	    CENTER = "center",
	    INSIDE = "inside",
	    OUTSIDE = "outside",
	    themeModule = __webpack_require__(330),
	    registerTheme = themeModule.registerTheme,
	    registerThemeAlias = themeModule.registerThemeAlias;
	registerTheme({
	    name: "generic.light",
	    font: {
	        color: SECONDARY_TITLE_COLOR,
	        family: "'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana",
	        weight: 400,
	        size: 12,
	        cursor: "default"
	    },
	    redrawOnResize: true,
	    backgroundColor: WHITE,
	    primaryTitleColor: PRIMARY_TITLE_COLOR,
	    secondaryTitleColor: SECONDARY_TITLE_COLOR,
	    axisColor: LIGHT_GREY,
	    axisLabelColor: SECONDARY_TITLE_COLOR,
	    title: {
	        backgroundColor: WHITE,
	        font: {
	            size: 28,
	            family: "'Segoe UI Light', 'Helvetica Neue Light', 'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana",
	            weight: 200
	        },
	        subtitle: {
	            font: {
	                size: 16
	            }
	        }
	    },
	    loadingIndicator: {
	        text: "Loading..."
	    },
	    "export": {
	        backgroundColor: WHITE,
	        font: {
	            size: 14,
	            color: PRIMARY_TITLE_COLOR,
	            weight: 400
	        },
	        button: {
	            "default": {
	                color: "#333",
	                borderColor: "#ddd",
	                backgroundColor: WHITE
	            },
	            hover: {
	                color: "#333",
	                borderColor: "#bebebe",
	                backgroundColor: "#e6e6e6"
	            },
	            focus: {
	                color: BLACK,
	                borderColor: "#9d9d9d",
	                backgroundColor: "#e6e6e6"
	            },
	            active: {
	                color: "#333",
	                borderColor: "#9d9d9d",
	                backgroundColor: "#d4d4d4"
	            }
	        },
	        shadowColor: LIGHT_GREY
	    },
	    tooltip: {
	        enabled: false,
	        border: {
	            width: 1,
	            color: LIGHT_GREY,
	            dashStyle: SOLID,
	            visible: true
	        },
	        font: {
	            color: PRIMARY_TITLE_COLOR
	        },
	        color: WHITE,
	        arrowLength: 10,
	        paddingLeftRight: 18,
	        paddingTopBottom: 15,
	        shared: false,
	        location: CENTER,
	        shadow: {
	            opacity: .4,
	            offsetX: 0,
	            offsetY: 4,
	            blur: 2,
	            color: BLACK
	        }
	    },
	    legend: {
	        hoverMode: "includePoints",
	        verticalAlignment: TOP,
	        horizontalAlignment: RIGHT,
	        position: OUTSIDE,
	        visible: true,
	        margin: 10,
	        markerSize: 12,
	        border: {
	            visible: false,
	            width: 1,
	            cornerRadius: 0,
	            dashStyle: SOLID
	        },
	        paddingLeftRight: 20,
	        paddingTopBottom: 15,
	        columnCount: 0,
	        rowCount: 0,
	        columnItemSpacing: 20,
	        rowItemSpacing: 8
	    },
	    "chart:common": {
	        animation: {
	            enabled: true,
	            duration: 1e3,
	            easing: "easeOutCubic",
	            maxPointCountSupported: 300
	        },
	        commonSeriesSettings: {
	            border: {
	                visible: false,
	                width: 2
	            },
	            showInLegend: true,
	            visible: true,
	            hoverMode: "nearestPoint",
	            selectionMode: "includePoints",
	            hoverStyle: {
	                hatching: {
	                    direction: RIGHT,
	                    width: 2,
	                    step: 6,
	                    opacity: .75
	                },
	                border: {
	                    visible: false,
	                    width: 3
	                }
	            },
	            selectionStyle: {
	                hatching: {
	                    direction: RIGHT,
	                    width: 2,
	                    step: 6,
	                    opacity: .5
	                },
	                border: {
	                    visible: false,
	                    width: 3
	                }
	            },
	            valueErrorBar: {
	                displayMode: "auto",
	                value: 1,
	                color: BLACK,
	                lineWidth: 2,
	                edgeLength: 8
	            },
	            label: {
	                visible: false,
	                alignment: CENTER,
	                rotationAngle: 0,
	                horizontalOffset: 0,
	                verticalOffset: 0,
	                radialOffset: 0,
	                showForZeroValues: true,
	                customizeText: void 0,
	                maxLabelCount: void 0,
	                position: OUTSIDE,
	                font: {
	                    color: WHITE
	                },
	                border: {
	                    visible: false,
	                    width: 1,
	                    color: LIGHT_GREY,
	                    dashStyle: SOLID
	                },
	                connector: {
	                    visible: false,
	                    width: 1
	                }
	            }
	        },
	        seriesSelectionMode: "single",
	        pointSelectionMode: "single",
	        equalRowHeight: true,
	        dataPrepareSettings: {
	            checkTypeForAllData: false,
	            convertToAxisDataType: true,
	            sortingMethod: true
	        },
	        title: {
	            margin: 10
	        },
	        adaptiveLayout: {
	            width: 80,
	            height: 80,
	            keepLabels: true
	        },
	        _rtl: {
	            legend: {
	                itemTextPosition: LEFT
	            }
	        },
	        resolveLabelOverlapping: NONE
	    },
	    "chart:common:axis": {
	        visible: false,
	        setTicksAtUnitBeginning: true,
	        valueMarginsEnabled: true,
	        placeholderSize: null,
	        logarithmBase: 10,
	        discreteAxisDivisionMode: "betweenLabels",
	        width: 1,
	        label: {
	            visible: true
	        },
	        grid: {
	            visible: false,
	            width: 1
	        },
	        minorGrid: {
	            visible: false,
	            width: 1,
	            opacity: .3
	        },
	        tick: {
	            visible: false,
	            width: 1,
	            length: 8
	        },
	        minorTick: {
	            visible: false,
	            width: 1,
	            opacity: .3,
	            length: 8
	        },
	        stripStyle: {
	            paddingLeftRight: 10,
	            paddingTopBottom: 5
	        },
	        constantLineStyle: {
	            width: 1,
	            color: BLACK,
	            dashStyle: SOLID,
	            label: {
	                visible: true,
	                position: INSIDE
	            }
	        },
	        marker: {
	            label: {}
	        }
	    },
	    chart: {
	        commonSeriesSettings: {
	            type: "line",
	            stack: "default",
	            point: {
	                visible: true,
	                symbol: "circle",
	                size: 12,
	                border: {
	                    visible: false,
	                    width: 1
	                },
	                hoverMode: "onlyPoint",
	                selectionMode: "onlyPoint",
	                hoverStyle: {
	                    border: {
	                        visible: true,
	                        width: 4
	                    },
	                    size: 12
	                },
	                selectionStyle: {
	                    border: {
	                        visible: true,
	                        width: 4
	                    },
	                    size: 12
	                }
	            },
	            scatter: {},
	            line: {
	                width: 2,
	                dashStyle: SOLID,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            stackedline: {
	                width: 2,
	                dashStyle: SOLID,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            stackedspline: {
	                width: 2,
	                dashStyle: SOLID,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            fullstackedline: {
	                width: 2,
	                dashStyle: SOLID,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            fullstackedspline: {
	                width: 2,
	                dashStyle: SOLID,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            stepline: {
	                width: 2,
	                dashStyle: SOLID,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            area: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            stackedarea: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            fullstackedarea: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            fullstackedsplinearea: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            steparea: {
	                border: {
	                    visible: true,
	                    width: 2
	                },
	                point: {
	                    visible: false
	                },
	                hoverStyle: {
	                    border: {
	                        visible: true,
	                        width: 3
	                    }
	                },
	                selectionStyle: {
	                    border: {
	                        visible: true,
	                        width: 3
	                    }
	                },
	                opacity: .5
	            },
	            spline: {
	                width: 2,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            splinearea: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            stackedsplinearea: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            bar: {
	                cornerRadius: 0,
	                point: {
	                    hoverStyle: {
	                        border: {
	                            visible: false
	                        }
	                    },
	                    selectionStyle: {
	                        border: {
	                            visible: false
	                        }
	                    }
	                }
	            },
	            stackedbar: {
	                cornerRadius: 0,
	                point: {
	                    hoverStyle: {
	                        border: {
	                            visible: false
	                        }
	                    },
	                    selectionStyle: {
	                        border: {
	                            visible: false
	                        }
	                    }
	                },
	                label: {
	                    position: INSIDE
	                }
	            },
	            fullstackedbar: {
	                cornerRadius: 0,
	                point: {
	                    hoverStyle: {
	                        border: {
	                            visible: false
	                        }
	                    },
	                    selectionStyle: {
	                        border: {
	                            visible: false
	                        }
	                    }
	                },
	                label: {
	                    position: INSIDE
	                }
	            },
	            rangebar: {
	                cornerRadius: 0,
	                point: {
	                    hoverStyle: {
	                        border: {
	                            visible: false
	                        }
	                    },
	                    selectionStyle: {
	                        border: {
	                            visible: false
	                        }
	                    }
	                }
	            },
	            rangearea: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            rangesplinearea: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            bubble: {
	                opacity: .5,
	                point: {
	                    hoverStyle: {
	                        border: {
	                            visible: false
	                        }
	                    },
	                    selectionStyle: {
	                        border: {
	                            visible: false
	                        }
	                    }
	                }
	            },
	            candlestick: {
	                width: 1,
	                reduction: {
	                    color: RED
	                },
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                },
	                point: {
	                    border: {
	                        visible: true
	                    }
	                }
	            },
	            stock: {
	                width: 1,
	                reduction: {
	                    color: RED
	                },
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                },
	                point: {
	                    border: {
	                        visible: true
	                    }
	                }
	            }
	        },
	        crosshair: {
	            enabled: false,
	            color: "#f05b41",
	            width: 1,
	            dashStyle: SOLID,
	            label: {
	                visible: false,
	                font: {
	                    color: WHITE,
	                    size: 12
	                }
	            },
	            verticalLine: {
	                visible: true
	            },
	            horizontalLine: {
	                visible: true
	            }
	        },
	        commonAxisSettings: {
	            multipleAxesSpacing: 5,
	            label: {
	                overlappingBehavior: {
	                    mode: "enlargeTickInterval",
	                    rotationAngle: 90,
	                    staggeringSpacing: 5
	                },
	                indentFromAxis: 10
	            },
	            title: {
	                font: {
	                    size: 16
	                },
	                margin: 6
	            },
	            constantLineStyle: {
	                paddingLeftRight: 10,
	                paddingTopBottom: 10
	            }
	        },
	        horizontalAxis: {
	            position: BOTTOM,
	            axisDivisionFactor: 50,
	            label: {
	                alignment: CENTER
	            },
	            stripStyle: {
	                label: {
	                    horizontalAlignment: CENTER,
	                    verticalAlignment: TOP
	                }
	            },
	            constantLineStyle: {
	                label: {
	                    horizontalAlignment: RIGHT,
	                    verticalAlignment: TOP
	                }
	            },
	            constantLines: {}
	        },
	        verticalAxis: {
	            position: LEFT,
	            axisDivisionFactor: 30,
	            label: {
	                alignment: RIGHT,
	                overlappingBehavior: {
	                    mode: "enlargeTickInterval"
	                }
	            },
	            stripStyle: {
	                label: {
	                    horizontalAlignment: LEFT,
	                    verticalAlignment: CENTER
	                }
	            },
	            constantLineStyle: {
	                label: {
	                    horizontalAlignment: LEFT,
	                    verticalAlignment: TOP
	                }
	            },
	            constantLines: {}
	        },
	        argumentAxis: {},
	        valueAxis: {
	            grid: {
	                visible: true
	            }
	        },
	        commonPaneSettings: {
	            backgroundColor: NONE,
	            border: {
	                color: LIGHT_GREY,
	                width: 1,
	                visible: false,
	                top: true,
	                bottom: true,
	                left: true,
	                right: true,
	                dashStyle: SOLID
	            }
	        },
	        scrollBar: {
	            visible: false,
	            offset: 5,
	            color: "gray",
	            width: 10
	        },
	        useAggregation: false,
	        adjustOnZoom: true,
	        rotated: false,
	        zoomingMode: NONE,
	        scrollingMode: NONE,
	        synchronizeMultiAxes: true,
	        equalBarWidth: true,
	        minBubbleSize: 12,
	        maxBubbleSize: .2
	    },
	    pie: {
	        innerRadius: .5,
	        type: "pie",
	        commonSeriesSettings: {
	            pie: {
	                border: {
	                    visible: false,
	                    width: 2,
	                    color: WHITE
	                },
	                hoverStyle: {
	                    hatching: {
	                        direction: RIGHT,
	                        width: 4,
	                        step: 10,
	                        opacity: .75
	                    },
	                    border: {
	                        visible: false,
	                        width: 2
	                    }
	                },
	                selectionStyle: {
	                    hatching: {
	                        direction: RIGHT,
	                        width: 4,
	                        step: 10,
	                        opacity: .5
	                    },
	                    border: {
	                        visible: false,
	                        width: 2
	                    }
	                }
	            },
	            doughnut: {
	                border: {
	                    visible: false,
	                    width: 2,
	                    color: WHITE
	                },
	                hoverStyle: {
	                    hatching: {
	                        direction: RIGHT,
	                        width: 4,
	                        step: 10,
	                        opacity: .75
	                    },
	                    border: {
	                        visible: false,
	                        width: 2
	                    }
	                },
	                selectionStyle: {
	                    hatching: {
	                        direction: RIGHT,
	                        width: 4,
	                        step: 10,
	                        opacity: .5
	                    },
	                    border: {
	                        visible: false,
	                        width: 2
	                    }
	                }
	            },
	            donut: {
	                border: {
	                    visible: false,
	                    width: 2,
	                    color: WHITE
	                },
	                hoverStyle: {
	                    hatching: {
	                        direction: RIGHT,
	                        width: 4,
	                        step: 10,
	                        opacity: .75
	                    },
	                    border: {
	                        visible: false,
	                        width: 2
	                    }
	                },
	                selectionStyle: {
	                    hatching: {
	                        direction: RIGHT,
	                        width: 4,
	                        step: 10,
	                        opacity: .5
	                    },
	                    border: {
	                        visible: false,
	                        width: 2
	                    }
	                }
	            }
	        },
	        legend: {
	            hoverMode: "allArgumentPoints",
	            backgroundColor: NONE
	        },
	        adaptiveLayout: {
	            keepLabels: false
	        }
	    },
	    gauge: {
	        scale: {
	            tick: {
	                visible: true,
	                length: 5,
	                width: 2,
	                opacity: 1
	            },
	            minorTick: {
	                visible: false,
	                length: 3,
	                width: 1,
	                opacity: 1
	            },
	            label: {
	                visible: true,
	                alignment: CENTER,
	                overlappingBehavior: {
	                    hideFirstOrLast: "last",
	                    useAutoArrangement: true
	                }
	            },
	            position: TOP
	        },
	        rangeContainer: {
	            offset: 0,
	            width: 5,
	            backgroundColor: "#808080"
	        },
	        valueIndicators: {
	            _default: {
	                color: "#c2c2c2"
	            },
	            rangebar: {
	                space: 2,
	                size: 10,
	                color: "#cbc5cf",
	                backgroundColor: NONE,
	                text: {
	                    indent: 0,
	                    font: {
	                        size: 14,
	                        color: null
	                    }
	                }
	            },
	            twocolorneedle: {
	                secondColor: "#e18e92"
	            },
	            trianglemarker: {
	                space: 2,
	                length: 14,
	                width: 13,
	                color: "#8798a5"
	            },
	            textcloud: {
	                arrowLength: 5,
	                horizontalOffset: 6,
	                verticalOffset: 3,
	                color: "#679ec5",
	                text: {
	                    font: {
	                        color: WHITE,
	                        size: 18
	                    }
	                }
	            }
	        },
	        indicator: {
	            hasPositiveMeaning: true,
	            layout: {
	                horizontalAlignment: CENTER,
	                verticalAlignment: BOTTOM
	            },
	            text: {
	                font: {
	                    size: 18
	                }
	            }
	        },
	        _circular: {
	            scale: {
	                orientation: OUTSIDE,
	                label: {
	                    indentFromTick: 10
	                }
	            },
	            rangeContainer: {
	                orientation: OUTSIDE
	            },
	            valueIndicatorType: "rectangleneedle",
	            subvalueIndicatorType: "trianglemarker",
	            valueIndicators: {
	                _type: "rectangleneedle",
	                _default: {
	                    offset: 20,
	                    indentFromCenter: 0,
	                    width: 2,
	                    spindleSize: 14,
	                    spindleGapSize: 10
	                },
	                triangleneedle: {
	                    width: 4
	                },
	                twocolorneedle: {
	                    space: 2,
	                    secondFraction: .4
	                },
	                rangebar: {
	                    offset: 30
	                },
	                trianglemarker: {
	                    offset: 6
	                },
	                textcloud: {
	                    offset: -6
	                }
	            }
	        },
	        _linear: {
	            scale: {
	                horizontalOrientation: RIGHT,
	                verticalOrientation: BOTTOM,
	                label: {
	                    indentFromTick: -10
	                }
	            },
	            rangeContainer: {
	                horizontalOrientation: RIGHT,
	                verticalOrientation: BOTTOM
	            },
	            valueIndicatorType: "rangebar",
	            subvalueIndicatorType: "trianglemarker",
	            valueIndicators: {
	                _type: "rectangle",
	                _default: {
	                    offset: 2.5,
	                    length: 15,
	                    width: 15
	                },
	                rectangle: {
	                    width: 10
	                },
	                rangebar: {
	                    offset: 10,
	                    horizontalOrientation: RIGHT,
	                    verticalOrientation: BOTTOM
	                },
	                trianglemarker: {
	                    offset: 10,
	                    horizontalOrientation: LEFT,
	                    verticalOrientation: TOP
	                },
	                textcloud: {
	                    offset: -1,
	                    horizontalOrientation: LEFT,
	                    verticalOrientation: TOP
	                }
	            }
	        }
	    },
	    barGauge: {
	        backgroundColor: "#e0e0e0",
	        relativeInnerRadius: .3,
	        barSpacing: 4,
	        label: {
	            indent: 20,
	            connectorWidth: 2,
	            font: {
	                size: 16
	            }
	        },
	        indicator: {
	            hasPositiveMeaning: true,
	            layout: {
	                horizontalAlignment: CENTER,
	                verticalAlignment: BOTTOM
	            },
	            text: {
	                font: {
	                    size: 18
	                }
	            }
	        }
	    },
	    rangeSelector: {
	        scale: {
	            width: 1,
	            color: BLACK,
	            opacity: .1,
	            showCustomBoundaryTicks: true,
	            showMinorTicks: true,
	            useTicksAutoArrangement: true,
	            setTicksAtUnitBeginning: true,
	            label: {
	                alignment: "center",
	                visible: true,
	                topIndent: 7,
	                font: {
	                    size: 11
	                }
	            },
	            tick: {
	                width: 1,
	                color: BLACK,
	                opacity: .17,
	                visible: true,
	                length: 12
	            },
	            minorTick: {
	                width: 1,
	                color: BLACK,
	                opacity: .05,
	                visible: true,
	                length: 12
	            },
	            marker: {
	                width: 1,
	                color: "#000000",
	                opacity: .1,
	                visible: true,
	                separatorHeight: 33,
	                topIndent: 10,
	                textLeftIndent: 7,
	                textTopIndent: 11,
	                label: {}
	            },
	            logarithmBase: 10
	        },
	        selectedRangeColor: "#606060",
	        sliderMarker: {
	            visible: true,
	            paddingTopBottom: 2,
	            paddingLeftRight: 4,
	            color: "#606060",
	            invalidRangeColor: RED,
	            font: {
	                color: WHITE,
	                size: 11
	            }
	        },
	        sliderHandle: {
	            width: 1,
	            color: BLACK,
	            opacity: .2
	        },
	        shutter: {
	            opacity: .75
	        },
	        background: {
	            color: "#c0bae1",
	            visible: true,
	            image: {
	                location: "full"
	            }
	        },
	        behavior: {
	            snapToTicks: true,
	            animationEnabled: true,
	            moveSelectedRangeByClick: true,
	            manualRangeSelectionEnabled: true,
	            allowSlidersSwap: true,
	            callSelectedRangeChanged: "onMovingComplete"
	        },
	        redrawOnResize: true,
	        chart: {
	            useAggregation: false,
	            equalBarWidth: true,
	            minBubbleSize: 12,
	            maxBubbleSize: .2,
	            topIndent: .1,
	            bottomIndent: 0,
	            valueAxis: {
	                inverted: false,
	                logarithmBase: 10
	            },
	            commonSeriesSettings: {
	                type: "area",
	                point: {
	                    visible: false
	                },
	                scatter: {
	                    point: {
	                        visible: true
	                    }
	                }
	            }
	        }
	    },
	    map: {
	        title: {
	            margin: 10
	        },
	        background: {
	            borderWidth: 1,
	            borderColor: "#cacaca"
	        },
	        layer: {
	            label: {
	                enabled: false,
	                stroke: WHITE,
	                "stroke-width": 1,
	                "stroke-opacity": .7,
	                font: {
	                    color: SOME_GREY,
	                    size: 12
	                }
	            }
	        },
	        "layer:area": {
	            borderWidth: 1,
	            borderColor: WHITE,
	            color: "#d2d2d2",
	            hoveredBorderColor: GREY_GREEN,
	            selectedBorderWidth: 2,
	            selectedBorderColor: GREY_GREEN,
	            label: {
	                "stroke-width": 2,
	                font: {
	                    size: 16
	                }
	            }
	        },
	        "layer:line": {
	            borderWidth: 2,
	            color: "#ba8365",
	            hoveredColor: "#a94813",
	            selectedBorderWidth: 3,
	            selectedColor: "#e55100",
	            label: {
	                "stroke-width": 2,
	                font: {
	                    size: 16
	                }
	            }
	        },
	        "layer:marker": {
	            label: {
	                enabled: true,
	                "stroke-width": 1,
	                font: {
	                    size: 12
	                }
	            }
	        },
	        "layer:marker:dot": {
	            borderWidth: 2,
	            borderColor: WHITE,
	            color: "#ba4d51",
	            size: 8,
	            selectedStep: 2,
	            backStep: 18,
	            backColor: WHITE,
	            backOpacity: .32,
	            shadow: true
	        },
	        "layer:marker:bubble": {
	            minSize: 20,
	            maxSize: 50,
	            color: "#ba4d51",
	            hoveredBorderWidth: 1,
	            hoveredBorderColor: GREY_GREEN,
	            selectedBorderWidth: 2,
	            selectedBorderColor: GREY_GREEN
	        },
	        "layer:marker:pie": {
	            size: 50,
	            hoveredBorderWidth: 1,
	            hoveredBorderColor: GREY_GREEN,
	            selectedBorderWidth: 2,
	            selectedBorderColor: GREY_GREEN
	        },
	        "layer:marker:image": {
	            size: 20
	        },
	        legend: {
	            verticalAlignment: BOTTOM,
	            horizontalAlignment: RIGHT,
	            position: INSIDE,
	            backgroundOpacity: .65,
	            border: {
	                visible: true
	            },
	            paddingLeftRight: 16,
	            paddingTopBottom: 12,
	            markerColor: "#ba4d51"
	        },
	        controlBar: {
	            borderColor: "#5d5d5d",
	            borderWidth: 3,
	            color: WHITE,
	            margin: 20,
	            opacity: .3
	        },
	        _rtl: {
	            legend: {
	                itemTextPosition: LEFT
	            }
	        }
	    },
	    treeMap: {
	        tile: {
	            border: {
	                width: 1,
	                opacity: .2,
	                color: "#000000"
	            },
	            color: "#5f8b95",
	            hoverStyle: {
	                hatching: {
	                    opacity: .75,
	                    step: 6,
	                    width: 2,
	                    direction: "right"
	                },
	                border: {}
	            },
	            selectionStyle: {
	                hatching: {
	                    opacity: .5,
	                    step: 6,
	                    width: 2,
	                    direction: "right"
	                },
	                border: {
	                    opacity: 1
	                }
	            },
	            label: {
	                visible: true,
	                paddingLeftRight: 5,
	                paddingTopBottom: 4,
	                stroke: "#000000",
	                "stroke-width": 1,
	                "stroke-opacity": .3,
	                font: {
	                    color: "#ffffff",
	                    weight: 300
	                },
	                shadow: {
	                    opacity: .8,
	                    offsetX: 0,
	                    offsetY: 1,
	                    blur: 1,
	                    color: "#000000"
	                }
	            }
	        },
	        group: {
	            padding: 4,
	            border: {
	                width: 1
	            },
	            color: "#eeeeee",
	            hoverStyle: {
	                hatching: {
	                    opacity: 0,
	                    step: 6,
	                    width: 2,
	                    direction: "right"
	                },
	                border: {}
	            },
	            selectionStyle: {
	                hatching: {
	                    opacity: 0,
	                    step: 6,
	                    width: 2,
	                    direction: "right"
	                },
	                border: {}
	            },
	            label: {
	                visible: true,
	                paddingLeftRight: 5,
	                paddingTopBottom: 4,
	                font: {
	                    weight: 600
	                }
	            }
	        },
	        title: {
	            subtitle: {}
	        },
	        tooltip: {},
	        loadingIndicator: {}
	    },
	    sparkline: {
	        lineColor: "#666666",
	        lineWidth: 2,
	        areaOpacity: .2,
	        minColor: "#e8c267",
	        maxColor: "#e55253",
	        barPositiveColor: "#a9a9a9",
	        barNegativeColor: "#d7d7d7",
	        winColor: "#a9a9a9",
	        lossColor: "#d7d7d7",
	        firstLastColor: "#666666",
	        pointSymbol: "circle",
	        pointColor: WHITE,
	        pointSize: 4,
	        type: "line",
	        argumentField: "arg",
	        valueField: "val",
	        winlossThreshold: 0,
	        showFirstLast: true,
	        showMinMax: false,
	        tooltip: {
	            enabled: true
	        }
	    },
	    bullet: {
	        color: "#e8c267",
	        targetColor: "#666666",
	        targetWidth: 4,
	        showTarget: true,
	        showZeroLevel: true,
	        tooltip: {
	            enabled: true
	        }
	    },
	    polar: {
	        commonSeriesSettings: {
	            type: "scatter",
	            closed: true,
	            point: {
	                visible: true,
	                symbol: "circle",
	                size: 12,
	                border: {
	                    visible: false,
	                    width: 1
	                },
	                hoverMode: "onlyPoint",
	                selectionMode: "onlyPoint",
	                hoverStyle: {
	                    border: {
	                        visible: true,
	                        width: 4
	                    },
	                    size: 12
	                },
	                selectionStyle: {
	                    border: {
	                        visible: true,
	                        width: 4
	                    },
	                    size: 12
	                }
	            },
	            scatter: {},
	            line: {
	                width: 2,
	                dashStyle: SOLID,
	                hoverStyle: {
	                    width: 3,
	                    hatching: {
	                        direction: NONE
	                    }
	                },
	                selectionStyle: {
	                    width: 3
	                }
	            },
	            area: {
	                point: {
	                    visible: false
	                },
	                opacity: .5
	            },
	            stackedline: {
	                width: 2
	            },
	            bar: {
	                opacity: .8
	            },
	            stackedbar: {
	                opacity: .8
	            }
	        },
	        adaptiveLayout: {
	            width: 170,
	            height: 170,
	            keepLabels: true
	        },
	        equalBarWidth: true,
	        commonAxisSettings: {
	            visible: true,
	            label: {
	                overlappingBehavior: {
	                    mode: "enlargeTickInterval"
	                },
	                indentFromAxis: 5
	            },
	            grid: {
	                visible: true
	            },
	            minorGrid: {
	                visible: true
	            },
	            tick: {
	                visible: true
	            },
	            title: {
	                font: {
	                    size: 16
	                },
	                margin: 10
	            }
	        },
	        argumentAxis: {
	            startAngle: 0,
	            firstPointOnStartAngle: false,
	            period: void 0
	        },
	        valueAxis: {
	            tick: {
	                visible: false
	            }
	        },
	        horizontalAxis: {
	            position: TOP,
	            axisDivisionFactor: 50,
	            label: {
	                alignment: CENTER
	            }
	        },
	        verticalAxis: {
	            position: TOP,
	            axisDivisionFactor: 30,
	            label: {
	                alignment: RIGHT
	            }
	        }
	    }
	});
	registerTheme({
	    name: "generic.dark",
	    font: {
	        color: "#808080"
	    },
	    backgroundColor: "#2a2a2a",
	    primaryTitleColor: "#dedede",
	    secondaryTitleColor: "#a3a3a3",
	    axisColor: "#555555",
	    axisLabelColor: "#a3a3a3",
	    "export": {
	        backgroundColor: "#2a2a2a",
	        font: {
	            color: "#dbdbdb"
	        },
	        button: {
	            "default": {
	                color: "#dedede",
	                borderColor: "#4d4d4d",
	                backgroundColor: "#2e2e2e"
	            },
	            hover: {
	                color: "#dedede",
	                borderColor: "#6c6c6c",
	                backgroundColor: "#444"
	            },
	            focus: {
	                color: "#dedede",
	                borderColor: "#8d8d8d",
	                backgroundColor: "#444444"
	            },
	            active: {
	                color: "#dedede",
	                borderColor: "#8d8d8d",
	                backgroundColor: "#555555"
	            }
	        },
	        shadowColor: "#292929"
	    },
	    tooltip: {
	        color: SOME_GREY,
	        border: {
	            color: "#494949"
	        },
	        font: {
	            color: "#929292"
	        }
	    },
	    "chart:common": {
	        commonSeriesSettings: {
	            label: {
	                border: {
	                    color: "#494949"
	                }
	            },
	            valueErrorBar: {
	                color: WHITE
	            }
	        }
	    },
	    "chart:common:axis": {
	        constantLineStyle: {
	            color: WHITE
	        }
	    },
	    chart: {
	        commonPaneSettings: {
	            border: {
	                color: "#494949"
	            }
	        }
	    },
	    gauge: {
	        rangeContainer: {
	            backgroundColor: RANGE_COLOR
	        },
	        valueIndicators: {
	            _default: {
	                color: RANGE_COLOR
	            },
	            rangebar: {
	                color: "#84788b"
	            },
	            twocolorneedle: {
	                secondColor: "#ba544d"
	            },
	            trianglemarker: {
	                color: "#b7918f"
	            },
	            textcloud: {
	                color: "#ba544d"
	            }
	        }
	    },
	    barGauge: {
	        backgroundColor: "#3c3c3c"
	    },
	    rangeSelector: {
	        scale: {
	            tick: {
	                color: WHITE,
	                opacity: .32
	            },
	            minorTick: {
	                color: WHITE,
	                opacity: .1
	            }
	        },
	        selectedRangeColor: RANGE_COLOR,
	        sliderMarker: {
	            color: RANGE_COLOR,
	            font: {
	                color: GREY_GREEN
	            }
	        },
	        sliderHandle: {
	            color: WHITE,
	            opacity: .2
	        },
	        shutter: {
	            color: SOME_GREY,
	            opacity: .9
	        }
	    },
	    map: {
	        background: {
	            borderColor: "#3f3f3f"
	        },
	        layer: {
	            label: {
	                stroke: BLACK,
	                font: {
	                    color: WHITE
	                }
	            }
	        },
	        "layer:area": {
	            borderColor: GREY_GREEN,
	            color: AREA_LAYER_COLOR,
	            hoveredBorderColor: WHITE,
	            selectedBorderColor: WHITE
	        },
	        "layer:line": {
	            color: "#c77244",
	            hoveredColor: "#ff5d04",
	            selectedColor: "#ff784f"
	        },
	        "layer:marker:bubble": {
	            hoveredBorderColor: WHITE,
	            selectedBorderColor: WHITE
	        },
	        "layer:marker:pie": {
	            hoveredBorderColor: WHITE,
	            selectedBorderColor: WHITE
	        },
	        legend: {
	            border: {
	                color: "#3f3f3f"
	            },
	            font: {
	                color: WHITE
	            }
	        },
	        controlBar: {
	            borderColor: LINE_COLOR,
	            color: GREY_GREEN
	        }
	    },
	    treeMap: {
	        group: {
	            color: "#4c4c4c"
	        }
	    },
	    sparkline: {
	        lineColor: LINE_COLOR,
	        firstLastColor: LINE_COLOR,
	        barPositiveColor: POSITIVE_COLOR,
	        barNegativeColor: TARGET_COLOR,
	        winColor: POSITIVE_COLOR,
	        lossColor: TARGET_COLOR,
	        pointColor: GREY_GREEN
	    },
	    bullet: {
	        targetColor: TARGET_COLOR
	    }
	}, "generic.light");
	registerTheme({
	    name: "generic.contrast",
	    defaultPalette: "Bright",
	    font: {
	        color: WHITE
	    },
	    backgroundColor: BLACK,
	    primaryTitleColor: WHITE,
	    secondaryTitleColor: WHITE,
	    axisColor: WHITE,
	    axisLabelColor: WHITE,
	    "export": {
	        backgroundColor: BLACK,
	        font: {
	            color: WHITE
	        },
	        button: {
	            "default": {
	                color: WHITE,
	                borderColor: WHITE,
	                backgroundColor: BLACK
	            },
	            hover: {
	                color: WHITE,
	                borderColor: WHITE,
	                backgroundColor: "#cf00d7"
	            },
	            focus: {
	                color: WHITE,
	                borderColor: "#cf00d7",
	                backgroundColor: BLACK
	            },
	            active: {
	                color: BLACK,
	                borderColor: WHITE,
	                backgroundColor: WHITE
	            }
	        },
	        borderColor: WHITE,
	        menuButtonColor: BLACK,
	        activeBackgroundColor: WHITE,
	        activeColor: BLACK,
	        selectedBorderColor: CONTRAST_ACTIVE,
	        selectedColor: CONTRAST_ACTIVE,
	        shadowColor: "none"
	    },
	    tooltip: {
	        border: {
	            color: WHITE
	        },
	        font: {
	            color: WHITE
	        },
	        color: BLACK
	    },
	    "chart:common": {
	        commonSeriesSettings: {
	            valueErrorBar: {
	                color: WHITE
	            },
	            hoverStyle: {
	                hatching: {
	                    opacity: .5
	                }
	            },
	            selectionStyle: {
	                hatching: {
	                    opacity: .35
	                }
	            },
	            label: {
	                font: {
	                    color: WHITE
	                },
	                border: {
	                    color: WHITE
	                }
	            }
	        }
	    },
	    "chart:common:axis": {
	        constantLineStyle: {
	            color: WHITE
	        }
	    },
	    chart: {
	        commonSeriesSettings: {},
	        commonPaneSettings: {
	            backgroundColor: BLACK,
	            border: {
	                color: WHITE
	            }
	        },
	        scrollBar: {
	            color: WHITE
	        }
	    },
	    pie: {
	        commonSeriesSettings: {
	            pie: {
	                hoverStyle: {
	                    hatching: {
	                        opacity: .5
	                    }
	                },
	                selectionStyle: {
	                    hatching: {
	                        opacity: .35
	                    }
	                }
	            },
	            doughnut: {
	                hoverStyle: {
	                    hatching: {
	                        opacity: .5
	                    }
	                },
	                selectionStyle: {
	                    hatching: {
	                        opacity: .35
	                    }
	                }
	            },
	            donut: {
	                hoverStyle: {
	                    hatching: {
	                        opacity: .5
	                    }
	                },
	                selectionStyle: {
	                    hatching: {
	                        opacity: .35
	                    }
	                }
	            }
	        },
	        legend: {
	            backgroundColor: BLACK
	        }
	    },
	    gauge: {
	        rangeContainer: {
	            backgroundColor: WHITE
	        },
	        valueIndicators: {
	            _default: {
	                color: WHITE
	            },
	            rangebar: {
	                color: WHITE,
	                backgroundColor: BLACK
	            },
	            twocolorneedle: {
	                secondColor: WHITE
	            },
	            trianglemarker: {
	                color: WHITE
	            },
	            textcloud: {
	                color: WHITE,
	                text: {
	                    font: {
	                        color: BLACK
	                    }
	                }
	            }
	        }
	    },
	    barGauge: {
	        backgroundColor: "#3c3c3c"
	    },
	    rangeSelector: {
	        scale: {
	            tick: {
	                opacity: .4
	            },
	            minorTick: {
	                opacity: .12
	            }
	        },
	        selectedRangeColor: CONTRAST_ACTIVE,
	        sliderMarker: {
	            color: CONTRAST_ACTIVE
	        },
	        sliderHandle: {
	            color: CONTRAST_ACTIVE,
	            opacity: 1
	        },
	        shutter: {
	            opacity: .75
	        },
	        background: {
	            color: BLACK
	        }
	    },
	    map: {
	        background: {
	            borderColor: WHITE
	        },
	        layer: {
	            label: {
	                stroke: BLACK,
	                font: {
	                    color: WHITE
	                }
	            }
	        },
	        "layer:area": {
	            borderColor: BLACK,
	            color: AREA_LAYER_COLOR,
	            hoveredBorderColor: WHITE,
	            selectedBorderColor: WHITE,
	            label: {
	                font: {
	                    opacity: 1
	                }
	            }
	        },
	        "layer:line": {
	            color: "#267cff",
	            hoveredColor: "#f613ff",
	            selectedColor: WHITE
	        },
	        "layer:marker:dot": {
	            borderColor: BLACK,
	            color: MARKER_COLOR,
	            backColor: BLACK,
	            backOpacity: .32
	        },
	        "layer:marker:bubble": {
	            color: MARKER_COLOR,
	            hoveredBorderColor: WHITE,
	            selectedBorderColor: WHITE
	        },
	        "layer:marker:pie": {
	            hoveredBorderColor: WHITE,
	            selectedBorderColor: WHITE
	        },
	        legend: {
	            markerColor: MARKER_COLOR
	        },
	        controlBar: {
	            borderColor: WHITE,
	            color: BLACK,
	            opacity: .3
	        }
	    },
	    treeMap: {
	        tile: {
	            color: "#70c92f"
	        },
	        group: {
	            color: "#797979"
	        }
	    },
	    sparkline: {
	        pointColor: BLACK
	    },
	    bullet: {},
	    polar: {
	        commonSeriesSettings: {}
	    }
	}, "generic.light");
	themeModule.currentTheme("generic.light");
	registerThemeAlias("desktop.light", "generic.light");
	registerThemeAlias("desktop.dark", "generic.dark");


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/ios.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var themeModule = __webpack_require__(330),
	    IOS7_DEFAULT = "ios7.default",
	    SECONDARY_TEXT_COLOR = "#767676",
	    BORDER_COLOR = "#d3d3d3",
	    BLACK = "#000000";
	themeModule.registerTheme({
	    name: IOS7_DEFAULT,
	    backgroundColor: "#ffffff",
	    primaryTitleColor: BLACK,
	    secondaryTitleColor: SECONDARY_TEXT_COLOR,
	    axisColor: "#ececec",
	    axisLabelColor: SECONDARY_TEXT_COLOR,
	    legend: {
	        font: {
	            color: BLACK
	        }
	    },
	    tooltip: {
	        font: {
	            color: SECONDARY_TEXT_COLOR
	        }
	    },
	    "chart:common": {
	        commonSeriesSettings: {
	            label: {
	                border: {
	                    color: BORDER_COLOR
	                }
	            }
	        }
	    },
	    chart: {
	        commonPaneSettings: {
	            border: {
	                color: BORDER_COLOR
	            }
	        }
	    },
	    rangeSelector: {
	        scale: {
	            tick: {
	                color: BLACK,
	                opacity: .1
	            },
	            minorTick: {
	                color: BLACK,
	                opacity: .03
	            }
	        }
	    }
	}, "generic.light");
	themeModule.registerThemeAlias("ios", IOS7_DEFAULT);


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/android.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var ANDROID5_LIGHT = "android5.light",
	    themeModule = __webpack_require__(330),
	    registerThemeAlias = themeModule.registerThemeAlias,
	    SECONDARY_TEXT_COLOR = "#767676",
	    BORDER_COLOR = "#e8e8e8",
	    BLACK = "#000000";
	themeModule.registerTheme({
	    name: ANDROID5_LIGHT,
	    backgroundColor: "#ffffff",
	    primaryTitleColor: "#232323",
	    secondaryTitleColor: SECONDARY_TEXT_COLOR,
	    axisColor: "#d3d3d3",
	    axisLabelColor: SECONDARY_TEXT_COLOR,
	    tooltip: {
	        color: BORDER_COLOR,
	        font: {
	            color: SECONDARY_TEXT_COLOR
	        }
	    },
	    legend: {
	        font: {
	            color: BLACK
	        }
	    },
	    rangeSelector: {
	        scale: {
	            tick: {
	                color: BLACK,
	                opacity: .17
	            },
	            minorTick: {
	                color: BLACK,
	                opacity: .05
	            }
	        }
	    }
	}, "generic.light");
	registerThemeAlias("android", ANDROID5_LIGHT);
	registerThemeAlias("android.holo-dark", ANDROID5_LIGHT);
	registerThemeAlias("android.holo-light", ANDROID5_LIGHT);
	registerThemeAlias("android.dark", ANDROID5_LIGHT);
	registerThemeAlias("android.light", ANDROID5_LIGHT);


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/win.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var themeModule = __webpack_require__(330),
	    registerTheme = themeModule.registerTheme,
	    registerThemeSchemeAlias = themeModule.registerThemeSchemeAlias,
	    BLACK = "#000000",
	    WHITE = "#ffffff",
	    WIN10_WHITE = "win10.white",
	    WIN10_BLACK = "win10.black",
	    WIN8_WHITE = "win8.white",
	    WIN8_BLACK = "win8.black";
	registerTheme({
	    name: WIN10_BLACK,
	    backgroundColor: BLACK,
	    primaryTitleColor: WHITE,
	    secondaryTitleColor: "#d8d8d8",
	    axisColor: "#4c4c4c",
	    axisLabelColor: WHITE,
	    title: {
	        font: {
	            color: WHITE
	        }
	    },
	    legend: {
	        font: {
	            color: WHITE
	        }
	    },
	    tooltip: {
	        color: BLACK,
	        font: {
	            color: WHITE
	        }
	    },
	    "chart:common": {
	        commonSeriesSettings: {
	            label: {
	                border: {
	                    color: "#454545"
	                }
	            }
	        }
	    },
	    chart: {
	        commonPaneSettings: {
	            border: {
	                color: "#454545"
	            }
	        }
	    },
	    barGauge: {
	        backgroundColor: "#2b3036"
	    },
	    rangeSelector: {
	        scale: {
	            tick: {
	                color: WHITE,
	                opacity: .23
	            },
	            minorTick: {
	                color: WHITE,
	                opacity: .07
	            }
	        }
	    }
	}, "generic.dark");
	registerTheme({
	    name: WIN10_WHITE,
	    backgroundColor: WHITE,
	    primaryTitleColor: BLACK,
	    secondaryTitleColor: "#767676",
	    axisColor: "#ececec",
	    axisLabelColor: BLACK,
	    title: {
	        font: {
	            color: BLACK
	        }
	    },
	    legend: {
	        font: {
	            color: BLACK
	        }
	    },
	    tooltip: {
	        font: {
	            color: BLACK
	        }
	    },
	    rangeSelector: {
	        scale: {
	            tick: {
	                color: BLACK,
	                opacity: .1
	            },
	            minorTick: {
	                color: BLACK,
	                opacity: .03
	            }
	        }
	    }
	}, "generic.light");
	registerThemeSchemeAlias("win10.dark", WIN10_BLACK);
	registerThemeSchemeAlias("win10.light", WIN10_WHITE);
	registerTheme({
	    name: WIN8_BLACK
	}, WIN10_BLACK);
	registerTheme({
	    name: WIN8_WHITE
	}, WIN10_WHITE);
	registerThemeSchemeAlias("win8.dark", WIN8_BLACK);
	registerThemeSchemeAlias("win8.light", WIN8_WHITE);


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/layout_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    layoutElementModule = __webpack_require__(300),
	    _isNumber = commonUtils.isNumber,
	    _min = Math.min,
	    _max = Math.max,
	    _floor = Math.floor,
	    _sqrt = Math.sqrt,
	    _each = $.each,
	    _extend = $.extend,
	    consts = __webpack_require__(305),
	    pieLabelIndent = consts.pieLabelIndent,
	    pieLabelSpacing = consts.pieLabelSpacing;

	function updateAxis(axes, side, needRemoveSpace) {
	    if (axes && needRemoveSpace[side] > 0) {
	        _each(axes, function(i, axis) {
	            var bBox = axis.getBoundingRect();
	            axis.updateSize();
	            needRemoveSpace[side] -= bBox[side] - axis.getBoundingRect()[side]
	        });
	        if (needRemoveSpace[side] > 0) {
	            _each(axes, function(_, axis) {
	                axis.updateSize(true)
	            })
	        }
	    }
	}

	function getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {
	    var nearestCoord;
	    if (pointCenterCoord < firstCoord) {
	        nearestCoord = firstCoord
	    } else {
	        if (secondCoord < pointCenterCoord) {
	            nearestCoord = secondCoord
	        } else {
	            nearestCoord = pointCenterCoord
	        }
	    }
	    return nearestCoord
	}

	function getLabelLayout(point) {
	    if (point._label.isVisible() && "inside" !== point._label.getLayoutOptions().position) {
	        return point._label.getBoundingRect()
	    }
	}

	function getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {
	    var radiusIsFound = false;
	    _each(series, function(_, singleSeries) {
	        if (radiusIsFound) {
	            return false
	        }
	        _each(singleSeries.getVisiblePoints(), function(_, point) {
	            var labelBBox = getLabelLayout(point);
	            if (labelBBox) {
	                var xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX),
	                    yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);
	                accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - pieLabelIndent, minR), accessibleRadius);
	                radiusIsFound = true
	            }
	        })
	    });
	    return accessibleRadius
	}

	function getSizeLabels(series) {
	    var sizes = [],
	        commonWidth = 0;
	    _each(series, function(_, singleSeries) {
	        var maxWidth = 0;
	        _each(singleSeries.getVisiblePoints(), function(_, point) {
	            var labelBBox = getLabelLayout(point);
	            if (labelBBox) {
	                maxWidth = _max(labelBBox.width + pieLabelSpacing, maxWidth)
	            }
	        });
	        sizes.push(maxWidth);
	        commonWidth += maxWidth
	    });
	    return {
	        sizes: sizes,
	        common: commonWidth
	    }
	}

	function correctLabelRadius(sizes, radius, series, canvas, averageWidthLabels) {
	    var curRadius, i, centerX = (canvas.width - canvas.left - canvas.right) / 2;
	    for (i = 0; i < series.length; i++) {
	        if (0 === sizes[i]) {
	            curRadius && (curRadius += sizes[i - 1]);
	            continue
	        }
	        curRadius = _floor(curRadius ? curRadius + sizes[i - 1] : radius);
	        series[i].correctLabelRadius(curRadius);
	        if (averageWidthLabels && i !== series.length - 1) {
	            sizes[i] = averageWidthLabels;
	            series[i].setVisibleArea({
	                left: centerX - radius - averageWidthLabels * (i + 1),
	                right: canvas.width - (centerX + radius + averageWidthLabels * (i + 1)),
	                top: canvas.top,
	                bottom: canvas.bottom,
	                width: canvas.width,
	                height: canvas.height
	            })
	        }
	    }
	}

	function getLengthFromCenter(x, y, paneCenterX, paneCenterY) {
	    return _sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY))
	}

	function getInnerRadius(series) {
	    var innerRadius;
	    if ("pie" === series.type) {
	        innerRadius = 0
	    } else {
	        innerRadius = _isNumber(series.innerRadius) ? Number(series.innerRadius) : .5;
	        innerRadius = innerRadius < .2 ? .2 : innerRadius;
	        innerRadius = innerRadius > .8 ? .8 : innerRadius
	    }
	    return innerRadius
	}

	function isValidBox(box) {
	    return !!(box.x || box.y || box.width || box.height)
	}

	function correctDeltaMarginValue(panes, marginSides) {
	    var canvas, deltaSide, requireAxesRedraw = false;
	    _each(panes, function(_, pane) {
	        canvas = pane.canvas;
	        _each(marginSides, function(_, side) {
	            deltaSide = "delta" + side;
	            canvas[deltaSide] = _max(canvas[deltaSide] - (canvas[side.toLowerCase()] - canvas["original" + side]), 0);
	            if (canvas[deltaSide] > 0) {
	                requireAxesRedraw = true
	            }
	        })
	    });
	    return requireAxesRedraw
	}

	function getPane(name, panes) {
	    var findPane = panes[0];
	    _each(panes, function(_, pane) {
	        if (name === pane.name) {
	            findPane = pane
	        }
	    });
	    return findPane
	}

	function applyFoundExceedings(panes, rotated) {
	    var stopDrawAxes = false,
	        maxLeft = 0,
	        maxRight = 0,
	        maxTop = 0,
	        maxBottom = 0;
	    _each(panes, function(_, pane) {
	        maxLeft = _max(maxLeft, pane.canvas.deltaLeft);
	        maxRight = _max(maxRight, pane.canvas.deltaRight);
	        maxTop = _max(maxTop, pane.canvas.deltaTop);
	        maxBottom = _max(maxBottom, pane.canvas.deltaBottom)
	    });
	    if (rotated) {
	        _each(panes, function(_, pane) {
	            pane.canvas.top += maxTop;
	            pane.canvas.bottom += maxBottom;
	            pane.canvas.right += pane.canvas.deltaRight;
	            pane.canvas.left += pane.canvas.deltaLeft
	        })
	    } else {
	        _each(panes, function(_, pane) {
	            pane.canvas.top += pane.canvas.deltaTop;
	            pane.canvas.bottom += pane.canvas.deltaBottom;
	            pane.canvas.right += maxRight;
	            pane.canvas.left += maxLeft
	        })
	    }
	    _each(panes, function(_, pane) {
	        if (pane.canvas.top + pane.canvas.bottom > pane.canvas.height) {
	            stopDrawAxes = true
	        }
	        if (pane.canvas.left + pane.canvas.right > pane.canvas.width) {
	            stopDrawAxes = true
	        }
	    });
	    return stopDrawAxes
	}
	var inverseAlign = {
	    left: "right",
	    right: "left",
	    top: "bottom",
	    bottom: "top",
	    center: "center"
	};

	function downSize(canvas, layoutOptions) {
	    canvas[layoutOptions.cutLayoutSide] += "horizontal" === layoutOptions.cutSide ? layoutOptions.width : layoutOptions.height
	}

	function getOffset(layoutOptions, offsets) {
	    var side = layoutOptions.cutLayoutSide,
	        offset = {
	            horizontal: 0,
	            vertical: 0
	        };
	    switch (side) {
	        case "top":
	        case "left":
	            offset[layoutOptions.cutSide] = -offsets[side];
	            break;
	        case "bottom":
	        case "right":
	            offset[layoutOptions.cutSide] = offsets[side]
	    }
	    return offset
	}

	function LayoutManager() {}

	function toLayoutElementCoords(canvas) {
	    return new layoutElementModule.WrapperLayoutElement(null, {
	        x: canvas.left,
	        y: canvas.top,
	        width: canvas.width - canvas.left - canvas.right,
	        height: canvas.height - canvas.top - canvas.bottom
	    })
	}
	LayoutManager.prototype = {
	    constructor: LayoutManager,
	    setOptions: function(options) {
	        this._options = options
	    },
	    applyVerticalAxesLayout: function(axes, panes, rotated) {
	        this._applyAxesLayout(axes, panes, rotated)
	    },
	    applyHorizontalAxesLayout: function(axes, panes, rotated) {
	        axes.reverse();
	        this._applyAxesLayout(axes, panes, rotated);
	        axes.reverse()
	    },
	    _applyAxesLayout: function(axes, panes, rotated) {
	        var canvas, axisPosition, box, delta, axis, axisLength, direction, directionMultiplier, pane, i, that = this,
	            someDirection = [];
	        _each(panes, function(_, pane) {
	            _extend(pane.canvas, {
	                deltaLeft: 0,
	                deltaRight: 0,
	                deltaTop: 0,
	                deltaBottom: 0
	            })
	        });
	        for (i = 0; i < axes.length; i++) {
	            axis = axes[i];
	            axisPosition = axis.getOptions().position || "left";
	            axis.delta = {};
	            box = axis.getBoundingRect();
	            pane = getPane(axis.pane, panes);
	            canvas = pane.canvas;
	            if (!isValidBox(box)) {
	                continue
	            }
	            direction = "delta" + axisPosition.slice(0, 1).toUpperCase() + axisPosition.slice(1);
	            switch (axisPosition) {
	                case "right":
	                    directionMultiplier = 1;
	                    canvas.deltaLeft += axis.padding ? axis.padding.left : 0;
	                    break;
	                case "left":
	                    directionMultiplier = -1;
	                    canvas.deltaRight += axis.padding ? axis.padding.right : 0;
	                    break;
	                case "top":
	                    directionMultiplier = -1;
	                    canvas.deltaBottom += axis.padding ? axis.padding.bottom : 0;
	                    break;
	                case "bottom":
	                    directionMultiplier = 1;
	                    canvas.deltaTop += axis.padding ? axis.padding.top : 0
	            }
	            switch (axisPosition) {
	                case "right":
	                case "left":
	                    if (!box.isEmpty) {
	                        delta = box.y + box.height - (canvas.height - canvas.originalBottom);
	                        if (delta > 0) {
	                            that.requireAxesRedraw = true;
	                            canvas.deltaBottom += delta
	                        }
	                        delta = canvas.originalTop - box.y;
	                        if (delta > 0) {
	                            that.requireAxesRedraw = true;
	                            canvas.deltaTop += delta
	                        }
	                    }
	                    axisLength = box.width;
	                    someDirection = ["Left", "Right"];
	                    break;
	                case "top":
	                case "bottom":
	                    if (!box.isEmpty) {
	                        delta = box.x + box.width - (canvas.width - canvas.originalRight);
	                        if (delta > 0) {
	                            that.requireAxesRedraw = true;
	                            canvas.deltaRight += delta
	                        }
	                        delta = canvas.originalLeft - box.x;
	                        if (delta > 0) {
	                            that.requireAxesRedraw = true;
	                            canvas.deltaLeft += delta
	                        }
	                    }
	                    someDirection = ["Bottom", "Top"];
	                    axisLength = box.height
	            }
	            if (!axis.delta[axisPosition] && canvas[direction] > 0) {
	                canvas[direction] += axis.getMultipleAxesSpacing()
	            }
	            axis.delta[axisPosition] = axis.delta[axisPosition] || 0;
	            axis.delta[axisPosition] += canvas[direction] * directionMultiplier;
	            canvas[direction] += axisLength
	        }
	        that.requireAxesRedraw = correctDeltaMarginValue(panes, someDirection) || that.requireAxesRedraw;
	        that.stopDrawAxes = applyFoundExceedings(panes, rotated)
	    },
	    applyPieChartSeriesLayout: function(canvas, series, hideLayoutLabels) {
	        var sizeLabels, averageWidthLabels, fullRadiusWithLabels, paneSpaceHeight = canvas.height - canvas.top - canvas.bottom,
	            paneSpaceWidth = canvas.width - canvas.left - canvas.right,
	            paneCenterX = paneSpaceWidth / 2 + canvas.left,
	            paneCenterY = paneSpaceHeight / 2 + canvas.top,
	            piePercentage = this._options.piePercentage,
	            accessibleRadius = _isNumber(piePercentage) ? piePercentage * _min(canvas.height, canvas.width) / 2 : _min(paneSpaceWidth, paneSpaceHeight) / 2,
	            minR = .7 * accessibleRadius,
	            countSeriesWithOuterLabels = 0,
	            innerRadius = getInnerRadius(series[0]);
	        if (!hideLayoutLabels && !_isNumber(piePercentage)) {
	            sizeLabels = getSizeLabels(series);
	            fullRadiusWithLabels = paneCenterX - sizeLabels.common + canvas.left;
	            if (fullRadiusWithLabels < minR) {
	                accessibleRadius = minR;
	                _each(sizeLabels.sizes, function(_, size) {
	                    0 !== size && countSeriesWithOuterLabels++
	                });
	                averageWidthLabels = (paneCenterX - accessibleRadius - canvas.left) / countSeriesWithOuterLabels
	            } else {
	                accessibleRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR), fullRadiusWithLabels)
	            }
	            correctLabelRadius(sizeLabels.sizes, accessibleRadius, series, canvas, averageWidthLabels)
	        }
	        return {
	            centerX: _floor(paneCenterX),
	            centerY: _floor(paneCenterY),
	            radiusInner: _floor(accessibleRadius * innerRadius),
	            radiusOuter: _floor(accessibleRadius),
	            canvas: canvas
	        }
	    },
	    needMoreSpaceForPanesCanvas: function(panes, rotated) {
	        var options = this._options,
	            width = options.width,
	            height = options.height,
	            piePercentage = options.piePercentage,
	            percentageIsValid = _isNumber(piePercentage),
	            needHorizontalSpace = 0,
	            needVerticalSpace = 0;
	        _each(panes, function(_, pane) {
	            var paneCanvas = pane.canvas,
	                minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : void 0,
	                needPaneHorizontalSpace = (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right),
	                needPaneVerticalSpace = (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom);
	            if (rotated) {
	                needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;
	                needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace)
	            } else {
	                needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);
	                needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0
	            }
	        });
	        return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
	            width: needHorizontalSpace,
	            height: needVerticalSpace
	        } : false
	    },
	    layoutElements: function(elements, canvas, funcAxisDrawer, panes, rotated, axes) {
	        this._elements = elements;
	        this._probeDrawing(canvas);
	        this._drawElements(canvas);
	        funcAxisDrawer && funcAxisDrawer();
	        this._processAdaptiveLayout(panes, rotated, canvas, axes, funcAxisDrawer);
	        this._positionElements(canvas)
	    },
	    _processAdaptiveLayout: function(panes, rotated, canvas, axes, funcAxisDrawer) {
	        var that = this,
	            size = that.needMoreSpaceForPanesCanvas(panes, rotated),
	            items = this._elements;
	        if (!size) {
	            return
	        }

	        function processCanvases(item, layoutOptions, side) {
	            if (!item.getLayoutOptions()[side]) {
	                canvas[layoutOptions.cutLayoutSide] -= layoutOptions[side];
	                size[side] = Math.max(size[side] - layoutOptions[side], 0)
	            }
	        }
	        $.each(items.slice().reverse(), function(_, item) {
	            var sizeObject, layoutOptions = _extend({}, item.getLayoutOptions());
	            if (!layoutOptions) {
	                return
	            }
	            sizeObject = $.extend({}, layoutOptions);
	            if ("vertical" === layoutOptions.cutSide && size.height) {
	                item.draw(sizeObject.width, sizeObject.height - size.height);
	                processCanvases(item, layoutOptions, "height")
	            }
	            if ("horizontal" === layoutOptions.cutSide && size.width) {
	                item.draw(sizeObject.width - size.width, sizeObject.height);
	                processCanvases(item, layoutOptions, "width")
	            }
	        });
	        updateAxis(axes.verticalAxes, "width", size);
	        updateAxis(axes.horizontalAxes, "height", size);
	        funcAxisDrawer && funcAxisDrawer(true)
	    },
	    _probeDrawing: function(canvas) {
	        var that = this;
	        $.each(this._elements, function(_, item) {
	            var sizeObject, layoutOptions = item.getLayoutOptions();
	            if (!layoutOptions) {
	                return
	            }
	            sizeObject = {
	                width: canvas.width - canvas.left - canvas.right,
	                height: canvas.height - canvas.top - canvas.bottom
	            };
	            if ("vertical" === layoutOptions.cutSide) {
	                sizeObject.height -= that._options.height
	            } else {
	                sizeObject.width -= that._options.width
	            }
	            item.probeDraw(sizeObject.width, sizeObject.height);
	            downSize(canvas, item.getLayoutOptions())
	        })
	    },
	    _drawElements: function(canvas) {
	        $.each(this._elements.slice().reverse(), function(_, item) {
	            var sizeObject, cutSide, length, layoutOptions = item.getLayoutOptions();
	            if (!layoutOptions) {
	                return
	            }
	            sizeObject = {
	                width: canvas.width - canvas.left - canvas.right,
	                height: canvas.height - canvas.top - canvas.bottom
	            };
	            cutSide = layoutOptions.cutSide;
	            length = "horizontal" === cutSide ? "width" : "height";
	            sizeObject[length] = layoutOptions[length];
	            item.draw(sizeObject.width, sizeObject.height)
	        })
	    },
	    _positionElements: function(canvas) {
	        var offsets = {
	            left: 0,
	            right: 0,
	            top: 0,
	            bottom: 0
	        };
	        $.each(this._elements.slice().reverse(), function(_, item) {
	            var position, cutSide, my, layoutOptions = item.getLayoutOptions();
	            if (!layoutOptions) {
	                return
	            }
	            position = layoutOptions.position;
	            cutSide = layoutOptions.cutSide;
	            my = {
	                horizontal: position.horizontal,
	                vertical: position.vertical
	            };
	            my[cutSide] = inverseAlign[my[cutSide]];
	            item.position({
	                of: toLayoutElementCoords(canvas),
	                my: my,
	                at: position,
	                offset: getOffset(layoutOptions, offsets)
	            });
	            offsets[layoutOptions.cutLayoutSide] += layoutOptions["horizontal" === layoutOptions.cutSide ? "width" : "height"]
	        })
	    }
	};
	exports.LayoutManager = LayoutManager;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/tracker.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    clickEvent = __webpack_require__(65),
	    eventsConsts = __webpack_require__(305).events,
	    vizUtils = __webpack_require__(291),
	    commonUtils = __webpack_require__(8),
	    pointerEvents = __webpack_require__(66),
	    wheelEvent = __webpack_require__(75),
	    holdEvent = __webpack_require__(132),
	    devices = __webpack_require__(40),
	    isDefined = commonUtils.isDefined,
	    _normalizeEnum = __webpack_require__(291).normalizeEnum,
	    _floor = Math.floor,
	    _each = $.each,
	    _inArray = $.inArray,
	    _noop = $.noop,
	    MULTIPLE_MODE = "multiple",
	    ALL_ARGUMENTS_POINTS_MODE = "allargumentpoints",
	    ALL_SERIES_POINTS_MODE = "allseriespoints",
	    NONE_MODE = "none",
	    POINTER_ACTION = [pointerEvents.down, pointerEvents.move].join(" "),
	    POINT_SELECTION_CHANGED = "pointSelectionChanged",
	    LEGEND_CLICK = "legendClick",
	    SERIES_CLICK = "seriesClick",
	    POINT_CLICK = "pointClick",
	    RELEASE_POINT_SELECTED_STATE = "releasePointSelectedState",
	    SET_POINT_SELECTED_STATE = "setPointSelectedState",
	    SET_POINT_HOVER_STATE = "setPointHoverState",
	    SERIES_HOVER_CHANGED = "seriesHoverChanged",
	    POINT_HOVER_CHANGED = "pointHoverChanged",
	    RELEASE_POINT_HOVER_STATE = "releasePointHoverState",
	    SERIES_SELECTION_CHANGED = "seriesSelectionChanged",
	    ZOOM_START = "zoomStart",
	    POINT_DATA = "chart-data-point",
	    SERIES_DATA = "chart-data-series",
	    ARG_DATA = "chart-data-argument",
	    DELAY = 100;

	function getData(event, dataKey) {
	    var target = event.target;
	    return ("tspan" === target.tagName ? target.parentNode : target)[dataKey]
	}

	function eventCanceled(event, target) {
	    return event.cancel || !target.getOptions()
	}

	function inCanvas(canvas, x, y) {
	    return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom
	}

	function setPointsSpecState(points, targetPoint, func, eventName, eventTrigger) {
	    _each(points, function(_, currentPoint) {
	        var series = currentPoint.series;
	        if (currentPoint === targetPoint) {
	            series[func]({
	                point: currentPoint,
	                setState: true
	            });
	            eventName && eventTrigger(eventName, {
	                target: currentPoint
	            })
	        } else {
	            series[func]({
	                point: currentPoint
	            })
	        }
	    })
	}
	var baseTrackerPrototype = {
	    ctor: function(options) {
	        var that = this,
	            data = {
	                tracker: that
	            };
	        that._renderer = options.renderer;
	        that._legend = options.legend;
	        that._tooltip = options.tooltip;
	        that._eventTrigger = options.eventTrigger;
	        options.seriesGroup.off().on(eventsConsts.selectSeries, data, that._selectSeries).on(eventsConsts.deselectSeries, data, that._deselectSeries).on(eventsConsts.selectPoint, data, that._selectPoint).on(eventsConsts.deselectPoint, data, that._deselectPoint).on(eventsConsts.showPointTooltip, data, that._showPointTooltip).on(eventsConsts.hidePointTooltip, data, that._hidePointTooltip);
	        that._renderer.root.off(POINTER_ACTION).off([clickEvent.name, holdEvent.name].join(" ")).on(POINTER_ACTION, data, that._pointerHandler).on(clickEvent.name, data, that._clickHandler).on(holdEvent.name, {
	            timeout: 300
	        }, _noop)
	    },
	    _setSelectedPoint: _noop,
	    _releaseSelectedPoint: _noop,
	    _releaseSelectedSeries: _noop,
	    _setSelectedSeries: _noop,
	    update: function(options) {
	        var that = this;
	        if (_normalizeEnum(options.pointSelectionMode) === MULTIPLE_MODE) {
	            that._setSelectedPoint = that._selectPointMultipleMode;
	            that._releaseSelectedPoint = that._releaseSelectedPointMultipleMode
	        } else {
	            that._setSelectedPoint = that._selectPointSingleMode;
	            that._releaseSelectedPoint = that._releaseSelectedPointSingleMode
	        }
	        if (_normalizeEnum(options.seriesSelectionMode) === MULTIPLE_MODE) {
	            that._releaseSelectedSeries = that._releaseSelectedSeriesMultipleMode;
	            that._setSelectedSeries = that._setSelectedSeriesMultipleMode
	        } else {
	            that._releaseSelectedSeries = that._releaseSelectedSeriesSingleMode;
	            that._setSelectedSeries = that._setSelectedSeriesSingleMode
	        }
	        that._prepare()
	    },
	    updateSeries: function(series) {
	        var that = this;
	        if (that._storedSeries !== series) {
	            that._storedSeries = series || [];
	            that._clean()
	        } else {
	            that._hideTooltip(that.pointAtShownTooltip);
	            that._clearHover();
	            that.clearSelection()
	        }
	    },
	    setCanvases: function(mainCanvas, paneCanvases) {
	        this._mainCanvas = mainCanvas;
	        this._canvases = paneCanvases
	    },
	    repairTooltip: function() {
	        var point = this.pointAtShownTooltip;
	        if (point && !point.isVisible()) {
	            this._hideTooltip(point, true)
	        } else {
	            this._showTooltip(point)
	        }
	    },
	    _prepare: function() {
	        this._toggleParentsScrollSubscription(true)
	    },
	    _toggleParentsScrollSubscription: function(subscribe) {
	        var that = this,
	            $parents = $(that._renderer.root.element).parents(),
	            scrollEvents = "scroll.dxChartTracker";
	        if ("generic" === devices.real().platform) {
	            $parents = $parents.add(window)
	        }
	        $().add(that._$prevRootParents).off(scrollEvents);
	        if (subscribe) {
	            $parents.on(scrollEvents, function() {
	                that._pointerOut()
	            });
	            that._$prevRootParents = $parents
	        }
	    },
	    _selectPointMultipleMode: function(point) {
	        var that = this;
	        that._selectedPoint = that._selectedPoint || [];
	        if (_inArray(point, that._selectedPoint) < 0) {
	            that._selectedPoint.push(point);
	            that._setPointState(point, SET_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point))
	        }
	    },
	    _releaseSelectedPointMultipleMode: function(point) {
	        var that = this,
	            points = that._selectedPoint || [],
	            pointIndex = _inArray(point, points);
	        if (pointIndex >= 0) {
	            that._setPointState(point, RELEASE_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point));
	            points.splice(pointIndex, 1)
	        } else {
	            if (!point) {
	                _each(points, function(_, point) {
	                    that._releaseSelectedPoint(point)
	                })
	            }
	        }
	    },
	    _selectPointSingleMode: function(point) {
	        var that = this;
	        if (that._selectedPoint !== point) {
	            that._releaseSelectedPoint();
	            that._selectedPoint = point;
	            that._setPointState(point, SET_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point))
	        }
	    },
	    _releaseSelectedPointSingleMode: function() {
	        var that = this,
	            point = that._selectedPoint;
	        if (point) {
	            that._setPointState(point, RELEASE_POINT_SELECTED_STATE, _normalizeEnum(point.getOptions().selectionMode), POINT_SELECTION_CHANGED, that._legend.getActionCallback(point));
	            that._selectedPoint = null
	        }
	    },
	    _setHoveredPoint: function(point, mode) {
	        var that = this;
	        if (that.hoveredPoint === point || !point.series) {
	            return
	        }
	        that._releaseHoveredPoint();
	        if (point && point.getOptions() && mode !== NONE_MODE) {
	            that.hoveredPoint = point;
	            that._setPointState(point, SET_POINT_HOVER_STATE, mode || _normalizeEnum(point.getOptions().hoverMode), POINT_HOVER_CHANGED, that._legend.getActionCallback(point))
	        }
	    },
	    _releaseHoveredPoint: function() {
	        var that = this,
	            point = that.hoveredPoint,
	            eventTrigger = that._eventTrigger;
	        if (!point || !point.getOptions()) {
	            return
	        }
	        that._releasePoint(point, eventTrigger);
	        if (that._tooltip.isEnabled()) {
	            that._hideTooltip(point)
	        }
	        that.hoveredPoint = null
	    },
	    _setSelectedSeriesMultipleMode: function(series, mode) {
	        var that = this;
	        that._selectedSeries = that._selectedSeries || [];
	        if (_inArray(series, that._selectedSeries) < 0) {
	            that._selectedSeries.push(series);
	            series.setSelectedState(true, mode, that._legend.getActionCallback(series));
	            that._eventTrigger(SERIES_SELECTION_CHANGED, {
	                target: series
	            })
	        }
	    },
	    _setSelectedSeriesSingleMode: function(series, mode) {
	        var that = this;
	        if (series !== that._selectedSeries || series.lastSelectionMode !== mode) {
	            that._releaseSelectedSeries();
	            that._selectedSeries = series;
	            series.setSelectedState(true, mode, that._legend.getActionCallback(series));
	            that._eventTrigger(SERIES_SELECTION_CHANGED, {
	                target: series
	            })
	        }
	    },
	    _releaseSelectedSeriesMultipleMode: function(series) {
	        var that = this,
	            selectedSeries = that._selectedSeries || [],
	            seriesIndex = _inArray(series, selectedSeries);
	        if (seriesIndex >= 0) {
	            series.setSelectedState(false, void 0, that._legend.getActionCallback(series));
	            that._eventTrigger(SERIES_SELECTION_CHANGED, {
	                target: series
	            });
	            selectedSeries.splice(seriesIndex, 1)
	        } else {
	            if (!series) {
	                _each(selectedSeries, function(_, series) {
	                    that._releaseSelectedSeries(series)
	                })
	            }
	        }
	    },
	    _releaseSelectedSeriesSingleMode: function(series) {
	        var that = this,
	            selectedSeries = that._selectedSeries;
	        if (selectedSeries && (!series || series === selectedSeries)) {
	            selectedSeries.setSelectedState(false, void 0, that._legend.getActionCallback(selectedSeries));
	            that._eventTrigger(SERIES_SELECTION_CHANGED, {
	                target: selectedSeries
	            });
	            that._selectedSeries = null
	        }
	    },
	    _setHoveredSeries: function(series, mode) {
	        var that = this;
	        if (mode !== NONE_MODE && that.hoveredSeries !== series || that._isModeChanged(series, mode)) {
	            that._clearHover();
	            series.setHoverState(true, mode, that._legend.getActionCallback(series));
	            that._eventTrigger(SERIES_HOVER_CHANGED, {
	                target: series
	            });
	            that.hoveredSeries = series
	        }
	    },
	    _releaseHoveredSeries: function(needSetHoverView, hoveredPoint) {
	        var that = this,
	            hoveredSeries = that.hoveredSeries,
	            seriesWithHoverView = that._seriesWithHoverView;
	        if (hoveredSeries) {
	            hoveredSeries.setHoverState(false, void 0, that._legend.getActionCallback(hoveredSeries));
	            if (needSetHoverView && hoveredPoint && hoveredPoint.series === hoveredSeries) {
	                that._seriesWithHoverView = hoveredSeries.setHoverView()
	            }
	            that._eventTrigger(SERIES_HOVER_CHANGED, {
	                target: hoveredSeries
	            });
	            that.hoveredSeries = null
	        } else {
	            if (seriesWithHoverView && !needSetHoverView) {
	                seriesWithHoverView.releaseHoverView();
	                that._seriesWithHoverView = null
	            }
	        }
	    },
	    _selectSeries: function(event, mode) {
	        event.data.tracker._setSelectedSeries(event.target, mode)
	    },
	    _deselectSeries: function(event, mode) {
	        event.data.tracker._releaseSelectedSeries(event.target, mode)
	    },
	    _selectPoint: function(event, point) {
	        event.data.tracker._setSelectedPoint(point)
	    },
	    _deselectPoint: function(event, point) {
	        event.data.tracker._releaseSelectedPoint(point)
	    },
	    clearSelection: function() {
	        this._releaseSelectedPoint();
	        this._releaseSelectedSeries()
	    },
	    _clean: function() {
	        var that = this;
	        that._selectedPoint = that._selectedSeries = that.hoveredPoint = that.hoveredSeries = that._hoveredArgumentPoints = that._seriesWithHoverView = null;
	        that._hideTooltip(that.pointAtShownTooltip)
	    },
	    _clearHover: function() {
	        this._releaseHoveredSeries(false);
	        this._releaseHoveredPoint()
	    },
	    _hideTooltip: function(point, silent) {
	        var that = this;
	        if (!that._tooltip || point && that.pointAtShownTooltip !== point) {
	            return
	        }
	        if (!silent && that.pointAtShownTooltip) {
	            that.pointAtShownTooltip = null
	        }
	        that._tooltip.hide()
	    },
	    _showTooltip: function(point) {
	        var tooltipFormatObject, eventData, that = this;
	        if (point && point.getOptions()) {
	            tooltipFormatObject = point.getTooltipFormatObject(that._tooltip);
	            if (!isDefined(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {
	                return
	            }
	            if (!that.pointAtShownTooltip || that.pointAtShownTooltip !== point) {
	                eventData = {
	                    target: point
	                }
	            }
	            var coords = point.getTooltipParams(that._tooltip.getLocation()),
	                rootOffset = that._renderer.getRootOffset();
	            coords.x += rootOffset.left;
	            coords.y += rootOffset.top;
	            if (!that._tooltip.show(tooltipFormatObject, coords, eventData)) {
	                return
	            }
	            that.pointAtShownTooltip = point
	        }
	    },
	    _showPointTooltip: function(event, point) {
	        var that = event.data.tracker,
	            pointWithTooltip = that.pointAtShownTooltip;
	        if (pointWithTooltip && pointWithTooltip !== point) {
	            that._hideTooltip(pointWithTooltip)
	        }
	        that._showTooltip(point)
	    },
	    _hidePointTooltip: function(event, point) {
	        event.data.tracker._hideTooltip(point)
	    },
	    _enableOutHandler: function() {
	        if (this._outHandler) {
	            return
	        }
	        var that = this,
	            handler = function(e) {
	                var rootOffset = that._renderer.getRootOffset(),
	                    x = _floor(e.pageX - rootOffset.left),
	                    y = _floor(e.pageY - rootOffset.top);
	                if (!inCanvas(that._mainCanvas, x, y)) {
	                    that._pointerOut();
	                    that._disableOutHandler()
	                }
	            };
	        $(document).on(POINTER_ACTION, handler);
	        this._outHandler = handler
	    },
	    _disableOutHandler: function() {
	        this._outHandler && $(document).off(POINTER_ACTION, this._outHandler);
	        this._outHandler = null
	    },
	    _pointerOut: function() {
	        this._clearHover();
	        this._tooltip.isEnabled() && this._hideTooltip(this.pointAtShownTooltip)
	    },
	    _triggerLegendClick: function(eventArgs, elementClick) {
	        var eventTrigger = this._eventTrigger;
	        eventTrigger(LEGEND_CLICK, eventArgs, function() {
	            !eventCanceled(eventArgs.jQueryEvent, eventArgs.target) && eventTrigger(elementClick, eventArgs)
	        })
	    },
	    _hoverLegendItem: function(x, y) {
	        var series, that = this,
	            item = that._legend.getItemByCoord(x, y);
	        if (item) {
	            series = that._storedSeries[item.id];
	            that._setHoveredSeries(series, that._legend._options.hoverMode);
	            that._tooltip.isEnabled() && that._hideTooltip(that.pointAtShownTooltip)
	        } else {
	            that._clearHover()
	        }
	    },
	    _pointerHandler: function(e) {
	        var that = e.data.tracker,
	            rootOffset = that._renderer.getRootOffset(),
	            x = _floor(e.pageX - rootOffset.left),
	            y = _floor(e.pageY - rootOffset.top),
	            canvas = that._getCanvas(x, y),
	            series = getData(e, SERIES_DATA),
	            point = getData(e, POINT_DATA) || series && series.getPointByCoord(x, y);
	        that._enableOutHandler();
	        if (that._checkGestureEvents(e, canvas, rootOffset)) {
	            return
	        }
	        if (that._legend.coordsIn(x, y)) {
	            that._hoverLegendItem(x, y);
	            return
	        }
	        if (that.hoveredSeries && that.hoveredSeries !== that._stuckSeries) {
	            that._releaseHoveredSeries()
	        }
	        if (that._hoverArgumentAxis(x, y, e)) {
	            return
	        }
	        if (that._isPointerOut(canvas, point)) {
	            that._pointerOut()
	        }
	        if (!canvas && !point) {
	            return
	        }
	        if (series && !point) {
	            point = series.getNeighborPoint(x, y);
	            if (series !== that.hoveredSeries) {
	                that._setTimeout(function() {
	                    that._setHoveredSeries(series, series.getOptions().hoverMode);
	                    that._stuckSeries = series;
	                    that._pointerComplete(point, x, y)
	                }, series);
	                return
	            }
	        } else {
	            if (point) {
	                if (that.hoveredSeries) {
	                    that._setTimeout(function() {
	                        that._pointerOnPoint(point, x, y)
	                    }, point)
	                } else {
	                    that._pointerOnPoint(point, x, y);
	                    that._setSeriesWithHoverView(point)
	                }
	                return
	            } else {
	                if (that._setStuckSeries(x, y)) {
	                    series = that._stuckSeries;
	                    point = series.getNeighborPoint(x, y);
	                    that._releaseHoveredSeries();
	                    point && that._setHoveredPoint(point)
	                }
	            }
	        }
	        that._pointerComplete(point, x, y)
	    },
	    _pointerOnPoint: function(point, x, y) {
	        this._setHoveredPoint(point);
	        this._pointerComplete(point, x, y)
	    },
	    _pointerComplete: function(point) {
	        this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point)
	    },
	    _clickHandler: function(e) {
	        var that = e.data.tracker,
	            rootOffset = that._renderer.getRootOffset(),
	            x = _floor(e.pageX - rootOffset.left),
	            y = _floor(e.pageY - rootOffset.top),
	            point = getData(e, POINT_DATA),
	            series = that._stuckSeries || getData(e, SERIES_DATA) || point && point.series,
	            axis = that._argumentAxis;
	        if (that._legend.coordsIn(x, y)) {
	            var item = that._legend.getItemByCoord(x, y);
	            if (item) {
	                that._legendClick(item, e)
	            }
	        } else {
	            if (axis && axis.coordsIn(x, y)) {
	                var argument = getData(e, ARG_DATA);
	                if (isDefined(argument)) {
	                    that._eventTrigger("argumentAxisClick", {
	                        argument: argument,
	                        jQueryEvent: e
	                    })
	                }
	            } else {
	                if (series) {
	                    point = point || series.getPointByCoord(x, y);
	                    if (point) {
	                        that._pointClick(point, e)
	                    } else {
	                        getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {
	                            target: series,
	                            jQueryEvent: e
	                        })
	                    }
	                }
	            }
	        }
	    },
	    dispose: function() {
	        var that = this;
	        that._disableOutHandler();
	        that._toggleParentsScrollSubscription();
	        _each(that, function(k) {
	            that[k] = null
	        })
	    }
	};
	var ChartTracker = function(options) {
	    this.ctor(options)
	};
	$.extend(ChartTracker.prototype, baseTrackerPrototype, {
	    _pointClick: function(point, event) {
	        var that = this,
	            eventTrigger = that._eventTrigger,
	            series = point.series;
	        eventTrigger(POINT_CLICK, {
	            target: point,
	            jQueryEvent: event
	        }, function() {
	            !eventCanceled(event, series) && eventTrigger(SERIES_CLICK, {
	                target: series,
	                jQueryEvent: event
	            })
	        })
	    },
	    update: function(options) {
	        var that = this;
	        that._zoomingMode = _normalizeEnum(options.zoomingMode);
	        that._scrollingMode = _normalizeEnum(options.scrollingMode);
	        baseTrackerPrototype.update.call(this, options);
	        that._argumentAxis = options.argumentAxis || {};
	        that._axisHoverEnabled = that._argumentAxis && _normalizeEnum(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENTS_POINTS_MODE;
	        that._chart = options.chart;
	        that._rotated = options.rotated;
	        that._crosshair = options.crosshair
	    },
	    _getCanvas: function(x, y) {
	        var that = this,
	            canvases = that._canvases || [];
	        for (var i = 0; i < canvases.length; i++) {
	            var c = canvases[i];
	            if (inCanvas(c, x, y)) {
	                return c
	            }
	        }
	        return null
	    },
	    _getPointSeries: function(point) {
	        return point.series
	    },
	    _isModeChanged: function(series, mode) {
	        return series.lastHoverMode !== mode
	    },
	    _isPointerOut: function(canvas) {
	        return !canvas && this._stuckSeries
	    },
	    _resetHoveredArgument: function() {
	        if (isDefined(this.hoveredArgument)) {
	            this._toAllArgumentPoints(this.hoveredArgument, RELEASE_POINT_HOVER_STATE);
	            this.hoveredArgument = null
	        }
	    },
	    _toAllArgumentPoints: function(argument, func, eventName, targetPoint) {
	        var that = this;
	        _each(that._storedSeries, function(_, series) {
	            setPointsSpecState(series.getPointsByArg(argument), targetPoint, func, eventName, that._eventTrigger)
	        })
	    },
	    _hideCrosshair: function() {
	        this._crosshair && this._crosshair.hide()
	    },
	    _moveCrosshair: function(point, x, y) {
	        if (point && this._crosshair && point.isVisible()) {
	            this._crosshair.show({
	                point: point,
	                x: x,
	                y: y
	            })
	        }
	    },
	    _releasePoint: function(point, eventTrigger) {
	        var that = this,
	            mode = _normalizeEnum(point.getOptions().hoverMode);
	        if (mode === ALL_SERIES_POINTS_MODE) {
	            setPointsSpecState(point.series.getPoints(), point, RELEASE_POINT_HOVER_STATE, POINT_HOVER_CHANGED, eventTrigger)
	        } else {
	            if (mode === ALL_ARGUMENTS_POINTS_MODE) {
	                that._toAllArgumentPoints(point.argument, RELEASE_POINT_HOVER_STATE, POINT_HOVER_CHANGED, point)
	            } else {
	                if ("none" !== mode) {
	                    that._getPointSeries(point).releasePointHoverState({
	                        point: point,
	                        setState: true,
	                        legendCallback: that._legend.getActionCallback(point)
	                    });
	                    eventTrigger(POINT_HOVER_CHANGED, {
	                        target: point
	                    })
	                }
	            }
	        }
	    },
	    _setPointState: function(point, action, mode, eventName, legendCallback) {
	        var series, that = this,
	            eventTrigger = that._eventTrigger;
	        switch (mode) {
	            case ALL_ARGUMENTS_POINTS_MODE:
	                that._toAllArgumentPoints(point.argument, action, eventName, point);
	                break;
	            case ALL_SERIES_POINTS_MODE:
	                setPointsSpecState(point.series.getPoints(), point, action, eventName, eventTrigger);
	                break;
	            case NONE_MODE:
	                break;
	            default:
	                series = that._getPointSeries(point);
	                series[action]({
	                    point: point,
	                    legendCallback: legendCallback,
	                    setState: true
	                });
	                eventTrigger(eventName, {
	                    target: point
	                })
	        }
	    },
	    _prepare: function() {
	        var that = this,
	            root = that._renderer.root,
	            touchScrollingEnabled = "all" === that._scrollingMode || "touch" === that._scrollingMode,
	            touchZoomingEnabled = "all" === that._zoomingMode || "touch" === that._zoomingMode,
	            cssValue = (!touchScrollingEnabled ? "pan-x pan-y " : "") + (!touchZoomingEnabled ? "pinch-zoom" : "") || "none",
	            rootStyles = {
	                "touch-action": cssValue,
	                "-ms-touch-action": cssValue
	            },
	            wheelZoomingEnabled = "all" === that._zoomingMode || "mouse" === that._zoomingMode;
	        root.off(wheelEvent.name + " dxc-scroll-start dxc-scroll-move");
	        baseTrackerPrototype._prepare.call(that);
	        if (!that._gestureEndHandler) {
	            that._gestureEndHandler = function() {
	                that._gestureEnd && that._gestureEnd()
	            };
	            $(document).on(pointerEvents.up, that._gestureEndHandler)
	        }
	        wheelZoomingEnabled && root.on(wheelEvent.name, function(e) {
	            var rootOffset = that._renderer.getRootOffset(),
	                x = that._rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left,
	                scale = that._argumentAxis.getTranslator().getMinScale(e.delta > 0),
	                translate = x - x * scale,
	                zoom = that._argumentAxis.getTranslator().zoom(-translate, scale);
	            that._pointerOut();
	            that._eventTrigger(ZOOM_START);
	            that._chart.zoomArgument(zoom.min, zoom.max, true);
	            e.preventDefault();
	            e.stopPropagation()
	        });
	        root.on("dxc-scroll-start", function(e) {
	            that._startScroll = true;
	            that._gestureStart(that._getGestureParams(e, {
	                left: 0,
	                top: 0
	            }))
	        }).on("dxc-scroll-move", function(e) {
	            that._gestureChange(that._getGestureParams(e, {
	                left: 0,
	                top: 0
	            })) && e.preventDefault()
	        });
	        root.css(rootStyles)
	    },
	    _getGestureParams: function(e, offset) {
	        var x1, x2, left, right, that = this,
	            touches = e.pointers.length,
	            eventCoordField = that._rotated ? "pageY" : "pageX";
	        offset = that._rotated ? offset.top : offset.left;
	        if (2 === touches) {
	            x1 = e.pointers[0][eventCoordField] - offset;
	            x2 = e.pointers[1][eventCoordField] - offset
	        } else {
	            if (1 === touches) {
	                x1 = x2 = e.pointers[0][eventCoordField] - offset
	            }
	        }
	        left = Math.min(x1, x2);
	        right = Math.max(x1, x2);
	        return {
	            center: left + (right - left) / 2,
	            distance: right - left,
	            touches: touches,
	            scale: 1,
	            pointerType: e.pointerType
	        }
	    },
	    _gestureStart: function(gestureParams) {
	        var that = this;
	        that._startGesture = that._startGesture || gestureParams;
	        if (that._startGesture.touches !== gestureParams.touches) {
	            that._startGesture = gestureParams
	        }
	    },
	    _gestureChange: function(gestureParams) {
	        var that = this,
	            startGesture = that._startGesture,
	            gestureChanged = false,
	            scrollingEnabled = "all" === that._scrollingMode || "none" !== that._scrollingMode && that._scrollingMode === gestureParams.pointerType,
	            zoomingEnabled = "all" === that._zoomingMode || "touch" === that._zoomingMode;
	        if (!startGesture) {
	            return gestureChanged
	        }
	        if (1 === startGesture.touches && Math.abs(startGesture.center - gestureParams.center) < 3) {
	            that._gestureStart(gestureParams);
	            return gestureChanged
	        }
	        if (2 === startGesture.touches && zoomingEnabled) {
	            gestureChanged = true;
	            startGesture.scale = gestureParams.distance / startGesture.distance;
	            startGesture.scroll = gestureParams.center - startGesture.center + (startGesture.center - startGesture.center * startGesture.scale)
	        } else {
	            if (1 === startGesture.touches && scrollingEnabled) {
	                gestureChanged = true;
	                startGesture.scroll = gestureParams.center - startGesture.center
	            }
	        }
	        if (gestureChanged) {
	            if (that._startScroll) {
	                that._eventTrigger(ZOOM_START);
	                that._startScroll = false
	            }
	            startGesture.changed = gestureChanged;
	            that._chart._transformArgument(startGesture.scroll, startGesture.scale)
	        }
	        return gestureChanged
	    },
	    _gestureEnd: function() {
	        var zoom, that = this,
	            startGesture = that._startGesture,
	            renderer = that._renderer;
	        that._startGesture = null;
	        that._startScroll = false;

	        function complete() {
	            that._chart.zoomArgument(zoom.min, zoom.max, true)
	        }
	        if (startGesture && startGesture.changed) {
	            zoom = that._argumentAxis._translator.zoom(-startGesture.scroll, startGesture.scale);
	            if (renderer.animationEnabled() && (-startGesture.scroll !== zoom.translate || startGesture.scale !== zoom.scale)) {
	                var translateDelta = -(startGesture.scroll + zoom.translate),
	                    scaleDelta = startGesture.scale - zoom.scale;
	                renderer.root.animate({
	                    _: 0
	                }, {
	                    step: function(pos) {
	                        var translateValue = -startGesture.scroll - translateDelta * pos,
	                            scaleValue = startGesture.scale - scaleDelta * pos;
	                        that._chart._transformArgument(-translateValue, scaleValue)
	                    },
	                    complete: complete,
	                    duration: 250
	                })
	            } else {
	                complete()
	            }
	        }
	    },
	    _clean: function() {
	        var that = this;
	        baseTrackerPrototype._clean.call(that);
	        that._resetTimer();
	        that._stuckSeries = null
	    },
	    _getSeriesForShared: function(x, y) {
	        var that = this,
	            points = [],
	            point = null,
	            distance = 1 / 0;
	        if (that._tooltip.isShared() && !that.hoveredSeries) {
	            _each(that._storedSeries, function(_, series) {
	                var point = series.getNeighborPoint(x, y);
	                point && points.push(point)
	            });
	            _each(points, function(_, p) {
	                var coords = p.getCrosshairData(x, y),
	                    d = vizUtils.getDistance(x, y, coords.x, coords.y);
	                if (d < distance) {
	                    point = p;
	                    distance = d
	                }
	            })
	        }
	        return point && point.series
	    },
	    _setTimeout: function(callback, keeper) {
	        var that = this;
	        if (that._timeoutKeeper !== keeper) {
	            that._resetTimer();
	            that._hoverTimeout = setTimeout(function() {
	                callback();
	                that._timeoutKeeper = null
	            }, DELAY);
	            that._timeoutKeeper = keeper
	        }
	    },
	    _resetTimer: function() {
	        clearTimeout(this._hoverTimeout);
	        this._timeoutKeeper = this._hoverTimeout = null
	    },
	    _checkGestureEvents: function(e, canvas, rootOffset) {
	        var that = this;
	        if (e.type === pointerEvents.down) {
	            if (canvas) {
	                that._startScroll = true;
	                that._gestureStart(that._getGestureParams(e, rootOffset))
	            }
	        } else {
	            if (that._startGesture && canvas) {
	                if (that._gestureChange(that._getGestureParams(e, rootOffset))) {
	                    that._pointerOut();
	                    e.preventDefault();
	                    return true
	                }
	            }
	        }
	    },
	    _setStuckSeries: function(x, y) {
	        this._stuckSeries = this._stuckSeries || this._getSeriesForShared(x, y);
	        return !!this._stuckSeries
	    },
	    _setSeriesWithHoverView: function(point) {
	        this._seriesWithHoverView = point.series.setHoverView()
	    },
	    _pointerOut: function() {
	        var that = this;
	        that._stuckSeries = null;
	        that._hideCrosshair();
	        that._resetHoveredArgument();
	        that._resetTimer();
	        baseTrackerPrototype._pointerOut.call(that)
	    },
	    _hoverArgumentAxis: function(x, y, e) {
	        var that = this;
	        that._resetHoveredArgument();
	        if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {
	            var argument = getData(e, ARG_DATA);
	            if (isDefined(argument) && that.hoveredArgument !== argument) {
	                that._clearHover();
	                that._toAllArgumentPoints(argument, SET_POINT_HOVER_STATE);
	                that.hoveredArgument = argument
	            }
	            return true
	        }
	    },
	    _pointerComplete: function(point, x, y) {
	        var that = this;
	        that.hoveredSeries && that.hoveredSeries.updateHover(x, y);
	        that._resetTimer();
	        that._moveCrosshair(point, x, y);
	        baseTrackerPrototype._pointerComplete.call(that, point)
	    },
	    _legendClick: function(item, e) {
	        var series = this._storedSeries[item.id];
	        this._triggerLegendClick({
	            target: series,
	            jQueryEvent: e
	        }, SERIES_CLICK)
	    },
	    _hoverLegendItem: function(x, y) {
	        this._stuckSeries = null;
	        this._hideCrosshair();
	        baseTrackerPrototype._hoverLegendItem.call(this, x, y)
	    },
	    _pointerOnPoint: function(point, x, y) {
	        var that = this,
	            seriesWithHoverView = that._seriesWithHoverView,
	            seriesFromPoint = point.series;
	        that._stuckSeries = seriesFromPoint;
	        that._releaseHoveredSeries(!seriesWithHoverView || seriesWithHoverView === seriesFromPoint, point);
	        baseTrackerPrototype._pointerOnPoint.call(that, point, x, y)
	    },
	    dispose: function() {
	        this._gestureEndHandler && $(document).off(pointerEvents.up, this._gestureEndHandler);
	        this._resetTimer();
	        baseTrackerPrototype.dispose.call(this)
	    }
	});
	var PieTracker = function(options) {
	    this.ctor(options)
	};
	$.extend(PieTracker.prototype, baseTrackerPrototype, {
	    _getPointSeries: function(point) {
	        return this._storedSeries[point.index]
	    },
	    _isModeChanged: function() {
	        return false
	    },
	    _isPointerOut: function(_, point) {
	        return !point
	    },
	    _legendClick: function(item, e) {
	        this._eventTrigger(LEGEND_CLICK, {
	            target: item.argument,
	            jQueryEvent: e
	        })
	    },
	    _pointClick: function(point, e) {
	        this._eventTrigger(POINT_CLICK, {
	            target: point,
	            jQueryEvent: e
	        })
	    },
	    _releasePoint: function(point, eventTrigger) {
	        var that = this,
	            mode = _normalizeEnum(point.getOptions().hoverMode);
	        if ("none" !== mode) {
	            that._getPointSeries(point).releasePointHoverState({
	                point: point,
	                setState: true,
	                legendCallback: that._legend.getActionCallback(point)
	            });
	            eventTrigger(POINT_HOVER_CHANGED, {
	                target: point
	            })
	        }
	    },
	    _setPointState: function(point, action, mode, eventName, legendCallback) {
	        var series, that = this,
	            eventTrigger = that._eventTrigger;
	        if ("none" !== mode) {
	            series = that._getPointSeries(point);
	            series[action]({
	                point: point,
	                legendCallback: legendCallback,
	                setState: true
	            });
	            eventTrigger(eventName, {
	                target: point
	            })
	        }
	    },
	    _hoverArgumentAxis: _noop,
	    _setStuckSeries: _noop,
	    _setSeriesWithHoverView: _noop,
	    _getCanvas: _noop,
	    _checkGestureEvents: _noop
	});
	exports.ChartTracker = ChartTracker;
	exports.PieTracker = PieTracker;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/header_block.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    LayoutElementModule = __webpack_require__(300),
	    _extend = $.extend,
	    _each = $.each;

	function HeaderBlock() {}
	_extend(HeaderBlock.prototype, LayoutElementModule.LayoutElement.prototype, {
	    update: function(elements, canvas) {
	        this._elements = $.map(elements, function(element) {
	            return element.getLayoutOptions() ? element : null
	        });
	        this._canvas = canvas
	    },
	    dispose: function() {
	        this._elements = null
	    },
	    measure: function() {
	        var result, that = this,
	            layoutOptions = that.getLayoutOptions();
	        if (layoutOptions) {
	            result = {
	                size: [layoutOptions.width, layoutOptions.height],
	                alignment: [layoutOptions.horizontalAlignment, layoutOptions.verticalAlignment],
	                side: 1
	            };
	            _each(that._elements, function(_, elem) {
	                elem.draw(layoutOptions.width, layoutOptions.height, that._canvas)
	            })
	        }
	        return result || null
	    },
	    getLayoutOptions: function() {
	        var firstElement, layout, elementLayout, that = this,
	            elements = that._elements,
	            length = elements.length,
	            i = 1;
	        if (!length) {
	            return null
	        }
	        firstElement = elements[0];
	        layout = _extend(true, {}, firstElement.getLayoutOptions());
	        layout.position = layout.position || {};
	        for (i; i < length; i++) {
	            elementLayout = elements[i].getLayoutOptions();
	            if (elementLayout.height > layout.height) {
	                layout.height = elementLayout.height
	            }
	            layout.width += elementLayout.width;
	            if (elementLayout.position) {
	                layout.position = elementLayout.position;
	                layout.verticalAlignment = elementLayout.position.vertical;
	                layout.horizontalAlignment = elementLayout.position.horizontal
	            }
	        }
	        return layout
	    },
	    probeDraw: function(width, height) {
	        this._elements.forEach(function(e) {
	            e.probeDraw(width, height);
	            width -= e.getLayoutOptions().width
	        })
	    },
	    draw: function(width, height) {
	        var canvas = this._canvas;
	        this._elements.forEach(function(e) {
	            e.draw(width, height, canvas);
	            width -= e.getLayoutOptions().width
	        })
	    },
	    shift: function(x, y) {
	        _each(this._elements, function(_, elem) {
	            elem.shift(x, y)
	        })
	    }
	});
	exports.HeaderBlock = HeaderBlock;


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/export.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _extend = $.extend,
	    _each = $.each,
	    clientExporter = __webpack_require__(13),
	    messageLocalization = __webpack_require__(79),
	    imageExporter = clientExporter.image,
	    svgExporter = clientExporter.svg,
	    pdfExporter = clientExporter.pdf,
	    hoverEvent = __webpack_require__(92),
	    pointerEvents = __webpack_require__(66),
	    pointerActions = [pointerEvents.down, pointerEvents.move].join(" "),
	    BUTTON_SIZE = 35,
	    ICON_COORDS = [
	        [9, 12, 26, 12, 26, 14, 9, 14],
	        [9, 17, 26, 17, 26, 19, 9, 19],
	        [9, 22, 26, 22, 26, 24, 9, 24]
	    ],
	    LIST_PADDING_TOP = 4,
	    LIST_WIDTH = 120,
	    VERTICAL_TEXT_MARGIN = 8,
	    HORIZONTAL_TEXT_MARGIN = 15,
	    MENU_ITEM_HEIGHT = 30,
	    LIST_STROKE_WIDTH = 1,
	    MARGIN = 10,
	    SHADOW_OFFSET = 2,
	    SHADOW_BLUR = 3,
	    ALLOWED_EXPORT_FORMATS = ["PNG", "PDF", "JPEG", "SVG", "GIF"],
	    EXPORT_CSS_CLASS = "dx-export-menu",
	    EXPORT_DATA_KEY = "export-element-type",
	    FORMAT_DATA_KEY = "export-element-format";

	function validateFormat(format) {
	    var validatedFormat = String(format).toUpperCase();
	    if ($.inArray(validatedFormat, ALLOWED_EXPORT_FORMATS) !== -1) {
	        return validatedFormat
	    }
	}

	function getCreatorFunc(format) {
	    if ("SVG" === format) {
	        return svgExporter.getData
	    } else {
	        if ("PDF" === format) {
	            return pdfExporter.getData
	        } else {
	            return imageExporter.getData
	        }
	    }
	}

	function print(data) {
	    var vizWindow = window.open();
	    if (!vizWindow) {
	        return
	    }
	    vizWindow.document.open();
	    vizWindow.document.write(data);
	    vizWindow.document.close();
	    vizWindow.print();
	    vizWindow.close()
	}
	exports.exportFromMarkup = function(markup, options) {
	    options.format = validateFormat(options.format) || "PNG";
	    options.fileName = options.fileName || "file";
	    clientExporter.export(markup, options, getCreatorFunc(options.format))
	};
	exports.ExportMenu = function(params) {
	    var that = this,
	        renderer = that._renderer = params.renderer;
	    that._incidentOccurred = params.incidentOccurred;
	    that._svgMethod = params.svgMethod;
	    that._shadow = renderer.shadowFilter("-50%", "-50%", "200%", "200%", SHADOW_OFFSET, 6, SHADOW_BLUR);
	    that._shadow.attr({
	        opacity: .8
	    });
	    that._group = renderer.g().attr({
	        "class": EXPORT_CSS_CLASS
	    }).linkOn(renderer.root, {
	        name: "export-menu",
	        after: "peripheral"
	    });
	    that._buttonGroup = renderer.g().attr({
	        "class": EXPORT_CSS_CLASS + "-button"
	    }).append(that._group);
	    that._listGroup = renderer.g().attr({
	        "class": EXPORT_CSS_CLASS + "-list"
	    }).append(that._group);
	    that._subscribeEvents()
	};
	_extend(exports.ExportMenu.prototype, {
	    getLayoutOptions: function() {
	        if (this._hiddenDueToLayout) {
	            return {
	                width: 0,
	                height: 0
	            }
	        }
	        var bBox = this._buttonGroup.getBBox();
	        bBox.cutSide = "vertical";
	        bBox.cutLayoutSide = "top";
	        bBox.height += MARGIN;
	        bBox.position = {
	            vertical: "top",
	            horizontal: "right"
	        };
	        bBox.verticalAlignment = "top";
	        bBox.horizontalAlignment = "right";
	        return bBox
	    },
	    probeDraw: function() {
	        this._hiddenDueToLayout = false;
	        this.show()
	    },
	    shift: function(_, y) {
	        this._group.attr({
	            translateY: this._group.attr("translateY") + y
	        })
	    },
	    draw: function(width, height, canvas) {
	        var layoutOptions;
	        this._options.exportOptions.width = canvas.width;
	        this._options.exportOptions.height = canvas.height;
	        this._group.move(width - BUTTON_SIZE - SHADOW_OFFSET - SHADOW_BLUR, Math.floor(height / 2 - BUTTON_SIZE / 2));
	        layoutOptions = this.getLayoutOptions();
	        if (layoutOptions.width > width || layoutOptions.height > height) {
	            this._incidentOccurred("W2107");
	            this._hiddenDueToLayout = true;
	            this.hide()
	        }
	        return this
	    },
	    show: function() {
	        !this._hiddenDueToLayout && this._group.linkAppend()
	    },
	    hide: function() {
	        this._group.linkRemove()
	    },
	    setOptions: function(options) {
	        this._options = options;
	        options.formats = options.formats || ALLOWED_EXPORT_FORMATS;
	        options.printingEnabled = void 0 === options.printingEnabled ? true : options.printingEnabled;
	        if (options.enabled && (options.formats.length || options.printingEnabled)) {
	            this.show();
	            this._updateButton();
	            this._updateList();
	            this._hideList()
	        } else {
	            this.hide()
	        }
	    },
	    dispose: function() {
	        var that = this;
	        that._unsubscribeEvents();
	        that._group.linkRemove().linkOff();
	        that._group.dispose();
	        that._shadow.dispose();
	        that._shadow = that._group = that._listGroup = that._buttonGroup = that._button = null;
	        that._options = null
	    },
	    layoutOptions: function() {
	        var options = this._options;
	        return options.enabled && {
	            horizontalAlignment: "right",
	            verticalAlignment: "top",
	            weak: true
	        }
	    },
	    measure: function() {
	        return [BUTTON_SIZE + SHADOW_OFFSET, BUTTON_SIZE]
	    },
	    move: function(rect) {
	        this._group.attr({
	            translateX: Math.round(rect[0]),
	            translateY: Math.round(rect[1])
	        })
	    },
	    _hideList: function() {
	        this._listGroup.remove();
	        this._listShown = false;
	        this._setButtonState("default")
	    },
	    _showList: function() {
	        this._listGroup.append(this._group);
	        this._listShown = true
	    },
	    _setButtonState: function(state) {
	        var that = this,
	            style = that._options.button[state];
	        this._button.attr({
	            stroke: style.borderColor,
	            fill: style.backgroundColor
	        });
	        this._icon.attr({
	            fill: style.color
	        })
	    },
	    _subscribeEvents: function() {
	        var that = this;
	        that._renderer.root.on(pointerEvents.up + ".export", function(e) {
	            var exportOptions, elementType = e.target[EXPORT_DATA_KEY],
	                options = that._options;
	            if (!elementType) {
	                if (that._button) {
	                    that._hideList()
	                }
	                return
	            }
	            if ("button" === elementType) {
	                if (that._listShown) {
	                    that._setButtonState("default");
	                    that._hideList()
	                } else {
	                    that._setButtonState("focus");
	                    that._showList()
	                }
	            } else {
	                if ("printing" === elementType) {
	                    that.hide();
	                    print(that._svgMethod());
	                    that.show();
	                    that._hideList()
	                } else {
	                    if ("exporting" === elementType) {
	                        that.hide();
	                        exportOptions = _extend({}, options.exportOptions, {
	                            format: e.target[FORMAT_DATA_KEY],
	                            backgroundColor: options.backgroundColor
	                        });
	                        clientExporter.export(that._svgMethod(), exportOptions, getCreatorFunc(exportOptions.format));
	                        that.show();
	                        that._hideList()
	                    }
	                }
	            }
	        });
	        that._listGroup.on(pointerActions, function(e) {
	            e.stopPropagation()
	        });
	        that._buttonGroup.on(pointerEvents.enter, function() {
	            that._setButtonState("hover")
	        });
	        that._buttonGroup.on(pointerEvents.leave, function() {
	            that._setButtonState(that._listShown ? "focus" : "default")
	        });
	        that._buttonGroup.on(pointerEvents.down + ".export", function() {
	            that._setButtonState("active")
	        })
	    },
	    _unsubscribeEvents: function() {
	        this._renderer.root.off(".export");
	        this._listGroup.off();
	        this._buttonGroup.off()
	    },
	    _updateButton: function() {
	        var that = this,
	            renderer = that._renderer,
	            options = that._options,
	            iconAttr = {
	                fill: options.button.default.color,
	                cursor: "pointer"
	            },
	            exportData = {
	                "export-element-type": "button"
	            };
	        if (!that._button) {
	            that._button = renderer.rect(0, 0, BUTTON_SIZE, BUTTON_SIZE).append(that._buttonGroup);
	            that._button.attr({
	                rx: 4,
	                ry: 4,
	                fill: options.button.default.backgroundColor,
	                stroke: options.button.default.borderColor,
	                "stroke-width": 1,
	                cursor: "pointer"
	            });
	            that._button.data(exportData);
	            that._icon = renderer.path(ICON_COORDS).append(that._buttonGroup);
	            that._icon.attr(iconAttr);
	            that._icon.data(exportData);
	            that._buttonGroup.setTitle(messageLocalization.format("vizExport-titleMenuText"))
	        }
	    },
	    _getItemStyle: function(options) {
	        var font = options.font,
	            style = {
	                rect: {
	                    cursor: "pointer",
	                    "pointer-events": "all"
	                },
	                text: {
	                    "pointer-events": "none"
	                }
	            };
	        style.text["font-size"] = font.size;
	        style.text["font-family"] = font.family;
	        style.text.fill = font.color;
	        style.text["font-weight"] = font.weight;
	        return style
	    },
	    _getItemAttributes: function(options, items) {
	        var path, attr = {},
	            x = BUTTON_SIZE - LIST_WIDTH,
	            y = BUTTON_SIZE + LIST_PADDING_TOP + (items.length + 1) * MENU_ITEM_HEIGHT;
	        attr.rect = {
	            width: LIST_WIDTH - 2 * LIST_STROKE_WIDTH,
	            height: MENU_ITEM_HEIGHT,
	            x: x + LIST_STROKE_WIDTH,
	            y: y - MENU_ITEM_HEIGHT
	        };
	        attr.text = {
	            x: x + HORIZONTAL_TEXT_MARGIN,
	            y: y - VERTICAL_TEXT_MARGIN,
	            align: "left"
	        };
	        if ("printing" === options.type) {
	            path = "M " + x + " " + (y - LIST_STROKE_WIDTH) + " L " + (x + LIST_WIDTH) + " " + (y - LIST_STROKE_WIDTH);
	            attr.separator = {
	                stroke: options.stroke,
	                "stroke-width": LIST_STROKE_WIDTH,
	                cursor: "pointer",
	                sharp: "v",
	                d: path
	            }
	        }
	        return attr
	    },
	    _addMenuItem: function(renderer, options, items) {
	        var menuItem, that = this,
	            itemData = {},
	            hoverFill = options.hoverFill,
	            fill = options.fill,
	            type = options.type,
	            format = options.format,
	            style = that._getItemStyle(options),
	            attr = that._getItemAttributes(options, items);
	        menuItem = renderer.g().attr({
	            "class": EXPORT_CSS_CLASS + "-list-item"
	        });
	        itemData[EXPORT_DATA_KEY] = type;
	        if (format) {
	            itemData[FORMAT_DATA_KEY] = format
	        }
	        var rect = renderer.rect(),
	            text = renderer.text(options.text);
	        rect.attr(attr.rect).css(style.rect).data(itemData);
	        rect.on(hoverEvent.start + ".export", function() {
	            rect.attr({
	                fill: hoverFill
	            })
	        }).on(hoverEvent.end + ".export", function() {
	            rect.attr({
	                fill: fill
	            })
	        });
	        rect.append(menuItem);
	        text.css(style.text).attr(attr.text).append(menuItem);
	        if ("printing" === type) {
	            renderer.path(null, "line").attr(attr.separator).append(menuItem)
	        }
	        items.push({
	            g: menuItem,
	            rect: rect
	        })
	    },
	    _getMenuItems: function(options) {
	        var that = this,
	            buttonDefault = options.button.default,
	            buttonHover = options.button.hover,
	            formats = options.formats,
	            renderer = that._renderer,
	            items = [];
	        if (options.printingEnabled) {
	            that._addMenuItem(renderer, {
	                font: options.font,
	                type: "printing",
	                fill: buttonDefault.backgroundColor,
	                stroke: buttonDefault.borderColor,
	                hoverFill: buttonHover.backgroundColor,
	                text: messageLocalization.format("vizExport-printingButtonText")
	            }, items)
	        }
	        _each(formats, function(_, format) {
	            format = validateFormat(format);
	            if (format) {
	                that._addMenuItem(renderer, {
	                    font: options.font,
	                    fill: buttonDefault.backgroundColor,
	                    stroke: buttonDefault.borderColor,
	                    hoverFill: buttonHover.backgroundColor,
	                    type: "exporting",
	                    text: messageLocalization.getFormatter("vizExport-exportButtonText")(format),
	                    format: format
	                }, items)
	            }
	        });
	        items && that._setCornerRadius(items);
	        return items
	    },
	    _getMenuOverlay: function(options, items) {
	        var rect, listHeight, that = this,
	            listPadding = BUTTON_SIZE + LIST_PADDING_TOP,
	            renderer = that._renderer,
	            xCoord = -LIST_WIDTH + BUTTON_SIZE;
	        listHeight = items.length * MENU_ITEM_HEIGHT;
	        rect = renderer.rect(xCoord, listPadding, LIST_WIDTH, listHeight);
	        that._shadow.attr({
	            color: options.shadowColor
	        });
	        rect.attr({
	            fill: options.button.default.backgroundColor,
	            stroke: options.button.default.borderColor,
	            "stroke-width": LIST_STROKE_WIDTH,
	            cursor: "pointer",
	            rx: 4,
	            ry: 4,
	            filter: that._shadow.ref
	        });
	        rect.data({
	            "export-element-type": "list"
	        });
	        return rect
	    },
	    _setCornerRadius: function(items) {
	        var firstRect = items[0].rect,
	            lastRect = items[items.length - 1].rect;
	        firstRect.attr({
	            y: parseInt(firstRect.attr("y")) + 2 * LIST_STROKE_WIDTH,
	            height: parseInt(firstRect.attr("height")) - 2 * LIST_STROKE_WIDTH
	        });
	        lastRect.attr({
	            height: parseInt(lastRect.attr("height")) - 2 * LIST_STROKE_WIDTH
	        })
	    },
	    _updateList: function() {
	        var that = this,
	            options = that._options,
	            listGroup = that._listGroup,
	            items = that._getMenuItems(options),
	            menuOverlay = that._getMenuOverlay(options, items);
	        listGroup.clear();
	        menuOverlay.append(listGroup);
	        _each(items, function(_, item) {
	            item.g.append(listGroup)
	        })
	    }
	});

	function getExportOptions(widget, fileName, format) {
	    var validatedFormat = String(format).toUpperCase();
	    if ($.inArray(validatedFormat, ["PNG", "PDF", "JPEG", "SVG", "GIF"]) === -1) {
	        validatedFormat = "PNG"
	    }
	    return {
	        format: validatedFormat,
	        fileName: fileName || "file",
	        proxyUrl: widget.option("export.proxyUrl"),
	        width: widget._canvas.width,
	        height: widget._canvas.height,
	        exportingAction: widget._createActionByOption("onExporting"),
	        exportedAction: widget._createActionByOption("onExported"),
	        fileSavingAction: widget._createActionByOption("onFileSaving")
	    }
	}
	exports.plugin = {
	    name: "export",
	    init: function() {
	        var that = this;
	        that._exportMenu = new exports.ExportMenu({
	            renderer: that._renderer,
	            svgMethod: function() {
	                return that.svg()
	            },
	            incidentOccurred: that._incidentOccurred
	        });
	        that._layout.add(that._exportMenu)
	    },
	    dispose: function() {
	        this._exportMenu.dispose();
	        this._exportMenu = null
	    },
	    members: {
	        _getExportMenuOptions: function() {
	            var that = this,
	                userOptions = that._getOption("export") || {},
	                options = getExportOptions(that, userOptions.fileName, userOptions.format);
	            return $.extend({}, userOptions, {
	                exportOptions: options
	            })
	        },
	        exportTo: function(fileName, format) {
	            var exportOptions = getExportOptions(this, fileName, format),
	                exportMenu = this._exportMenu;
	            exportMenu && exportMenu.hide();
	            clientExporter.export(this.svg(), exportOptions, getCreatorFunc(exportOptions.format));
	            exportMenu && exportMenu.show()
	        },
	        print: function() {
	            var vizWindow = window.open();
	            if (!vizWindow) {
	                return
	            }
	            vizWindow.document.open();
	            vizWindow.document.write(this.svg());
	            vizWindow.document.close();
	            vizWindow.print();
	            vizWindow.close()
	        }
	    },
	    customize: function(constructor) {
	        var proto = constructor.prototype;
	        constructor.addChange({
	            code: "EXPORT",
	            handler: function() {
	                this._exportMenu.setOptions(this._getExportMenuOptions());
	                this._change(["LAYOUT"])
	            },
	            isThemeDependent: true,
	            isOptionChange: true,
	            option: "export"
	        });
	        proto._optionChangesMap.onExporting = "EXPORT";
	        proto._optionChangesMap.onExported = "EXPORT";
	        proto._optionChangesMap.onFileSaving = "EXPORT"
	    }
	};


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/title.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _Number = Number,
	    _isString = __webpack_require__(8).isString,
	    _patchFontOptions = __webpack_require__(291).patchFontOptions,
	    parseHorizontalAlignment = __webpack_require__(291).enumParser(["left", "center", "right"]),
	    parseVerticalAlignment = __webpack_require__(291).enumParser(["top", "bottom"]),
	    DEFAULT_MARGIN = 10,
	    DEFAULT_GAP = 3;

	function hasText(text) {
	    return !!(text && String(text).length > 0)
	}

	function processTitleLength(elem, text, width) {
	    if (elem.attr({
	            text: text
	        }).applyEllipsis(width)) {
	        elem.setTitle(text)
	    }
	}

	function pickMarginValue(value) {
	    return value >= 0 ? _Number(value) : DEFAULT_MARGIN
	}

	function validateMargin(margin) {
	    var result;
	    if (margin >= 0) {
	        result = {
	            left: _Number(margin),
	            top: _Number(margin),
	            right: _Number(margin),
	            bottom: _Number(margin)
	        }
	    } else {
	        margin = margin || {};
	        result = {
	            left: pickMarginValue(margin.left),
	            top: pickMarginValue(margin.top),
	            right: pickMarginValue(margin.right),
	            bottom: pickMarginValue(margin.bottom)
	        }
	    }
	    return result
	}

	function Title(params) {
	    this._params = params;
	    this._group = params.renderer.g().attr({
	        "class": params.cssClass
	    }).linkOn(params.renderer.root, {
	        name: "title",
	        after: "peripheral"
	    });
	    this._hasText = false
	}
	__webpack_require__(5).extend(Title.prototype, __webpack_require__(300).LayoutElement.prototype, {
	    dispose: function() {
	        var that = this;
	        that._group.linkRemove();
	        that._group.linkOff();
	        if (that._titleElement) {
	            that._clipRect.dispose();
	            that._titleElement = that._subtitleElement = that._clipRect = null
	        }
	        that._params = that._group = that._options = null
	    },
	    _updateOptions: function(options) {
	        this._options = options;
	        this._options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, "center");
	        this._options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, "top");
	        this._options.margin = validateMargin(options.margin)
	    },
	    _updateStructure: function() {
	        var that = this,
	            renderer = that._params.renderer,
	            group = that._group,
	            alignObj = {
	                align: that._options.horizontalAlignment
	            };
	        if (!that._titleElement) {
	            that._titleElement = renderer.text().attr(alignObj).append(group);
	            that._subtitleElement = renderer.text().attr(alignObj);
	            that._clipRect = renderer.clipRect();
	            group.attr({
	                clipId: that._clipRect.id
	            })
	        }
	        group.linkAppend();
	        hasText(that._options.subtitle.text) ? that._subtitleElement.append(group) : that._subtitleElement.remove()
	    },
	    _updateTexts: function() {
	        var titleBox, y, that = this,
	            options = that._options,
	            subtitleOptions = options.subtitle,
	            titleElement = that._titleElement,
	            subtitleElement = that._subtitleElement,
	            testText = "A";
	        titleElement.attr({
	            text: testText,
	            y: 0
	        }).css(_patchFontOptions(options.font));
	        titleBox = titleElement.getBBox();
	        that._titleTextY = titleBox.height + titleBox.y;
	        titleElement.attr({
	            text: options.text
	        });
	        titleBox = titleElement.getBBox();
	        y = -titleBox.y;
	        titleElement.attr({
	            y: y
	        });
	        if (hasText(subtitleOptions.text)) {
	            y += titleBox.height + titleBox.y;
	            subtitleElement.attr({
	                text: subtitleOptions.text,
	                y: 0
	            }).css(_patchFontOptions(subtitleOptions.font));
	            y += -subtitleElement.getBBox().y - that._titleTextY + DEFAULT_GAP;
	            subtitleElement.attr({
	                y: y
	            })
	        }
	    },
	    _updateBoundingRectAlignment: function() {
	        var boundingRect = this._boundingRect,
	            options = this._options;
	        boundingRect.verticalAlignment = options.verticalAlignment;
	        boundingRect.horizontalAlignment = options.horizontalAlignment;
	        boundingRect.cutLayoutSide = options.verticalAlignment;
	        boundingRect.cutSide = "vertical";
	        boundingRect.position = {
	            horizontal: options.horizontalAlignment,
	            vertical: options.verticalAlignment
	        }
	    },
	    update: function(options) {
	        var that = this,
	            _hasText = hasText(options.text),
	            isLayoutChanged = _hasText || _hasText !== that._hasText;
	        if (_hasText) {
	            that._updateOptions(options);
	            that._updateStructure();
	            that._updateTexts();
	            that._boundingRect = {};
	            that._updateBoundingRect();
	            that._updateBoundingRectAlignment()
	        } else {
	            that._group.linkRemove();
	            that._boundingRect = null
	        }
	        that._hasText = _hasText;
	        return isLayoutChanged
	    },
	    draw: function(width, height) {
	        var layoutOptions, that = this;
	        that._group.linkAppend();
	        that._correctTitleLength(width);
	        layoutOptions = that.getLayoutOptions();
	        if (layoutOptions.width > width || layoutOptions.height > height) {
	            that._params.incidentOccurred("W2103");
	            that._group.linkRemove();
	            that._boundingRect.width = that._boundingRect.height = 0
	        }
	        return that
	    },
	    probeDraw: function(width, height) {
	        this.draw(width, height);
	        return this
	    },
	    _correctTitleLength: function(width) {
	        var that = this,
	            options = that._options,
	            margin = options.margin,
	            maxWidth = width - margin.left - margin.right;
	        processTitleLength(that._titleElement, options.text, maxWidth);
	        that._subtitleElement && processTitleLength(that._subtitleElement, options.subtitle.text, maxWidth);
	        that._updateBoundingRect()
	    },
	    getLayoutOptions: function() {
	        return this._boundingRect || null
	    },
	    shift: function(x, y) {
	        var that = this,
	            box = that.getLayoutOptions();
	        that._group.move(x - box.x, y - box.y);
	        that._setClipRectSettings();
	        return that
	    },
	    _setClipRectSettings: function() {
	        var bBox = this.getLayoutOptions();
	        this._clipRect.attr({
	            x: bBox.x,
	            y: bBox.y,
	            width: bBox.width,
	            height: bBox.height
	        })
	    },
	    _updateBoundingRect: function() {
	        var box, that = this,
	            options = that._options,
	            margin = options.margin,
	            boundingRect = that._boundingRect;
	        box = that._group.getBBox();
	        box.height += margin.top + margin.bottom - that._titleTextY;
	        box.width += margin.left + margin.right;
	        box.x -= margin.left;
	        box.y += that._titleTextY - margin.top;
	        if (options.placeholderSize > 0) {
	            box.height = options.placeholderSize
	        }
	        boundingRect.height = box.height;
	        boundingRect.width = box.width;
	        boundingRect.x = box.x;
	        boundingRect.y = box.y
	    },
	    layoutOptions: function() {
	        return this._boundingRect && {
	            horizontalAlignment: this._boundingRect.horizontalAlignment,
	            verticalAlignment: this._boundingRect.verticalAlignment
	        }
	    },
	    measure: function(size) {
	        this.draw(size[0], size[1]);
	        return [this._boundingRect.width, this._boundingRect.height]
	    },
	    move: function(rect) {
	        var boundingRect = this._boundingRect;
	        if (rect[2] - rect[0] < boundingRect.width || rect[3] - rect[1] < boundingRect.height) {
	            this.draw(rect[2] - rect[0], rect[3] - rect[1])
	        }
	        this.shift(Math.round(rect[0]), Math.round(rect[1]))
	    }
	});
	exports.Title = Title;

	function processTitleOptions(options) {
	    var newOptions = _isString(options) ? {
	        text: options
	    } : options || {};
	    newOptions.subtitle = _isString(newOptions.subtitle) ? {
	        text: newOptions.subtitle
	    } : newOptions.subtitle || {};
	    return newOptions
	}
	exports.plugin = {
	    name: "title",
	    init: function() {
	        var that = this;
	        that._title = new exports.Title({
	            renderer: that._renderer,
	            cssClass: that._rootClassPrefix + "-title",
	            incidentOccurred: that._incidentOccurred
	        });
	        that._layout.add(that._title)
	    },
	    dispose: function() {
	        this._title.dispose();
	        this._title = null
	    },
	    members: {
	        _getTitleOptions: function() {
	            return $.extend(true, {}, this._themeManager.theme("title"), processTitleOptions(this.option("title")))
	        }
	    },
	    customize: function(constructor) {
	        constructor.addChange({
	            code: "TITLE",
	            handler: function() {
	                if (this._title.update(this._getTitleOptions())) {
	                    this._change(["LAYOUT"])
	                }
	            },
	            isThemeDependent: true,
	            option: "title",
	            isOptionChange: true
	        })
	    }
	};


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/tooltip.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var doc = document,
	    win = window,
	    $ = __webpack_require__(5),
	    rendererModule = __webpack_require__(296),
	    commonUtils = __webpack_require__(8),
	    HALF_ARROW_WIDTH = 10,
	    vizUtils = __webpack_require__(291),
	    _format = __webpack_require__(308),
	    mathCeil = Math.ceil;

	function hideElement($element) {
	    $element.css({
	        left: "-9999px"
	    }).detach()
	}

	function getSpecialFormatOptions(options, specialFormat) {
	    var result = options;
	    switch (specialFormat) {
	        case "argument":
	            result = {
	                format: options.argumentFormat,
	                precision: options.argumentPrecision
	            };
	            break;
	        case "percent":
	            result = {
	                format: {
	                    type: "percent",
	                    precision: options.format && options.format.percentPrecision || options.percentPrecision
	                }
	            }
	    }
	    return result
	}

	function Tooltip(params) {
	    var renderer, root, that = this;
	    that._eventTrigger = params.eventTrigger;
	    that._wrapper = $("<div></div>").css({
	        position: "absolute",
	        overflow: "visible",
	        width: "1px",
	        height: "1px",
	        "pointer-events": "none"
	    }).addClass(params.cssClass);
	    that._renderer = renderer = new rendererModule.Renderer({
	        pathModified: params.pathModified,
	        container: that._wrapper[0]
	    });
	    root = renderer.root;
	    root.attr({
	        "pointer-events": "none"
	    });
	    that._cloud = renderer.path([], "area").sharp().append(root);
	    that._shadow = renderer.shadowFilter();
	    that._textGroup = renderer.g().attr({
	        align: "center"
	    }).append(root);
	    that._text = renderer.text(void 0, 0, 0).append(that._textGroup);
	    that._textGroupHtml = $("<div></div>").css({
	        position: "absolute",
	        width: 0,
	        padding: 0,
	        margin: 0,
	        border: "0px solid transparent"
	    }).appendTo(that._wrapper);
	    that._textHtml = $("<div></div>").css({
	        position: "relative",
	        display: "inline-block",
	        padding: 0,
	        margin: 0,
	        border: "0px solid transparent"
	    }).appendTo(that._textGroupHtml)
	}
	Tooltip.prototype = {
	    constructor: Tooltip,
	    dispose: function() {
	        this._wrapper.remove();
	        this._renderer.dispose();
	        this._options = null
	    },
	    setOptions: function(options) {
	        options = options || {};
	        var that = this,
	            cloudSettings = that._cloudSettings = {
	                opacity: options.opacity,
	                filter: that._shadow.ref,
	                "stroke-width": null,
	                stroke: null
	            },
	            borderOptions = options.border || {},
	            container = $(options.container);
	        that._container = (container.length ? container : $("body")).get(0);
	        that._shadowSettings = $.extend({
	            x: "-50%",
	            y: "-50%",
	            width: "200%",
	            height: "200%"
	        }, options.shadow);
	        that._options = options;
	        if (borderOptions.visible) {
	            $.extend(cloudSettings, {
	                "stroke-width": borderOptions.width,
	                stroke: borderOptions.color,
	                "stroke-opacity": borderOptions.opacity,
	                dashStyle: borderOptions.dashStyle
	            })
	        }
	        that._textFontStyles = vizUtils.patchFontOptions(options.font);
	        that._textFontStyles.color = options.font.color;
	        that._wrapper.css({
	            "z-index": options.zIndex
	        });
	        that._customizeTooltip = $.isFunction(options.customizeTooltip) ? options.customizeTooltip : null;
	        return that
	    },
	    setRendererOptions: function(options) {
	        this._renderer.setOptions(options);
	        this._textGroupHtml.css({
	            direction: options.rtl ? "rtl" : "ltr"
	        });
	        return this
	    },
	    render: function() {
	        var that = this;
	        hideElement(that._wrapper);
	        that._cloud.attr(that._cloudSettings);
	        that._shadow.attr(that._shadowSettings);
	        that._textGroupHtml.css(that._textFontStyles);
	        that._textGroup.css(that._textFontStyles);
	        that._text.css(that._textFontStyles);
	        that._eventData = null;
	        return that
	    },
	    update: function(options) {
	        return this.setOptions(options).render()
	    },
	    _prepare: function(formatObject, state) {
	        var options = this._options,
	            customize = {};
	        if (this._customizeTooltip) {
	            customize = this._customizeTooltip.call(formatObject, formatObject);
	            customize = $.isPlainObject(customize) ? customize : {};
	            if ("text" in customize) {
	                state.text = commonUtils.isDefined(customize.text) ? String(customize.text) : ""
	            }
	            if ("html" in customize) {
	                state.html = commonUtils.isDefined(customize.html) ? String(customize.html) : ""
	            }
	        }
	        if (!("text" in state) && !("html" in state)) {
	            state.text = formatObject.valueText || ""
	        }
	        state.color = customize.color || options.color;
	        state.borderColor = customize.borderColor || (options.border || {}).color;
	        state.textColor = customize.fontColor || (options.font || {}).color;
	        return !!state.text || !!state.html
	    },
	    show: function(formatObject, params, eventData) {
	        var bBox, contentSize, that = this,
	            state = {},
	            options = that._options,
	            paddingLeftRight = options.paddingLeftRight,
	            paddingTopBottom = options.paddingTopBottom,
	            textGroupHtml = that._textGroupHtml,
	            textHtml = that._textHtml,
	            ss = that._shadowSettings,
	            xOff = ss.offsetX,
	            yOff = ss.offsetY,
	            blur = 2 * ss.blur + 1,
	            getComputedStyle = win.getComputedStyle;
	        if (!that._prepare(formatObject, state)) {
	            return false
	        }
	        that._state = state;
	        state.tc = {};
	        that._wrapper.appendTo(that._container);
	        that._cloud.attr({
	            fill: state.color,
	            stroke: state.borderColor
	        });
	        if (state.html) {
	            that._text.attr({
	                text: ""
	            });
	            textGroupHtml.css({
	                color: state.textColor,
	                width: that._getCanvas().width
	            });
	            textHtml.html(state.html);
	            if (getComputedStyle) {
	                bBox = getComputedStyle(textHtml.get(0));
	                bBox = {
	                    x: 0,
	                    y: 0,
	                    width: mathCeil(parseFloat(bBox.width)),
	                    height: mathCeil(parseFloat(bBox.height))
	                }
	            } else {
	                bBox = textHtml.get(0).getBoundingClientRect();
	                bBox = {
	                    x: 0,
	                    y: 0,
	                    width: mathCeil(bBox.width ? bBox.width : bBox.right - bBox.left),
	                    height: mathCeil(bBox.height ? bBox.height : bBox.bottom - bBox.top)
	                }
	            }
	            textGroupHtml.width(bBox.width);
	            textGroupHtml.height(bBox.height)
	        } else {
	            textHtml.html("");
	            that._text.css({
	                fill: state.textColor
	            }).attr({
	                text: state.text
	            });
	            bBox = that._textGroup.css({
	                fill: state.textColor
	            }).getBBox()
	        }
	        contentSize = state.contentSize = {
	            x: bBox.x - paddingLeftRight,
	            y: bBox.y - paddingTopBottom,
	            width: bBox.width + 2 * paddingLeftRight,
	            height: bBox.height + 2 * paddingTopBottom,
	            lm: blur - xOff > 0 ? blur - xOff : 0,
	            rm: blur + xOff > 0 ? blur + xOff : 0,
	            tm: blur - yOff > 0 ? blur - yOff : 0,
	            bm: blur + yOff > 0 ? blur + yOff : 0
	        };
	        contentSize.fullWidth = contentSize.width + contentSize.lm + contentSize.rm;
	        contentSize.fullHeight = contentSize.height + contentSize.tm + contentSize.bm + options.arrowLength;
	        that.move(params.x, params.y, params.offset);
	        that._eventData && that._eventTrigger("tooltipHidden", that._eventData);
	        that._eventData = eventData;
	        that._eventTrigger("tooltipShown", that._eventData);
	        return true
	    },
	    hide: function() {
	        var that = this;
	        hideElement(that._wrapper);
	        that._eventData && that._eventTrigger("tooltipHidden", that._eventData);
	        that._eventData = null
	    },
	    move: function(x, y, offset) {
	        offset = offset || 0;
	        var that = this,
	            canvas = that._getCanvas(),
	            state = that._state,
	            coords = state.tc,
	            contentSize = state.contentSize;
	        if (that._calculatePosition(x, y, offset, canvas)) {
	            that._cloud.attr({
	                points: coords.cloudPoints
	            }).move(contentSize.lm, contentSize.tm);
	            if (state.html) {
	                that._textGroupHtml.css({
	                    left: -contentSize.x + contentSize.lm,
	                    top: -contentSize.y + contentSize.tm + coords.correction
	                })
	            } else {
	                that._textGroup.move(-contentSize.x + contentSize.lm, -contentSize.y + contentSize.tm + coords.correction)
	            }
	            that._renderer.resize("out" === coords.hp ? canvas.fullWidth - canvas.left : contentSize.fullWidth, "out" === coords.vp ? canvas.fullHeight - canvas.top : contentSize.fullHeight)
	        }
	        offset = that._wrapper.css({
	            left: 0,
	            top: 0
	        }).offset();
	        that._wrapper.css({
	            left: coords.x - offset.left,
	            top: coords.y - offset.top
	        })
	    },
	    formatValue: function(value, _specialFormat) {
	        var options = _specialFormat ? getSpecialFormatOptions(this._options, _specialFormat) : this._options;
	        return _format(value, options)
	    },
	    getLocation: function() {
	        return vizUtils.normalizeEnum(this._options.location)
	    },
	    isEnabled: function() {
	        return !!this._options.enabled
	    },
	    isShared: function() {
	        return !!this._options.shared
	    },
	    _calculatePosition: function(x, y, offset, canvas) {
	        var cloudPoints, y1, y3, hasDeprecatedPosition, that = this,
	            options = that._options,
	            arrowLength = options.arrowLength,
	            state = that._state,
	            coords = state.tc,
	            contentSize = state.contentSize,
	            contentWidth = contentSize.width,
	            halfContentWidth = contentWidth / 2,
	            contentHeight = contentSize.height,
	            cTop = y - canvas.top,
	            cBottom = canvas.top + canvas.height - y,
	            cLeft = x - canvas.left,
	            cRight = canvas.width + canvas.left - x,
	            tTop = contentHeight + arrowLength + offset + contentSize.tm,
	            tBottom = contentHeight + arrowLength + offset + contentSize.bm,
	            tLeft = contentWidth + contentSize.lm,
	            tRight = contentWidth + contentSize.rm,
	            tHalfLeft = halfContentWidth + contentSize.lm,
	            tHalfRight = halfContentWidth + contentSize.rm,
	            correction = 0,
	            arrowPoints = [6, 0],
	            x1 = halfContentWidth + HALF_ARROW_WIDTH,
	            x2 = halfContentWidth,
	            x3 = halfContentWidth - HALF_ARROW_WIDTH,
	            y2 = contentHeight + arrowLength,
	            hp = "center",
	            vp = "bottom";
	        y1 = y3 = contentHeight;
	        switch (options.verticalAlignment) {
	            case "top":
	                vp = "bottom";
	                hasDeprecatedPosition = true;
	                break;
	            case "bottom":
	                vp = "top";
	                hasDeprecatedPosition = true
	        }
	        if (!hasDeprecatedPosition) {
	            if (tTop > cTop && tBottom > cBottom) {
	                vp = "out"
	            } else {
	                if (tTop > cTop) {
	                    vp = "top"
	                }
	            }
	        }
	        hasDeprecatedPosition = false;
	        switch (options.horizontalAlignment) {
	            case "left":
	                hp = "right";
	                hasDeprecatedPosition = true;
	                break;
	            case "center":
	                hp = "center";
	                hasDeprecatedPosition = true;
	                break;
	            case "right":
	                hp = "left";
	                hasDeprecatedPosition = true
	        }
	        if (!hasDeprecatedPosition) {
	            if (tLeft > cLeft && tRight > cRight) {
	                hp = "out"
	            } else {
	                if (tHalfLeft > cLeft && tRight < cRight) {
	                    hp = "left"
	                } else {
	                    if (tHalfRight > cRight && tLeft < cLeft) {
	                        hp = "right"
	                    }
	                }
	            }
	        }
	        if ("out" === hp) {
	            x = canvas.left
	        } else {
	            if ("left" === hp) {
	                x1 = HALF_ARROW_WIDTH;
	                x2 = x3 = 0
	            } else {
	                if ("right" === hp) {
	                    x1 = x2 = contentWidth;
	                    x3 = contentWidth - HALF_ARROW_WIDTH;
	                    x -= contentWidth
	                } else {
	                    if ("center" === hp) {
	                        x -= halfContentWidth
	                    }
	                }
	            }
	        }
	        if ("out" === vp) {
	            y = canvas.top
	        } else {
	            if ("top" === vp) {
	                "out" !== hp && (correction = arrowLength);
	                arrowPoints[0] = 2;
	                y1 = y3 = arrowLength;
	                y2 = x1;
	                x1 = x3;
	                x3 = y2;
	                y2 = 0;
	                y += offset
	            } else {
	                y -= contentHeight + arrowLength + offset
	            }
	        }
	        coords.x = x - contentSize.lm;
	        coords.y = y - contentSize.tm;
	        coords.correction = correction;
	        if (hp === coords.hp && vp === coords.vp) {
	            return false
	        }
	        coords.hp = hp;
	        coords.vp = vp;
	        cloudPoints = [0, 0 + correction, contentWidth, 0 + correction, contentWidth, contentHeight + correction, 0, contentHeight + correction];
	        if ("out" !== hp && "out" !== vp) {
	            arrowPoints.splice(2, 0, x1, y1, x2, y2, x3, y3);
	            cloudPoints.splice.apply(cloudPoints, arrowPoints)
	        }
	        coords.cloudPoints = cloudPoints;
	        return true
	    },
	    _getCanvas: function() {
	        var html = doc.documentElement,
	            body = doc.body;
	        return {
	            left: win.pageXOffset || html.scrollLeft || 0,
	            top: win.pageYOffset || html.scrollTop || 0,
	            width: html.clientWidth || 0,
	            height: html.clientHeight || 0,
	            fullWidth: Math.max(body.scrollWidth, html.scrollWidth, body.offsetWidth, html.offsetWidth, body.clientWidth, html.clientWidth),
	            fullHeight: Math.max(body.scrollHeight, html.scrollHeight, body.offsetHeight, html.offsetHeight, body.clientHeight, html.clientHeight)
	        }
	    }
	};
	exports.Tooltip = Tooltip;
	exports.plugin = {
	    name: "tooltip",
	    init: function() {
	        this._initTooltip()
	    },
	    dispose: function() {
	        this._disposeTooltip()
	    },
	    members: {
	        _initTooltip: function() {
	            this._tooltip = new exports.Tooltip({
	                cssClass: this._rootClassPrefix + "-tooltip",
	                eventTrigger: this._eventTrigger,
	                pathModified: this.option("pathModified")
	            })
	        },
	        _disposeTooltip: function() {
	            this._tooltip.dispose();
	            this._tooltip = null
	        },
	        _hideTooltip: function() {
	            this._tooltip.hide()
	        },
	        _onRender: function() {
	            if (!this._$element.is(":visible")) {
	                this._hideTooltip()
	            }
	        },
	        _setTooltipRendererOptions: function() {
	            this._tooltip.setRendererOptions(this._getRendererOptions())
	        },
	        _setTooltipOptions: function() {
	            this._tooltip.update(this._getOption("tooltip"))
	        }
	    },
	    customize: function(constructor) {
	        var proto = constructor.prototype;
	        proto._eventsMap.onTooltipShown = {
	            name: "tooltipShown"
	        };
	        proto._eventsMap.onTooltipHidden = {
	            name: "tooltipHidden"
	        };
	        constructor.addChange({
	            code: "TOOLTIP_RENDERER",
	            handler: function() {
	                this._setTooltipRendererOptions()
	            },
	            isThemeDependent: true,
	            isOptionChange: true
	        });
	        constructor.addChange({
	            code: "TOOLTIP",
	            handler: function() {
	                this._setTooltipOptions()
	            },
	            isThemeDependent: true,
	            isOptionChange: true,
	            option: "tooltip"
	        })
	    }
	};


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/loading_indicator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var _patchFontOptions = __webpack_require__(291).patchFontOptions,
	    STATE_HIDDEN = 0,
	    STATE_SHOWN = 1,
	    ANIMATION_EASING = "linear",
	    ANIMATION_DURATION = 400,
	    LOADING_INDICATOR_READY = "loadingIndicatorReady";

	function LoadingIndicator(parameters) {
	    var that = this,
	        renderer = parameters.renderer;
	    that._group = renderer.g().attr({
	        "class": "dx-loading-indicator"
	    }).linkOn(renderer.root, {
	        name: "loading-indicator",
	        after: "peripheral"
	    });
	    that._rect = renderer.rect().attr({
	        opacity: 0
	    }).append(that._group);
	    that._text = renderer.text().attr({
	        align: "center"
	    }).append(that._group);
	    that._createStates(parameters.eventTrigger, that._group, renderer.root, parameters.notify)
	}
	LoadingIndicator.prototype = {
	    constructor: LoadingIndicator,
	    _createStates: function(eventTrigger, group, root, notify) {
	        var that = this;
	        that._states = [{
	            opacity: 0,
	            start: function() {
	                notify(false)
	            },
	            complete: function() {
	                group.linkRemove();
	                root.attr({
	                    "pointer-events": null
	                });
	                eventTrigger(LOADING_INDICATOR_READY)
	            }
	        }, {
	            opacity: .85,
	            start: function() {
	                group.linkAppend();
	                root.attr({
	                    "pointer-events": "none"
	                });
	                notify(true)
	            },
	            complete: function() {
	                eventTrigger(LOADING_INDICATOR_READY)
	            }
	        }];
	        that._state = STATE_HIDDEN
	    },
	    setSize: function(size) {
	        var width = size.width,
	            height = size.height;
	        this._rect.attr({
	            width: width,
	            height: height
	        });
	        this._text.attr({
	            x: width / 2,
	            y: height / 2
	        })
	    },
	    setOptions: function(options) {
	        this._rect.attr({
	            fill: options.backgroundColor
	        });
	        this._text.css(_patchFontOptions(options.font)).attr({
	            text: options.text
	        });
	        this[options.show ? "show" : "hide"]()
	    },
	    dispose: function() {
	        var that = this;
	        that._group.linkRemove().linkOff();
	        that._group = that._rect = that._text = that._states = null
	    },
	    _transit: function(stateId) {
	        var state, that = this;
	        if (that._state !== stateId) {
	            that._state = stateId;
	            that._isHiding = false;
	            state = that._states[stateId];
	            that._rect.stopAnimation().animate({
	                opacity: state.opacity
	            }, {
	                complete: state.complete,
	                easing: ANIMATION_EASING,
	                duration: ANIMATION_DURATION,
	                unstoppable: true
	            });
	            that._noHiding = true;
	            state.start();
	            that._noHiding = false
	        }
	    },
	    show: function() {
	        this._transit(STATE_SHOWN)
	    },
	    hide: function() {
	        this._transit(STATE_HIDDEN)
	    },
	    scheduleHiding: function() {
	        if (!this._noHiding) {
	            this._isHiding = true
	        }
	    },
	    fulfillHiding: function() {
	        if (this._isHiding) {
	            this.hide()
	        }
	    }
	};
	exports.LoadingIndicator = LoadingIndicator;
	exports.plugin = {
	    name: "loading_indicator",
	    init: function() {
	        var that = this;
	        that._loadingIndicator = new exports.LoadingIndicator({
	            eventTrigger: that._eventTrigger,
	            renderer: that._renderer,
	            notify: notify
	        });
	        that._scheduleLoadingIndicatorHiding();

	        function notify(state) {
	            that._skipLoadingIndicatorOptions = true;
	            that.option("loadingIndicator", {
	                show: state
	            });
	            that._skipLoadingIndicatorOptions = false;
	            if (state) {
	                that._hideTooltip && that._hideTooltip()
	            }
	        }
	    },
	    dispose: function() {
	        this._loadingIndicator.dispose();
	        this._loadingIndicator = null
	    },
	    members: {
	        _scheduleLoadingIndicatorHiding: function() {
	            this._loadingIndicator.scheduleHiding()
	        },
	        _fulfillLoadingIndicatorHiding: function() {
	            this._loadingIndicator.fulfillHiding()
	        },
	        showLoadingIndicator: function() {
	            this._loadingIndicator.show()
	        },
	        hideLoadingIndicator: function() {
	            this._loadingIndicator.hide()
	        },
	        _onBeginUpdate: function() {
	            this._scheduleLoadingIndicatorHiding()
	        }
	    },
	    customize: function(constructor) {
	        var proto = constructor.prototype;
	        if (proto._dataSourceChangedHandler) {
	            var _dataSourceChangedHandler = proto._dataSourceChangedHandler;
	            proto._dataSourceChangedHandler = function() {
	                this._scheduleLoadingIndicatorHiding();
	                _dataSourceChangedHandler.apply(this, arguments)
	            }
	        }
	        var _setContentSize = proto._setContentSize;
	        proto._setContentSize = function() {
	            _setContentSize.apply(this, arguments);
	            this._loadingIndicator.setSize(this._canvas)
	        };
	        constructor.addChange({
	            code: "LOADING_INDICATOR",
	            handler: function() {
	                if (!this._skipLoadingIndicatorOptions) {
	                    this._loadingIndicator.setOptions(this._getOption("loadingIndicator"))
	                }
	                this._scheduleLoadingIndicatorHiding()
	            },
	            isThemeDependent: true,
	            option: "loadingIndicator",
	            isOptionChange: true
	        });
	        proto._eventsMap.onLoadingIndicatorReady = {
	            name: "loadingIndicatorReady"
	        };
	        var _drawn = proto._drawn;
	        proto._drawn = function() {
	            _drawn.apply(this, arguments);
	            if (this._dataIsReady()) {
	                this._fulfillLoadingIndicatorHiding()
	            }
	        }
	    }
	};


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/data_source.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    DataHelperMixin = __webpack_require__(120),
	    postCtor = DataHelperMixin.postCtor,
	    name, members = {
	        _dataSourceLoadErrorHandler: function() {
	            this._dataSourceChangedHandler()
	        },
	        _dataSourceOptions: function() {
	            return {
	                paginate: false
	            }
	        },
	        _updateDataSource: function() {
	            this._refreshDataSource();
	            if (!this.option("dataSource")) {
	                this._dataSourceChangedHandler()
	            }
	        },
	        _dataIsLoaded: function() {
	            return !this._dataSource || this._dataSource.isLoaded()
	        },
	        _dataSourceItems: function() {
	            return this._dataSource && this._dataSource.items()
	        }
	    };
	for (name in DataHelperMixin) {
	    if ("postCtor" === name) {
	        continue
	    }
	    members[name] = DataHelperMixin[name]
	}
	exports.plugin = {
	    name: "data_source",
	    init: function() {
	        postCtor.call(this)
	    },
	    dispose: $.noop,
	    members: members
	};


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/translators/translator2d.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    numericTranslator = __webpack_require__(344),
	    categoryTranslator = __webpack_require__(345),
	    intervalTranslator = __webpack_require__(346),
	    datetimeTranslator = __webpack_require__(347),
	    logarithmicTranslator = __webpack_require__(348),
	    vizUtils = __webpack_require__(291),
	    commonUtils = __webpack_require__(8),
	    getLog = vizUtils.getLog,
	    getPower = vizUtils.getPower,
	    isDefined = commonUtils.isDefined,
	    _abs = Math.abs,
	    CANVAS_PROP = ["width", "height", "left", "top", "bottom", "right"],
	    NUMBER_EQUALITY_CORRECTION = 1,
	    DATETIME_EQUALITY_CORRECTION = 6e4,
	    _noop = $.noop,
	    _Translator2d, addInterval = __webpack_require__(51).addInterval;
	var validateCanvas = function(canvas) {
	    $.each(CANVAS_PROP, function(_, prop) {
	        canvas[prop] = parseInt(canvas[prop]) || 0
	    });
	    return canvas
	};
	var makeCategoriesToPoints = function(categories) {
	    var categoriesToPoints = {},
	        length = categories.length,
	        i = 0;
	    for (; i < length; i++) {
	        categoriesToPoints[categories[i]] = i
	    }
	    return categoriesToPoints
	};
	var validateBusinessRange = function(businessRange) {
	    function validate(valueSelector, baseValueSelector) {
	        if (!isDefined(businessRange[valueSelector]) && isDefined(businessRange[baseValueSelector])) {
	            businessRange[valueSelector] = businessRange[baseValueSelector]
	        }
	    }
	    validate("minVisible", "min");
	    validate("maxVisible", "max");
	    return businessRange
	};

	function valuesIsDefinedAndEqual(val1, val2) {
	    return isDefined(val1) && isDefined(val2) && val1.valueOf() === val2.valueOf()
	}

	function getCanvasBounds(range) {
	    var newMin, newMax, min = range.min,
	        max = range.max,
	        minVisible = range.minVisible,
	        maxVisible = range.maxVisible,
	        base = range.base,
	        isDateTime = commonUtils.isDate(max) || commonUtils.isDate(min),
	        correction = isDateTime ? DATETIME_EQUALITY_CORRECTION : NUMBER_EQUALITY_CORRECTION,
	        isLogarithmic = "logarithmic" === range.axisType;
	    if (isLogarithmic) {
	        maxVisible = getLog(maxVisible, base);
	        minVisible = getLog(minVisible, base);
	        min = getLog(min, base);
	        max = getLog(max, base)
	    }
	    if (valuesIsDefinedAndEqual(min, max)) {
	        newMin = min.valueOf() - correction;
	        newMax = max.valueOf() + correction;
	        if (isDateTime) {
	            min = new Date(newMin);
	            max = new Date(newMax)
	        } else {
	            min = 0 !== min || isLogarithmic ? newMin : 0;
	            max = newMax
	        }
	    }
	    if (valuesIsDefinedAndEqual(minVisible, maxVisible)) {
	        newMin = minVisible.valueOf() - correction;
	        newMax = maxVisible.valueOf() + correction;
	        if (isDateTime) {
	            minVisible = newMin < min.valueOf() ? min : new Date(newMin);
	            maxVisible = newMax > max.valueOf() ? max : new Date(newMax)
	        } else {
	            if (0 !== minVisible || isLogarithmic) {
	                minVisible = newMin < min ? min : newMin
	            }
	            maxVisible = newMax > max ? max : newMax
	        }
	    }
	    return {
	        base: base,
	        rangeMin: min,
	        rangeMax: max,
	        rangeMinVisible: minVisible,
	        rangeMaxVisible: maxVisible
	    }
	}
	exports.Translator2D = _Translator2d = function(businessRange, canvas, options) {
	    this.update(businessRange, canvas, options)
	};
	_Translator2d.prototype = {
	    constructor: _Translator2d,
	    reinit: function() {
	        var that = this,
	            range = that._businessRange,
	            categories = range.categories || [],
	            script = {},
	            canvasOptions = that._prepareCanvasOptions(),
	            visibleCategories = vizUtils.getCategoriesInfo(categories, range.minVisible, range.maxVisible).categories,
	            categoriesLength = (visibleCategories || categories).length;
	        switch (range.axisType) {
	            case "logarithmic":
	                script = logarithmicTranslator;
	                break;
	            case "semidiscrete":
	                script = intervalTranslator;
	                canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (addInterval(canvasOptions.rangeMaxVisible, that._options.interval) - canvasOptions.rangeMinVisible);
	                break;
	            case "discrete":
	                script = categoryTranslator;
	                that._categories = categories;
	                canvasOptions.interval = that._getDiscreteInterval(range.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);
	                that._categoriesToPoints = makeCategoriesToPoints(categories, canvasOptions.invert);
	                if (visibleCategories && categoriesLength) {
	                    canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0]];
	                    that.visibleCategories = visibleCategories
	                }
	                break;
	            default:
	                if ("datetime" === range.dataType) {
	                    script = datetimeTranslator
	                } else {
	                    script = numericTranslator
	                }
	        }
	        $.extend(that, script);
	        that._conversionValue = that._options.conversionValue ? function(value) {
	            return value
	        } : function(value) {
	            return Math.round(value)
	        };
	        that._calculateSpecialValues()
	    },
	    _getDiscreteInterval: function(categoriesLength, canvasOptions) {
	        var correctedCategoriesCount = categoriesLength - (this._businessRange.stick ? 1 : 0);
	        return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength
	    },
	    _prepareCanvasOptions: function() {
	        var length, that = this,
	            businessRange = that._businessRange,
	            canvasOptions = that._canvasOptions = getCanvasBounds(businessRange),
	            canvas = that._canvas;
	        if (that._options.isHorizontal) {
	            canvasOptions.startPoint = canvas.left;
	            length = canvas.width;
	            canvasOptions.endPoint = canvas.width - canvas.right;
	            canvasOptions.invert = businessRange.invert
	        } else {
	            canvasOptions.startPoint = canvas.top;
	            length = canvas.height;
	            canvasOptions.endPoint = canvas.height - canvas.bottom;
	            canvasOptions.invert = !businessRange.invert
	        }
	        that.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;
	        canvasOptions.rangeDoubleError = Math.pow(10, getPower(canvasOptions.rangeMax - canvasOptions.rangeMin) - getPower(length) - 2);
	        canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);
	        return canvasOptions
	    },
	    updateCanvas: function(canvas) {
	        this._canvas = validateCanvas(canvas);
	        this.reinit()
	    },
	    updateBusinessRange: function(businessRange) {
	        this._businessRange = validateBusinessRange(businessRange);
	        this.reinit()
	    },
	    update: function(businessRange, canvas, options) {
	        var that = this;
	        that._options = $.extend(that._options || {}, options);
	        that._canvas = validateCanvas(canvas);
	        that.updateBusinessRange(businessRange)
	    },
	    getBusinessRange: function() {
	        return this._businessRange
	    },
	    getCanvasVisibleArea: function() {
	        return {
	            min: this._canvasOptions.startPoint,
	            max: this._canvasOptions.endPoint
	        }
	    },
	    _calculateSpecialValues: function() {
	        var invert, canvas_position_default, canvas_position_center_middle, that = this,
	            canvasOptions = that._canvasOptions,
	            startPoint = canvasOptions.startPoint,
	            endPoint = canvasOptions.endPoint,
	            range = that._businessRange,
	            minVisible = range.minVisible,
	            maxVisible = range.maxVisible;
	        if (minVisible <= 0 && maxVisible >= 0) {
	            that.sc = {};
	            canvas_position_default = that.translate(0)
	        } else {
	            invert = range.invert ^ (minVisible <= 0 && maxVisible <= 0);
	            if (that._options.isHorizontal) {
	                canvas_position_default = invert ? endPoint : startPoint
	            } else {
	                canvas_position_default = invert ? startPoint : endPoint
	            }
	        }
	        canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;
	        that.sc = {
	            canvas_position_default: canvas_position_default,
	            canvas_position_left: startPoint,
	            canvas_position_top: startPoint,
	            canvas_position_center: canvas_position_center_middle,
	            canvas_position_middle: canvas_position_center_middle,
	            canvas_position_right: endPoint,
	            canvas_position_bottom: endPoint,
	            canvas_position_start: canvasOptions.invert ? endPoint : startPoint,
	            canvas_position_end: canvasOptions.invert ? startPoint : endPoint
	        }
	    },
	    translateSpecialCase: function(value) {
	        return this.sc[value]
	    },
	    _calculateProjection: function(distance) {
	        var canvasOptions = this._canvasOptions;
	        return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance
	    },
	    _calculateUnProjection: function(distance) {
	        var canvasOptions = this._canvasOptions;
	        return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance
	    },
	    getVisibleCategories: function() {
	        return this.visibleCategories
	    },
	    getMinBarSize: function(minBarSize) {
	        var visibleArea = this.getCanvasVisibleArea(),
	            minValue = this.untranslate(visibleArea.min + minBarSize);
	        return _abs(this.untranslate(visibleArea.min) - (!isDefined(minValue) ? this.untranslate(visibleArea.max) : minValue))
	    },
	    translate: _noop,
	    untranslate: _noop,
	    getInterval: _noop,
	    zoom: _noop,
	    getMinScale: _noop,
	    getRange: function() {
	        return [this.untranslate(this._canvasOptions.startPoint, -1), this.untranslate(this._canvasOptions.endPoint, 1)]
	    },
	    isEmptyValueRange: function() {
	        return this._businessRange.stubData
	    },
	    getScreenRange: function() {
	        return [this._canvasOptions.startPoint, this._canvasOptions.endPoint]
	    },
	    add: function(value, diff, dir) {
	        return this._add(value, diff, (this._businessRange.invert ? -1 : 1) * dir)
	    }
	};


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/translators/numeric_translator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var commonUtils = __webpack_require__(8),
	    isDefined = commonUtils.isDefined,
	    round = Math.round;
	module.exports = {
	    translate: function(bp) {
	        var that = this,
	            canvasOptions = that._canvasOptions,
	            doubleError = canvasOptions.rangeDoubleError,
	            specialValue = that.translateSpecialCase(bp);
	        if (isDefined(specialValue)) {
	            return specialValue
	        }
	        if (isNaN(bp) || bp.valueOf() + doubleError < canvasOptions.rangeMin || bp.valueOf() - doubleError > canvasOptions.rangeMax) {
	            return null
	        }
	        return that._conversionValue(that._calculateProjection((bp - canvasOptions.rangeMinVisible) * canvasOptions.ratioOfCanvasRange))
	    },
	    untranslate: function(pos, _directionOffset, enableOutOfCanvas) {
	        var canvasOptions = this._canvasOptions,
	            startPoint = canvasOptions.startPoint;
	        if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint) || !isDefined(canvasOptions.rangeMin) || !isDefined(canvasOptions.rangeMax)) {
	            return null
	        }
	        return this._calculateUnProjection((pos - startPoint) / canvasOptions.ratioOfCanvasRange)
	    },
	    getInterval: function() {
	        return round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)))
	    },
	    _getValue: function(val) {
	        return val
	    },
	    zoom: function(translate, scale) {
	        var that = this,
	            canvasOptions = that._canvasOptions,
	            startPoint = canvasOptions.startPoint,
	            endPoint = canvasOptions.endPoint,
	            newStart = (startPoint + translate) / scale,
	            newEnd = (endPoint + translate) / scale,
	            translatedRangeMinMax = [that.translate(that._getValue(canvasOptions.rangeMin)), that.translate(that._getValue(canvasOptions.rangeMax))],
	            minPoint = Math.min(translatedRangeMinMax[0], translatedRangeMinMax[1]),
	            maxPoint = Math.max(translatedRangeMinMax[0], translatedRangeMinMax[1]);
	        if (minPoint > newStart) {
	            newEnd -= newStart - minPoint;
	            newStart = minPoint
	        }
	        if (maxPoint < newEnd) {
	            newStart -= newEnd - maxPoint;
	            newEnd = maxPoint
	        }
	        if (maxPoint - minPoint < newEnd - newStart) {
	            newStart = minPoint;
	            newEnd = maxPoint
	        }
	        translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;
	        scale = (startPoint + translate) / newStart || 1;
	        return {
	            min: that.untranslate(newStart, void 0, true),
	            max: that.untranslate(newEnd, void 0, true),
	            translate: translate,
	            scale: scale
	        }
	    },
	    getMinScale: function(zoom) {
	        return zoom ? 1.1 : .9
	    },
	    getScale: function(val1, val2) {
	        var canvasOptions = this._canvasOptions;
	        val1 = isDefined(val1) ? val1 : canvasOptions.rangeMin;
	        val2 = isDefined(val2) ? val2 : canvasOptions.rangeMax;
	        return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2)
	    },
	    isValid: function(value) {
	        var co = this._canvasOptions;
	        return null !== value && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax
	    },
	    parse: function(value) {
	        return Number(value)
	    },
	    to: function(value) {
	        return this._conversionValue(this._calculateProjection((value - this._canvasOptions.rangeMinVisible) * this._canvasOptions.ratioOfCanvasRange))
	    },
	    from: function(position) {
	        return this._calculateUnProjection((position - this._canvasOptions.startPoint) / this._canvasOptions.ratioOfCanvasRange)
	    },
	    _add: function(value, diff, coeff) {
	        return value + diff * coeff
	    },
	    isValueProlonged: false
	};


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/translators/category_translator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var commonUtils = __webpack_require__(8),
	    isDefined = commonUtils.isDefined,
	    round = Math.round;
	module.exports = {
	    translate: function(category, directionOffset) {
	        var stickDelta, that = this,
	            canvasOptions = that._canvasOptions,
	            categoryIndex = that._categoriesToPoints[category],
	            specialValue = that.translateSpecialCase(category),
	            startPointIndex = canvasOptions.startPointIndex || 0,
	            stickInterval = that._businessRange.stick ? 0 : .5;
	        if (isDefined(specialValue)) {
	            return specialValue
	        }
	        if (!categoryIndex && 0 !== categoryIndex) {
	            return null
	        }
	        directionOffset = directionOffset || 0;
	        stickDelta = categoryIndex + stickInterval - startPointIndex + .5 * directionOffset;
	        return round(that._calculateProjection(canvasOptions.interval * stickDelta))
	    },
	    untranslate: function(pos, directionOffset, enableOutOfCanvas) {
	        var that = this,
	            canvasOptions = that._canvasOptions,
	            startPoint = canvasOptions.startPoint,
	            categories = that.visibleCategories || that._categories,
	            categoriesLength = categories.length,
	            result = 0,
	            stickInterval = that._businessRange.stick ? .5 : 0;
	        if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint)) {
	            return null
	        }
	        directionOffset = directionOffset || 0;
	        result = round((pos - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * directionOffset);
	        if (categoriesLength === result) {
	            result--
	        }
	        if (result === -1) {
	            result = 0
	        }
	        if (canvasOptions.invert) {
	            result = categoriesLength - result - 1
	        }
	        return categories[result]
	    },
	    getInterval: function() {
	        return this._canvasOptions.interval
	    },
	    zoom: function(translate, scale) {
	        var endCategoryIndex, newVisibleCategories, newInterval, that = this,
	            canvasOptions = that._canvasOptions,
	            stick = that._businessRange.stick,
	            invert = canvasOptions.invert,
	            interval = canvasOptions.interval * scale,
	            translateCategories = translate / interval,
	            startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + .5),
	            categoriesLength = parseInt(canvasOptions.canvasLength / interval + (stick ? 1 : 0)) || 1,
	            categories = that._categories;
	        if (invert) {
	            startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + (that.visibleCategories || []).length - translateCategories + .5) - categoriesLength
	        }
	        if (startCategoryIndex < 0) {
	            startCategoryIndex = 0
	        }
	        endCategoryIndex = startCategoryIndex + categoriesLength;
	        if (endCategoryIndex > categories.length) {
	            endCategoryIndex = categories.length;
	            startCategoryIndex = endCategoryIndex - categoriesLength;
	            if (startCategoryIndex < 0) {
	                startCategoryIndex = 0
	            }
	        }
	        newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));
	        newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);
	        scale = newInterval / canvasOptions.interval;
	        translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));
	        return {
	            min: newVisibleCategories[0],
	            max: newVisibleCategories[newVisibleCategories.length - 1],
	            translate: translate,
	            scale: scale
	        }
	    },
	    getMinScale: function(zoom) {
	        var that = this,
	            canvasOptions = that._canvasOptions,
	            categoriesLength = (that.visibleCategories || that._categories).length;
	        categoriesLength += (parseInt(.1 * categoriesLength) || 1) * (zoom ? -2 : 2);
	        return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval)
	    },
	    getScale: function(min, max) {
	        var that = this,
	            canvasOptions = that._canvasOptions,
	            visibleArea = that.getCanvasVisibleArea(),
	            stickOffset = !that._businessRange.stick && 1,
	            minPoint = that.translate(min, -stickOffset),
	            maxPoint = that.translate(max, +stickOffset);
	        if (!isDefined(minPoint)) {
	            minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min
	        }
	        if (!isDefined(maxPoint)) {
	            maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max
	        }
	        return that.canvasLength / Math.abs(maxPoint - minPoint)
	    },
	    isValid: function(value) {
	        return this._categoriesToPoints[value] >= 0
	    },
	    parse: function(value) {
	        return value
	    },
	    to: function(value, direction) {
	        var canvasOptions = this._canvasOptions,
	            businessRange = this._businessRange,
	            categoryIndex = this._categoriesToPoints[value],
	            startPointIndex = canvasOptions.startPointIndex || 0,
	            stickInterval = businessRange.stick ? 0 : .5,
	            stickDelta = categoryIndex + stickInterval - startPointIndex + (businessRange.invert ? -1 : 1) * direction * .5;
	        return round(this._calculateProjection(canvasOptions.interval * stickDelta))
	    },
	    from: function(position, direction) {
	        var canvasOptions = this._canvasOptions,
	            businessRange = this._businessRange,
	            startPoint = canvasOptions.startPoint,
	            categories = this._categories,
	            categoriesLength = categories.length,
	            stickInterval = businessRange.stick ? .5 : 0,
	            result = round((position - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * direction);
	        if (categoriesLength === result) {
	            result--
	        }
	        if (result === -1) {
	            result = 0
	        }
	        if (canvasOptions.invert) {
	            result = categoriesLength - result - 1
	        }
	        return categories[result]
	    },
	    _add: function() {
	        return NaN
	    },
	    isValueProlonged: true
	};


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/translators/interval_translator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var adjustValue = __webpack_require__(291).adjustValue,
	    commonUtils = __webpack_require__(8),
	    isNumber = commonUtils.isNumber,
	    isDefined = commonUtils.isDefined,
	    dateUtils = __webpack_require__(51),
	    addInterval = dateUtils.addInterval,
	    dateToMilliseconds = dateUtils.dateToMilliseconds,
	    floor = Math.floor;
	module.exports = {
	    _intervalize: function(value, interval) {
	        if (!isDefined(value)) {
	            return
	        }
	        if ("datetime" === this._businessRange.dataType) {
	            if (isNumber(value)) {
	                value = new Date(value)
	            } else {
	                value = new Date(value.getTime())
	            }
	            value = dateUtils.correctDateWithUnitBeginning(value, interval)
	        } else {
	            value = adjustValue(floor(value / interval) * interval)
	        }
	        return value
	    },
	    translate: function(bp, direction, interval) {
	        var that = this,
	            specialValue = that.translateSpecialCase(bp);
	        if (isDefined(specialValue)) {
	            return specialValue
	        }
	        interval = interval || that._options.interval;
	        if (!that.isValid(bp, interval)) {
	            return null
	        }
	        return that.to(bp, direction, interval)
	    },
	    untranslate: function(pos, direction, enableOutOfCanvas) {
	        var canvasOptions = this._canvasOptions,
	            startPoint = canvasOptions.startPoint;
	        if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint) || !isDefined(canvasOptions.rangeMin) || !isDefined(canvasOptions.rangeMax)) {
	            return null
	        }
	        return this.from(pos, direction)
	    },
	    getInterval: function() {
	        return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)))
	    },
	    _getValue: function() {},
	    zoom: function() {},
	    getMinScale: function() {},
	    getScale: function() {},
	    isValid: function(value, interval) {
	        var that = this,
	            co = that._canvasOptions,
	            rangeMin = co.rangeMin,
	            rangeMax = co.rangeMax;
	        interval = interval || that._options.interval;
	        if (null === value || isNaN(value)) {
	            return false
	        }
	        value = "datetime" === that._businessRange.dataType && isNumber(value) ? new Date(value) : value;
	        if (interval !== that._options.interval) {
	            rangeMin = that._intervalize(rangeMin, interval);
	            rangeMax = that._intervalize(rangeMax, interval)
	        }
	        if (value.valueOf() < rangeMin || value.valueOf() >= addInterval(rangeMax, interval)) {
	            return false
	        }
	        return true
	    },
	    parse: function(value) {
	        return "datetime" === this._businessRange.dataType ? isNumber(value) ? new Date(value) : value : Number(value)
	    },
	    to: function(bp, direction, interval) {
	        var that = this;
	        interval = interval || that._options.interval;
	        var v1 = that._intervalize(bp, interval),
	            v2 = addInterval(v1, interval),
	            res = that._to(v1),
	            p2 = that._to(v2);
	        if (!direction) {
	            res = floor((res + p2) / 2)
	        } else {
	            if (direction > 0) {
	                res = p2
	            }
	        }
	        return res
	    },
	    _to: function(value) {
	        var co = this._canvasOptions,
	            rMin = co.rangeMinVisible,
	            rMax = co.rangeMaxVisible,
	            offset = value - rMin;
	        if (value < rMin) {
	            offset = 0
	        } else {
	            if (value > rMax) {
	                offset = addInterval(rMax, this._options.interval) - rMin
	            }
	        }
	        return this._conversionValue(this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange))
	    },
	    from: function(position, direction) {
	        var value, that = this,
	            origInterval = that._options.interval,
	            interval = origInterval,
	            co = that._canvasOptions,
	            rMin = co.rangeMinVisible,
	            rMax = co.rangeMaxVisible;
	        if ("datetime" === that._businessRange.dataType) {
	            interval = dateToMilliseconds(origInterval)
	        }
	        value = that._calculateUnProjection((position - that._canvasOptions.startPoint) / that._canvasOptions.ratioOfCanvasRange);
	        value = that._intervalize(addInterval(value, interval / 2, direction > 0), origInterval);
	        if (value < rMin) {
	            value = rMin
	        } else {
	            if (value > rMax) {
	                value = rMax
	            }
	        }
	        return value
	    },
	    _add: function() {
	        return NaN
	    },
	    isValueProlonged: true
	};


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/translators/datetime_translator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var numericTranslator = __webpack_require__(344);
	module.exports = {
	    translate: numericTranslator.translate,
	    untranslate: function() {
	        var result = numericTranslator.untranslate.apply(this, arguments);
	        return null === result ? result : new Date(result)
	    },
	    _getValue: numericTranslator._getValue,
	    getInterval: numericTranslator.getInterval,
	    zoom: numericTranslator.zoom,
	    getMinScale: numericTranslator.getMinScale,
	    getScale: numericTranslator.getScale,
	    isValid: function(value) {
	        return numericTranslator.isValid.call(this, new Date(value))
	    },
	    parse: function(value) {
	        return new Date(value)
	    },
	    to: numericTranslator.to,
	    from: function(position) {
	        return new Date(numericTranslator.from.call(this, position))
	    },
	    _add: __webpack_require__(51).addDateInterval,
	    isValueProlonged: numericTranslator.isValueProlonged
	};


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/translators/logarithmic_translator.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var numericTranslator = __webpack_require__(344),
	    vizUtils = __webpack_require__(291),
	    commonUtils = __webpack_require__(8),
	    raiseTo = vizUtils.raiseTo,
	    getLog = vizUtils.getLog;
	module.exports = {
	    translate: function(bp) {
	        var that = this,
	            specialValue = that.translateSpecialCase(bp);
	        if (commonUtils.isDefined(specialValue)) {
	            return specialValue
	        }
	        return numericTranslator.translate.call(that, getLog(bp, that._businessRange.base))
	    },
	    untranslate: function() {
	        var result = numericTranslator.untranslate.apply(this, arguments);
	        return null === result ? result : raiseTo(result, this._businessRange.base)
	    },
	    getInterval: numericTranslator.getInterval,
	    _getValue: function(value) {
	        return Math.pow(this._canvasOptions.base, value)
	    },
	    zoom: numericTranslator.zoom,
	    getMinScale: numericTranslator.getMinScale,
	    getScale: function(val1, val2) {
	        var base = this._businessRange.base;
	        val1 = commonUtils.isDefined(val1) ? getLog(val1, base) : void 0;
	        val2 = commonUtils.isDefined(val2) ? getLog(val2, base) : void 0;
	        return numericTranslator.getScale.call(this, val1, val2)
	    },
	    isValid: function(value) {
	        return numericTranslator.isValid.call(this, getLog(value, this._businessRange.base))
	    },
	    parse: numericTranslator.parse,
	    to: function(value) {
	        return numericTranslator.to.call(this, getLog(value, this._businessRange.base))
	    },
	    from: function(position) {
	        return raiseTo(numericTranslator.from.call(this, position), this._businessRange.base)
	    },
	    _add: function(value, diff, dir) {
	        var b = this._businessRange.base;
	        return raiseTo(numericTranslator._add(getLog(value, b), diff, dir), b)
	    },
	    isValueProlonged: numericTranslator.isValueProlonged
	};


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/translators/range.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _isDate = commonUtils.isDate,
	    unique = __webpack_require__(291).unique,
	    minSelector = "min",
	    maxSelector = "max",
	    minVisibleSelector = "minVisible",
	    maxVisibleSelector = "maxVisible",
	    baseSelector = "base",
	    axisTypeSelector = "axisType",
	    _Range;

	function otherLessThan(thisValue, otherValue) {
	    return otherValue < thisValue
	}

	function otherGreaterThan(thisValue, otherValue) {
	    return otherValue > thisValue
	}

	function compareAndReplace(thisValue, otherValue, setValue, compare) {
	    var otherValueDefined = _isDefined(otherValue);
	    if (_isDefined(thisValue)) {
	        if (otherValueDefined && compare(thisValue, otherValue)) {
	            setValue(otherValue)
	        }
	    } else {
	        if (otherValueDefined) {
	            setValue(otherValue)
	        }
	    }
	}
	_Range = exports.Range = function(range) {
	    range && $.extend(this, range)
	};
	_Range.prototype = {
	    constructor: _Range,
	    addRange: function(otherRange) {
	        var that = this,
	            categories = that.categories,
	            otherCategories = otherRange.categories;
	        var compareAndReplaceByField = function(field, compare) {
	            compareAndReplace(that[field], otherRange[field], function(value) {
	                that[field] = value
	            }, compare)
	        };
	        var controlValuesByVisibleBounds = function(valueField, visibleValueField, compare) {
	            compareAndReplace(that[valueField], that[visibleValueField], function(value) {
	                _isDefined(that[valueField]) && (that[valueField] = value)
	            }, compare)
	        };
	        var checkField = function(field) {
	            that[field] = that[field] || otherRange[field]
	        };
	        if (commonUtils.isDefined(otherRange.stick)) {
	            that.stick = otherRange.stick
	        }
	        checkField("addSpiderCategory");
	        checkField("percentStick");
	        checkField("minSpaceCorrection");
	        checkField("maxSpaceCorrection");
	        checkField("invert");
	        checkField(axisTypeSelector);
	        checkField("dataType");
	        if ("logarithmic" === that[axisTypeSelector]) {
	            checkField(baseSelector)
	        } else {
	            that[baseSelector] = void 0
	        }
	        compareAndReplaceByField(minSelector, otherLessThan);
	        compareAndReplaceByField(maxSelector, otherGreaterThan);
	        if ("discrete" === that[axisTypeSelector]) {
	            checkField(minVisibleSelector);
	            checkField(maxVisibleSelector)
	        } else {
	            compareAndReplaceByField(minVisibleSelector, otherLessThan);
	            compareAndReplaceByField(maxVisibleSelector, otherGreaterThan)
	        }
	        compareAndReplaceByField("interval", otherLessThan);
	        controlValuesByVisibleBounds(minSelector, minVisibleSelector, otherLessThan);
	        controlValuesByVisibleBounds(minSelector, maxVisibleSelector, otherLessThan);
	        controlValuesByVisibleBounds(maxSelector, maxVisibleSelector, otherGreaterThan);
	        controlValuesByVisibleBounds(maxSelector, minVisibleSelector, otherGreaterThan);
	        if (void 0 === categories) {
	            that.categories = otherCategories
	        } else {
	            that.categories = otherCategories ? unique(categories.concat(otherCategories)) : categories
	        }
	        return that
	    },
	    isDefined: function() {
	        return _isDefined(this[minSelector]) && _isDefined(this[maxSelector]) || this.categories && this.categories.length
	    },
	    setStubData: function(dataType) {
	        var that = this,
	            year = (new Date).getFullYear() - 1,
	            isDate = "datetime" === dataType,
	            axisType = that[axisTypeSelector],
	            min = "logarithmic" === axisType ? 1 : 0;
	        if ("discrete" === axisType) {
	            that.categories = isDate ? [new Date(year, 0, 1), new Date(year, 3, 1), new Date(year, 6, 1), new Date(year, 9, 1)] : ["0", "1", "2"]
	        } else {
	            that[minSelector] = isDate ? new Date(year, 0, 1) : min;
	            that[maxSelector] = isDate ? new Date(year, 11, 31) : 10
	        }
	        that.stubData = true;
	        return that
	    },
	    correctValueZeroLevel: function() {
	        var that = this;
	        if ("logarithmic" === that[axisTypeSelector] || _isDate(that[maxSelector]) || _isDate(that[minSelector])) {
	            return that
	        }

	        function setZeroLevel(min, max) {
	            that[min] < 0 && that[max] < 0 && (that[max] = 0);
	            that[min] > 0 && that[max] > 0 && (that[min] = 0)
	        }
	        setZeroLevel(minSelector, maxSelector);
	        setZeroLevel(minVisibleSelector, maxVisibleSelector);
	        return that
	    },
	    sortCategories: function(arr) {
	        var cat = this.categories;
	        arr && cat && (this.categories = arr.filter(function(item) {
	            return cat.indexOf(item) !== -1
	        }))
	    },
	    checkZeroStick: function() {
	        var that = this;
	        if (that.min >= 0 && that.max >= 0) {
	            that.minStickValue = 0
	        } else {
	            if (that.min <= 0 && that.max <= 0) {
	                that.maxStickValue = 0
	            }
	        }
	        return that
	    }
	};


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/multi_axes_synchronizer.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    debug = __webpack_require__(6).debug,
	    Range = __webpack_require__(349).Range,
	    commonUtils = __webpack_require__(8),
	    vizUtils = __webpack_require__(291),
	    _adjustValue = vizUtils.adjustValue,
	    _applyPrecisionByMinDelta = vizUtils.applyPrecisionByMinDelta,
	    _isDefined = commonUtils.isDefined,
	    _math = Math,
	    _floor = _math.floor,
	    _max = _math.max,
	    _abs = _math.abs,
	    _each = $.each,
	    _map = __webpack_require__(291).map,
	    MIN_RANGE_FOR_ADJUST_BOUNDS = .1;
	var getValueAxesPerPanes = function(valueAxes) {
	    var result = {};
	    _each(valueAxes, function(_, axis) {
	        var pane = axis.pane;
	        if (!result[pane]) {
	            result[pane] = []
	        }
	        result[pane].push(axis)
	    });
	    return result
	};
	var restoreOriginalBusinessRange = function(axis) {
	    var businessRange, translator = axis.getTranslator();
	    if (!translator._originalBusinessRange) {
	        translator._originalBusinessRange = new Range(translator.getBusinessRange())
	    } else {
	        businessRange = new Range(translator._originalBusinessRange);
	        translator.updateBusinessRange(businessRange)
	    }
	};
	var linearConverter = {
	    transform: function(v, b) {
	        return vizUtils.getLog(v, b)
	    },
	    addInterval: function(v, i) {
	        return v + i
	    },
	    getInterval: function(base, tickInterval) {
	        return tickInterval
	    },
	    adjustValue: _floor
	};
	var logConverter = {
	    transform: function(v, b) {
	        return vizUtils.raiseTo(v, b)
	    },
	    addInterval: function(v, i) {
	        return v * i
	    },
	    getInterval: function(base, tickInterval) {
	        return _math.pow(base, tickInterval)
	    },
	    adjustValue: _adjustValue
	};
	var convertAxisInfo = function(axisInfo, converter) {
	    if (!axisInfo.isLogarithmic) {
	        return
	    }
	    var tick, interval, i, base = axisInfo.logarithmicBase,
	        tickValues = axisInfo.tickValues,
	        ticks = [];
	    axisInfo.minValue = converter.transform(axisInfo.minValue, base);
	    axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);
	    axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);
	    axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);
	    axisInfo.tickInterval = _math.round(axisInfo.tickInterval);
	    if (axisInfo.tickInterval < 1) {
	        axisInfo.tickInterval = 1
	    }
	    interval = converter.getInterval(base, axisInfo.tickInterval);
	    tick = converter.transform(tickValues[0], base);
	    for (i = 0; i < tickValues.length; i++) {
	        ticks.push(converter.adjustValue(tick));
	        tick = converter.addInterval(tick, interval)
	    }
	    ticks.tickInterval = axisInfo.tickInterval;
	    axisInfo.tickValues = ticks
	};
	var populateAxesInfo = function(axes) {
	    return _map(axes, function(axis) {
	        restoreOriginalBusinessRange(axis);
	        var minValue, maxValue, businessRange, tickInterval, synchronizedValue, ticksValues = axis.getTicksValues(),
	            majorTicks = ticksValues.majorTicksValues,
	            options = axis.getOptions(),
	            axisInfo = null;
	        if (majorTicks && majorTicks.length > 0 && commonUtils.isNumber(majorTicks[0]) && "discrete" !== options.type) {
	            businessRange = axis.getTranslator().getBusinessRange();
	            tickInterval = axis._tickManager.getTickInterval();
	            minValue = businessRange.minVisible;
	            maxValue = businessRange.maxVisible;
	            synchronizedValue = options.synchronizedValue;
	            if (minValue === maxValue && _isDefined(synchronizedValue)) {
	                tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;
	                minValue = majorTicks[0] - tickInterval;
	                maxValue = majorTicks[0] + tickInterval
	            }
	            axisInfo = {
	                axis: axis,
	                isLogarithmic: "logarithmic" === options.type,
	                logarithmicBase: businessRange.base,
	                tickValues: majorTicks,
	                minorValues: ticksValues.minorTicksValues,
	                minValue: minValue,
	                oldMinValue: minValue,
	                maxValue: maxValue,
	                oldMaxValue: maxValue,
	                inverted: businessRange.invert,
	                tickInterval: tickInterval,
	                synchronizedValue: synchronizedValue
	            };
	            if (businessRange.stubData) {
	                axisInfo.stubData = true;
	                axisInfo.tickInterval = axisInfo.tickInterval || options.tickInterval;
	                axisInfo.isLogarithmic = false
	            }
	            convertAxisInfo(axisInfo, linearConverter)
	        }
	        return axisInfo
	    })
	};
	var updateTickValues = function(axesInfo) {
	    var maxTicksCount = 0;
	    _each(axesInfo, function(_, axisInfo) {
	        maxTicksCount = _max(maxTicksCount, axisInfo.tickValues.length)
	    });
	    _each(axesInfo, function(_, axisInfo) {
	        var ticksMultiplier, ticksCount, additionalStartTicksCount = 0,
	            synchronizedValue = axisInfo.synchronizedValue,
	            tickValues = axisInfo.tickValues,
	            tickInterval = axisInfo.tickInterval;
	        if (_isDefined(synchronizedValue)) {
	            axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;
	            axisInfo.tickValues = [axisInfo.baseTickValue]
	        } else {
	            if (tickValues.length > 1 && tickInterval) {
	                ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);
	                ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
	                additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);
	                while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {
	                    tickValues.unshift(_applyPrecisionByMinDelta(tickValues[0], tickInterval, tickValues[0] - tickInterval));
	                    additionalStartTicksCount--
	                }
	                while (tickValues.length < ticksCount) {
	                    tickValues.push(_applyPrecisionByMinDelta(tickValues[0], tickInterval, tickValues[tickValues.length - 1] + tickInterval))
	                }
	                axisInfo.tickInterval = tickInterval / ticksMultiplier
	            }
	            axisInfo.baseTickValue = tickValues[0];
	            axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]
	        }
	    })
	};
	var getAxisRange = function(axisInfo) {
	    return axisInfo.maxValue - axisInfo.minValue || 1
	};
	var getMainAxisInfo = function(axesInfo) {
	    for (var i = 0; i < axesInfo.length; i++) {
	        if (!axesInfo[i].stubData) {
	            return axesInfo[i]
	        }
	    }
	    return null
	};
	var correctMinMaxValues = function(axesInfo) {
	    var mainAxisInfo = getMainAxisInfo(axesInfo),
	        mainAxisInfoTickInterval = mainAxisInfo.tickInterval;
	    _each(axesInfo, function(_, axisInfo) {
	        var scale, move, mainAxisBaseValueOffset, valueFromAxisInfo;
	        if (axisInfo !== mainAxisInfo) {
	            if (mainAxisInfoTickInterval && axisInfo.tickInterval) {
	                if (axisInfo.stubData && _isDefined(axisInfo.synchronizedValue)) {
	                    axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
	                    axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval
	                }
	                scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);
	                axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale
	            }
	            if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {
	                mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue
	            } else {
	                mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue
	            }
	            valueFromAxisInfo = getAxisRange(axisInfo);
	            move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;
	            axisInfo.minValue -= move;
	            axisInfo.maxValue -= move
	        }
	    })
	};
	var calculatePaddings = function(axesInfo) {
	    var minPadding, maxPadding, startPadding = 0,
	        endPadding = 0;
	    _each(axesInfo, function(_, axisInfo) {
	        var inverted = axisInfo.inverted;
	        minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;
	        maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;
	        startPadding = _max(startPadding, inverted ? maxPadding : minPadding);
	        endPadding = _max(endPadding, inverted ? minPadding : maxPadding)
	    });
	    return {
	        start: startPadding,
	        end: endPadding
	    }
	};
	var correctMinMaxValuesByPaddings = function(axesInfo, paddings) {
	    _each(axesInfo, function(_, info) {
	        var range = getAxisRange(info),
	            inverted = info.inverted;
	        info.minValue -= paddings[inverted ? "end" : "start"] * range;
	        info.maxValue += paddings[inverted ? "start" : "end"] * range;
	        if (range > MIN_RANGE_FOR_ADJUST_BOUNDS) {
	            info.minValue = _math.min(info.minValue, _adjustValue(info.minValue));
	            info.maxValue = _max(info.maxValue, _adjustValue(info.maxValue))
	        }
	    })
	};
	var updateTickValuesIfSynchronizedValueUsed = function(axesInfo) {
	    var hasSynchronizedValue = false;
	    _each(axesInfo, function(_, info) {
	        hasSynchronizedValue = hasSynchronizedValue || _isDefined(info.synchronizedValue)
	    });
	    _each(axesInfo, function(_, info) {
	        var lastTickValue, tickInterval = info.tickInterval,
	            tickValues = info.tickValues,
	            maxValue = info.maxValue,
	            minValue = info.minValue;
	        if (hasSynchronizedValue && tickInterval) {
	            while (tickValues[0] - tickInterval >= minValue) {
	                tickValues.unshift(_adjustValue(tickValues[0] - tickInterval))
	            }
	            lastTickValue = tickValues[tickValues.length - 1];
	            while ((lastTickValue += tickInterval) <= maxValue) {
	                tickValues.push(commonUtils.isExponential(lastTickValue) ? _adjustValue(lastTickValue) : _applyPrecisionByMinDelta(minValue, tickInterval, lastTickValue))
	            }
	        }
	        while (tickValues[0] < minValue) {
	            tickValues.shift()
	        }
	        while (tickValues[tickValues.length - 1] > maxValue) {
	            tickValues.pop()
	        }
	    })
	};
	var applyMinMaxValues = function(axesInfo) {
	    _each(axesInfo, function(_, info) {
	        var axis = info.axis,
	            range = axis.getTranslator().getBusinessRange();
	        if (range.min === range.minVisible) {
	            range.min = info.minValue
	        }
	        if (range.max === range.maxVisible) {
	            range.max = info.maxValue
	        }
	        range.minVisible = info.minValue;
	        range.maxVisible = info.maxValue;
	        if (_isDefined(info.stubData)) {
	            range.stubData = info.stubData
	        }
	        if (range.min > range.minVisible) {
	            range.min = range.minVisible
	        }
	        if (range.max < range.maxVisible) {
	            range.max = range.maxVisible
	        }
	        range.isSynchronized = true;
	        axis.getTranslator().updateBusinessRange(range);
	        axis.setTicks({
	            majorTicks: info.tickValues,
	            minorTicks: info.minorValues
	        })
	    })
	};
	var correctAfterSynchronize = function(axesInfo) {
	    var correctValue, validAxisInfo, invalidAxisInfo = [];
	    _each(axesInfo, function(i, info) {
	        if (info.oldMaxValue - info.oldMinValue === 0) {
	            invalidAxisInfo.push(info)
	        } else {
	            if (!_isDefined(correctValue) && !_isDefined(info.synchronizedValue)) {
	                correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));
	                validAxisInfo = info
	            }
	        }
	    });
	    if (!_isDefined(correctValue)) {
	        return
	    }
	    _each(invalidAxisInfo, function(i, info) {
	        var firstTick = info.tickValues[0],
	            correctedTick = firstTick * correctValue,
	            tickValues = validAxisInfo.tickValues,
	            centralTick = tickValues[_floor(tickValues.length / 2)];
	        if (firstTick > 0) {
	            info.maxValue = correctedTick;
	            info.minValue = 0
	        } else {
	            if (firstTick < 0) {
	                info.minValue = correctedTick;
	                info.maxValue = 0
	            } else {
	                if (0 === firstTick) {
	                    info.maxValue = validAxisInfo.maxValue - centralTick;
	                    info.minValue = validAxisInfo.minValue - centralTick
	                }
	            }
	        }
	    })
	};
	var multiAxesSynchronizer = {
	    synchronize: function(valueAxes) {
	        _each(getValueAxesPerPanes(valueAxes), function(_, axes) {
	            var axesInfo, paddings;
	            if (axes.length > 1) {
	                axesInfo = populateAxesInfo(axes);
	                if (0 === axesInfo.length || !getMainAxisInfo(axesInfo)) {
	                    return
	                }
	                updateTickValues(axesInfo);
	                correctMinMaxValues(axesInfo);
	                paddings = calculatePaddings(axesInfo);
	                correctMinMaxValuesByPaddings(axesInfo, paddings);
	                correctAfterSynchronize(axesInfo);
	                updateTickValuesIfSynchronizedValueUsed(axesInfo);
	                _each(axesInfo, function() {
	                    convertAxisInfo(this, logConverter)
	                });
	                applyMinMaxValues(axesInfo)
	            }
	        })
	    }
	};
	module.exports = multiAxesSynchronizer;


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/advanced_chart.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    rangeModule = __webpack_require__(349),
	    dateUtils = __webpack_require__(51),
	    DEFAULT_AXIS_NAME = "defaultAxisName",
	    axisModule = __webpack_require__(352),
	    seriesFamilyModule = __webpack_require__(361),
	    BaseChart = __webpack_require__(292).BaseChart,
	    _isArray = commonUtils.isArray,
	    _isDefined = commonUtils.isDefined,
	    _each = $.each,
	    _noop = $.noop,
	    _extend = $.extend,
	    vizUtils = __webpack_require__(291),
	    _map = vizUtils.map,
	    MIN = "min",
	    MAX = "max";

	function prepareAxis(axisOptions) {
	    return _isArray(axisOptions) ? 0 === axisOptions.length ? [{}] : axisOptions : [axisOptions]
	}
	var AdvancedChart = BaseChart.inherit({
	    _dispose: function() {
	        var that = this,
	            disposeObjectsInArray = this._disposeObjectsInArray;
	        that.callBase();
	        that.panes = null;
	        if (that._legend) {
	            that._legend.dispose();
	            that._legend = null
	        }
	        disposeObjectsInArray.call(that, "panesBackground");
	        disposeObjectsInArray.call(that, "seriesFamilies");
	        that._disposeAxes()
	    },
	    _reinitAxes: function() {
	        this.translators = {};
	        this.panes = this._createPanes();
	        this._populateAxes()
	    },
	    _populateAxes: function() {
	        var argumentAxes, paneWithNonVirtualAxis, that = this,
	            valueAxes = [],
	            panes = that.panes,
	            rotated = that._isRotated(),
	            valueAxisOptions = that.option("valueAxis") || {},
	            argumentOption = that.option("argumentAxis") || {},
	            argumentAxesOptions = prepareAxis(argumentOption)[0],
	            valueAxesOptions = prepareAxis(valueAxisOptions),
	            axisNames = [],
	            valueAxesCounter = 0,
	            crosshairOptions = that._getCrosshairOptions() || {},
	            crosshairEnabled = crosshairOptions.enabled,
	            horCrosshairEnabled = crosshairEnabled && crosshairOptions.horizontalLine.visible,
	            verCrosshairEnabled = crosshairEnabled && crosshairOptions.verticalLine.visible;

	        function getNextAxisName() {
	            return DEFAULT_AXIS_NAME + valueAxesCounter++
	        }
	        that._disposeAxes();
	        if (rotated) {
	            paneWithNonVirtualAxis = "right" === argumentAxesOptions.position ? panes[panes.length - 1].name : panes[0].name
	        } else {
	            paneWithNonVirtualAxis = "top" === argumentAxesOptions.position ? panes[0].name : panes[panes.length - 1].name
	        }
	        argumentAxes = _map(panes, function(pane, index) {
	            return that._createAxis("argumentAxis", argumentAxesOptions, {
	                pane: pane.name,
	                crosshairEnabled: rotated ? horCrosshairEnabled : verCrosshairEnabled
	            }, rotated, pane.name !== paneWithNonVirtualAxis, index)
	        });
	        _each(valueAxesOptions, function(priority, axisOptions) {
	            var axisPanes = [],
	                name = axisOptions.name;
	            if (name && $.inArray(name, axisNames) !== -1) {
	                that._incidentOccurred("E2102");
	                return
	            }
	            name && axisNames.push(name);
	            if (axisOptions.pane) {
	                axisPanes.push(axisOptions.pane)
	            }
	            if (axisOptions.panes && axisOptions.panes.length) {
	                axisPanes = axisPanes.concat(axisOptions.panes.slice(0))
	            }
	            axisPanes = vizUtils.unique(axisPanes);
	            if (!axisPanes.length) {
	                axisPanes.push(void 0)
	            }
	            _each(axisPanes, function(_, pane) {
	                valueAxes.push(that._createAxis("valueAxis", axisOptions, {
	                    name: name || getNextAxisName(),
	                    pane: pane,
	                    priority: priority,
	                    crosshairEnabled: rotated ? verCrosshairEnabled : horCrosshairEnabled
	                }, rotated))
	            })
	        });
	        that._valueAxes = valueAxes;
	        that._argumentAxes = argumentAxes
	    },
	    _prepareStackPoints: function(singleSeries, stackPoints) {
	        var points = singleSeries.getPoints(),
	            stackName = singleSeries.getStackName();
	        _each(points, function(_, point) {
	            var argument = point.argument;
	            if (!stackPoints[argument]) {
	                stackPoints[argument] = {};
	                stackPoints[argument][null] = []
	            }
	            if (stackName && !_isArray(stackPoints[argument][stackName])) {
	                stackPoints[argument][stackName] = [];
	                _each(stackPoints[argument][null], function(_, point) {
	                    if (!point.stackName) {
	                        stackPoints[argument][stackName].push(point)
	                    }
	                })
	            }
	            if (stackName) {
	                stackPoints[argument][stackName].push(point);
	                stackPoints[argument][null].push(point)
	            } else {
	                _each(stackPoints[argument], function(_, stack) {
	                    stack.push(point)
	                })
	            }
	            point.stackPoints = stackPoints[argument][stackName];
	            point.stackName = stackName
	        })
	    },
	    _resetStackPoints: function(singleSeries) {
	        _each(singleSeries.getPoints(), function(_, point) {
	            point.stackPoints = null;
	            point.stackName = null
	        })
	    },
	    _disposeAxes: function() {
	        var that = this,
	            disposeObjectsInArray = that._disposeObjectsInArray;
	        disposeObjectsInArray.call(that, "_argumentAxes");
	        disposeObjectsInArray.call(that, "_valueAxes")
	    },
	    _drawAxes: function(panesBorderOptions, drawOptions, adjustUnits) {
	        var that = this,
	            drawAxes = function(axes) {
	                _each(axes, function(_, axis) {
	                    axis.draw(adjustUnits)
	                })
	            },
	            drawStaticAxisElements = function(axes) {
	                _each(axes, function(_i, axis) {
	                    axis.drawGrids(panesBorderOptions[axis.pane])
	                })
	            };
	        that._restoreOriginalBusinessRange();
	        that._reinitTranslators();
	        that._prepareAxesAndDraw(drawAxes, drawStaticAxisElements, drawOptions)
	    },
	    _restoreOriginalBusinessRange: _noop,
	    _appendAdditionalSeriesGroups: function() {
	        this._crosshairCursorGroup.linkAppend();
	        this._scrollBar && this._scrollBarGroup.linkAppend()
	    },
	    _getLegendTargets: function() {
	        var that = this;
	        return _map(that.series, function(item) {
	            if (item.getOptions().showInLegend) {
	                return that._getLegendOptions(item)
	            }
	            return null
	        })
	    },
	    _legendItemTextField: "name",
	    _seriesPopulatedHandlerCore: function() {
	        this._processSeriesFamilies();
	        this._processValueAxisFormat()
	    },
	    _renderTrackers: function() {
	        var i, that = this;
	        for (i = 0; i < that.series.length; ++i) {
	            that.series[i].drawTrackers()
	        }
	    },
	    _specialProcessSeries: function() {
	        this._processSeriesFamilies()
	    },
	    _processSeriesFamilies: function() {
	        var paneSeries, that = this,
	            types = [],
	            families = [],
	            themeManager = that._themeManager,
	            negativesAsZeroes = themeManager.getOptions("negativesAsZeroes"),
	            negativesAsZeros = themeManager.getOptions("negativesAsZeros"),
	            familyOptions = {
	                equalBarWidth: themeManager.getOptions("equalBarWidth"),
	                minBubbleSize: themeManager.getOptions("minBubbleSize"),
	                maxBubbleSize: themeManager.getOptions("maxBubbleSize"),
	                barWidth: themeManager.getOptions("barWidth"),
	                negativesAsZeroes: _isDefined(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros
	            };
	        if (that.seriesFamilies && that.seriesFamilies.length) {
	            _each(that.seriesFamilies, function(_, family) {
	                family.updateOptions(familyOptions);
	                family.adjustSeriesValues()
	            });
	            return
	        }
	        _each(that.series, function(_, item) {
	            if ($.inArray(item.type, types) === -1) {
	                types.push(item.type)
	            }
	        });
	        _each(that._getLayoutTargets(), function(_, pane) {
	            paneSeries = that._getSeriesForPane(pane.name);
	            _each(types, function(_, type) {
	                var family = new seriesFamilyModule.SeriesFamily({
	                    type: type,
	                    pane: pane.name,
	                    equalBarWidth: familyOptions.equalBarWidth,
	                    minBubbleSize: familyOptions.minBubbleSize,
	                    maxBubbleSize: familyOptions.maxBubbleSize,
	                    barWidth: familyOptions.barWidth,
	                    negativesAsZeroes: familyOptions.negativesAsZeroes,
	                    rotated: that._isRotated()
	                });
	                family.add(paneSeries);
	                family.adjustSeriesValues();
	                families.push(family)
	            })
	        });
	        that.seriesFamilies = families
	    },
	    _updateSeriesDimensions: function() {
	        var i, that = this,
	            seriesFamilies = that.seriesFamilies || [];
	        for (i = 0; i < seriesFamilies.length; i++) {
	            var family = seriesFamilies[i],
	                translators = that._getTranslator(family.pane) || {};
	            family.updateSeriesValues(translators);
	            family.adjustSeriesDimensions(translators)
	        }
	    },
	    _getLegendCallBack: function(series) {
	        return this._legend && this._legend.getActionCallback(series)
	    },
	    _appendAxesGroups: function() {
	        var that = this;
	        that._stripsGroup.linkAppend();
	        that._gridGroup.linkAppend();
	        that._axesGroup.linkAppend();
	        that._constantLinesGroup.linkAppend();
	        that._labelAxesGroup.linkAppend()
	    },
	    _populateBusinessRange: function(visibleArea) {
	        var argBusinessRange, that = this,
	            businessRanges = [],
	            rotated = that._isRotated(),
	            argAxes = that._argumentAxes,
	            lastArgAxis = argAxes[argAxes.length - 1],
	            translator = argAxes[0].getTranslator(),
	            calcInterval = lastArgAxis.calcInterval,
	            argRange = new rangeModule.Range({
	                rotated: !!rotated
	            }),
	            groupsData = that._groupsData;
	        that.businessRanges = null;
	        _each(argAxes, function(_, axis) {
	            argRange.addRange(axis.getRangeData())
	        });
	        _each(groupsData.groups, function(_, group) {
	            var groupRange = new rangeModule.Range({
	                    rotated: !!rotated,
	                    pane: group.valueAxis.pane,
	                    axis: group.valueAxis.name
	                }),
	                groupAxisRange = group.valueAxis.getRangeData();
	            groupRange.addRange(groupAxisRange);
	            if (visibleArea) {
	                visibleArea.minArg = _isDefined(visibleArea.minArg) ? visibleArea.minArg : argRange.minVisible;
	                visibleArea.maxArg = _isDefined(visibleArea.maxArg) ? visibleArea.maxArg : argRange.maxVisible
	            }
	            _each(group.series, function(_, series) {
	                var aggregationRange = series.getRangeData(),
	                    visibleSeriesArea = visibleArea && {
	                        minArg: _isDefined(visibleArea.minArg) ? visibleArea.minArg : aggregationRange.arg.min,
	                        maxArg: _isDefined(visibleArea.maxArg) ? visibleArea.maxArg : aggregationRange.arg.max,
	                        minVal: groupAxisRange.min,
	                        maxVal: groupAxisRange.max,
	                        adjustOnZoom: visibleArea.adjustOnZoom
	                    },
	                    seriesRange = series.getRangeData(visibleSeriesArea, calcInterval);
	                groupRange.addRange(seriesRange.val);
	                argRange.addRange(seriesRange.arg)
	            });
	            if (!groupRange.isDefined()) {
	                groupRange.setStubData(group.valueAxis.getOptions().valueType)
	            }
	            if (group.valueAxis.getOptions().showZero) {
	                groupRange.correctValueZeroLevel()
	            }
	            groupRange.checkZeroStick();
	            businessRanges.push({
	                val: groupRange,
	                arg: argRange
	            })
	        });
	        argRange.sortCategories(groupsData.categories);
	        if (!argRange.isDefined()) {
	            if (translator && "discrete" !== argRange.axisType) {
	                argBusinessRange = translator.getBusinessRange();
	                argRange.addRange({
	                    min: argBusinessRange.min,
	                    max: argBusinessRange.max
	                });
	                argRange.stubData = true
	            } else {
	                argRange.setStubData(argAxes[0].getOptions().argumentType)
	            }
	        }
	        if (visibleArea && visibleArea.notApplyMargins && "discrete" !== argRange.axisType) {
	            argBusinessRange = translator.getBusinessRange();
	            argRange.addRange({
	                min: argBusinessRange.min,
	                max: argBusinessRange.max,
	                stick: true
	            })
	        }
	        that._correctBusinessRange(argRange, lastArgAxis);
	        that.businessRanges = businessRanges
	    },
	    _correctBusinessRange: function(range, lastArgAxis) {
	        var setTicksAtUnitBeginning = lastArgAxis.getOptions().setTicksAtUnitBeginning,
	            tickIntervalRange = {},
	            tickInterval = lastArgAxis.getOptions().tickInterval,
	            originInterval = tickInterval;
	        tickInterval = $.isNumeric(tickInterval) ? tickInterval : dateUtils.dateToMilliseconds(tickInterval);
	        if (tickInterval && _isDefined(range[MIN]) && _isDefined(range[MAX]) && tickInterval >= Math.abs(range[MAX] - range[MIN])) {
	            if (commonUtils.isDate(range[MIN])) {
	                if (!$.isNumeric(originInterval)) {
	                    tickIntervalRange[MIN] = dateUtils.addInterval(range[MIN], originInterval, true);
	                    tickIntervalRange[MAX] = dateUtils.addInterval(range[MAX], originInterval, false)
	                } else {
	                    tickIntervalRange[MIN] = new Date(range[MIN].valueOf() - tickInterval);
	                    tickIntervalRange[MAX] = new Date(range[MAX].valueOf() + tickInterval)
	                }
	                if (setTicksAtUnitBeginning) {
	                    tickIntervalRange[MAX] = dateUtils.correctDateWithUnitBeginning(tickIntervalRange[MAX], originInterval);
	                    tickIntervalRange[MIN] = dateUtils.correctDateWithUnitBeginning(tickIntervalRange[MIN], originInterval)
	                }
	            } else {
	                tickIntervalRange[MIN] = range[MIN] - tickInterval;
	                tickIntervalRange[MAX] = range[MAX] + tickInterval
	            }
	            range.addRange(tickIntervalRange)
	        }
	    },
	    _getArgumentAxes: function() {
	        return this._argumentAxes
	    },
	    _getValueAxes: function() {
	        return this._valueAxes
	    },
	    _processValueAxisFormat: function() {
	        var that = this,
	            valueAxes = that._valueAxes,
	            axesWithFullStackedFormat = [];
	        _each(that.series, function() {
	            if (this.isFullStackedSeries() && $.inArray(this.axis, axesWithFullStackedFormat) === -1) {
	                axesWithFullStackedFormat.push(this.axis)
	            }
	        });
	        _each(valueAxes, function() {
	            if ($.inArray(this.name, axesWithFullStackedFormat) !== -1) {
	                this.setPercentLabelFormat()
	            } else {
	                this.resetAutoLabelFormat()
	            }
	        })
	    },
	    _createAxis: function(typeSelector, userOptions, axisOptions, rotated, virtual, index) {
	        var axis, that = this,
	            renderingSettings = _extend({
	                renderer: that._renderer,
	                incidentOccurred: that._incidentOccurred,
	                axisClass: "argumentAxis" === typeSelector ? "arg" : "val",
	                widgetClass: "dxc",
	                stripsGroup: that._stripsGroup,
	                labelAxesGroup: that._labelAxesGroup,
	                constantLinesGroup: that._constantLinesGroup,
	                axesContainerGroup: that._axesGroup,
	                gridGroup: that._gridGroup
	            }, that._getAxisRenderingOptions(typeSelector)),
	            preparedUserOptions = that._prepareStripsAndConstantLines(typeSelector, userOptions, rotated),
	            options = _extend(true, {}, preparedUserOptions, axisOptions, that._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));
	        if (virtual) {
	            options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;
	            options.title = {}
	        }
	        axis = new axisModule.Axis(renderingSettings);
	        axis.updateOptions(options);
	        if (!virtual && _isDefined(index)) {
	            that._displayedArgumentAxisIndex = index
	        }
	        return axis
	    },
	    _getTrackerSettings: function() {
	        return _extend(this.callBase(), {
	            argumentAxis: this._argumentAxes[this._displayedArgumentAxisIndex]
	        })
	    },
	    _prepareStripsAndConstantLines: function(typeSelector, userOptions, rotated) {
	        userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);
	        if (userOptions.strips) {
	            _each(userOptions.strips, function(i) {
	                userOptions.strips[i] = _extend(true, {}, userOptions.stripStyle, userOptions.strips[i])
	            })
	        }
	        if (userOptions.constantLines) {
	            _each(userOptions.constantLines, function(i, line) {
	                userOptions.constantLines[i] = _extend(true, {}, userOptions.constantLineStyle, line)
	            })
	        }
	        return userOptions
	    },
	    _legendDataField: "series",
	    _getStoredSeries: function() {
	        return this.series
	    },
	    _adjustSeries: _noop,
	    _collectPointsByArg: _noop
	});
	exports.AdvancedChart = AdvancedChart;


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/base_axis.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    vizUtils = __webpack_require__(291),
	    commonUtils = __webpack_require__(8),
	    constants = __webpack_require__(353),
	    parseUtils = __webpack_require__(302),
	    tickManagerModule = __webpack_require__(354),
	    formatLabel = constants.formatLabel,
	    convertTicksToValues = constants.convertTicksToValues,
	    convertValuesToTicks = constants.convertValuesToTicks,
	    _isDefined = commonUtils.isDefined,
	    _isNumber = commonUtils.isNumber,
	    _getSignificantDigitPosition = vizUtils.getSignificantDigitPosition,
	    _roundValue = vizUtils.roundValue,
	    patchFontOptions = vizUtils.patchFontOptions,
	    _math = Math,
	    _abs = _math.abs,
	    _round = _math.round,
	    _extend = $.extend,
	    _each = $.each,
	    _noop = $.noop,
	    DEFAULT_AXIS_LABEL_SPACING = 5,
	    MAX_GRID_BORDER_ADHENSION = 4,
	    LABEL_BACKGROUND_PADDING_X = 8,
	    LABEL_BACKGROUND_PADDING_Y = 4,
	    Axis;

	function hasCategories(range) {
	    return range.categories && range.categories.length
	}

	function validateAxisOptions(options) {
	    var labelOptions = options.label,
	        position = options.position,
	        defaultPosition = options.isHorizontal ? constants.bottom : constants.left,
	        secondaryPosition = options.isHorizontal ? constants.top : constants.right;
	    if (position !== defaultPosition && position !== secondaryPosition) {
	        position = defaultPosition
	    }
	    if (position === constants.right && !labelOptions.userAlignment) {
	        labelOptions.alignment = constants.left
	    }
	    options.position = position;
	    options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : "none";
	    labelOptions.minSpacing = _isDefined(labelOptions.minSpacing) ? labelOptions.minSpacing : DEFAULT_AXIS_LABEL_SPACING
	}

	function findSkippedIndexCategory(ticks, skippedCategory) {
	    var i = ticks.length;
	    if (void 0 !== skippedCategory) {
	        while (i--) {
	            if (ticks[i].value === skippedCategory) {
	                return i
	            }
	        }
	    }
	    return -1
	}
	Axis = exports.Axis = function(renderSettings) {
	    var that = this;
	    that._renderer = renderSettings.renderer;
	    that._incidentOccurred = renderSettings.incidentOccurred;
	    that._stripsGroup = renderSettings.stripsGroup;
	    that._labelAxesGroup = renderSettings.labelAxesGroup;
	    that._constantLinesGroup = renderSettings.constantLinesGroup;
	    that._axesContainerGroup = renderSettings.axesContainerGroup;
	    that._gridContainerGroup = renderSettings.gridGroup;
	    that._axisCssPrefix = renderSettings.widgetClass + "-" + (renderSettings.axisClass ? renderSettings.axisClass + "-" : "");
	    that._setType(renderSettings.axisType, renderSettings.drawingType);
	    that._createAxisGroups();
	    that._tickManager = that._createTickManager()
	};
	Axis.prototype = {
	    constructor: Axis,
	    _updateIntervalAndBounds: function() {
	        var i, ticks, length, minInterval, bounds, that = this,
	            translator = that._translator,
	            businessRange = translator.getBusinessRange();
	        if (!hasCategories(businessRange)) {
	            ticks = that.getMajorTicks(true);
	            length = ticks.length;
	            if (!businessRange.isSynchronized) {
	                bounds = this._tickManager.getTickBounds()
	            }
	            if (length > 1) {
	                minInterval = _abs(ticks[0].value - ticks[1].value);
	                for (i = 1; i < length - 1; i++) {
	                    minInterval = Math.min(_abs(ticks[i].value - ticks[i + 1].value), minInterval)
	                }
	                bounds = _extend({
	                    interval: minInterval
	                }, bounds)
	            }
	            if (bounds) {
	                businessRange.addRange(bounds);
	                translator.reinit()
	            }
	        }
	    },
	    _createAllTicks: function(businessRange) {
	        var that = this;
	        that._boundaryTicks = that._getBoundaryTicks();
	        that._majorTicks = that.getMajorTicks(that._options.withoutOverlappingBehavior);
	        that._decimatedTicks = hasCategories(businessRange) || "semidiscrete" === that._options.type ? that.getDecimatedTicks() : [];
	        that._minorTicks = that.getMinorTicks()
	    },
	    _drawAxis: function() {
	        var that = this,
	            options = that._options,
	            axis = that._createAxis({
	                "stroke-width": options.width,
	                stroke: options.color,
	                "stroke-opacity": options.opacity
	            });
	        axis.append(that._axisLineGroup)
	    },
	    _correctMinForTicks: function(min, max, screenDelta) {
	        var correctingValue, digitPosition = _getSignificantDigitPosition(_abs(max - min) / screenDelta),
	            newMin = _roundValue(Number(min), digitPosition);
	        if (newMin < min) {
	            correctingValue = _math.pow(10, -digitPosition);
	            newMin = vizUtils.applyPrecisionByMinDelta(newMin, correctingValue, newMin + correctingValue)
	        }
	        if (newMin > max) {
	            newMin = min
	        }
	        return newMin
	    },
	    _getTickManagerData: function() {
	        var that = this,
	            options = that._options,
	            screenDelta = that._getScreenDelta(),
	            min = that._minBound,
	            max = that._maxBound,
	            categories = that._translator.getVisibleCategories() || that._translator.getBusinessRange().categories,
	            customTicks = options.customTicks || (hasCategories({
	                categories: categories
	            }) ? categories : that._majorTicks && that._majorTicks.length && convertTicksToValues(that._majorTicks)),
	            customMinorTicks = options.customMinorTicks || that._minorTicks && that._minorTicks.length && convertTicksToValues(that._minorTicks);
	        if (_isNumber(min) && options.type !== constants.logarithmic) {
	            min = that._correctMinForTicks(min, max, screenDelta)
	        }
	        return {
	            min: min,
	            max: max,
	            customTicks: customTicks,
	            customMinorTicks: customMinorTicks,
	            customBoundTicks: options.customBoundTicks,
	            screenDelta: screenDelta
	        }
	    },
	    _getTickManagerTypes: function() {
	        return {
	            axisType: this._options.type,
	            dataType: this._options.dataType
	        }
	    },
	    _getTicksOptions: function() {
	        var options = this._options;
	        return {
	            base: options.type === constants.logarithmic ? options.logarithmBase : void 0,
	            tickInterval: this._translator.getBusinessRange().stubData ? null : options.tickInterval,
	            gridSpacingFactor: options.axisDivisionFactor,
	            minorGridSpacingFactor: options.minorAxisDivisionFactor,
	            numberMultipliers: options.numberMultipliers,
	            incidentOccurred: options.incidentOccurred,
	            setTicksAtUnitBeginning: options.setTicksAtUnitBeginning,
	            showMinorTicks: options.minorTick.visible || options.minorGrid.visible,
	            minorTickInterval: options.minorTickInterval,
	            minorTickCount: options.minorTickCount,
	            useTicksAutoArrangement: options.useTicksAutoArrangement,
	            showCalculatedTicks: options.tick.showCalculatedTicks,
	            showMinorCalculatedTicks: options.minorTick.showCalculatedTicks
	        }
	    },
	    _getBoundaryTicks: function() {
	        var categories = this._translator.getVisibleCategories() || this._translator.getBusinessRange().categories,
	            boundaryValues = hasCategories({
	                categories: categories
	            }) && this._tickOffset ? [categories[0], categories[categories.length - 1]] : this._tickManager.getBoundaryTicks();
	        return convertValuesToTicks(boundaryValues)
	    },
	    _createTickManager: function() {
	        return new tickManagerModule.TickManager({}, {}, {
	            overlappingBehaviorType: this._overlappingBehaviorType
	        })
	    },
	    _getMarginsOptions: function() {
	        var range = this._translator.getBusinessRange();
	        return {
	            stick: range.stick || this._options.stick,
	            minStickValue: range.minStickValue,
	            maxStickValue: range.maxStickValue,
	            percentStick: range.percentStick,
	            minValueMargin: this._options.minValueMargin,
	            maxValueMargin: this._options.maxValueMargin,
	            minSpaceCorrection: range.minSpaceCorrection,
	            maxSpaceCorrection: range.maxSpaceCorrection
	        }
	    },
	    _updateTickManager: function() {
	        var options, overlappingOptions = this._getOverlappingBehaviorOptions();
	        options = _extend(true, this._getMarginsOptions(), overlappingOptions, this._getTicksOptions());
	        this._tickManager.update(this._getTickManagerTypes(), this._getTickManagerData(), options)
	    },
	    _correctLabelAlignment: function() {
	        var that = this,
	            labelOptions = that._options.label,
	            overlappingBehavior = that._tickManager.getOverlappingBehavior();
	        if (overlappingBehavior && "rotate" === overlappingBehavior.mode) {
	            that._textOptions.rotate = overlappingBehavior.rotationAngle;
	            if (!labelOptions.userAlignment) {
	                that._textOptions.align = constants.left
	            }
	        } else {
	            if (!labelOptions.userAlignment) {
	                that._textOptions.align = labelOptions.alignment
	            }
	        }
	    },
	    _correctLabelFormat: function() {
	        this._options.label = this._tickManager.getOptions().labelOptions
	    },
	    _deleteLabels: function() {
	        this._axisElementsGroup && this._axisElementsGroup.clear()
	    },
	    _drawTicks: function(ticks) {
	        var that = this,
	            group = that._axisLineGroup;
	        _each(ticks || [], function(_, tick) {
	            var points, coord = that._getTickCoord(tick);
	            if (coord) {
	                points = that._isHorizontal ? [coord.x1, coord.y1, coord.x2, coord.y2] : [coord.y1, coord.x1, coord.y2, coord.x2];
	                tick.graphic = that._createPathElement(points, tick.tickStyle).append(group);
	                coord.angle && that._rotateTick(tick, coord.angle)
	            }
	        })
	    },
	    _createPathElement: function(points, attr) {
	        return this._renderer.path(points, "line").attr(attr).sharp(this._getSharpParam())
	    },
	    _createAxis: function(options) {
	        return this._createAxisElement().attr(options).sharp(this._getSharpParam(true))
	    },
	    _drawLabels: function() {
	        var that = this,
	            renderer = that._renderer,
	            group = that._axisElementsGroup,
	            emptyStrRegExp = /^\s+$/;
	        _each(that._majorTicks, function(_, tick) {
	            var xCoord, yCoord, text = tick.labelText;
	            if (_isDefined(text) && "" !== text && !emptyStrRegExp.test(text)) {
	                xCoord = that._isHorizontal ? tick.labelPos.x : tick.labelPos.y;
	                yCoord = that._isHorizontal ? tick.labelPos.y : tick.labelPos.x;
	                if (!tick.label) {
	                    tick.label = renderer.text(text, xCoord, yCoord).css(tick.labelFontStyle).attr(tick.labelStyle).append(group)
	                } else {
	                    tick.label.css(tick.labelFontStyle).attr(tick.labelStyle).attr({
	                        text: text,
	                        x: xCoord,
	                        y: yCoord
	                    })
	                }
	                tick.label.data({
	                    "chart-data-argument": tick.value
	                })
	            }
	        })
	    },
	    _getGridLineDrawer: function(borderOptions) {
	        var that = this,
	            translator = that._translator,
	            additionalTranslator = that._additionalTranslator,
	            isHorizontal = that._isHorizontal,
	            canvasStart = isHorizontal ? constants.left : constants.top,
	            canvasEnd = isHorizontal ? constants.right : constants.bottom,
	            positionFrom = additionalTranslator.translateSpecialCase(constants.canvasPositionStart),
	            positionTo = additionalTranslator.translateSpecialCase(constants.canvasPositionEnd),
	            firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? translator.translateSpecialCase(constants.canvasPositionPrefix + canvasStart) : void 0,
	            lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? translator.translateSpecialCase(constants.canvasPositionPrefix + canvasEnd) : void 0,
	            getPoints = isHorizontal ? function(tick) {
	                return null !== tick.posX ? [tick.posX, positionFrom, tick.posX, positionTo] : null
	            } : function(tick) {
	                return null !== tick.posX ? [positionFrom, tick.posX, positionTo, tick.posX] : null
	            },
	            minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition,
	            maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;
	        return function(tick) {
	            if (void 0 === tick.posX || tick.posX < minDelta || tick.posX > maxDelta) {
	                return
	            }
	            var points = getPoints(tick);
	            return points && that._createPathElement(points, tick.gridStyle)
	        }
	    },
	    _drawGrids: function(ticks, borderOptions) {
	        var tick, that = this,
	            group = that._axisGridGroup,
	            i = 0,
	            length = ticks.length,
	            drawLine = that._getGridLineDrawer(borderOptions || {
	                visible: false
	            });
	        for (i; i < length; i++) {
	            tick = ticks[i];
	            tick.grid = drawLine(tick);
	            tick.grid && tick.grid.append(group)
	        }
	    },
	    _getConstantLinePos: function(lineValue, canvasStart, canvasEnd) {
	        var parsedValue = this._validateUnit(lineValue, "E2105", "constantLine"),
	            value = this._getTranslatedCoord(parsedValue);
	        if (!_isDefined(value) || value < _math.min(canvasStart, canvasEnd) || value > _math.max(canvasStart, canvasEnd)) {
	            return {}
	        }
	        return {
	            value: value,
	            parsedValue: parsedValue
	        }
	    },
	    _createConstantLine: function(value, attr) {
	        var that = this,
	            additionalTranslator = this._additionalTranslator,
	            positionFrom = additionalTranslator.translateSpecialCase(constants.canvasPositionStart),
	            positionTo = additionalTranslator.translateSpecialCase(constants.canvasPositionEnd),
	            points = this._isHorizontal ? [value, positionTo, value, positionFrom] : [positionFrom, value, positionTo, value];
	        return that._createPathElement(points, attr)
	    },
	    _drawConstantLinesAndLabels: function(lineOptions, canvasStart, canvasEnd) {
	        if (!_isDefined(lineOptions.value)) {
	            return
	        }
	        var that = this,
	            pos = that._getConstantLinePos(lineOptions.value, canvasStart, canvasEnd),
	            labelOptions = lineOptions.label || {},
	            value = pos.value,
	            attr = {
	                stroke: lineOptions.color,
	                "stroke-width": lineOptions.width,
	                dashStyle: lineOptions.dashStyle
	            };
	        if (!_isDefined(value)) {
	            that._constantLines.push(null);
	            if (labelOptions.visible) {
	                that._constantLineLabels.push(null)
	            }
	            return
	        }
	        that._constantLines.push(that._createConstantLine(value, attr).append(that._axisConstantLineGroup));
	        that._constantLineLabels.push(labelOptions.visible ? that._drawConstantLineLabels(pos.parsedValue, labelOptions, value) : null)
	    },
	    _drawConstantLine: function() {
	        var that = this,
	            options = that._options,
	            data = options.constantLines,
	            canvas = that._getCanvasStartEnd();
	        if (that._translator.getBusinessRange().stubData) {
	            return
	        }
	        that._constantLines = [];
	        that._constantLineLabels = [];
	        _each(data, function(_, dataItem) {
	            that._drawConstantLinesAndLabels(dataItem, canvas.start, canvas.end)
	        })
	    },
	    _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value) {
	        var coords, that = this,
	            text = lineLabelOptions.text,
	            options = that._options,
	            labelOptions = options.label;
	        that._checkAlignmentConstantLineLabels(lineLabelOptions);
	        text = _isDefined(text) ? text : formatLabel(parsedValue, labelOptions);
	        coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);
	        return that._renderer.text(text, coords.x, coords.y).css(patchFontOptions(_extend({}, labelOptions.font, lineLabelOptions.font))).attr({
	            align: coords.align
	        }).append(that._axisConstantLineGroup)
	    },
	    _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {
	        var start, end, swap, startCategoryIndex, endCategoryIndex, isContinuous = !!(range.minVisible || range.maxVisible),
	            categories = range.categories || [],
	            min = range.minVisible;
	        if (!isContinuous) {
	            if (_isDefined(startValue) && _isDefined(endValue)) {
	                startCategoryIndex = $.inArray(startValue, categories);
	                endCategoryIndex = $.inArray(endValue, categories);
	                if (startCategoryIndex === -1 || endCategoryIndex === -1) {
	                    return {
	                        stripFrom: 0,
	                        stripTo: 0
	                    }
	                }
	                if (startCategoryIndex > endCategoryIndex) {
	                    swap = endValue;
	                    endValue = startValue;
	                    startValue = swap
	                }
	            }
	        }
	        if (_isDefined(startValue)) {
	            startValue = this._validateUnit(startValue, "E2105", "strip");
	            start = this._getTranslatedCoord(startValue, -1);
	            if (!_isDefined(start) && isContinuous) {
	                start = startValue < min ? canvasStart : canvasEnd
	            }
	        } else {
	            start = canvasStart
	        }
	        if (_isDefined(endValue)) {
	            endValue = this._validateUnit(endValue, "E2105", "strip");
	            end = this._getTranslatedCoord(endValue, 1);
	            if (!_isDefined(end) && isContinuous) {
	                end = endValue > min ? canvasEnd : canvasStart
	            }
	        } else {
	            end = canvasEnd
	        }
	        return start < end ? {
	            stripFrom: start,
	            stripTo: end
	        } : {
	            stripFrom: end,
	            stripTo: start
	        }
	    },
	    _createStrip: function(fromPoint, toPoint, attr) {
	        var x, y, width, height, additionalTranslator = this._additionalTranslator,
	            positionFrom = additionalTranslator.translateSpecialCase(constants.canvasPositionStart),
	            positionTo = additionalTranslator.translateSpecialCase(constants.canvasPositionEnd);
	        if (this._isHorizontal) {
	            x = fromPoint;
	            y = _math.min(positionFrom, positionTo);
	            width = toPoint - fromPoint;
	            height = _abs(positionFrom - positionTo)
	        } else {
	            x = _math.min(positionFrom, positionTo);
	            y = fromPoint;
	            width = _abs(positionFrom - positionTo);
	            height = _abs(fromPoint - toPoint)
	        }
	        return this._renderer.rect(x, y, width, height).attr(attr)
	    },
	    _drawStrip: function() {
	        var i, stripOptions, stripPos, stripLabelOptions, attr, that = this,
	            options = that._options,
	            stripData = options.strips,
	            canvas = this._getCanvasStartEnd(),
	            range = that._translator.getBusinessRange();
	        if (range.stubData) {
	            return
	        }
	        that._strips = [];
	        for (i = 0; i < stripData.length; i++) {
	            stripOptions = stripData[i];
	            stripLabelOptions = stripOptions.label || {};
	            attr = {
	                fill: stripOptions.color
	            };
	            if ((_isDefined(stripOptions.startValue) || _isDefined(stripOptions.endValue)) && _isDefined(stripOptions.color)) {
	                stripPos = that._getStripPos(stripOptions.startValue, stripOptions.endValue, canvas.start, canvas.end, range);
	                if (stripPos.stripTo - stripPos.stripFrom === 0 || !_isDefined(stripPos.stripTo) || !_isDefined(stripPos.stripFrom)) {
	                    continue
	                }
	                that._strips.push({
	                    rect: that._createStrip(stripPos.stripFrom, stripPos.stripTo, attr).append(that._axisStripGroup),
	                    options: stripOptions,
	                    label: stripLabelOptions.text ? that._drawStripLabel(stripLabelOptions, stripPos.stripFrom, stripPos.stripTo) : null
	                })
	            }
	        }
	    },
	    _drawStripLabel: function(stripLabelOptions, stripFrom, stripTo) {
	        var that = this,
	            options = that._options,
	            coords = that._getStripLabelCoords(stripLabelOptions, stripFrom, stripTo);
	        return that._renderer.text(stripLabelOptions.text, coords.x, coords.y).css(patchFontOptions(_extend({}, options.label.font, stripLabelOptions.font))).attr({
	            align: coords.align
	        }).append(that._axisLabelGroup)
	    },
	    _adjustStripLabels: function() {
	        var label, i, coords, strips = this._strips;
	        if (void 0 === strips) {
	            return
	        }
	        for (i = 0; i < strips.length; i++) {
	            label = strips[i].label;
	            if (label) {
	                coords = this._getAdjustedStripLabelCoords(strips[i]);
	                label.move(coords.x, coords.y)
	            }
	        }
	    },
	    _adjustLabels: function() {
	        var label, labelHeight, isNeedLabelAdjustment, staggeringSpacing, i, box, that = this,
	            options = that._options,
	            majorTicks = that._majorTicks,
	            majorTicksLength = majorTicks.length,
	            isHorizontal = that._isHorizontal,
	            overlappingBehavior = that._tickManager ? that._tickManager.getOverlappingBehavior() : options.label.overlappingBehavior,
	            position = options.position,
	            hasLabels = false,
	            boxAxis = that._axisElementsGroup && that._axisElementsGroup.getBBox() || {};
	        _each(majorTicks, function(_, tick) {
	            if (tick.label) {
	                tick.label.attr(that._getLabelAdjustedCoord(tick, boxAxis));
	                hasLabels = true
	            }
	        });
	        isNeedLabelAdjustment = hasLabels && isHorizontal && overlappingBehavior && "stagger" === overlappingBehavior.mode;
	        if (isNeedLabelAdjustment) {
	            labelHeight = 0;
	            for (i = 0; i < majorTicksLength; i += 2) {
	                label = majorTicks[i].label;
	                box = label && label.getBBox() || {};
	                if (box.height > labelHeight) {
	                    labelHeight = box.height
	                }
	            }
	            staggeringSpacing = overlappingBehavior.staggeringSpacing;
	            labelHeight = _round(labelHeight) + staggeringSpacing;
	            for (i = 1; i < majorTicksLength; i += 2) {
	                label = majorTicks[i].label;
	                if (label) {
	                    if (position === constants.bottom) {
	                        label.move(0, labelHeight)
	                    } else {
	                        if (position === constants.top) {
	                            label.move(0, -labelHeight)
	                        }
	                    }
	                }
	            }
	            for (i = 0; i < majorTicksLength; i++) {
	                majorTicks[i].label && majorTicks[i].label.rotate(0)
	            }
	        }
	    },
	    _getLabelAdjustedCoord: function(tick, boxAxis) {
	        var x, y, that = this,
	            options = that._options,
	            box = tick.label.getBBox(),
	            isHorizontal = that._isHorizontal,
	            position = options.position,
	            shift = that.padding && that.padding[position] || 0,
	            textOptions = that._textOptions,
	            labelSettingsY = tick.label.attr("y");
	        if (isHorizontal && position === constants.bottom) {
	            y = 2 * labelSettingsY - box.y + shift
	        } else {
	            if (!isHorizontal) {
	                if (position === constants.left) {
	                    if (textOptions.align === constants.right) {
	                        x = box.x + box.width - shift
	                    } else {
	                        if (textOptions.align === constants.center) {
	                            x = box.x + box.width / 2 - shift - (boxAxis.width / 2 || 0)
	                        } else {
	                            x = box.x - shift - (boxAxis.width || 0)
	                        }
	                    }
	                } else {
	                    if (textOptions.align === constants.center) {
	                        x = box.x + box.width / 2 + (boxAxis.width / 2 || 0) + shift
	                    } else {
	                        if (textOptions.align === constants.right) {
	                            x = box.x + box.width + (boxAxis.width || 0) + shift
	                        } else {
	                            x = box.x + shift
	                        }
	                    }
	                }
	                y = labelSettingsY + ~~(labelSettingsY - box.y - box.height / 2)
	            } else {
	                if (isHorizontal && position === constants.top) {
	                    y = 2 * labelSettingsY - box.y - box.height - shift
	                }
	            }
	        }
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _createAxisGroups: function() {
	        var that = this,
	            renderer = that._renderer,
	            classSelector = that._axisCssPrefix;
	        that._axisGroup = renderer.g().attr({
	            "class": classSelector + "axis"
	        });
	        that._axisStripGroup = renderer.g().attr({
	            "class": classSelector + "strips"
	        });
	        that._axisGridGroup = renderer.g().attr({
	            "class": classSelector + "grid"
	        });
	        that._axisElementsGroup = renderer.g().attr({
	            "class": classSelector + "elements"
	        }).append(that._axisGroup);
	        that._axisLineGroup = renderer.g().attr({
	            "class": classSelector + "line"
	        }).append(that._axisGroup);
	        that._axisTitleGroup = renderer.g().attr({
	            "class": classSelector + "title"
	        }).append(that._axisGroup);
	        that._axisConstantLineGroup = renderer.g().attr({
	            "class": classSelector + "constant-lines"
	        });
	        that._axisLabelGroup = renderer.g().attr({
	            "class": classSelector + "axis-labels"
	        })
	    },
	    _clearAxisGroups: function(adjustAxis) {
	        var that = this,
	            classSelector = that._axisCssPrefix;
	        that._axisGroup.remove();
	        that._axisStripGroup.remove();
	        that._axisLabelGroup.remove();
	        that._axisConstantLineGroup.remove();
	        that._axisGridGroup.remove();
	        if (that._axisTitleGroup) {
	            that._axisTitleGroup.clear()
	        } else {
	            if (!adjustAxis) {
	                that._axisTitleGroup = that._renderer.g().attr({
	                    "class": classSelector + "title"
	                }).append(that._axisGroup)
	            }
	        }
	        if (that._axisElementsGroup) {
	            that._axisElementsGroup.clear()
	        } else {
	            if (!adjustAxis) {
	                that._axisElementsGroup = that._renderer.g().attr({
	                    "class": classSelector + "elements"
	                }).append(that._axisGroup)
	            }
	        }
	        that._axisLineGroup && that._axisLineGroup.clear();
	        that._axisStripGroup && that._axisStripGroup.clear();
	        that._axisGridGroup && that._axisGridGroup.clear();
	        that._axisConstantLineGroup && that._axisConstantLineGroup.clear();
	        that._axisLabelGroup && that._axisLabelGroup.clear()
	    },
	    _initTickCoord: function(tick, offset) {
	        var coord = this._getTranslatedValue(tick.value, this._axisPosition, offset);
	        tick.posX = coord.x;
	        tick.posY = coord.y;
	        tick.angle = coord.angle
	    },
	    _initTickStyle: function(tick, style) {
	        tick.length = style.length;
	        tick.tickStyle = tick.withoutPath ? {
	            stroke: "none",
	            "stroke-width": 0,
	            "stroke-opacity": 0
	        } : style.tickStyle;
	        tick.gridStyle = style.gridStyle
	    },
	    _initTickLabel: function(tick, position) {
	        var that = this,
	            customizeColor = that._options.label.customizeColor;
	        tick.labelText = formatLabel(tick.value, that._options.label, {
	            min: that._minBound,
	            max: that._maxBound
	        });
	        tick.labelPos = that._getTranslatedValue(tick.value, position);
	        tick.labelStyle = that._textOptions;
	        tick.labelFontStyle = _extend({}, that._textFontStyles);
	        if (customizeColor && customizeColor.call) {
	            tick.labelFontStyle.fill = customizeColor.call(tick, tick)
	        }
	        tick.labelHint = constants.formatHint(tick.value, that._options.label, {
	            min: that._minBound,
	            max: that._maxBound
	        })
	    },
	    _getTickStyle: function(tickOptions, gridOptions) {
	        return {
	            tickStyle: {
	                stroke: tickOptions.color,
	                "stroke-width": tickOptions.width,
	                "stroke-opacity": tickOptions.opacity
	            },
	            gridStyle: {
	                stroke: gridOptions.color,
	                "stroke-width": gridOptions.width,
	                "stroke-opacity": gridOptions.opacity
	            },
	            length: tickOptions.length
	        }
	    },
	    _initTicks: function(ticks, style, withLabels, skippedCategory, offset, labelPosition) {
	        var tick, that = this,
	            i = 0,
	            length = ticks.length,
	            indexSkippedCategory = findSkippedIndexCategory(ticks, skippedCategory);
	        for (i; i < length; i++) {
	            tick = ticks[i];
	            i !== indexSkippedCategory && that._initTickCoord(tick, offset);
	            that._initTickStyle(tick, style);
	            withLabels && !tick.withoutLabel && that._initTickLabel(tick, labelPosition)
	        }
	    },
	    _initAllTicks: function() {
	        var that = this,
	            options = that._options,
	            majorTickStyle = that._getTickStyle(options.tick, options.grid),
	            minorTickStyle = that._getTickStyle(options.minorTick, options.minorGrid),
	            skippedCategory = that._getSkippedCategory(),
	            boundaryTicks = this._boundaryTicks,
	            withLabels = options.label.visible && that._axisElementsGroup && !that._translator.getBusinessRange().stubData,
	            labelPosition = that.getLabelsPosition(),
	            offset = that._tickOffset;
	        that._initTicks(that._majorTicks, majorTickStyle, withLabels, skippedCategory, offset, labelPosition);
	        that._initTicks(that._minorTicks, minorTickStyle, false, void 0, offset);
	        that._initTicks(that._decimatedTicks, majorTickStyle, false, skippedCategory, offset);
	        if (options.showCustomBoundaryTicks && boundaryTicks.length) {
	            that._initTicks([boundaryTicks[0]], majorTickStyle, false, -1, -1);
	            boundaryTicks.length > 1 && that._initTicks([boundaryTicks[1]], majorTickStyle, false, -1, 1)
	        }
	    },
	    _buildTicks: function() {
	        var that = this;
	        that._createAllTicks(that._translator.getBusinessRange());
	        that._correctLabelAlignment();
	        that._correctLabelFormat()
	    },
	    _setTickOffset: function() {
	        var options = this._options,
	            discreteAxisDivisionMode = options.discreteAxisDivisionMode;
	        this._tickOffset = +("crossLabels" !== discreteAxisDivisionMode || !discreteAxisDivisionMode)
	    },
	    _createHints: function() {
	        var that = this;
	        _each(that._majorTicks || [], function(_, tick) {
	            var labelHint = tick.labelHint;
	            if (_isDefined(labelHint) && "" !== labelHint) {
	                tick.label.setTitle(labelHint)
	            }
	        })
	    },
	    _setBoundingRect: function() {
	        var start, that = this,
	            options = that._options,
	            axisBox = that._axisElementsGroup ? that._axisElementsGroup.getBBox() : {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0,
	                isEmpty: true
	            },
	            lineBox = that._axisLineGroup.getBBox(),
	            placeholderSize = options.placeholderSize,
	            isHorizontal = that._isHorizontal,
	            coord = isHorizontal ? "y" : "x",
	            side = isHorizontal ? "height" : "width",
	            shiftCoords = options.crosshairEnabled ? isHorizontal ? LABEL_BACKGROUND_PADDING_Y : LABEL_BACKGROUND_PADDING_X : 0,
	            axisTitleBox = that._title && that._axisTitleGroup ? that._axisTitleGroup.getBBox() : axisBox;
	        if (axisBox.isEmpty && axisTitleBox.isEmpty && !placeholderSize) {
	            that.boundingRect = axisBox;
	            return
	        }
	        start = lineBox[coord] || that._axisPosition;
	        if (options.position === (isHorizontal && constants.bottom || constants.right)) {
	            axisBox[side] = placeholderSize || axisTitleBox[coord] + axisTitleBox[side] - start + shiftCoords;
	            axisBox[coord] = start
	        } else {
	            axisBox[side] = placeholderSize || lineBox[side] + start - axisTitleBox[coord] + shiftCoords;
	            axisBox[coord] = axisTitleBox.isEmpty ? start : axisTitleBox[coord] - shiftCoords
	        }
	        that.boundingRect = axisBox
	    },
	    _validateUnit: function(unit, idError, parameters) {
	        var that = this;
	        unit = that.parser(unit);
	        if (void 0 === unit && idError) {
	            that._incidentOccurred(idError, [parameters])
	        }
	        return unit
	    },
	    _setType: function(axisType, drawingType) {
	        var axisTypeMethods, that = this;
	        switch (axisType) {
	            case "xyAxes":
	                axisTypeMethods = __webpack_require__(359);
	                break;
	            case "polarAxes":
	                axisTypeMethods = __webpack_require__(360)
	        }
	        _each(axisTypeMethods[drawingType], function(methodName, method) {
	            that[methodName] = method
	        })
	    },
	    _getSharpParam: function() {
	        return true
	    },
	    dispose: function() {
	        var that = this;
	        that._axisElementsGroup && that._axisElementsGroup.dispose();
	        that._strips = null;
	        that._title = null;
	        that._axisStripGroup = that._axisConstantLineGroup = that._axisLabelGroup = null;
	        that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;
	        that._axisGroup = that._axisTitleGroup = null;
	        that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = null;
	        that._renderer = that._options = that._textOptions = that._textFontStyles = null;
	        that._translator = that._additionalTranslator = null;
	        that._majorTicks = that._minorTicks = null;
	        that._tickManager = null
	    },
	    getOptions: function() {
	        return this._options
	    },
	    setPane: function(pane) {
	        this.pane = pane;
	        this._options.pane = pane
	    },
	    setTypes: function(type, axisType, typeSelector) {
	        this._options.type = type || this._options.type;
	        this._options[typeSelector] = axisType || this._options[typeSelector]
	    },
	    resetTypes: function(typeSelector) {
	        this._options.type = this._initTypes.type;
	        this._options[typeSelector] = this._initTypes[typeSelector]
	    },
	    getTranslator: function() {
	        return this._translator
	    },
	    updateOptions: function(options) {
	        var that = this,
	            labelOpt = options.label;
	        that._options = options;
	        options.tick = options.tick || {};
	        options.minorTick = options.minorTick || {};
	        options.grid = options.grid || {};
	        options.minorGrid = options.minorGrid || {};
	        options.title = options.title || {};
	        options.marker = options.marker || {};
	        that._initTypes = {
	            type: options.type,
	            argumentType: options.argumentType,
	            valueType: options.valueType
	        };
	        validateAxisOptions(options);
	        that._setTickOffset();
	        that._isHorizontal = options.isHorizontal;
	        that.pane = options.pane;
	        that.name = options.name;
	        that.priority = options.priority;
	        that._hasLabelFormat = "" !== labelOpt.format && _isDefined(labelOpt.format);
	        that._textOptions = {
	            align: labelOpt.alignment,
	            opacity: labelOpt.opacity
	        };
	        that._textFontStyles = vizUtils.patchFontOptions(labelOpt.font);
	        if (options.type === constants.logarithmic) {
	            if (options.logarithmBaseError) {
	                that._incidentOccurred("E2104");
	                delete options.logarithmBaseError
	            }
	            that.calcInterval = function(value, prevValue) {
	                return vizUtils.getLog(value / prevValue, options.logarithmBase)
	            }
	        }
	    },
	    updateSize: function(clearAxis) {
	        var that = this,
	            options = that._options,
	            direction = that._isHorizontal ? "horizontal" : "vertical";
	        if (options.title.text && that._axisTitleGroup) {
	            that._incidentOccurred("W2105", [direction]);
	            that._axisTitleGroup.dispose();
	            that._axisTitleGroup = null
	        }
	        if (clearAxis && that._axisElementsGroup && options.label.visible && !that._translator.getBusinessRange().stubData) {
	            that._incidentOccurred("W2106", [direction]);
	            that._axisElementsGroup.dispose();
	            that._axisElementsGroup = null
	        }
	        that._setBoundingRect()
	    },
	    setTranslator: function(translator, additionalTranslator) {
	        var that = this,
	            range = translator.getBusinessRange();
	        this._minBound = range.minVisible;
	        this._maxBound = range.maxVisible;
	        that._translator = translator;
	        that._additionalTranslator = additionalTranslator;
	        that.resetTicks();
	        that._updateIntervalAndBounds();
	        that._buildTicks()
	    },
	    resetTicks: function() {
	        this._deleteLabels();
	        this._majorTicks = this._minorTicks = null
	    },
	    getLabelsPosition: function() {
	        var options = this._options,
	            position = options.position,
	            labelOffset = options.label.indentFromAxis,
	            axisPosition = this._axisPosition;
	        return position === constants.top || position === constants.left ? axisPosition - labelOffset : axisPosition + labelOffset
	    },
	    getFormattedValue: function(value, options, point) {
	        var labelOptions = this._options.label;
	        return _isDefined(value) ? formatLabel(value, _extend(true, {}, labelOptions, options), void 0, point) : null
	    },
	    getTicksValues: function() {
	        return {
	            majorTicksValues: convertTicksToValues(this._majorTicks || this.getMajorTicks()),
	            minorTicksValues: convertTicksToValues(this._minorTicks || this.getMinorTicks())
	        }
	    },
	    getMajorTicks: function(withoutOverlappingBehavior) {
	        var majorTicks, boundedOverlappedTicks, that = this,
	            overlappingBehavior = that._options.label.overlappingBehavior;
	        that._updateTickManager();
	        that._textOptions.rotate = 0;
	        majorTicks = convertValuesToTicks(that._tickManager.getTicks(withoutOverlappingBehavior));
	        if (majorTicks.length) {
	            if (overlappingBehavior.hideFirstTick || overlappingBehavior.hideLastTick || overlappingBehavior.hideFirstLabel || overlappingBehavior.hideLastLabel) {
	                overlappingBehavior.hideFirstLabel && (majorTicks[0].withoutLabel = true);
	                overlappingBehavior.hideLastLabel && (majorTicks[majorTicks.length - 1].withoutLabel = true);
	                overlappingBehavior.hideFirstTick && (majorTicks[0].withoutPath = true);
	                overlappingBehavior.hideLastTick && (majorTicks[majorTicks.length - 1].withoutPath = true)
	            } else {
	                if (!withoutOverlappingBehavior && "ignore" !== overlappingBehavior.mode) {
	                    boundedOverlappedTicks = that._tickManager.checkBoundedTicksOverlapping();
	                    boundedOverlappedTicks.overlappedDates && (majorTicks[1].withoutLabel = true);
	                    if (boundedOverlappedTicks.overlappedStartEnd) {
	                        "first" === overlappingBehavior.hideFirstOrLast ? majorTicks[0].withoutLabel = true : majorTicks[majorTicks.length - 1].withoutLabel = true
	                    }
	                }
	            }
	        }
	        that._addBoundaryTick(majorTicks);
	        return majorTicks
	    },
	    getMinorTicks: function() {
	        return convertValuesToTicks(this._tickManager.getMinorTicks())
	    },
	    getDecimatedTicks: function() {
	        return convertValuesToTicks(this._tickManager.getDecimatedTicks())
	    },
	    setTicks: function(ticks) {
	        this.resetTicks();
	        this._majorTicks = convertValuesToTicks(ticks.majorTicks);
	        this._minorTicks = convertValuesToTicks(ticks.minorTicks)
	    },
	    setPercentLabelFormat: function() {
	        if (!this._hasLabelFormat) {
	            this._options.label.format = "percent"
	        }
	    },
	    resetAutoLabelFormat: function() {
	        if (!this._hasLabelFormat) {
	            delete this._options.label.format
	        }
	    },
	    getMultipleAxesSpacing: function() {
	        return this._options.multipleAxesSpacing || 0
	    },
	    drawGrids: function(borderOptions) {
	        var that = this,
	            options = that._options;
	        borderOptions = borderOptions || {};
	        that._axisGridGroup.append(that._gridContainerGroup);
	        if (options.grid.visible) {
	            that._drawGrids(that._majorTicks.concat(that._decimatedTicks), borderOptions)
	        }
	        options.minorGrid.visible && that._drawGrids(that._minorTicks, borderOptions)
	    },
	    draw: function(adjustAxis) {
	        var areLabelsVisible, that = this,
	            options = that._options;
	        that._axisGroup && that._clearAxisGroups(adjustAxis);
	        areLabelsVisible = options.label.visible && that._axisElementsGroup && !that._translator.getBusinessRange().stubData;
	        that._updateIntervalAndBounds();
	        that._buildTicks();
	        that._initAxisPositions();
	        that._initAllTicks();
	        options.visible && that._drawAxis();
	        if (options.tick.visible) {
	            that._drawTicks(that._majorTicks);
	            that._drawTicks(that._decimatedTicks)
	        }
	        options.minorTick.visible && that._drawTicks(that._minorTicks);
	        areLabelsVisible && that._drawLabels();
	        options.showCustomBoundaryTicks && this._drawTicks(that._boundaryTicks);
	        that._drawTitle();
	        options.strips && that._drawStrip();
	        options.constantLines && that._drawConstantLine();
	        that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);
	        that._constantLinesGroup && that._axisConstantLineGroup.append(that._constantLinesGroup);
	        that._axisGroup.append(that._axesContainerGroup);
	        that._labelAxesGroup && that._axisLabelGroup.append(that._labelAxesGroup);
	        that._adjustConstantLineLabels();
	        areLabelsVisible && that._adjustLabels();
	        options.marker.visible && that._drawDateMarkers();
	        that._createHints();
	        that._adjustStripLabels();
	        that._adjustTitle();
	        that._setBoundingRect()
	    },
	    getBoundingRect: function() {
	        return this._axisElementsGroup ? this.boundingRect : {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        }
	    },
	    shift: function(x, y) {
	        this._axisGroup.attr({
	            translateX: x,
	            translateY: y
	        })
	    },
	    applyClipRects: function(elementsClipID, canvasClipID) {
	        this._axisGroup.attr({
	            clipId: canvasClipID
	        });
	        this._axisStripGroup.attr({
	            clipId: elementsClipID
	        })
	    },
	    validate: function(isArgumentAxis) {
	        var that = this,
	            options = that._options,
	            dataType = isArgumentAxis ? options.argumentType : options.valueType,
	            parser = dataType ? parseUtils.getParser(dataType) : function(unit) {
	                return unit
	            };
	        that.parser = parser;
	        options.dataType = dataType;
	        if (void 0 !== options.min) {
	            options.min = that._validateUnit(options.min, "E2106")
	        }
	        if (void 0 !== options.max) {
	            options.max = that._validateUnit(options.max, "E2106")
	        }
	        if (void 0 !== that._minBound) {
	            that._minBound = that._validateUnit(that._minBound)
	        }
	        if (void 0 !== that._maxBound) {
	            that._maxBound = that._validateUnit(that._maxBound)
	        }
	    },
	    zoom: function(min, max, skipAdjusting) {
	        var that = this,
	            minOpt = that._options.min,
	            maxOpt = that._options.max;
	        skipAdjusting = skipAdjusting || that._options.type === constants.discrete;
	        min = that._validateUnit(min);
	        max = that._validateUnit(max);
	        if (!skipAdjusting) {
	            if (void 0 !== minOpt) {
	                min = minOpt > min ? minOpt : min;
	                max = minOpt > max ? minOpt : max
	            }
	            if (void 0 !== maxOpt) {
	                max = maxOpt < max ? maxOpt : max;
	                min = maxOpt < min ? maxOpt : min
	            }
	        }
	        that._zoomArgs = {
	            min: min,
	            max: max
	        };
	        return that._zoomArgs
	    },
	    resetZoom: function() {
	        this._zoomArgs = null
	    },
	    getRangeData: function() {
	        var rangeMin, rangeMax, rangeMinVisible, rangeMaxVisible, that = this,
	            options = that._options,
	            minMax = that._getMinMax(),
	            min = minMax.min,
	            max = minMax.max,
	            zoomArgs = that._zoomArgs || {},
	            type = options.type;
	        if (type === constants.logarithmic) {
	            min = min <= 0 ? void 0 : min;
	            max = max <= 0 ? void 0 : max
	        }
	        if (type !== constants.discrete) {
	            rangeMin = min;
	            rangeMax = max;
	            if (_isDefined(min) && _isDefined(max)) {
	                rangeMin = min < max ? min : max;
	                rangeMax = max > min ? max : min
	            }
	            rangeMinVisible = _isDefined(zoomArgs.min) ? zoomArgs.min : rangeMin;
	            rangeMaxVisible = _isDefined(zoomArgs.max) ? zoomArgs.max : rangeMax
	        } else {
	            rangeMinVisible = _isDefined(zoomArgs.min) ? zoomArgs.min : min;
	            rangeMaxVisible = _isDefined(zoomArgs.max) ? zoomArgs.max : max
	        }
	        return {
	            min: rangeMin,
	            max: rangeMax,
	            stick: that._getStick(),
	            categories: options.categories,
	            dataType: options.dataType,
	            axisType: type,
	            base: options.logarithmBase,
	            invert: options.inverted,
	            addSpiderCategory: that._getSpiderCategoryOption(),
	            minVisible: rangeMinVisible,
	            maxVisible: rangeMaxVisible
	        }
	    },
	    getFullTicks: function() {
	        return this._tickManager.getFullTicks()
	    },
	    _addBoundaryTick: _noop,
	    getMarkerTrackers: _noop,
	    measureLabels: _noop,
	    _drawDateMarkers: _noop,
	    coordsIn: _noop,
	    _getSkippedCategory: _noop,
	    _initAxisPositions: _noop,
	    _drawTitle: _noop,
	    _adjustConstantLineLabels: _noop,
	    _adjustTitle: _noop,
	    getSpiderTicks: _noop,
	    setSpiderTicks: _noop
	};


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/axes_constants.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    _map = __webpack_require__(291).map,
	    _format = __webpack_require__(308);

	function getFormatObject(value, options, axisMinMax, point) {
	    var formatObject = {
	        value: value,
	        valueText: _format(value, options) || ""
	    };
	    if (axisMinMax) {
	        formatObject.min = axisMinMax.min;
	        formatObject.max = axisMinMax.max
	    }
	    if (point) {
	        formatObject.point = point
	    }
	    return formatObject
	}
	module.exports = {
	    logarithmic: "logarithmic",
	    discrete: "discrete",
	    numeric: "numeric",
	    left: "left",
	    right: "right",
	    top: "top",
	    bottom: "bottom",
	    center: "center",
	    canvasPositionPrefix: "canvas_position_",
	    canvasPositionTop: "canvas_position_top",
	    canvasPositionBottom: "canvas_position_bottom",
	    canvasPositionLeft: "canvas_position_left",
	    canvasPositionRight: "canvas_position_right",
	    canvasPositionStart: "canvas_position_start",
	    canvasPositionEnd: "canvas_position_end",
	    horizontal: "horizontal",
	    vertical: "vertical",
	    convertTicksToValues: function(ticks) {
	        return _map(ticks || [], function(item) {
	            return item.value
	        })
	    },
	    convertValuesToTicks: function(values) {
	        return _map(values || [], function(item) {
	            return {
	                value: item
	            }
	        })
	    },
	    validateOverlappingMode: function(mode) {
	        return "ignore" !== mode ? "enlargeTickInterval" : "ignore"
	    },
	    formatLabel: function(value, options, axisMinMax, point) {
	        var formatObject = getFormatObject(value, options, axisMinMax, point);
	        return $.isFunction(options.customizeText) ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText
	    },
	    formatHint: function(value, options, axisMinMax) {
	        var formatObject = getFormatObject(value, options, axisMinMax);
	        return $.isFunction(options.customizeHint) ? options.customizeHint.call(formatObject, formatObject) : void 0
	    }
	};


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/base_tick_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    TickManager, coreTickManager = __webpack_require__(355),
	    dateTimeManager = __webpack_require__(356),
	    overlappingMethods = __webpack_require__(357),
	    logarithmicMethods = __webpack_require__(358),
	    dateUtils = __webpack_require__(51),
	    commonUtils = __webpack_require__(8),
	    formatHelper = __webpack_require__(54),
	    _isDefined = commonUtils.isDefined,
	    _isNumber = commonUtils.isNumber,
	    _addInterval = dateUtils.addInterval,
	    utils = __webpack_require__(291),
	    _adjustValue = utils.adjustValue,
	    _map = utils.map,
	    _each = $.each,
	    _inArray = $.inArray,
	    _noop = $.noop,
	    DEFAULT_GRID_SPACING_FACTOR = 30,
	    DEFAULT_MINOR_GRID_SPACING_FACTOR = 15,
	    DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 3, 5],
	    TICKS_COUNT_LIMIT = 2e3,
	    MIN_ARRANGEMENT_TICKS_COUNT = 2;

	function getUniqueValues(array) {
	    var currentValue, lastValue = array[0],
	        result = [lastValue.obj],
	        length = array.length,
	        i = 1;
	    for (i; i < length; i++) {
	        currentValue = array[i];
	        if (lastValue.value !== currentValue.value) {
	            result.push(currentValue.obj);
	            lastValue = currentValue
	        }
	    }
	    return result
	}

	function concatAndSort(array1, array2) {
	    if (!array1.length && !array2.length) {
	        return []
	    }
	    var array = array1.concat(array2),
	        values = [],
	        length = array.length,
	        hasNull = false,
	        i = 0;
	    for (i; i < length; i++) {
	        if (null !== array[i]) {
	            values.push({
	                obj: array[i],
	                value: array[i].valueOf()
	            })
	        } else {
	            hasNull = true
	        }
	    }
	    values.sort(function(x, y) {
	        return x.value - y.value
	    });
	    values = getUniqueValues(values);
	    hasNull && values.push(null);
	    return values
	}
	exports.discrete = $.extend({}, coreTickManager.continuous, {
	    _calculateMinorTicks: _noop,
	    _findTickInterval: _noop,
	    _createTicks: function() {
	        return []
	    },
	    _getMarginValue: _noop,
	    _generateBounds: _noop,
	    _correctMin: _noop,
	    _correctMax: _noop,
	    _findBusinessDelta: _noop,
	    _addBoundedTicks: _noop,
	    getFullTicks: function() {
	        return this._customTicks
	    },
	    getMinorTicks: function() {
	        return this._decimatedTicks || []
	    },
	    _findTickIntervalForCustomTicks: function() {
	        return 1
	    }
	});
	TickManager = exports.TickManager = function(types, data, options) {
	    options = options || {};
	    this.update(types || {}, data || {}, options);
	    this._initOverlappingMethods(options.overlappingBehaviorType)
	};
	TickManager.prototype = {
	    constructor: TickManager,
	    dispose: function() {
	        this._ticks = null;
	        this._minorTicks = null;
	        this._decimatedTicks = null;
	        this._boundaryTicks = null;
	        this._options = null
	    },
	    update: function(types, data, options) {
	        this._updateOptions(options || {});
	        this._min = data.min;
	        this._updateTypes(types || {});
	        this._updateData(data || {})
	    },
	    _updateMinMax: function(data) {
	        var min = data.min || 0,
	            max = data.max || 0,
	            newMinMax = this._applyMinMaxMargins(min, max);
	        this._min = this._originalMin = newMinMax.min;
	        this._max = this._originalMax = newMinMax.max;
	        this._updateBusinessDelta()
	    },
	    _updateBusinessDelta: function() {
	        this._businessDelta = this._findBusinessDelta && this._findBusinessDelta(this._min, this._max)
	    },
	    _updateTypes: function(types) {
	        var that = this,
	            axisType = that._validateAxisType(types.axisType),
	            dataType = that._validateDataType(types.dataType);
	        that._resetMethods();
	        this._axisType = axisType;
	        this._dataType = dataType;
	        this._initMethods()
	    },
	    _updateData: function(data) {
	        data = $.extend({}, data);
	        data.min = _isDefined(data.min) ? data.min : this._originalMin;
	        data.max = _isDefined(data.max) ? data.max : this._originalMax;
	        this._updateMinMax(data);
	        this._customTicks = data.customTicks && data.customTicks.slice();
	        this._customMinorTicks = data.customMinorTicks;
	        this._customBoundTicks = data.customBoundTicks;
	        this._screenDelta = data.screenDelta || 0
	    },
	    _updateOptions: function(options) {
	        var opt;
	        this._options = opt = options;
	        this._useAutoArrangement = !!this._options.useTicksAutoArrangement;
	        opt.gridSpacingFactor = opt.gridSpacingFactor || DEFAULT_GRID_SPACING_FACTOR;
	        opt.minorGridSpacingFactor = opt.minorGridSpacingFactor || DEFAULT_MINOR_GRID_SPACING_FACTOR;
	        opt.numberMultipliers = opt.numberMultipliers || DEFAULT_NUMBER_MULTIPLIERS
	    },
	    getTickBounds: function() {
	        return {
	            minVisible: this._minBound,
	            maxVisible: this._maxBound
	        }
	    },
	    getTicks: function(withoutOverlappingBehavior) {
	        var that = this,
	            options = that._options;
	        that._ticks = that._calculateMajorTicks();
	        that._checkLabelFormat();
	        that._decimatedTicks = [];
	        that._applyAutoArrangement();
	        !withoutOverlappingBehavior && that._applyOverlappingBehavior();
	        that._generateBounds();
	        if (options.showMinorTicks) {
	            that._minorTicks = that._calculateMinorTicks()
	        }
	        that._addBoundedTicks();
	        return that._ticks
	    },
	    getMinorTicks: function() {
	        var that = this,
	            decimatedTicks = that.getDecimatedTicks(),
	            options = that._options || {},
	            hasDecimatedTicks = decimatedTicks.length,
	            hasMinorTickOptions = _isDefined(options.minorTickInterval) || _isDefined(options.minorTickCount),
	            hasCustomMinorTicks = that._customMinorTicks && that._customMinorTicks.length,
	            hasMinorTicks = options.showMinorTicks && (hasMinorTickOptions || hasCustomMinorTicks),
	            ticks = hasDecimatedTicks && !hasMinorTicks ? decimatedTicks : that._minorTicks || [];
	        return concatAndSort(ticks, [])
	    },
	    getDecimatedTicks: function() {
	        return this._decimatedTicks || []
	    },
	    getFullTicks: function() {
	        var that = this,
	            needCalculateMinorTicks = that._ticks && !that._minorTicks,
	            minorTicks = needCalculateMinorTicks ? that._calculateMinorTicks() : that._minorTicks || [];
	        return concatAndSort(that._ticks || [], minorTicks.concat(that.getBoundaryTicks()))
	    },
	    getBoundaryTicks: function() {
	        return this._boundaryTicks || []
	    },
	    getTickInterval: function() {
	        return this._tickInterval
	    },
	    getMinorTickInterval: function() {
	        return this._minorTickInterval
	    },
	    getOverlappingBehavior: function() {
	        return this._options.overlappingBehavior
	    },
	    getOptions: function() {
	        return this._options
	    },
	    _calculateMajorTicks: function() {
	        var ticks, that = this;
	        if (that._options.showCalculatedTicks || !that._customTicks) {
	            ticks = that._createTicks(that._options.showCalculatedTicks ? that._customTicks || [] : [], that._findTickInterval(), that._min, that._max)
	        } else {
	            ticks = that._customTicks.slice();
	            that._tickInterval = ticks.length > 1 ? that._findTickIntervalForCustomTicks() : 0
	        }
	        return ticks
	    },
	    _applyMargin: function(margin, min, max, isNegative) {
	        var coef, value = min;
	        if (isFinite(margin)) {
	            coef = this._getMarginValue(min, max, margin);
	            if (coef) {
	                value = this._getNextTickValue(min, coef, isNegative, false)
	            }
	        }
	        return value
	    },
	    _applyMinMaxMargins: function(min, max) {
	        var options = this._options,
	            newMin = min > max ? max : min,
	            newMax = max > min ? max : min;
	        this._minCorrectionEnabled = this._getCorrectionEnabled(min, "min");
	        this._maxCorrectionEnabled = this._getCorrectionEnabled(max, "max");
	        if (options && !options.stick) {
	            newMin = this._applyMargin(options.minValueMargin, min, max, true);
	            newMax = this._applyMargin(options.maxValueMargin, max, min, false)
	        }
	        return {
	            min: newMin,
	            max: newMax
	        }
	    },
	    _checkBoundedTickInArray: function(value, array) {
	        var arrayValues = _map(array || [], function(item) {
	                return item.valueOf()
	            }),
	            minorTicksIndex = _inArray(value.valueOf(), arrayValues);
	        if (minorTicksIndex !== -1) {
	            array.splice(minorTicksIndex, 1)
	        }
	    },
	    _checkLabelFormat: function() {
	        var options = this._options;
	        if ("datetime" === this._dataType && !options.hasLabelFormat && this._ticks.length) {
	            options.labelOptions.format = options.isMarkersVisible ? dateUtils.getDateFormatByTickInterval(this._tickInterval) : formatHelper.getDateFormatByTicks(this._ticks)
	        }
	    },
	    _generateBounds: function() {
	        var that = this,
	            interval = that._getBoundInterval(),
	            stick = that._options.stick,
	            minStickValue = that._options.minStickValue,
	            maxStickValue = that._options.maxStickValue,
	            minBound = that._minCorrectionEnabled && !stick ? that._getNextTickValue(that._min, interval, true) : that._originalMin,
	            maxBound = that._maxCorrectionEnabled && !stick ? that._getNextTickValue(that._max, interval) : that._originalMax;
	        that._minBound = minBound < minStickValue ? minStickValue : minBound;
	        that._maxBound = maxBound > maxStickValue ? maxStickValue : maxBound
	    },
	    _initOverlappingMethods: function(type) {
	        this._initMethods(overlappingMethods[type || "linear"])
	    },
	    _addBoundedTicks: function() {
	        var that = this,
	            tickValues = _map(that._ticks, function(tick) {
	                return tick.valueOf()
	            }),
	            customBounds = that._customBoundTicks,
	            min = that._originalMin,
	            max = that._originalMax,
	            addMinMax = that._options.addMinMax || {};

	        function processTick(tick) {
	            that._boundaryTicks.push(tick);
	            that._checkBoundedTickInArray(tick, that._minorTicks);
	            that._checkBoundedTickInArray(tick, that._decimatedTicks)
	        }
	        that._boundaryTicks = [];
	        if (customBounds) {
	            if (addMinMax.min && _isDefined(customBounds[0])) {
	                processTick(customBounds[0])
	            }
	            if (addMinMax.max && _isDefined(customBounds[1])) {
	                processTick(customBounds[1])
	            }
	        } else {
	            if (addMinMax.min && _inArray(min.valueOf(), tickValues) === -1) {
	                processTick(min)
	            }
	            if (addMinMax.max && _inArray(max.valueOf(), tickValues) === -1) {
	                processTick(max)
	            }
	        }
	    },
	    _getCorrectionEnabled: function(value, marginSelector) {
	        var options = this._options || {},
	            hasPercentStick = options.percentStick && 1 === Math.abs(value),
	            hasValueMargin = options[marginSelector + "ValueMargin"];
	        return !hasPercentStick && !hasValueMargin
	    },
	    _validateAxisType: function(type) {
	        var defaultType = "continuous",
	            allowedTypes = {
	                continuous: true,
	                discrete: true,
	                logarithmic: true
	            };
	        return allowedTypes[type] ? type : defaultType
	    },
	    _validateDataType: function(type) {
	        var allowedTypes = {
	            numeric: true,
	            datetime: true,
	            string: true
	        };
	        if (!allowedTypes[type]) {
	            type = _isDefined(this._min) ? this._getDataType(this._min) : "numeric"
	        }
	        return type
	    },
	    _getDataType: function(value) {
	        return commonUtils.isDate(value) ? "datetime" : "numeric"
	    },
	    _getMethods: function() {
	        var methods;
	        if ("continuous" === this._axisType) {
	            methods = "datetime" === this._dataType ? dateTimeManager.datetime : coreTickManager.continuous
	        } else {
	            switch (this._axisType) {
	                case "discrete":
	                    methods = exports.discrete;
	                    break;
	                case "logarithmic":
	                    methods = logarithmicMethods.logarithmic;
	                    break;
	                default:
	                    methods = coreTickManager.continuous
	            }
	        }
	        return methods
	    },
	    _resetMethods: function() {
	        var that = this,
	            methods = that._getMethods();
	        _each(methods, function(name) {
	            if (that[name]) {
	                delete that[name]
	            }
	        })
	    },
	    _initMethods: function(methods) {
	        var that = this;
	        methods = methods || that._getMethods();
	        _each(methods, function(name, func) {
	            that[name] = func
	        })
	    },
	    _getDeltaCoef: function(screenDelta, businessDelta, gridSpacingFactor) {
	        var count;
	        gridSpacingFactor = gridSpacingFactor || this._options.gridSpacingFactor;
	        screenDelta = screenDelta || this._screenDelta;
	        businessDelta = businessDelta || this._businessDelta;
	        count = screenDelta / gridSpacingFactor;
	        count = count <= 1 ? MIN_ARRANGEMENT_TICKS_COUNT : count;
	        return businessDelta / count
	    },
	    _adjustNumericTickValue: function(value, interval, min) {
	        return commonUtils.isExponential(value) ? _adjustValue(value) : utils.applyPrecisionByMinDelta(min, interval, value)
	    },
	    _isTickIntervalCorrect: function(tickInterval, tickCountLimit, businessDelta) {
	        var date;
	        businessDelta = businessDelta || this._businessDelta;
	        if (!_isNumber(tickInterval)) {
	            date = new Date;
	            tickInterval = _addInterval(date, tickInterval) - date;
	            if (!tickInterval) {
	                return false
	            }
	        }
	        if (_isNumber(tickInterval)) {
	            if (tickInterval > 0 && businessDelta / tickInterval > tickCountLimit) {
	                if (this._options.incidentOccurred) {
	                    this._options.incidentOccurred("W2003")
	                }
	            } else {
	                return true
	            }
	        }
	        return false
	    },
	    _correctValue: function(valueTypeSelector, tickInterval, correctionMethod) {
	        var that = this,
	            correctionEnabledSelector = "_" + valueTypeSelector + "CorrectionEnabled",
	            spaceCorrectionSelector = valueTypeSelector + "SpaceCorrection",
	            valueSelector = "_" + valueTypeSelector,
	            minStickValue = that._options.minStickValue,
	            maxStickValue = that._options.maxStickValue;
	        if (that[correctionEnabledSelector]) {
	            if (that._options[spaceCorrectionSelector]) {
	                that[valueSelector] = that._getNextTickValue(that[valueSelector], tickInterval, "min" === valueTypeSelector)
	            }
	            correctionMethod.call(this, tickInterval)
	        }
	        if ("min" === valueTypeSelector) {
	            that[valueSelector] = that[valueSelector] < minStickValue ? minStickValue : that[valueSelector]
	        }
	        if ("max" === valueTypeSelector) {
	            that[valueSelector] = that[valueSelector] > maxStickValue ? maxStickValue : that[valueSelector]
	        }
	    },
	    _findTickInterval: function() {
	        var tickInterval, that = this,
	            options = that._options,
	            calculatedTickInterval = that._getInterval(),
	            userTickInterval = that._isTickIntervalValid(options.tickInterval) && that._isTickIntervalCorrect(options.tickInterval, TICKS_COUNT_LIMIT) && options.tickInterval;
	        tickInterval = that.checkUserTickInterval(userTickInterval, calculatedTickInterval);
	        if (that._isTickIntervalValid(tickInterval)) {
	            that._correctValue("min", tickInterval, that._correctMin);
	            that._correctValue("max", tickInterval, that._correctMax);
	            that._updateBusinessDelta()
	        }
	        that._tickInterval = tickInterval;
	        return tickInterval
	    },
	    _findMinorTickInterval: function(firstTick, secondTick) {
	        var that = this,
	            ticks = that._ticks,
	            intervals = that._options.stick ? ticks.length - 1 : ticks.length;
	        if (intervals < 1) {
	            intervals = 1
	        }
	        that._getMinorInterval(that._screenDelta / intervals, that._findBusinessDelta(firstTick, secondTick, false));
	        return that._minorTickInterval
	    },
	    _createMinorTicks: function(ticks, firstTick, secondTick) {
	        var that = this,
	            tickInterval = that._findMinorTickInterval(firstTick, secondTick),
	            isTickIntervalNegative = false,
	            isTickIntervalWithPow = false,
	            needCorrectTick = false,
	            startTick = that._getNextTickValue(firstTick, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
	        if (that._isTickIntervalValid(tickInterval)) {
	            ticks = that._createCountedTicks(ticks, tickInterval, startTick, secondTick, that._minorTickCount, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick)
	        }
	        return ticks
	    },
	    _calculateMinorTicks: function() {
	        var that = this,
	            options = that._options,
	            minorTicks = [],
	            ticks = that._ticks,
	            ticksLength = ticks.length,
	            hasUnitBeginningTick = that._hasUnitBeginningTickCorrection(),
	            i = hasUnitBeginningTick ? 1 : 0;
	        if (options.showMinorCalculatedTicks || !that._customMinorTicks) {
	            if (ticks.length) {
	                minorTicks = that._getBoundedMinorTicks(minorTicks, that._minBound, ticks[0], true);
	                if (hasUnitBeginningTick) {
	                    minorTicks = that._getUnitBeginningMinorTicks(minorTicks)
	                }
	                for (i; i < ticksLength - 1; i++) {
	                    minorTicks = that._createMinorTicks(minorTicks, ticks[i], ticks[i + 1])
	                }
	                minorTicks = that._getBoundedMinorTicks(minorTicks, that._maxBound, ticks[ticksLength - 1])
	            } else {
	                minorTicks = that._createMinorTicks(minorTicks, that._minBound, that._maxBound)
	            }
	            options.showMinorCalculatedTicks && (minorTicks = minorTicks.concat(that._customMinorTicks || []))
	        } else {
	            minorTicks = that._customMinorTicks
	        }
	        return minorTicks
	    },
	    _createCountedTicks: function(ticks, tickInterval, min, max, count, isTickIntervalWithPow, needMax) {
	        var i, value = min;
	        for (i = 0; i < count; i++) {
	            if (!(false === needMax && value.valueOf() === max.valueOf())) {
	                ticks.push(value)
	            }
	            value = this._getNextTickValue(value, tickInterval, false, isTickIntervalWithPow, false)
	        }
	        return ticks
	    },
	    _createTicks: function(ticks, tickInterval, min, max, isTickIntervalNegative, isTickIntervalWithPow, withCorrection) {
	        var leftBound, rightBound, boundedRule, that = this,
	            value = min,
	            newValue = min;
	        if (that._isTickIntervalValid(tickInterval)) {
	            boundedRule = min - max < 0;
	            do {
	                value = newValue;
	                if (that._options.stick) {
	                    if (value >= that._originalMin && value <= that._originalMax) {
	                        ticks.push(value)
	                    }
	                } else {
	                    ticks.push(value)
	                }
	                newValue = that._getNextTickValue(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, withCorrection);
	                if (value.valueOf() === newValue.valueOf()) {
	                    break
	                }
	                leftBound = newValue - min >= 0;
	                rightBound = max - newValue >= 0
	            } while (boundedRule === leftBound && boundedRule === rightBound)
	        } else {
	            ticks.push(value)
	        }
	        return ticks
	    },
	    _getBoundedMinorTicks: function(minorTicks, boundedTick, tick, isNegative) {
	        var startTick, endTick, that = this,
	            needCorrectTick = false,
	            nextTick = that._tickInterval ? this._getNextTickValue(tick, that._tickInterval, isNegative, true, needCorrectTick) : boundedTick,
	            tickInterval = that._findMinorTickInterval(tick, nextTick),
	            isTickIntervalCorrect = that._isTickIntervalCorrect(tickInterval, TICKS_COUNT_LIMIT, that._findBusinessDelta(tick, boundedTick, false)),
	            boundedTickValue = boundedTick.valueOf();
	        if (isTickIntervalCorrect && that._isTickIntervalValid(tickInterval) && that._minorTickCount > 0) {
	            if (isNegative) {
	                if (tick.valueOf() <= boundedTickValue) {
	                    return minorTicks
	                }
	                while (nextTick.valueOf() < boundedTickValue) {
	                    nextTick = this._getNextTickValue(nextTick, tickInterval, false, false, needCorrectTick)
	                }
	                startTick = nextTick;
	                endTick = that._getNextTickValue(tick, tickInterval, true, false, false)
	            } else {
	                startTick = that._getNextTickValue(tick, tickInterval, false, false, false);
	                endTick = boundedTick
	            }
	            minorTicks = that._createTicks(minorTicks, tickInterval, startTick, endTick, false, false, needCorrectTick)
	        }
	        return minorTicks
	    }
	};


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/numeric_tick_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    vizUtils = __webpack_require__(291),
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _adjustValue = vizUtils.adjustValue,
	    _math = Math,
	    _abs = _math.abs,
	    _ceil = _math.ceil,
	    _floor = _math.floor,
	    _noop = $.noop,
	    MINOR_TICKS_COUNT_LIMIT = 200,
	    DEFAULT_MINOR_NUMBER_MULTIPLIERS = [2, 4, 5, 8, 10];
	exports.continuous = {
	    _hasUnitBeginningTickCorrection: _noop,
	    _checkBoundedDatesOverlapping: _noop,
	    _correctInterval: function(step) {
	        this._tickInterval *= step
	    },
	    _correctMax: function(tickInterval) {
	        this._max = this._adjustNumericTickValue(_ceil(this._max / tickInterval) * tickInterval, tickInterval, this._min)
	    },
	    _correctMin: function(tickInterval) {
	        this._min = this._adjustNumericTickValue(_floor(this._min / tickInterval) * tickInterval, tickInterval, this._min)
	    },
	    _findBusinessDelta: function(min, max) {
	        return _adjustValue(_abs(min - max))
	    },
	    _findTickIntervalForCustomTicks: function() {
	        return _abs(this._customTicks[1] - this._customTicks[0])
	    },
	    _getBoundInterval: function() {
	        var that = this,
	            boundCoef = that._options.boundCoef;
	        return _isDefined(boundCoef) && isFinite(boundCoef) ? that._tickInterval * _abs(boundCoef) : that._tickInterval / 2
	    },
	    _getInterval: function(deltaCoef, numberMultipliers) {
	        var factor, newResult, i, interval = deltaCoef || this._getDeltaCoef(this._screenDelta, this._businessDelta, this._options.gridSpacingFactor),
	            multipliers = numberMultipliers || this._options.numberMultipliers,
	            result = 0,
	            hasResult = false;
	        if (interval > 1) {
	            for (factor = 1; !hasResult; factor *= 10) {
	                for (i = 0; i < multipliers.length; i++) {
	                    result = multipliers[i] * factor;
	                    if (interval <= result) {
	                        hasResult = true;
	                        break
	                    }
	                }
	            }
	        } else {
	            if (interval > 0) {
	                result = 1;
	                for (factor = .1; !hasResult; factor /= 10) {
	                    for (i = multipliers.length - 1; i >= 0; i--) {
	                        newResult = multipliers[i] * factor;
	                        if (interval > newResult) {
	                            hasResult = true;
	                            break
	                        }
	                        result = newResult
	                    }
	                }
	            }
	        }
	        return _adjustValue(result)
	    },
	    _getMarginValue: function(min, max, margin) {
	        return vizUtils.applyPrecisionByMinDelta(min, margin, _abs(max - min) * margin)
	    },
	    _getDefaultMinorInterval: function(screenDelta, businessDelta) {
	        var result, deltaCoef = this._getDeltaCoef(screenDelta, businessDelta, this._options.minorGridSpacingFactor),
	            multipliers = DEFAULT_MINOR_NUMBER_MULTIPLIERS,
	            i = multipliers.length - 1;
	        for (i; i >= 0; i--) {
	            result = businessDelta / multipliers[i];
	            if (deltaCoef <= result) {
	                return _adjustValue(result)
	            }
	        }
	        return 0
	    },
	    _getMinorInterval: function(screenDelta, businessDelta) {
	        var interval, intervalsCount, count, that = this,
	            options = that._options,
	            minorTickInterval = options.minorTickInterval,
	            minorTickCount = options.minorTickCount;
	        if (isFinite(minorTickInterval) && that._isTickIntervalCorrect(minorTickInterval, MINOR_TICKS_COUNT_LIMIT, businessDelta)) {
	            interval = minorTickInterval;
	            count = interval < businessDelta ? _ceil(businessDelta / interval) - 1 : 0
	        } else {
	            if (_isDefined(minorTickCount)) {
	                intervalsCount = _isDefined(minorTickCount) ? minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor);
	                count = intervalsCount - 1;
	                interval = count > 0 ? businessDelta / intervalsCount : 0
	            } else {
	                interval = that._getDefaultMinorInterval(screenDelta, businessDelta);
	                count = interval < businessDelta ? _floor(businessDelta / interval) - 1 : 0
	            }
	        }
	        that._minorTickInterval = interval;
	        that._minorTickCount = count
	    },
	    _getNextTickValue: function(value, tickInterval, isTickIntervalNegative) {
	        tickInterval = _isDefined(isTickIntervalNegative) && isTickIntervalNegative ? -tickInterval : tickInterval;
	        value += tickInterval;
	        return this._adjustNumericTickValue(value, tickInterval, this._min)
	    },
	    _isTickIntervalValid: function(tickInterval) {
	        return _isDefined(tickInterval) && isFinite(tickInterval) && 0 !== tickInterval
	    }
	};


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/datetime_tick_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    dateUtils = __webpack_require__(51),
	    commonUtils = __webpack_require__(8),
	    tickManagerContinuous = __webpack_require__(355).continuous,
	    _isDefined = commonUtils.isDefined,
	    _convertDateUnitToMilliseconds = dateUtils.convertDateUnitToMilliseconds,
	    _correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning,
	    _dateToMilliseconds = dateUtils.dateToMilliseconds,
	    _convertMillisecondsToDateUnits = dateUtils.convertMillisecondsToDateUnits,
	    _math = Math,
	    _abs = _math.abs,
	    _ceil = _math.ceil,
	    _floor = _math.floor,
	    _round = _math.round,
	    MINOR_TICKS_COUNT_LIMIT = 50,
	    DEFAULT_DATETIME_MULTIPLIERS = {
	        millisecond: [1, 2, 5, 10, 25, 100, 250, 300, 500],
	        second: [1, 2, 3, 5, 10, 15, 20, 30],
	        minute: [1, 2, 3, 5, 10, 15, 20, 30],
	        hour: [1, 2, 3, 4, 6, 8, 12],
	        day: [1, 2, 3, 5, 7, 10, 14],
	        month: [1, 2, 3, 6]
	    };

	function correctDate(date, tickInterval, correctionMethod) {
	    var interval = _dateToMilliseconds(tickInterval),
	        timezoneOffset = 60 * date.getTimezoneOffset() * 1e3;
	    return new Date(Math[correctionMethod]((date - 0 - timezoneOffset) / interval) * interval + timezoneOffset)
	}
	exports.datetime = $.extend({}, tickManagerContinuous, {
	    _correctInterval: function(step) {
	        var tickIntervalInMs = _dateToMilliseconds(this._tickInterval);
	        this._tickInterval = _convertMillisecondsToDateUnits(tickIntervalInMs * step)
	    },
	    _correctMax: function(tickInterval) {
	        this._max = correctDate(this._max, tickInterval, "ceil")
	    },
	    _correctMin: function(tickInterval) {
	        this._min = correctDate(this._min, tickInterval, "floor");
	        if (this._options.setTicksAtUnitBeginning) {
	            this._min = _correctDateWithUnitBeginning(this._min, tickInterval)
	        }
	    },
	    _findTickIntervalForCustomTicks: function() {
	        return _convertMillisecondsToDateUnits(_abs(this._customTicks[1] - this._customTicks[0]))
	    },
	    _getBoundInterval: function() {
	        var that = this,
	            interval = that._tickInterval,
	            intervalInMs = _dateToMilliseconds(interval),
	            boundCoef = that._options.boundCoef,
	            boundIntervalInMs = _isDefined(boundCoef) && isFinite(boundCoef) ? intervalInMs * _abs(boundCoef) : intervalInMs / 2;
	        return _convertMillisecondsToDateUnits(boundIntervalInMs)
	    },
	    _getInterval: function(deltaCoef) {
	        var factor, i, key, specificMultipliers, yearsCount, interval = deltaCoef || this._getDeltaCoef(this._screenDelta, this._businessDelta, this._options.gridSpacingFactor),
	            multipliers = this._options.numberMultipliers,
	            result = {};
	        if (interval > 0 && interval < 1) {
	            return {
	                milliseconds: 1
	            }
	        }
	        if (0 === interval) {
	            return 0
	        }
	        for (key in DEFAULT_DATETIME_MULTIPLIERS) {
	            if (DEFAULT_DATETIME_MULTIPLIERS.hasOwnProperty(key)) {
	                specificMultipliers = DEFAULT_DATETIME_MULTIPLIERS[key];
	                for (i = 0; i < specificMultipliers.length; i++) {
	                    if (interval <= _convertDateUnitToMilliseconds(key, specificMultipliers[i])) {
	                        result[key + "s"] = specificMultipliers[i];
	                        return result
	                    }
	                }
	            }
	        }
	        for (factor = 1;; factor *= 10) {
	            for (i = 0; i < multipliers.length; i++) {
	                yearsCount = factor * multipliers[i];
	                if (interval <= _convertDateUnitToMilliseconds("year", yearsCount)) {
	                    return {
	                        years: yearsCount
	                    }
	                }
	            }
	        }
	    },
	    _getMarginValue: function(min, max, margin) {
	        return _convertMillisecondsToDateUnits(_round(_abs(max - min) * margin))
	    },
	    _getMinorInterval: function(screenDelta, businessDelta) {
	        var interval, intervalInMs, intervalsCount, count, that = this,
	            options = that._options;
	        if (_isDefined(options.minorTickInterval) && that._isTickIntervalCorrect(options.minorTickInterval, MINOR_TICKS_COUNT_LIMIT, businessDelta)) {
	            interval = options.minorTickInterval;
	            intervalInMs = _dateToMilliseconds(interval);
	            count = intervalInMs < businessDelta ? _ceil(businessDelta / intervalInMs) - 1 : 0
	        } else {
	            intervalsCount = _isDefined(options.minorTickCount) ? options.minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor);
	            count = intervalsCount - 1;
	            interval = count > 0 ? _convertMillisecondsToDateUnits(businessDelta / intervalsCount) : 0
	        }
	        that._minorTickInterval = interval;
	        that._minorTickCount = count
	    },
	    _getNextTickValue: function(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, withCorrection) {
	        var newValue = dateUtils.addInterval(value, tickInterval, isTickIntervalNegative);
	        if (this._options.setTicksAtUnitBeginning && false !== withCorrection) {
	            newValue = _correctDateWithUnitBeginning(newValue, tickInterval, true)
	        }
	        return newValue
	    },
	    _getUnitBeginningMinorTicks: function(minorTicks) {
	        var that = this,
	            ticks = that._ticks,
	            tickInterval = that._findMinorTickInterval(ticks[1], ticks[2]),
	            isTickIntervalNegative = true,
	            isTickIntervalWithPow = false,
	            needCorrectTick = false,
	            startTick = that._getNextTickValue(ticks[1], tickInterval, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
	        if (that._isTickIntervalValid(tickInterval)) {
	            minorTicks = that._createTicks(minorTicks, tickInterval, startTick, ticks[0], isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick)
	        }
	        return minorTicks
	    },
	    _hasUnitBeginningTickCorrection: function() {
	        var ticks = this._ticks;
	        if (ticks.length < 3) {
	            return false
	        }
	        return ticks[1] - ticks[0] !== ticks[2] - ticks[1] && this._options.setTicksAtUnitBeginning && this._options.minorTickCount
	    },
	    _isTickIntervalValid: function(tickInterval) {
	        return _isDefined(tickInterval) && 0 !== _dateToMilliseconds(tickInterval)
	    },
	    _checkBoundedDatesOverlapping: function() {
	        var dates = this._ticks,
	            overlappingBehavior = this.getOverlappingBehavior();
	        return dates.length > 2 && "stagger" !== overlappingBehavior.mode && "ignore" !== overlappingBehavior.mode && !this._areDisplayValuesValid(dates[0], dates[1])
	    }
	});


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/tick_overlapping_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    numericTickManager = __webpack_require__(355),
	    commonUtils = __webpack_require__(8),
	    _addInterval = __webpack_require__(51).addInterval,
	    _isDefined = commonUtils.isDefined,
	    _isNumber = commonUtils.isNumber,
	    _math = Math,
	    _abs = _math.abs,
	    _ceil = _math.ceil,
	    _floor = _math.floor,
	    _atan = _math.atan,
	    _max = _math.max,
	    _each = $.each,
	    _noop = $.noop,
	    _isFunction = $.isFunction,
	    _extend = $.extend,
	    SCREEN_DELTA_KOEF = 4,
	    AXIS_STAGGER_OVERLAPPING_KOEF = 2,
	    STAGGER = "stagger",
	    ROTATE = "rotate",
	    MIN_ARRANGEMENT_TICKS_COUNT = 2,
	    outOfScreen = {
	        x: -1e3,
	        y: -1e3
	    };

	function nextState(state) {
	    switch (state) {
	        case "overlap":
	            return STAGGER;
	        case STAGGER:
	            return ROTATE;
	        default:
	            return "end"
	    }
	}

	function defaultGetTextFunc(value) {
	    return value.toString()
	}

	function convertDateIntervalToNumeric(interval) {
	    if (!_isNumber(interval)) {
	        var date = new Date;
	        interval = _addInterval(date, interval) - date
	    }
	    return interval
	}
	exports.base = {
	    _applyOverlappingBehavior: function() {
	        var that = this,
	            options = that._options,
	            overlappingBehavior = options.overlappingBehavior;
	        if ("ignore" !== overlappingBehavior.mode) {
	            that._useAutoArrangement = true;
	            that._correctTicks();
	            if ("_auto" === overlappingBehavior.mode) {
	                that._applyAutoOverlappingBehavior();
	                that._useAutoArrangement = options.overlappingBehavior.isOverlapped
	            }
	            if (that._useAutoArrangement) {
	                if (overlappingBehavior.mode === STAGGER) {
	                    that._screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF
	                }
	                that._applyAutoArrangement()
	            }
	        }
	    },
	    checkBoundedTicksOverlapping: function() {
	        return {
	            overlappedDates: this._checkBoundedDatesOverlapping(),
	            overlappedStartEnd: this._checkStartEndOverlapping()
	        }
	    },
	    getMaxLabelParams: function(ticks) {
	        var tickWithMaxLength, tickTextWithMaxLength, that = this,
	            getText = that._options.getText || defaultGetTextFunc,
	            maxLength = 0;
	        ticks = ticks || that._calculateMajorTicks();
	        _each(ticks, function(_, item) {
	            var text = getText(item, that._options.labelOptions),
	                length = _isDefined(text) ? text.length : -1;
	            if (maxLength < length) {
	                maxLength = length;
	                tickWithMaxLength = item;
	                tickTextWithMaxLength = text
	            }
	        });
	        return maxLength > 0 ? that._getTextElementBBox(tickWithMaxLength, tickTextWithMaxLength) : {
	            width: 0,
	            height: 0,
	            length: 0,
	            y: 0
	        }
	    },
	    _applyAutoArrangement: function() {
	        var arrangementStep, maxDisplayValueSize, that = this,
	            options = that._options;
	        if (that._useAutoArrangement) {
	            maxDisplayValueSize = that._getTicksSize();
	            arrangementStep = that._getAutoArrangementStep(maxDisplayValueSize);
	            if (arrangementStep > 1) {
	                if (_isDefined(that._tickInterval) || _isDefined(that._customTicks)) {
	                    that._ticks = that._getAutoArrangementTicks(arrangementStep)
	                } else {
	                    options.gridSpacingFactor = maxDisplayValueSize;
	                    that._ticks = that._createTicks([], that._findTickInterval(), that._min, that._max)
	                }
	            }
	        }
	    },
	    _getAutoArrangementTicks: function(step) {
	        var i, that = this,
	            ticks = that._ticks,
	            ticksLength = ticks.length,
	            resultTicks = ticks,
	            decimatedTicks = that._decimatedTicks || [];
	        if (step > 1) {
	            resultTicks = [];
	            for (i = 0; i < ticksLength; i++) {
	                if (i % step === 0) {
	                    resultTicks.push(ticks[i])
	                } else {
	                    decimatedTicks.push(ticks[i])
	                }
	            }
	            that._correctInterval(step)
	        }
	        return resultTicks
	    },
	    _isOverlappedTicks: function(screenDelta) {
	        return this._getAutoArrangementStep(this._getTicksSize(), screenDelta, -1) > 1
	    },
	    _areDisplayValuesValid: function(value1, value2) {
	        var hasHorizontalOverlapping, hasVerticalOverlapping, result, that = this,
	            options = that._options,
	            getText = options.getText || defaultGetTextFunc,
	            rotationAngle = options.overlappingBehavior && _isNumber(options.overlappingBehavior.rotationAngle) ? options.overlappingBehavior.rotationAngle : 0,
	            bBox1 = that._getTextElementBBox(value1, getText(value1, options.labelOptions)),
	            bBox2 = that._getTextElementBBox(value2, getText(value2, options.labelOptions)),
	            horizontalInverted = bBox1.x > bBox2.x,
	            verticalInverted = bBox1.y > bBox2.y;
	        if (0 !== rotationAngle) {
	            result = that._getDistanceByAngle(bBox1, rotationAngle) <= _abs(bBox2.x - bBox1.x)
	        } else {
	            hasHorizontalOverlapping = !horizontalInverted ? bBox1.x + bBox1.width > bBox2.x : bBox2.x + bBox2.width > bBox1.x;
	            hasVerticalOverlapping = !verticalInverted ? bBox1.y + bBox1.height > bBox2.y : bBox2.y + bBox2.height > bBox1.y;
	            result = !(hasHorizontalOverlapping && hasVerticalOverlapping)
	        }
	        return result
	    },
	    checkUserTickInterval: function(userTickInterval, calculatedTickInterval) {
	        var tickInterval1, tickInterval2, behavior = this._options.overlappingBehavior;
	        if (!behavior || "enlargeTickInterval" !== behavior.mode) {
	            return userTickInterval || calculatedTickInterval
	        }
	        if (!userTickInterval) {
	            return calculatedTickInterval
	        }
	        tickInterval1 = convertDateIntervalToNumeric(userTickInterval);
	        tickInterval2 = convertDateIntervalToNumeric(calculatedTickInterval);
	        if (_isNumber(tickInterval1) && _isNumber(tickInterval2)) {
	            if (tickInterval1 > tickInterval2) {
	                return userTickInterval
	            }
	        }
	        return calculatedTickInterval
	    }
	};
	exports.circular = _extend({}, exports.base, {
	    checkUserTickInterval: function(userTickInterval, calculatedTickInterval) {
	        return userTickInterval || calculatedTickInterval
	    },
	    _correctTicks: _noop,
	    _applyAutoOverlappingBehavior: function() {
	        this._options.overlappingBehavior.isOverlapped = true
	    },
	    _getTextElementBBox: function(value, text) {
	        var bBox, textOptions = _extend({}, this._options.textOptions, {
	                rotate: 0
	            }),
	            delta = _isFunction(this._options.translate) ? this._options.translate(value) : {
	                x: 0,
	                y: 0
	            };
	        text = this._options.renderText(text, delta.x, delta.y).css(this._options.textFontStyles).attr(textOptions);
	        bBox = text.getBBox();
	        text.remove();
	        return bBox
	    },
	    _getTicksSize: function() {
	        return this.getMaxLabelParams(this._ticks)
	    },
	    _checkStartEndOverlapping: function() {
	        var ticks = this._ticks,
	            lastTick = ticks[ticks.length - 1];
	        return ticks.length > 1 && !this._areDisplayValuesValid(ticks[0], lastTick)
	    },
	    _getAutoArrangementStep: function(maxDisplayValueSize) {
	        var that = this,
	            options = that._options,
	            radius = options.circularRadius,
	            startAngle = options.circularStartAngle,
	            endAngle = options.circularEndAngle,
	            circleDelta = startAngle === endAngle ? 360 : _abs(startAngle - endAngle),
	            businessDelta = that._businessDelta || that._ticks.length,
	            degreesPerTick = that._tickInterval * circleDelta / businessDelta,
	            width = maxDisplayValueSize.width,
	            height = maxDisplayValueSize.height,
	            angle1 = _abs(2 * _atan(height / (2 * radius - width)) * 180 / _math.PI),
	            angle2 = _abs(2 * _atan(width / (2 * radius - height)) * 180 / _math.PI),
	            minAngleForTick = _max(angle1, angle2),
	            step = 1;
	        if (degreesPerTick < minAngleForTick) {
	            step = _ceil(minAngleForTick / degreesPerTick)
	        }
	        return _max(1, step)
	    }
	});
	exports.linear = _extend({}, exports.base, {
	    _correctTicks: function() {
	        var arrangementStep, getIntervalFunc = numericTickManager.continuous._getInterval;
	        arrangementStep = _ceil(getIntervalFunc.call(this, this._getDeltaCoef(this._screenDelta * SCREEN_DELTA_KOEF, this._ticks.length))) || this._ticks.length;
	        this._ticks = this._getAutoArrangementTicks(arrangementStep)
	    },
	    _getTextElementBBox: function(value, text) {
	        var bBox, textOptions = _extend({}, this._options.textOptions, {
	                rotate: 0
	            }),
	            x = 0,
	            y = 0,
	            delta = _isFunction(this._options.translate) ? this._options.translate(value) : 0;
	        if (this._options.isHorizontal) {
	            x += delta
	        } else {
	            y += delta
	        }
	        text = this._options.renderText(text, x, y).css(this._options.textFontStyles).attr(textOptions);
	        bBox = text.getBBox();
	        text.remove();
	        return bBox
	    },
	    _checkStartEndOverlapping: _noop,
	    _getAutoArrangementStep: function(maxDisplayValueSize, screenDelta, minArrangementTicksStep) {
	        var requiredValuesCount, that = this,
	            options = that._options,
	            textSpacing = options.textSpacing || 0,
	            addedSpacing = options.isHorizontal ? textSpacing : 0;
	        screenDelta = screenDelta || that._screenDelta;
	        minArrangementTicksStep = _isDefined(minArrangementTicksStep) ? minArrangementTicksStep : 1;
	        if (options.getCustomAutoArrangementStep) {
	            return options.getCustomAutoArrangementStep(that._ticks, options)
	        }
	        if (maxDisplayValueSize > 0) {
	            requiredValuesCount = _floor((screenDelta + textSpacing) / (maxDisplayValueSize + addedSpacing));
	            requiredValuesCount = requiredValuesCount <= minArrangementTicksStep ? MIN_ARRANGEMENT_TICKS_COUNT : requiredValuesCount;
	            return _ceil((options.ticksCount || that._ticks.length) / requiredValuesCount)
	        }
	        return 1
	    },
	    _getOptimalRotationAngle: function() {
	        var that = this,
	            options = that._options,
	            tick1 = that._ticks[0],
	            tick2 = that._ticks[1],
	            textOptions = that._textOptions,
	            getText = options.getText || defaultGetTextFunc,
	            textFontStyles = options.textFontStyles,
	            svgElement1 = options.renderText(getText(tick1, options.labelOptions), outOfScreen.x + options.translate(tick1, !options.isHorizontal), outOfScreen.y).css(textFontStyles).attr(textOptions),
	            svgElement2 = options.renderText(getText(tick2, options.labelOptions), outOfScreen.x + options.translate(tick2, !options.isHorizontal), outOfScreen.y).css(textFontStyles).attr(textOptions),
	            bBox1 = svgElement1.getBBox(),
	            bBox2 = svgElement2.getBBox(),
	            angle = 180 * _math.asin((bBox1.height + options.textSpacing) / (bBox2.x - bBox1.x)) / Math.PI;
	        svgElement1.remove();
	        svgElement2.remove();
	        return isNaN(angle) ? 90 : _ceil(angle)
	    },
	    _applyAutoOverlappingBehavior: function() {
	        var that = this,
	            overlappingBehavior = that._options.overlappingBehavior,
	            screenDelta = that._screenDelta,
	            isOverlapped = false,
	            rotationAngle = null,
	            mode = null,
	            state = "overlap";
	        while ("end" !== state) {
	            isOverlapped = rotationAngle && 90 !== rotationAngle ? false : that._isOverlappedTicks(screenDelta);
	            state = nextState(isOverlapped ? state : null);
	            switch (state) {
	                case STAGGER:
	                    screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF;
	                    mode = state;
	                    break;
	                case ROTATE:
	                    rotationAngle = that._getOptimalRotationAngle();
	                    screenDelta = that._screenDelta;
	                    mode = state
	            }
	        }
	        overlappingBehavior.isOverlapped = isOverlapped;
	        overlappingBehavior.mode = mode;
	        overlappingBehavior.rotationAngle = rotationAngle
	    },
	    _getDistanceByAngle: function(bBox, rotationAngle) {
	        rotationAngle = _abs(rotationAngle);
	        rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;
	        var a = rotationAngle * (_math.PI / 180);
	        if (a >= _atan(bBox.height / bBox.width)) {
	            return bBox.height / _abs(_math.sin(a))
	        } else {
	            return bBox.width
	        }
	    },
	    _getTicksSize: function() {
	        var bBox = this.getMaxLabelParams(this._ticks),
	            options = this._options,
	            rotationAngle = options.overlappingBehavior ? options.overlappingBehavior.rotationAngle : 0,
	            isRotate = _isNumber(rotationAngle) && 0 !== rotationAngle;
	        return _ceil(isRotate ? this._getDistanceByAngle(bBox, rotationAngle) : options.isHorizontal ? bBox.width : bBox.height)
	    }
	});


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/logarithmic_tick_manager.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    vizUtils = __webpack_require__(291),
	    dateUtils = __webpack_require__(51),
	    commonUtils = __webpack_require__(8),
	    _isDefined = commonUtils.isDefined,
	    _addInterval = dateUtils.addInterval,
	    _adjustValue = vizUtils.adjustValue,
	    tickManagerContinuous = __webpack_require__(355).continuous,
	    _getLog = vizUtils.getLog,
	    _raiseTo = vizUtils.raiseTo,
	    _math = Math,
	    _abs = _math.abs,
	    _ceil = _math.ceil,
	    _floor = _math.floor,
	    _round = _math.round;
	exports.logarithmic = $.extend({}, tickManagerContinuous, {
	    _correctMax: function() {
	        var base = this._options.base;
	        this._max = _adjustValue(_raiseTo(_ceil(_adjustValue(_getLog(this._max, base))), base))
	    },
	    _correctMin: function() {
	        var base = this._options.base;
	        this._min = _adjustValue(_raiseTo(_floor(_adjustValue(_getLog(this._min, base))), base))
	    },
	    _findBusinessDelta: function(min, max, isTickIntervalWithPow) {
	        var delta;
	        if (min <= 0 || max <= 0) {
	            return 0
	        }
	        if (false === isTickIntervalWithPow) {
	            delta = tickManagerContinuous._findBusinessDelta(min, max)
	        } else {
	            delta = _round(_abs(_getLog(min, this._options.base) - _getLog(max, this._options.base)))
	        }
	        return delta
	    },
	    _findTickIntervalForCustomTicks: function() {
	        return _adjustValue(_getLog(this._customTicks[1] / this._customTicks[0], this._options.base))
	    },
	    _getInterval: function(deltaCoef) {
	        var factor, i, interval = deltaCoef || this._getDeltaCoef(this._screenDelta, this._businessDelta, this._options.gridSpacingFactor),
	            multipliers = this._options.numberMultipliers,
	            result = 0,
	            hasResult = false;
	        if (0 !== interval) {
	            for (factor = 1; !hasResult; factor *= 10) {
	                for (i = 0; i < multipliers.length; i++) {
	                    result = multipliers[i] * factor;
	                    if (interval <= result) {
	                        hasResult = true;
	                        break
	                    }
	                }
	            }
	        }
	        return _adjustValue(result)
	    },
	    _getMinorInterval: function(screenDelta, businessDelta) {
	        var that = this,
	            options = that._options,
	            minorTickCount = options.minorTickCount,
	            intervalsCount = _isDefined(minorTickCount) ? minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor),
	            count = intervalsCount - 1,
	            interval = count > 0 ? businessDelta / intervalsCount : 0;
	        that._minorTickInterval = interval;
	        that._minorTickCount = count
	    },
	    _getMarginValue: function() {
	        return null
	    },
	    _getNextTickValue: function(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow) {
	        var pow, nextTickValue, that = this;
	        tickInterval = _isDefined(isTickIntervalNegative) && isTickIntervalNegative ? -tickInterval : tickInterval;
	        if (false === isTickIntervalWithPow) {
	            nextTickValue = value + tickInterval
	        } else {
	            pow = _addInterval(_getLog(value, that._options.base), tickInterval, that._min > that._max);
	            nextTickValue = _adjustValue(_raiseTo(pow, that._options.base))
	        }
	        return nextTickValue
	    }
	});


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/xy_axes.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    formatHelper = __webpack_require__(54),
	    dateUtils = __webpack_require__(51),
	    getNextDateUnit = dateUtils.getNextDateUnit,
	    correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning,
	    commonUtils = __webpack_require__(8),
	    vizUtils = __webpack_require__(291),
	    _isDefined = commonUtils.isDefined,
	    constants = __webpack_require__(353),
	    _extend = $.extend,
	    CANVAS_POSITION_PREFIX = constants.canvasPositionPrefix,
	    TOP = constants.top,
	    BOTTOM = constants.bottom,
	    LEFT = constants.left,
	    RIGHT = constants.right,
	    CENTER = constants.center;

	function prepareDatesDifferences(datesDifferences, tickInterval) {
	    var dateUnitInterval, i;
	    if ("week" === tickInterval) {
	        tickInterval = "day"
	    }
	    if ("quarter" === tickInterval) {
	        tickInterval = "month"
	    }
	    if (datesDifferences[tickInterval]) {
	        for (i = 0; i < dateUtils.dateUnitIntervals.length; i++) {
	            dateUnitInterval = dateUtils.dateUnitIntervals[i];
	            if (datesDifferences[dateUnitInterval]) {
	                datesDifferences[dateUnitInterval] = false;
	                datesDifferences.count--
	            }
	            if (dateUnitInterval === tickInterval) {
	                break
	            }
	        }
	    }
	}

	function getMarkerDates(min, max, markerInterval) {
	    var dates, origMin = min;
	    min = correctDateWithUnitBeginning(min, markerInterval);
	    max = correctDateWithUnitBeginning(max, markerInterval);
	    dates = dateUtils.getSequenceByInterval(min, max, markerInterval);
	    if (dates.length && origMin > dates[0]) {
	        dates = dates.slice(1)
	    }
	    return dates
	}

	function getMarkerInterval(tickInterval) {
	    var markerInterval = getNextDateUnit(tickInterval);
	    if ("quarter" === markerInterval) {
	        markerInterval = getNextDateUnit(markerInterval)
	    }
	    return markerInterval
	}

	function getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {
	    var format = markerInterval,
	        datesDifferences = prevDate && dateUtils.getDatesDifferences(prevDate, curDate);
	    if (prevDate && "year" !== tickInterval) {
	        prepareDatesDifferences(datesDifferences, tickInterval);
	        format = formatHelper.getDateFormatByDifferences(datesDifferences)
	    }
	    return format
	}
	module.exports = {
	    linear: {
	        measureLabels: function() {
	            return this._tickManager.getMaxLabelParams()
	        },
	        getMarkerTrackers: function() {
	            return this._markerTrackers
	        },
	        _getSharpParam: function(opposite) {
	            return this._isHorizontal ^ opposite ? "h" : "v"
	        },
	        _createAxisElement: function() {
	            var axisCoord = this._axisPosition,
	                canvas = this._getCanvasStartEnd(),
	                points = this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end];
	            return this._renderer.path(points, "line")
	        },
	        _getTranslatedCoord: function(value, offset) {
	            return this._translator.translate(value, offset)
	        },
	        _getCanvasStartEnd: function() {
	            return {
	                start: this._translator.translateSpecialCase(constants.canvasPositionStart),
	                end: this._translator.translateSpecialCase(constants.canvasPositionEnd)
	            }
	        },
	        _getScreenDelta: function() {
	            return Math.abs(this._translator.translateSpecialCase(constants.canvasPositionStart) - this._translator.translateSpecialCase(constants.canvasPositionEnd))
	        },
	        _initAxisPositions: function() {
	            var that = this,
	                position = that._options.position,
	                delta = 0;
	            if (that.delta) {
	                delta = that.delta[position] || 0
	            }
	            that._axisPosition = that._additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + position) + delta
	        },
	        _getTickCoord: function(tick) {
	            var coords, corrections = {
	                    top: -1,
	                    middle: -.5,
	                    bottom: 0,
	                    left: -1,
	                    center: -.5,
	                    right: 0
	                },
	                tickCorrection = corrections[this._options.tickOrientation || "center"];
	            if (_isDefined(tick.posX) && _isDefined(tick.posY)) {
	                coords = {
	                    x1: tick.posX,
	                    y1: tick.posY + tickCorrection * tick.length,
	                    x2: tick.posX,
	                    y2: tick.posY + tickCorrection * tick.length + tick.length
	                }
	            } else {
	                coords = null
	            }
	            return coords
	        },
	        _drawTitle: function() {
	            var that = this,
	                options = that._options,
	                titleOptions = options.title,
	                attr = {
	                    opacity: titleOptions.opacity,
	                    align: CENTER
	                };
	            if (!titleOptions.text || !that._axisTitleGroup) {
	                return
	            }
	            that._title = that._renderer.text(titleOptions.text, 0, 0).css(vizUtils.patchFontOptions(titleOptions.font)).attr(attr).append(that._axisTitleGroup)
	        },
	        _drawDateMarker: function(date, options) {
	            var labelPosX, labelPosY, textElement, text, textSize, textIndent, pathElement, that = this,
	                markerOptions = that._options.marker;
	            if (null === options.x) {
	                return
	            }
	            if (!options.withoutStick) {
	                pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], "line").attr({
	                    "stroke-width": markerOptions.width,
	                    stroke: markerOptions.color,
	                    "stroke-opacity": markerOptions.opacity,
	                    sharp: "h"
	                }).append(that._axisElementsGroup)
	            }
	            text = String(constants.formatLabel(date, options.labelFormat));
	            textElement = that._renderer.text(text, 0, 0).attr({
	                align: "left"
	            }).css(vizUtils.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup);
	            textSize = textElement.getBBox();
	            textIndent = markerOptions.width + markerOptions.textLeftIndent;
	            labelPosX = this._translator.getBusinessRange().invert ? options.x - textIndent - textSize.width : options.x + textIndent;
	            labelPosY = options.y + markerOptions.textTopIndent + textSize.height / 2;
	            textElement.move(labelPosX, labelPosY);
	            return {
	                labelStartPosX: labelPosX - textIndent,
	                labelEndPosX: labelPosX + textSize.width,
	                date: date,
	                dateMarkerStartPosX: options.x,
	                setTitle: function() {
	                    this.title = text
	                },
	                dispose: function(onlyLabel) {
	                    if (!onlyLabel && pathElement) {
	                        pathElement.dispose();
	                        pathElement = null
	                    }
	                    textElement.dispose();
	                    textElement = null
	                }
	            }
	        },
	        _drawDateMarkers: function() {
	            var tickInterval, markerInterval, markerDates, prevDateMarker, markersAreaTop, dateMarker, curDate, that = this,
	                options = that._options,
	                translator = that._translator,
	                minBound = that._minBound,
	                dateMarkers = [],
	                invert = translator.getBusinessRange().invert,
	                xBound = translator.translateSpecialCase("canvas_position_end"),
	                i = 1;

	            function draw(markerDate, format, withoutStick) {
	                return that._drawDateMarker(markerDate, {
	                    x: translator.translate(markerDate),
	                    y: markersAreaTop,
	                    labelFormat: that._getLabelFormatOptions(format),
	                    withoutStick: withoutStick
	                })
	            }
	            if ("datetime" !== options.argumentType || "discrete" === options.type || that._majorTicks.length <= 1) {
	                return
	            }
	            markersAreaTop = that._axisPosition + this._axisElementsGroup.getBBox().height + options.label.indentFromAxis + options.marker.topIndent;
	            tickInterval = dateUtils.getDateUnitInterval(this._tickManager.getTickInterval());
	            markerInterval = getMarkerInterval(tickInterval);
	            markerDates = getMarkerDates(minBound, that._maxBound, markerInterval);
	            if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {
	                for (i = 0; i < markerDates.length; i++) {
	                    curDate = markerDates[i];
	                    dateMarker = draw(curDate, getMarkerFormat(curDate, markerDates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));
	                    if (dateMarker) {
	                        if (invert ? dateMarker.labelStartPosX < xBound : dateMarker.labelEndPosX > xBound) {
	                            dateMarkers.push(dateMarker);
	                            dateMarker.dispose(true);
	                            dateMarker.setTitle()
	                        } else {
	                            if (that._checkMarkersPosition(dateMarker, prevDateMarker)) {
	                                dateMarkers.push(dateMarker);
	                                prevDateMarker = dateMarker
	                            } else {
	                                dateMarker.dispose()
	                            }
	                        }
	                    }
	                }
	                if (minBound < markerDates[0]) {
	                    dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);
	                    if (dateMarker) {
	                        if (!that._checkMarkersPosition(dateMarker, dateMarkers[0])) {
	                            dateMarker.dispose();
	                            dateMarker.setTitle()
	                        }
	                        dateMarkers.unshift(dateMarker)
	                    }
	                }
	            }
	            that._initializeMarkersTrackers(dateMarkers, that._axisElementsGroup, that._axisGroup.getBBox().width, markersAreaTop)
	        },
	        _initializeMarkersTrackers: function(dateMarkers, group, axisWidth, markersAreaTop) {
	            var markerTracker, nextMarker, i, x, currentMarker, that = this,
	                separatorHeight = that._options.marker.separatorHeight,
	                renderer = that._renderer,
	                businessRange = this._translator.getBusinessRange();
	            that._markerTrackers = [];
	            for (i = 0; i < dateMarkers.length; i++) {
	                currentMarker = dateMarkers[i];
	                nextMarker = dateMarkers[i + 1] || {
	                    dateMarkerStartPosX: businessRange.invert ? this._translator.translateSpecialCase("canvas_position_end") : axisWidth,
	                    date: businessRange.max
	                };
	                x = currentMarker.dateMarkerStartPosX;
	                markerTracker = renderer.path([x, markersAreaTop, x, markersAreaTop + separatorHeight, nextMarker.dateMarkerStartPosX, markersAreaTop + separatorHeight, nextMarker.dateMarkerStartPosX, markersAreaTop, x, markersAreaTop]).attr({
	                    "stroke-width": 1,
	                    stroke: "grey",
	                    fill: "grey",
	                    "fill-opacity": 1e-4,
	                    "stroke-opacity": 1e-4
	                }).append(group);
	                markerTracker.data("range", {
	                    startValue: currentMarker.date,
	                    endValue: nextMarker.date
	                });
	                if (currentMarker.title) {
	                    markerTracker.setTitle(currentMarker.title)
	                }
	                that._markerTrackers.push(markerTracker)
	            }
	        },
	        _checkMarkersPosition: function(dateMarker, prevDateMarker) {
	            return void 0 === prevDateMarker || dateMarker.labelStartPosX > prevDateMarker.labelEndPosX || dateMarker.labelEndPosX < prevDateMarker.labelStartPosX
	        },
	        _getLabelFormatOptions: function(formatString) {
	            var that = this,
	                markerLabelOptions = that._markerLabelOptions;
	            if (!markerLabelOptions) {
	                that._markerLabelOptions = markerLabelOptions = _extend(true, {}, that._options.marker.label)
	            }
	            if (!_isDefined(that._options.marker.label.format)) {
	                markerLabelOptions.format = formatString
	            }
	            return markerLabelOptions
	        },
	        _adjustConstantLineLabels: function() {
	            var label, line, lineBox, linesOptions, labelOptions, box, x, y, i, paddingTopBottom, paddingLeftRight, labelVerticalAlignment, labelHorizontalAlignment, labelIsInside, labelHeight, labelWidth, that = this,
	                options = that._options,
	                isHorizontal = that._isHorizontal,
	                lines = that._constantLines,
	                labels = that._constantLineLabels,
	                padding = isHorizontal ? {
	                    top: 0,
	                    bottom: 0
	                } : {
	                    left: 0,
	                    right: 0
	                },
	                delta = 0;
	            if (void 0 === labels && void 0 === lines) {
	                return
	            }
	            for (i = 0; i < labels.length; i++) {
	                x = y = 0;
	                linesOptions = options.constantLines[i];
	                paddingTopBottom = linesOptions.paddingTopBottom;
	                paddingLeftRight = linesOptions.paddingLeftRight;
	                labelOptions = linesOptions.label;
	                labelVerticalAlignment = labelOptions.verticalAlignment;
	                labelHorizontalAlignment = labelOptions.horizontalAlignment;
	                labelIsInside = "inside" === labelOptions.position;
	                label = labels[i];
	                if (null !== label) {
	                    line = lines[i];
	                    box = label.getBBox();
	                    lineBox = line.getBBox();
	                    labelHeight = box.height;
	                    labelWidth = box.width;
	                    if (isHorizontal) {
	                        if (labelIsInside) {
	                            if (labelHorizontalAlignment === LEFT) {
	                                x -= paddingLeftRight
	                            } else {
	                                x += paddingLeftRight
	                            }
	                            switch (labelVerticalAlignment) {
	                                case CENTER:
	                                    y += lineBox.y + lineBox.height / 2 - box.y - labelHeight / 2;
	                                    break;
	                                case BOTTOM:
	                                    y += lineBox.y + lineBox.height - box.y - labelHeight - paddingTopBottom;
	                                    break;
	                                default:
	                                    y += lineBox.y - box.y + paddingTopBottom
	                            }
	                        } else {
	                            if (labelVerticalAlignment === BOTTOM) {
	                                delta = that.delta && that.delta[BOTTOM] || 0;
	                                y += paddingTopBottom - box.y + that._additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + BOTTOM) + delta;
	                                if (padding[BOTTOM] < labelHeight + paddingTopBottom) {
	                                    padding[BOTTOM] = labelHeight + paddingTopBottom
	                                }
	                            } else {
	                                delta = that.delta && that.delta[TOP] || 0;
	                                y -= paddingTopBottom + box.y + labelHeight - that._additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + TOP) - delta;
	                                if (padding[TOP] < paddingTopBottom + labelHeight) {
	                                    padding[TOP] = paddingTopBottom + labelHeight
	                                }
	                            }
	                        }
	                    } else {
	                        if (labelIsInside) {
	                            switch (labelHorizontalAlignment) {
	                                case CENTER:
	                                    x += lineBox.x + lineBox.width / 2 - box.x - labelWidth / 2;
	                                    break;
	                                case RIGHT:
	                                    x -= paddingLeftRight;
	                                    break;
	                                default:
	                                    x += paddingLeftRight
	                            }
	                            if (labelVerticalAlignment === BOTTOM) {
	                                y += lineBox.y - box.y + paddingTopBottom
	                            } else {
	                                y += lineBox.y - box.y - labelHeight - paddingTopBottom
	                            }
	                        } else {
	                            y += lineBox.y + lineBox.height / 2 - box.y - labelHeight / 2;
	                            if (labelHorizontalAlignment === RIGHT) {
	                                x += paddingLeftRight;
	                                if (padding[RIGHT] < paddingLeftRight + labelWidth) {
	                                    padding[RIGHT] = paddingLeftRight + labelWidth
	                                }
	                            } else {
	                                x -= paddingLeftRight;
	                                if (padding[LEFT] < paddingLeftRight + labelWidth) {
	                                    padding[LEFT] = paddingLeftRight + labelWidth
	                                }
	                            }
	                        }
	                    }
	                    label.move(x, y)
	                }
	            }
	            that.padding = padding
	        },
	        _checkAlignmentConstantLineLabels: function(labelOptions) {
	            var position = labelOptions.position,
	                verticalAlignment = (labelOptions.verticalAlignment || "").toLowerCase(),
	                horizontalAlignment = (labelOptions.horizontalAlignment || "").toLowerCase();
	            if (this._isHorizontal) {
	                if ("outside" === position) {
	                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
	                    horizontalAlignment = CENTER
	                } else {
	                    verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;
	                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
	                }
	            } else {
	                if ("outside" === position) {
	                    verticalAlignment = CENTER;
	                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
	                } else {
	                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
	                    horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT
	                }
	            }
	            labelOptions.verticalAlignment = verticalAlignment;
	            labelOptions.horizontalAlignment = horizontalAlignment
	        },
	        _getConstantLineLabelsCoords: function(value, lineLabelOptions) {
	            var that = this,
	                additionalTranslator = that._additionalTranslator,
	                align = CENTER,
	                x = value,
	                y = value;
	            if (that._isHorizontal) {
	                y = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + lineLabelOptions.verticalAlignment)
	            } else {
	                x = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + lineLabelOptions.horizontalAlignment)
	            }
	            switch (lineLabelOptions.horizontalAlignment) {
	                case LEFT:
	                    align = !that._isHorizontal && "inside" === lineLabelOptions.position ? LEFT : RIGHT;
	                    break;
	                case CENTER:
	                    align = CENTER;
	                    break;
	                case RIGHT:
	                    align = !that._isHorizontal && "inside" === lineLabelOptions.position ? RIGHT : LEFT
	            }
	            return {
	                x: x,
	                y: y,
	                align: align
	            }
	        },
	        _getAdjustedStripLabelCoords: function(strip) {
	            var x = 0,
	                y = 0,
	                stripOptions = strip.options,
	                horizontalAlignment = stripOptions.label.horizontalAlignment,
	                verticalAlignment = stripOptions.label.verticalAlignment,
	                box = strip.label.getBBox(),
	                rectBox = strip.rect.getBBox();
	            if (horizontalAlignment === LEFT) {
	                x += stripOptions.paddingLeftRight
	            } else {
	                if (horizontalAlignment === RIGHT) {
	                    x -= stripOptions.paddingLeftRight
	                }
	            }
	            if (verticalAlignment === TOP) {
	                y += rectBox.y - box.y + stripOptions.paddingTopBottom
	            } else {
	                if (verticalAlignment === CENTER) {
	                    y += rectBox.y + rectBox.height / 2 - box.y - box.height / 2
	                } else {
	                    if (verticalAlignment === BOTTOM) {
	                        y -= stripOptions.paddingTopBottom
	                    }
	                }
	            }
	            return {
	                x: x,
	                y: y
	            }
	        },
	        _adjustTitle: function() {
	            var boxGroup, boxTitle, params, heightTitle, noLabels, that = this,
	                options = that._options,
	                position = options.position,
	                title = that._title,
	                margin = options.title.margin,
	                centerPosition = that._translator.translateSpecialCase(CANVAS_POSITION_PREFIX + CENTER),
	                axisElementsGroup = that._axisElementsGroup,
	                axisPosition = that._axisPosition;
	            if (!title || !axisElementsGroup) {
	                return
	            }
	            boxTitle = title.getBBox();
	            boxGroup = axisElementsGroup.getBBox();
	            noLabels = boxGroup.isEmpty;
	            heightTitle = boxTitle.height;
	            if (that._isHorizontal) {
	                if (position === BOTTOM) {
	                    params = {
	                        y: (noLabels ? axisPosition : boxGroup.y + boxGroup.height) - boxTitle.y + margin,
	                        x: centerPosition
	                    }
	                } else {
	                    params = {
	                        y: (noLabels ? axisPosition : boxGroup.y) - heightTitle - boxTitle.y - margin,
	                        x: centerPosition
	                    }
	                }
	            } else {
	                if (position === LEFT) {
	                    params = {
	                        x: (noLabels ? axisPosition : boxGroup.x) - heightTitle - boxTitle.y - margin,
	                        y: centerPosition
	                    }
	                } else {
	                    params = {
	                        x: (noLabels ? axisPosition : boxGroup.x + boxGroup.width) + heightTitle + boxTitle.y + margin,
	                        y: centerPosition
	                    }
	                }
	                params.rotate = options.position === LEFT ? 270 : 90
	            }
	            title.attr(params)
	        },
	        coordsIn: function(x, y) {
	            var rect = this.getBoundingRect();
	            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height
	        },
	        _boundaryTicksVisibility: {
	            min: true,
	            max: true
	        },
	        _getOverlappingBehaviorOptions: function() {
	            var that = this,
	                options = that._options,
	                getText = function() {
	                    return ""
	                },
	                overlappingBehavior = options.label.overlappingBehavior ? _extend({}, options.label.overlappingBehavior) : null;
	            if (overlappingBehavior) {
	                if (!that._isHorizontal) {
	                    overlappingBehavior.mode = constants.validateOverlappingMode(overlappingBehavior.mode)
	                }
	                if ("rotate" !== overlappingBehavior.mode) {
	                    overlappingBehavior.rotationAngle = 0
	                }
	            }
	            if (!that._translator.getBusinessRange().stubData) {
	                getText = function(value, labelOptions) {
	                    return constants.formatLabel(value, labelOptions, {
	                        min: options.min,
	                        max: options.max
	                    })
	                }
	            }
	            return {
	                hasLabelFormat: that._hasLabelFormat,
	                labelOptions: options.label,
	                isMarkersVisible: "discrete" === options.type ? false : options.marker.visible,
	                overlappingBehavior: overlappingBehavior,
	                isHorizontal: that._isHorizontal,
	                textOptions: that._textOptions,
	                textFontStyles: that._textFontStyles,
	                textSpacing: options.label.minSpacing,
	                getText: getText,
	                renderText: function(text, x, y, options) {
	                    return that._renderer.text(text, x, y, options).append(that._renderer.root)
	                },
	                translate: function(value, useAdditionalTranslator) {
	                    return useAdditionalTranslator ? that._additionalTranslator.translate(value) : that._translator.translate(value)
	                },
	                addMinMax: options.showCustomBoundaryTicks ? that._boundaryTicksVisibility : void 0
	            }
	        },
	        _getMinMax: function() {
	            return {
	                min: this._options.min,
	                max: this._options.max
	            }
	        },
	        _getStick: function() {
	            return !this._options.valueMarginsEnabled
	        },
	        _getStripLabelCoords: function(stripLabelOptions, stripFrom, stripTo) {
	            var x, y, that = this,
	                additionalTranslator = that._additionalTranslator,
	                isHorizontal = that._isHorizontal,
	                align = isHorizontal ? CENTER : LEFT;
	            if (isHorizontal) {
	                if (stripLabelOptions.horizontalAlignment === CENTER) {
	                    x = stripFrom + (stripTo - stripFrom) / 2;
	                    align = CENTER
	                } else {
	                    if (stripLabelOptions.horizontalAlignment === LEFT) {
	                        x = stripFrom;
	                        align = LEFT
	                    } else {
	                        if (stripLabelOptions.horizontalAlignment === RIGHT) {
	                            x = stripTo;
	                            align = RIGHT
	                        }
	                    }
	                }
	                y = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + stripLabelOptions.verticalAlignment)
	            } else {
	                x = additionalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + stripLabelOptions.horizontalAlignment);
	                align = stripLabelOptions.horizontalAlignment;
	                if (stripLabelOptions.verticalAlignment === TOP) {
	                    y = stripFrom
	                } else {
	                    if (stripLabelOptions.verticalAlignment === CENTER) {
	                        y = stripTo + (stripFrom - stripTo) / 2
	                    } else {
	                        if (stripLabelOptions.verticalAlignment === BOTTOM) {
	                            y = stripTo
	                        }
	                    }
	                }
	            }
	            return {
	                x: x,
	                y: y,
	                align: align
	            }
	        },
	        _getTranslatedValue: function(value, y, offset) {
	            return {
	                x: this._translator.translate(value, offset, "semidiscrete" === this._options.type && this._options.tickInterval),
	                y: y
	            }
	        },
	        _getSkippedCategory: function() {
	            var skippedCategory, categories = this._translator.getVisibleCategories() || this._translator.getBusinessRange().categories;
	            if (categories && categories.length && !!this._tickOffset) {
	                skippedCategory = categories[categories.length - 1]
	            }
	            return skippedCategory
	        },
	        _getSpiderCategoryOption: $.noop
	    }
	};


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/axes/polar_axes.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    vizUtils = __webpack_require__(291),
	    commonUtils = __webpack_require__(8),
	    constants = __webpack_require__(353),
	    circularAxes, xyAxesLinear = __webpack_require__(359).linear,
	    polarAxes, _map = vizUtils.map,
	    _math = Math,
	    _abs = _math.abs,
	    _round = _math.round,
	    convertPolarToXY = vizUtils.convertPolarToXY,
	    _extend = $.extend,
	    _noop = $.noop,
	    HALF_PI_ANGLE = 90;

	function getPolarQuarter(angle) {
	    var quarter;
	    angle = vizUtils.normalizeAngle(angle);
	    if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {
	        quarter = 1
	    } else {
	        if (angle >= 45 && angle < 135) {
	            quarter = 2
	        } else {
	            if (angle >= 135 && angle < 225) {
	                quarter = 3
	            } else {
	                if (angle >= 225 && angle < 315) {
	                    quarter = 4
	                }
	            }
	        }
	    }
	    return quarter
	}
	polarAxes = exports;
	circularAxes = polarAxes.circular = {
	    _overlappingBehaviorType: "circular",
	    _createAxisElement: function() {
	        var additionalTranslator = this._additionalTranslator;
	        return this._renderer.circle(additionalTranslator.getCenter().x, additionalTranslator.getCenter().y, additionalTranslator.getRadius())
	    },
	    _setBoundingRect: function() {
	        this.boundingRect = {
	            width: 0,
	            height: 0
	        }
	    },
	    _boundaryTicksVisibility: {
	        min: true
	    },
	    _getOverlappingBehaviorOptions: function() {
	        var that = this,
	            additionalTranslator = that._additionalTranslator,
	            angles = additionalTranslator.getAngles(),
	            options = xyAxesLinear._getOverlappingBehaviorOptions.call(that),
	            translator = that._translator,
	            indentFromAxis = that._options.label.indentFromAxis || 0;
	        if (options.overlappingBehavior) {
	            options.overlappingBehavior = {
	                mode: constants.validateOverlappingMode(options.overlappingBehavior.mode)
	            }
	        }
	        options.translate = function(value) {
	            return convertPolarToXY(additionalTranslator.getCenter(), angles[0], translator.translate(value), additionalTranslator.translate(constants.canvasPositionBottom))
	        };
	        options.circularRadius = additionalTranslator.getRadius() + indentFromAxis;
	        options.circularStartAngle = angles[0];
	        options.circularEndAngle = angles[1];
	        options.isHorizontal = false;
	        return options
	    },
	    _addBoundaryTick: function(ticks) {
	        var boundaryTicks = this._tickManager.getBoundaryTicks();
	        boundaryTicks.length && ticks.unshift({
	            value: boundaryTicks[0]
	        })
	    },
	    _getSpiderCategoryOption: function() {
	        return this._options.firstPointOnStartAngle
	    },
	    _getMinMax: function() {
	        var max, options = this._options,
	            min = commonUtils.isNumber(options.originValue) ? options.originValue : void 0;
	        if (options.period > 0 && options.argumentType === constants.numeric) {
	            min = min || 0;
	            max = min + options.period
	        }
	        return {
	            min: min,
	            max: max
	        }
	    },
	    _getStick: function() {
	        return this._options.firstPointOnStartAngle || this._options.type !== constants.discrete
	    },
	    measureLabels: function(withIndents) {
	        var maxLabelParams, that = this,
	            options = that._options,
	            indentFromAxis = options.label.indentFromAxis || 0,
	            widthAxis = options.visible ? options.width : 0,
	            halfTickLength = .5 * options.tick.length,
	            indent = withIndents ? indentFromAxis + halfTickLength : 0;
	        if (!that._axisElementsGroup || !that._options.label.visible) {
	            return {
	                height: widthAxis,
	                width: widthAxis
	            }
	        }
	        that._updateTickManager();
	        maxLabelParams = that._tickManager.getMaxLabelParams();
	        return {
	            height: maxLabelParams.height + indent,
	            width: maxLabelParams.width + indent
	        }
	    },
	    _getTranslatedCoord: function(value, offset) {
	        return this._translator.translate(value, offset) - HALF_PI_ANGLE
	    },
	    _getCanvasStartEnd: function() {
	        return {
	            start: 0 - HALF_PI_ANGLE,
	            end: 360 - HALF_PI_ANGLE
	        }
	    },
	    _createStrip: function(fromAngle, toAngle, attr) {
	        var center = this._additionalTranslator.getCenter(),
	            r = this._additionalTranslator.getRadius();
	        return this._renderer.arc(center.x, center.y, 0, r, -toAngle, -fromAngle).attr(attr)
	    },
	    _getStripLabelCoords: function(_, stripFrom, stripTo) {
	        var that = this,
	            angle = stripFrom + (stripTo - stripFrom) / 2,
	            cosSin = vizUtils.getCosAndSin(-angle),
	            halfRad = that._additionalTranslator.getRadius() / 2,
	            center = that._additionalTranslator.getCenter(),
	            x = _round(center.x + halfRad * cosSin.cos),
	            y = _round(center.y - halfRad * cosSin.sin);
	        return {
	            x: x,
	            y: y,
	            align: constants.center
	        }
	    },
	    _createConstantLine: function(value, attr) {
	        var center = this._additionalTranslator.getCenter(),
	            r = this._additionalTranslator.getRadius();
	        return this._createPathElement([center.x, center.y, center.x + r, center.y], attr).rotate(value, center.x, center.y)
	    },
	    _getConstantLineLabelsCoords: function(value) {
	        var that = this,
	            cosSin = vizUtils.getCosAndSin(-value),
	            halfRad = that._additionalTranslator.getRadius() / 2,
	            center = that._additionalTranslator.getCenter(),
	            x = _round(center.x + halfRad * cosSin.cos),
	            y = _round(center.y - halfRad * cosSin.sin);
	        return {
	            x: x,
	            y: y,
	            align: constants.center
	        }
	    },
	    _checkAlignmentConstantLineLabels: _noop,
	    _getScreenDelta: function() {
	        return 2 * Math.PI * this._additionalTranslator.getRadius()
	    },
	    _getTickCoord: function(tick) {
	        var center = this._additionalTranslator.getCenter(),
	            r = this._additionalTranslator.getRadius(),
	            corrections = {
	                inside: -1,
	                center: -.5,
	                outside: 0
	            },
	            tickCorrection = tick.length * corrections[this._options.tickOrientation || "center"],
	            radiusWithTicks = r + tickCorrection;
	        return {
	            x1: center.x + radiusWithTicks,
	            y1: center.y,
	            x2: center.x + radiusWithTicks + tick.length,
	            y2: center.y,
	            angle: tick.angle
	        }
	    },
	    _getLabelAdjustedCoord: function(tick) {
	        var that = this,
	            pos = tick.labelPos,
	            cosSin = vizUtils.getCosAndSin(pos.angle),
	            cos = cosSin.cos,
	            sin = cosSin.sin,
	            box = tick.label.getBBox(),
	            halfWidth = box.width / 2,
	            halfHeight = box.height / 2,
	            indentFromAxis = that._options.label.indentFromAxis || 0,
	            x = pos.x + indentFromAxis * cos,
	            y = pos.y + (pos.y - box.y - halfHeight) + indentFromAxis * sin;
	        switch (getPolarQuarter(pos.angle)) {
	            case 1:
	                x += halfWidth;
	                y += halfHeight * sin;
	                break;
	            case 2:
	                x += halfWidth * cos;
	                y += halfHeight;
	                break;
	            case 3:
	                x += -halfWidth;
	                y += halfHeight * sin;
	                break;
	            case 4:
	                x += halfWidth * cos;
	                y += -halfHeight
	        }
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _getGridLineDrawer: function() {
	        var that = this,
	            r = that._additionalTranslator.getRadius(),
	            center = that._additionalTranslator.getCenter();
	        return function(tick) {
	            return that._createPathElement([center.x, center.y, center.x + r, center.y], tick.gridStyle).rotate(tick.angle, center.x, center.y)
	        }
	    },
	    _getTranslatedValue: function(value, _, offset) {
	        var additionalTranslator = this._additionalTranslator,
	            startAngle = additionalTranslator.getAngles()[0],
	            angle = this._translator.translate(value, -offset),
	            coords = convertPolarToXY(additionalTranslator.getCenter(), startAngle, angle, additionalTranslator.translate(constants.canvasPositionBottom));
	        return {
	            x: coords.x,
	            y: coords.y,
	            angle: angle + startAngle - HALF_PI_ANGLE
	        }
	    },
	    _getAdjustedStripLabelCoords: function(strip) {
	        var box = strip.label.getBBox();
	        return {
	            x: 0,
	            y: strip.label.attr("y") - box.y - box.height / 2
	        }
	    },
	    coordsIn: function(x, y) {
	        return vizUtils.convertXYToPolar(this._additionalTranslator.getCenter(), x, y).r > this._additionalTranslator.getRadius()
	    },
	    _rotateTick: function(tick, angle) {
	        var center = this._additionalTranslator.getCenter();
	        tick.graphic.rotate(angle, center.x, center.y)
	    }
	};
	exports.circularSpider = _extend({}, circularAxes, {
	    _createAxisElement: function() {
	        var points = _map(this.getSpiderTicks(), function(tick) {
	            return {
	                x: tick.posX,
	                y: tick.posY
	            }
	        });
	        return this._renderer.path(points, "area")
	    },
	    _getStick: function() {
	        return true
	    },
	    _getSpiderCategoryOption: function() {
	        return true
	    },
	    getSpiderTicks: function() {
	        var that = this;
	        that._spiderTicks = constants.convertValuesToTicks(that._tickManager.getFullTicks());
	        that._initTicks(that._spiderTicks, {
	            tickStyle: {},
	            gridStyle: {}
	        }, false, that._getSkippedCategory(), that._tickOffset);
	        return that._spiderTicks
	    },
	    _createStrip: function(fromAngle, toAngle, attr) {
	        var firstTick, lastTick, nextTick, tick, center = this._additionalTranslator.getCenter(),
	            spiderTicks = this.getSpiderTicks(),
	            points = [],
	            i = 0,
	            len = spiderTicks.length;
	        while (i < len) {
	            tick = spiderTicks[i];
	            if (tick.angle >= fromAngle && tick.angle <= toAngle) {
	                if (!firstTick) {
	                    firstTick = spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1];
	                    points.push((tick.posX + firstTick.posX) / 2, (tick.posY + firstTick.posY) / 2)
	                }
	                points.push(tick.posX, tick.posY);
	                nextTick = spiderTicks[i + 1] || spiderTicks[0];
	                lastTick = {
	                    x: (tick.posX + nextTick.posX) / 2,
	                    y: (tick.posY + nextTick.posY) / 2
	                }
	            }
	            i++
	        }
	        points.push(lastTick.x, lastTick.y);
	        points.push(center.x, center.y);
	        return this._renderer.path(points, "area").attr(attr)
	    },
	    _getTranslatedCoord: function(value, offset) {
	        return this._translator.translate(value, offset) - HALF_PI_ANGLE
	    },
	    _setTickOffset: function() {
	        this._tickOffset = false
	    }
	});
	polarAxes.linear = {
	    _overlappingBehaviorType: "linear",
	    _getMinMax: circularAxes._getMinMax,
	    _getStick: xyAxesLinear._getStick,
	    _getSpiderCategoryOption: $.noop,
	    _createAxisElement: function() {
	        var additionalTranslator = this._additionalTranslator,
	            centerCoord = additionalTranslator.getCenter(),
	            points = [centerCoord.x, centerCoord.y, centerCoord.x + additionalTranslator.getRadius(), centerCoord.y];
	        return this._renderer.path(points, "line").rotate(additionalTranslator.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y)
	    },
	    _setBoundingRect: circularAxes._setBoundingRect,
	    _getScreenDelta: function() {
	        return this._additionalTranslator.getRadius()
	    },
	    _getTickCoord: function(tick) {
	        return {
	            x1: tick.posX - tick.length / 2,
	            y1: tick.posY,
	            x2: tick.posX + tick.length / 2,
	            y2: tick.posY,
	            angle: tick.angle + HALF_PI_ANGLE
	        }
	    },
	    _getOverlappingBehaviorOptions: function() {
	        var that = this,
	            translator = that._translator,
	            additionalTranslator = that._additionalTranslator,
	            options = xyAxesLinear._getOverlappingBehaviorOptions.call(this),
	            startAngle = vizUtils.normalizeAngle(that._additionalTranslator.getAngles()[0]);
	        if (options.overlappingBehavior) {
	            options.overlappingBehavior = {
	                mode: constants.validateOverlappingMode(options.overlappingBehavior.mode)
	            }
	        }
	        options.isHorizontal = startAngle > 45 && startAngle < 135 || startAngle > 225 && startAngle < 315 ? true : false;
	        options.translate = function(value) {
	            return convertPolarToXY(additionalTranslator.getCenter(), that._options.startAngle, additionalTranslator.translate(constants.canvasPositionTop), translator.translate(value)).x
	        };
	        return options
	    },
	    _getLabelAdjustedCoord: function(tick) {
	        var x, y, that = this,
	            pos = tick.labelPos,
	            cosSin = vizUtils.getCosAndSin(pos.angle),
	            indentFromAxis = that._options.label.indentFromAxis || 0,
	            box = tick.label.getBBox();
	        x = pos.x - _abs(indentFromAxis * cosSin.sin) + _abs(box.width / 2 * cosSin.cos);
	        y = pos.y + (pos.y - box.y) - _abs(box.height / 2 * cosSin.sin) + _abs(indentFromAxis * cosSin.cos);
	        return {
	            x: x,
	            y: y
	        }
	    },
	    _getGridLineDrawer: function() {
	        var that = this,
	            pos = that._additionalTranslator.getCenter();
	        return function(tick) {
	            return that._renderer.circle(pos.x, pos.y, vizUtils.getDistance(pos.x, pos.y, tick.posX, tick.posY)).attr(tick.gridStyle).sharp()
	        }
	    },
	    _getTranslatedValue: function(value, _, offset) {
	        var additionalTranslator = this._additionalTranslator,
	            startAngle = additionalTranslator.getAngles()[0],
	            angle = additionalTranslator.translate(constants.canvasPositionStart),
	            xy = convertPolarToXY(additionalTranslator.getCenter(), startAngle, angle, this._translator.translate(value, offset));
	        return {
	            x: xy.x,
	            y: xy.y,
	            angle: angle + startAngle - HALF_PI_ANGLE
	        }
	    },
	    _getTranslatedCoord: function(value, offset) {
	        return this._translator.translate(value, offset)
	    },
	    _getCanvasStartEnd: function() {
	        return {
	            start: 0,
	            end: this._additionalTranslator.getRadius()
	        }
	    },
	    _createStrip: function(fromPoint, toPoint, attr) {
	        var center = this._additionalTranslator.getCenter();
	        return this._renderer.arc(center.x, center.y, fromPoint, toPoint, 0, 360).attr(attr)
	    },
	    _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,
	    _getStripLabelCoords: function(_, stripFrom, stripTo) {
	        var that = this,
	            labelPos = stripFrom + (stripTo - stripFrom) / 2,
	            center = that._additionalTranslator.getCenter(),
	            y = _round(center.y - labelPos);
	        return {
	            x: center.x,
	            y: y,
	            align: constants.center
	        }
	    },
	    _createConstantLine: function(value, attr) {
	        var center = this._additionalTranslator.getCenter();
	        return this._renderer.circle(center.x, center.y, value).attr(attr).sharp()
	    },
	    _getConstantLineLabelsCoords: function(value) {
	        var that = this,
	            center = that._additionalTranslator.getCenter(),
	            y = _round(center.y - value);
	        return {
	            x: center.x,
	            y: y,
	            align: constants.center
	        }
	    },
	    _checkAlignmentConstantLineLabels: _noop,
	    _rotateTick: function(tick, angle) {
	        tick.graphic.rotate(angle, tick.posX, tick.posY)
	    }
	};
	polarAxes.linearSpider = _extend({}, polarAxes.linear, {
	    _createPathElement: function(points, attr) {
	        return this._renderer.path(points, "area").attr(attr).sharp()
	    },
	    setSpiderTicks: function(ticks) {
	        this._spiderTicks = ticks
	    },
	    _getGridLineDrawer: function() {
	        var that = this,
	            pos = that._additionalTranslator.getCenter();
	        return function(tick) {
	            var radius = vizUtils.getDistance(pos.x, pos.y, tick.posX, tick.posY);
	            return that._createPathElement(that._getGridPoints(pos, radius), tick.gridStyle)
	        }
	    },
	    _getGridPoints: function(pos, radius) {
	        return _map(this._spiderTicks, function(tick) {
	            var cosSin = vizUtils.getCosAndSin(tick.angle);
	            return {
	                x: _round(pos.x + radius * cosSin.cos),
	                y: _round(pos.y + radius * cosSin.sin)
	            }
	        })
	    },
	    _createStrip: function(fromPoint, toPoint, attr) {
	        var center = this._additionalTranslator.getCenter(),
	            innerPoints = this._getGridPoints(center, toPoint),
	            outerPoints = this._getGridPoints(center, fromPoint);
	        return this._renderer.path([outerPoints, innerPoints.reverse()], "area").attr(attr)
	    },
	    _createConstantLine: function(value, attr) {
	        var center = this._additionalTranslator.getCenter(),
	            points = this._getGridPoints(center, value);
	        return this._createPathElement(points, attr)
	    }
	});


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/core/series_family.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    commonUtils = __webpack_require__(8),
	    _math = Math,
	    _round = _math.round,
	    _abs = _math.abs,
	    _pow = _math.pow,
	    _each = $.each,
	    _noop = $.noop,
	    vizUtils = __webpack_require__(291),
	    _normalizeEnum = vizUtils.normalizeEnum;

	function getStacksWithArgument(stackKeepers, argument) {
	    var stacksWithArgument = [];
	    _each(stackKeepers, function(stackName, seriesInStack) {
	        _each(seriesInStack, function(_, singleSeries) {
	            var i, points = singleSeries.getPointsByArg(argument),
	                pointsLength = points.length;
	            for (i = 0; i < pointsLength; ++i) {
	                if (points[i].value) {
	                    stacksWithArgument.push(stackName);
	                    return false
	                }
	            }
	        })
	    });
	    return stacksWithArgument
	}

	function correctPointCoordinatesForStacks(stackKeepers, stacksWithArgument, argument, parameters) {
	    _each(stackKeepers, function(stackName, seriesInStack) {
	        var offset, stackIndex = $.inArray(stackName, stacksWithArgument);
	        if (stackIndex === -1) {
	            return
	        }
	        offset = getOffset(stackIndex, parameters);
	        _each(seriesInStack, function(_, singleSeries) {
	            correctPointCoordinates(singleSeries.getPointsByArg(argument) || [], parameters.width, offset)
	        })
	    })
	}

	function adjustBarSeriesDimensionsCore(series, interval, stackCount, options, seriesStackIndexCallback) {
	    var percentWidth, stackIndex, i, points, stackName, stacksWithArgument, parameters, argumentsKeeper = {},
	        stackKeepers = {},
	        barsArea = .7 * interval,
	        barWidth = options.barWidth;
	    if (options.equalBarWidth) {
	        percentWidth = barWidth && (barWidth < 0 || barWidth > 1) ? 0 : barWidth;
	        parameters = calculateParams(barsArea, stackCount, percentWidth);
	        for (i = 0; i < series.length; i++) {
	            stackIndex = seriesStackIndexCallback(i, stackCount);
	            points = series[i].getPoints();
	            correctPointCoordinates(points, parameters.width, getOffset(stackIndex, parameters))
	        }
	    } else {
	        _each(series, function(i, singleSeries) {
	            stackName = singleSeries.getStackName && singleSeries.getStackName();
	            stackName = stackName || i.toString();
	            if (!stackKeepers[stackName]) {
	                stackKeepers[stackName] = []
	            }
	            stackKeepers[stackName].push(singleSeries);
	            _each(singleSeries.getPoints(), function(_, point) {
	                var argument = point.argument;
	                if (!argumentsKeeper.hasOwnProperty(argument)) {
	                    argumentsKeeper[argument.valueOf()] = 1
	                }
	            })
	        });
	        for (var argument in argumentsKeeper) {
	            stacksWithArgument = getStacksWithArgument(stackKeepers, argument);
	            parameters = calculateParams(barsArea, stacksWithArgument.length);
	            correctPointCoordinatesForStacks(stackKeepers, stacksWithArgument, argument, parameters)
	        }
	    }
	}

	function calculateParams(barsArea, count, percentWidth) {
	    var spacing, width, middleIndex = count / 2;
	    if (!percentWidth) {
	        spacing = _round(barsArea / count * .2);
	        width = _round((barsArea - spacing * (count - 1)) / count);
	        width < 2 && (width = 2)
	    } else {
	        width = _round(barsArea * percentWidth / count);
	        spacing = _round(count > 1 ? (barsArea - barsArea * percentWidth) / (count - 1) : 0)
	    }
	    return {
	        width: width,
	        spacing: spacing,
	        middleIndex: middleIndex
	    }
	}

	function getOffset(stackIndex, parameters) {
	    return (stackIndex - parameters.middleIndex + .5) * parameters.width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing
	}

	function correctPointCoordinates(points, width, offset) {
	    _each(points, function(_, point) {
	        point.correctCoordinates({
	            width: width,
	            offset: offset
	        })
	    })
	}

	function checkMinBarSize(value, minShownValue) {
	    return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value
	}

	function getValueType(value) {
	    return value >= 0 ? "positive" : "negative"
	}

	function getVisibleSeries(that) {
	    return vizUtils.map(that.series, function(s) {
	        return s.isVisible() ? s : null
	    })
	}

	function getAbsStackSumByArg(stackKeepers, stackName, argument) {
	    var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0,
	        negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;
	    return positiveStackValue + negativeStackValue
	}

	function getSeriesStackIndexCallback(rotated, series, stackIndexes) {
	    if (!rotated) {
	        return function(seriesIndex) {
	            return stackIndexes ? stackIndexes[series[seriesIndex].getStackName()] : seriesIndex
	        }
	    } else {
	        return function(seriesIndex, stackCount) {
	            return stackCount - (stackIndexes ? stackIndexes[series[seriesIndex].getStackName()] : seriesIndex) - 1
	        }
	    }
	}

	function adjustBarSeriesDimensions(translators) {
	    var that = this,
	        series = getVisibleSeries(that);
	    adjustBarSeriesDimensionsCore(series, translators.arg.getInterval(), series.length, that._options, getSeriesStackIndexCallback(that.rotated, series))
	}

	function adjustStackedBarSeriesDimensions(translators) {
	    var that = this,
	        series = getVisibleSeries(that),
	        stackIndexes = {},
	        stackCount = 0;
	    _each(series, function() {
	        var stackName = this.getStackName();
	        if (!stackIndexes.hasOwnProperty(stackName)) {
	            stackIndexes[stackName] = stackCount++
	        }
	    });
	    adjustBarSeriesDimensionsCore(series, translators.arg.getInterval(), stackCount, that._options, getSeriesStackIndexCallback(that.rotated, series, stackIndexes))
	}

	function adjustStackedSeriesValues() {
	    var that = this,
	        negativesAsZeroes = that._options.negativesAsZeroes,
	        series = getVisibleSeries(that),
	        stackKeepers = {
	            positive: {},
	            negative: {}
	        },
	        holesStack = {
	            left: {},
	            right: {}
	        };
	    _each(series, function(seriesIndex, singleSeries) {
	        var points = singleSeries.getPoints(),
	            hole = false;
	        singleSeries._prevSeries = series[seriesIndex - 1];
	        singleSeries.holes = $.extend(true, {}, holesStack);
	        _each(points, function(index, point) {
	            var currentStack, value = point.initialValue,
	                argument = point.argument.valueOf(),
	                stackName = singleSeries.getStackName(),
	                stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;
	            if (negativesAsZeroes && value < 0) {
	                stacks = stackKeepers.positive;
	                value = 0;
	                point.resetValue()
	            }
	            stacks[stackName] = stacks[stackName] || {};
	            currentStack = stacks[stackName];
	            if (currentStack[argument]) {
	                point.correctValue(currentStack[argument]);
	                currentStack[argument] += value
	            } else {
	                currentStack[argument] = value;
	                point.resetCorrection()
	            }
	            if (!point.hasValue()) {
	                var prevPoint = points[index - 1];
	                if (!hole && prevPoint && prevPoint.hasValue()) {
	                    argument = prevPoint.argument.valueOf();
	                    prevPoint._skipSetRightHole = true;
	                    holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value - (isFinite(prevPoint.minValue) ? prevPoint.minValue : 0))
	                }
	                hole = true
	            } else {
	                if (hole) {
	                    hole = false;
	                    holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value - (isFinite(point.minValue) ? point.minValue : 0));
	                    point._skipSetLeftHole = true
	                }
	            }
	        })
	    });
	    _each(series, function(seriesIndex, singleSeries) {
	        var points = singleSeries.getPoints(),
	            holes = singleSeries.holes;
	        _each(points, function(index, point) {
	            var argument = point.argument.valueOf();
	            point.resetHoles();
	            !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, "left");
	            !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, "right");
	            point._skipSetLeftHole = null;
	            point._skipSetRightHole = null
	        })
	    });
	    that._stackKeepers = stackKeepers;
	    _each(series, function(_, singleSeries) {
	        _each(singleSeries.getPoints(), function(_, point) {
	            var argument = point.argument.valueOf();
	            point.setPercentValue(getAbsStackSumByArg(stackKeepers, singleSeries.getStackName(), argument), that.fullStacked, holesStack.left[argument], holesStack.right[argument])
	        })
	    })
	}

	function updateStackedSeriesValues(translators) {
	    var that = this,
	        series = getVisibleSeries(that),
	        stack = that._stackKeepers,
	        stackKeepers = {
	            positive: {},
	            negative: {}
	        };
	    _each(series, function(_, singleSeries) {
	        var minBarSize = singleSeries.getOptions().minBarSize,
	            tr = singleSeries.axis ? translators.axesTrans[singleSeries.axis] : translators,
	            minShownBusinessValue = minBarSize && tr.val.getMinBarSize(minBarSize),
	            stackName = singleSeries.getStackName();
	        _each(singleSeries.getPoints(), function(index, point) {
	            if (!point.hasValue()) {
	                return
	            }
	            var updateValue, valueType, currentStack, value = point.initialValue,
	                argument = point.argument.valueOf();
	            if (that.fullStacked) {
	                value = value / getAbsStackSumByArg(stack, stackName, argument) || 0
	            }
	            updateValue = checkMinBarSize(value, minShownBusinessValue);
	            valueType = getValueType(updateValue);
	            currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
	            if (currentStack[argument]) {
	                point.minValue = currentStack[argument];
	                currentStack[argument] += updateValue
	            } else {
	                currentStack[argument] = updateValue
	            }
	            point.value = currentStack[argument]
	        })
	    });
	    if (that.fullStacked) {
	        updateFullStackedSeriesValues(series, stackKeepers)
	    }
	}

	function updateFullStackedSeriesValues(series, stackKeepers) {
	    _each(series, function(_, singleSeries) {
	        var stackName = singleSeries.getStackName ? singleSeries.getStackName() : "default";
	        _each(singleSeries.getPoints(), function(index, point) {
	            var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());
	            point.value = point.value / stackSum;
	            if (commonUtils.isNumber(point.minValue)) {
	                point.minValue = point.minValue / stackSum
	            }
	        })
	    })
	}

	function updateBarSeriesValues(translators) {
	    _each(this.series, function(_, singleSeries) {
	        var minBarSize = singleSeries.getOptions().minBarSize,
	            tr = singleSeries.axis ? translators.axesTrans[singleSeries.axis] : translators,
	            minShownBusinessValue = minBarSize && tr.val.getMinBarSize(minBarSize);
	        if (minShownBusinessValue) {
	            _each(singleSeries.getPoints(), function(index, point) {
	                if (point.hasValue()) {
	                    point.value = checkMinBarSize(point.initialValue, minShownBusinessValue)
	                }
	            })
	        }
	    })
	}

	function adjustCandlestickSeriesDimensions(translators) {
	    var series = getVisibleSeries(this);
	    adjustBarSeriesDimensionsCore(series, translators.arg.getInterval(), series.length, {
	        barWidth: null,
	        equalBarWidth: true
	    }, getSeriesStackIndexCallback(this.rotated, series))
	}

	function adjustBubbleSeriesDimensions(translators) {
	    var pointSize, bubbleArea, sizeProportion, sizeDispersion, areaDispersion, that = this,
	        series = getVisibleSeries(that),
	        options = that._options,
	        visibleAreaX = translators.arg.getCanvasVisibleArea(),
	        visibleAreaY = translators.val.getCanvasVisibleArea(),
	        min = _math.min(visibleAreaX.max - visibleAreaX.min, visibleAreaY.max - visibleAreaY.min),
	        minBubbleArea = _pow(options.minBubbleSize, 2),
	        maxBubbleArea = _pow(min * options.maxBubbleSize, 2),
	        equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2,
	        minPointSize = 1 / 0,
	        maxPointSize = 0;
	    _each(series, function(_, seriesItem) {
	        _each(seriesItem.getPoints(), function(_, point) {
	            maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;
	            minPointSize = minPointSize < point.size ? minPointSize : point.size
	        })
	    });
	    sizeDispersion = maxPointSize - minPointSize;
	    areaDispersion = _abs(maxBubbleArea - minBubbleArea);
	    minPointSize = minPointSize < 0 ? 0 : minPointSize;
	    _each(series, function(_, seriesItem) {
	        _each(seriesItem.getPoints(), function(_, point) {
	            if (maxPointSize === minPointSize) {
	                pointSize = _round(equalBubbleSize)
	            } else {
	                sizeProportion = _abs(point.size - minPointSize) / sizeDispersion;
	                bubbleArea = areaDispersion * sizeProportion + minBubbleArea;
	                pointSize = _round(_math.sqrt(bubbleArea))
	            }
	            point.correctCoordinates(pointSize)
	        })
	    })
	}

	function SeriesFamily(options) {
	    var that = this;
	    that.type = _normalizeEnum(options.type);
	    that.pane = options.pane;
	    that.rotated = options.rotated;
	    that.series = [];
	    that.updateOptions(options);
	    switch (that.type) {
	        case "bar":
	            that.adjustSeriesDimensions = adjustBarSeriesDimensions;
	            that.updateSeriesValues = updateBarSeriesValues;
	            break;
	        case "rangebar":
	            that.adjustSeriesDimensions = adjustBarSeriesDimensions;
	            break;
	        case "fullstackedbar":
	            that.fullStacked = true;
	            that.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
	            that.adjustSeriesValues = adjustStackedSeriesValues;
	            that.updateSeriesValues = updateStackedSeriesValues;
	            break;
	        case "stackedbar":
	            that.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
	            that.adjustSeriesValues = adjustStackedSeriesValues;
	            that.updateSeriesValues = updateStackedSeriesValues;
	            break;
	        case "fullstackedarea":
	        case "fullstackedline":
	        case "fullstackedspline":
	        case "fullstackedsplinearea":
	            that.fullStacked = true;
	            that.adjustSeriesValues = adjustStackedSeriesValues;
	            break;
	        case "stackedarea":
	        case "stackedsplinearea":
	        case "stackedline":
	        case "stackedspline":
	            that.adjustSeriesValues = adjustStackedSeriesValues;
	            break;
	        case "candlestick":
	        case "stock":
	            that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;
	            break;
	        case "bubble":
	            that.adjustSeriesDimensions = adjustBubbleSeriesDimensions
	    }
	}
	exports.SeriesFamily = SeriesFamily;
	SeriesFamily.prototype = {
	    constructor: SeriesFamily,
	    adjustSeriesDimensions: _noop,
	    adjustSeriesValues: _noop,
	    updateSeriesValues: _noop,
	    updateOptions: function(options) {
	        this._options = options
	    },
	    dispose: function() {
	        this.series = this.translators = null
	    },
	    add: function(series) {
	        var type = this.type;
	        this.series = vizUtils.map(series, function(singleSeries) {
	            return singleSeries.type === type ? singleSeries : null
	        })
	    }
	};


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/scroll_bar.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    MIN_SCROLL_BAR_SIZE = 2,
	    translator2DModule = __webpack_require__(343),
	    commonUtils = __webpack_require__(8),
	    pointerEvents = __webpack_require__(66),
	    isDefined = commonUtils.isDefined,
	    _min = Math.min,
	    _max = Math.max;
	var ScrollBar = function(renderer, group) {
	    this._translator = new translator2DModule.Translator2D({}, {}, {});
	    this._scroll = renderer.rect().append(group);
	    this._addEvents()
	};

	function _getXCoord(canvas, pos, offset, width) {
	    var x = 0;
	    if ("right" === pos) {
	        x = canvas.width - canvas.right + offset
	    } else {
	        if ("left" === pos) {
	            x = canvas.left - offset - width
	        }
	    }
	    return x
	}

	function _getYCoord(canvas, pos, offset, width) {
	    var y = 0;
	    if ("top" === pos) {
	        y = canvas.top - offset
	    } else {
	        if ("bottom" === pos) {
	            y = canvas.height - canvas.bottom + width + offset
	        }
	    }
	    return y
	}
	ScrollBar.prototype = {
	    _addEvents: function() {
	        var that = this,
	            $scroll = $(that._scroll.element),
	            startPosX = 0,
	            startPosY = 0,
	            scrollChangeHandler = function(e) {
	                var dX = (startPosX - e.pageX) * that._scale,
	                    dY = (startPosY - e.pageY) * that._scale;
	                $scroll.trigger(new $.Event("dxc-scroll-move", $.extend(e, {
	                    type: "dxc-scroll-move",
	                    pointers: [{
	                        pageX: startPosX + dX,
	                        pageY: startPosY + dY
	                    }]
	                })))
	            };
	        $scroll.on(pointerEvents.down, function(e) {
	            startPosX = e.pageX;
	            startPosY = e.pageY;
	            $scroll.trigger(new $.Event("dxc-scroll-start", {
	                pointers: [{
	                    pageX: startPosX,
	                    pageY: startPosY
	                }]
	            }));
	            $(document).on(pointerEvents.move, scrollChangeHandler)
	        });
	        $(document).on(pointerEvents.up, function() {
	            $(document).off(pointerEvents.move, scrollChangeHandler)
	        })
	    },
	    update: function(options) {
	        var that = this,
	            position = options.position,
	            isVertical = options.rotated,
	            defaultPosition = isVertical ? "right" : "top",
	            secondaryPosition = isVertical ? "left" : "bottom";
	        if (position !== defaultPosition && position !== secondaryPosition) {
	            position = defaultPosition
	        }
	        that._scroll.attr({
	            rotate: !options.rotated ? -90 : 0,
	            rotateX: 0,
	            rotateY: 0,
	            fill: options.color,
	            width: options.width,
	            opacity: options.opacity
	        });
	        that._layoutOptions = {
	            width: options.width,
	            offset: options.offset,
	            vertical: isVertical,
	            position: position
	        };
	        return that
	    },
	    init: function(range, canvas) {
	        var that = this;
	        that._translateWithOffset = "discrete" === range.axisType && !range.stick && 1 || 0;
	        that._translator.update($.extend({}, range, {
	            minVisible: null,
	            maxVisible: null,
	            visibleCategories: null
	        }), $.extend({}, canvas), {
	            isHorizontal: !that._layoutOptions.vertical
	        });
	        return that
	    },
	    getOptions: function() {
	        return this._layoutOptions
	    },
	    shift: function(x, y) {
	        this._scroll.attr({
	            translateX: x,
	            translateY: y
	        })
	    },
	    setPane: function(panes) {
	        var pane, position = this._layoutOptions.position;
	        if ("left" === position || "top" === position) {
	            pane = panes[0]
	        } else {
	            pane = panes[panes.length - 1]
	        }
	        this.pane = pane.name;
	        this._canvas = pane.canvas;
	        return this
	    },
	    getMultipleAxesSpacing: function() {
	        return 0
	    },
	    getBoundingRect: function() {
	        var options = this._layoutOptions,
	            isVertical = options.vertical,
	            offset = options.offset,
	            width = options.width,
	            pos = options.position,
	            size = width + offset,
	            canvas = this._canvas;
	        return isVertical ? {
	            x: _getXCoord(canvas, pos, offset, width),
	            y: canvas.top,
	            width: size,
	            height: canvas.height - canvas.top - canvas.bottom
	        } : {
	            x: canvas.left,
	            y: _getYCoord(canvas, pos, offset, width),
	            width: canvas.width - canvas.left - canvas.right,
	            height: size
	        }
	    },
	    applyLayout: function() {
	        var canvas = this._canvas,
	            options = this._layoutOptions,
	            pos = options.position,
	            offset = options.offset,
	            width = options.width;
	        this.shift(_getXCoord(canvas, pos, offset, width), _getYCoord(canvas, pos, offset, width))
	    },
	    setPosition: function(min, max) {
	        var that = this,
	            translator = that._translator,
	            minPoint = isDefined(min) ? translator.translate(min, -that._translateWithOffset) : translator.translate("canvas_position_start"),
	            maxPoint = isDefined(max) ? translator.translate(max, that._translateWithOffset) : translator.translate("canvas_position_end");
	        that._offset = _min(minPoint, maxPoint);
	        that._scale = translator.getScale(min, max);
	        that._applyPosition(_min(minPoint, maxPoint), _max(minPoint, maxPoint))
	    },
	    transform: function(translate, scale) {
	        var translator = this._translator,
	            x = translator.getCanvasVisibleArea().min,
	            dx = x - (x * scale - translate),
	            lx = this._offset + dx / (this._scale * scale);
	        this._applyPosition(lx, lx + translator.canvasLength / (this._scale * scale))
	    },
	    dispose: function() {
	        this._scroll.dispose();
	        this._scroll = this._translator = null
	    },
	    _applyPosition: function(x1, x2) {
	        var height, that = this,
	            visibleArea = that._translator.getCanvasVisibleArea();
	        x1 = _max(x1, visibleArea.min);
	        x1 = _min(x1, visibleArea.max);
	        x2 = _min(x2, visibleArea.max);
	        x2 = _max(x2, visibleArea.min);
	        height = Math.abs(x2 - x1);
	        that._scroll.attr({
	            y: x1,
	            height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height
	        })
	    }
	};
	exports.ScrollBar = ScrollBar;


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/chart_components/crosshair.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    math = Math,
	    mathAbs = math.abs,
	    mathMin = math.min,
	    mathMax = math.max,
	    mathFloor = math.floor,
	    vizUtils = __webpack_require__(291),
	    HORIZONTAL = "horizontal",
	    VERTICAL = "vertical",
	    LABEL_BACKGROUND_PADDING_X = 8,
	    LABEL_BACKGROUND_PADDING_Y = 4,
	    CENTER = "center",
	    RIGHT = "right",
	    LEFT = "left",
	    TOP = "top",
	    BOTTOM = "bottom";

	function getRectangleBBox(bBox) {
	    return {
	        x: bBox.x - LABEL_BACKGROUND_PADDING_X,
	        y: bBox.y - LABEL_BACKGROUND_PADDING_Y,
	        width: bBox.width + 2 * LABEL_BACKGROUND_PADDING_X,
	        height: bBox.height + 2 * LABEL_BACKGROUND_PADDING_Y
	    }
	}

	function getLabelCheckerPosition(x, y, isHorizontal, canvas) {
	    var params = isHorizontal ? ["x", "width", "y", "height", y, 0] : ["y", "height", "x", "width", x, 1];
	    return function(bBox, position, coord) {
	        var labelCoord = {
	                x: coord.x,
	                y: coord.y
	            },
	            rectangleBBox = getRectangleBBox(bBox),
	            delta = isHorizontal ? coord.y - bBox.y - bBox.height / 2 : coord.y - bBox.y;
	        labelCoord.y = isHorizontal || !isHorizontal && position === BOTTOM ? coord.y + delta : coord.y;
	        if (rectangleBBox[params[0]] < 0) {
	            labelCoord[params[0]] -= rectangleBBox[params[0]]
	        } else {
	            if (rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] > canvas[params[1]]) {
	                labelCoord[params[0]] -= rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] - canvas[params[1]]
	            }
	        }
	        if (params[4] - rectangleBBox[params[3]] / 2 < 0) {
	            labelCoord[params[2]] -= params[4] - rectangleBBox[params[3]] / 2
	        } else {
	            if (params[4] + rectangleBBox[params[3]] / 2 > canvas[params[3]]) {
	                labelCoord[params[2]] -= params[4] + rectangleBBox[params[3]] / 2 - canvas[params[3]]
	            }
	        }
	        return labelCoord
	    }
	}

	function Crosshair(renderer, options, params, group) {
	    var that = this;
	    that._renderer = renderer;
	    that._crosshairGroup = group;
	    that._options = {};
	    that.update(options, params)
	}
	Crosshair.prototype = {
	    constructor: Crosshair,
	    update: function(options, params) {
	        var that = this,
	            canvas = params.canvas;
	        that._canvas = {
	            top: canvas.top,
	            bottom: canvas.height - canvas.bottom,
	            left: canvas.left,
	            right: canvas.width - canvas.right,
	            width: canvas.width,
	            height: canvas.height
	        };
	        that._axes = params.axes;
	        that._panes = params.panes;
	        that._prepareOptions(options, HORIZONTAL);
	        that._prepareOptions(options, VERTICAL)
	    },
	    dispose: function() {
	        var that = this;
	        that._renderer = that._crosshairGroup = that._options = that._axes = that._canvas = that._horizontalGroup = that._verticalGroup = that._horizontal = that._vertical = that._circle = that._panes = null
	    },
	    _prepareOptions: function(options, direction) {
	        var lineOptions = options[direction + "Line"];
	        this._options[direction] = {
	            visible: lineOptions.visible,
	            line: {
	                stroke: lineOptions.color || options.color,
	                "stroke-width": lineOptions.width || options.width,
	                dashStyle: lineOptions.dashStyle || options.dashStyle,
	                opacity: lineOptions.opacity || options.opacity,
	                "stroke-linecap": "butt"
	            },
	            label: $.extend(true, {}, options.label, lineOptions.label)
	        }
	    },
	    _createLines: function(options, sharpParam, group) {
	        var lines = [],
	            canvas = this._canvas,
	            points = [canvas.left, canvas.top, canvas.left, canvas.top];
	        for (var i = 0; i < 2; i++) {
	            lines.push(this._renderer.path(points, "line").attr(options).sharp(sharpParam).append(group))
	        }
	        return lines
	    },
	    render: function() {
	        var that = this,
	            renderer = that._renderer,
	            options = that._options,
	            verticalOptions = options.vertical,
	            horizontalOptions = options.horizontal,
	            extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line,
	            circleOptions = {
	                stroke: extraOptions.stroke,
	                "stroke-width": extraOptions["stroke-width"],
	                dashStyle: extraOptions.dashStyle,
	                opacity: extraOptions.opacity
	            },
	            canvas = that._canvas;
	        that._horizontal = {};
	        that._vertical = {};
	        that._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(that._crosshairGroup);
	        that._horizontalGroup = renderer.g().append(that._crosshairGroup);
	        that._verticalGroup = renderer.g().append(that._crosshairGroup);
	        if (verticalOptions.visible) {
	            that._vertical.lines = that._createLines(verticalOptions.line, "h", that._verticalGroup);
	            that._vertical.labels = that._createLabels(that._axes[0], verticalOptions, false, that._verticalGroup)
	        }
	        if (horizontalOptions.visible) {
	            that._horizontal.lines = that._createLines(horizontalOptions.line, "v", that._horizontalGroup);
	            that._horizontal.labels = that._createLabels(that._axes[1], horizontalOptions, true, that._horizontalGroup)
	        }
	        that.hide()
	    },
	    _createLabels: function(axes, options, isHorizontal, group) {
	        var x, y, text, background, currentLabelPos, that = this,
	            canvas = that._canvas,
	            renderer = that._renderer,
	            labels = [],
	            labelOptions = options.label;
	        if (labelOptions.visible) {
	            axes.forEach(function(axis) {
	                var align, position = axis.getOptions().position;
	                if (axis.getTranslator().getBusinessRange().stubData) {
	                    return
	                }
	                currentLabelPos = axis.getLabelsPosition();
	                if (isHorizontal) {
	                    y = canvas.top;
	                    x = currentLabelPos
	                } else {
	                    x = canvas.left;
	                    y = currentLabelPos
	                }
	                align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;
	                background = renderer.rect(0, 0, 0, 0).attr({
	                    fill: labelOptions.backgroundColor || options.line.stroke
	                }).append(group);
	                text = renderer.text("0", 0, 0).css(vizUtils.patchFontOptions(options.label.font)).attr({
	                    align: align
	                }).append(group);
	                labels.push({
	                    text: text,
	                    background: background,
	                    axis: axis,
	                    options: labelOptions,
	                    pos: {
	                        coord: currentLabelPos,
	                        side: position
	                    },
	                    startXY: {
	                        x: x,
	                        y: y
	                    }
	                })
	            })
	        }
	        return labels
	    },
	    _updateText: function(value, axisName, labels, point, func) {
	        var that = this;
	        labels.forEach(function(label) {
	            var axis = label.axis,
	                coord = label.startXY,
	                textElement = label.text,
	                backgroundElement = label.background,
	                text = "";
	            if (!axis.name || axis.name === axisName) {
	                text = axis.getFormattedValue(value, label.options, point)
	            }
	            if (text) {
	                textElement.attr({
	                    text: text,
	                    x: coord.x,
	                    y: coord.y
	                });
	                textElement.attr(func(textElement.getBBox(), label.pos.side, coord));
	                that._updateLinesCanvas(label);
	                backgroundElement.attr(getRectangleBBox(textElement.getBBox()))
	            } else {
	                textElement.attr({
	                    text: ""
	                });
	                backgroundElement.attr({
	                    x: 0,
	                    y: 0,
	                    width: 0,
	                    height: 0
	                })
	            }
	        })
	    },
	    hide: function() {
	        this._crosshairGroup.attr({
	            visibility: "hidden"
	        })
	    },
	    _updateLinesCanvas: function(label) {
	        var position = label.pos.side,
	            labelCoord = label.pos.coord,
	            coords = this._linesCanvas,
	            canvas = this._canvas;
	        coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelCoord - canvas[position]) ? coords[position] : labelCoord
	    },
	    _updateLines: function(lines, x, y, r, isHorizontal) {
	        var coords = this._linesCanvas,
	            canvas = this._canvas,
	            points = isHorizontal ? [
	                [mathMin(x - r, coords.left), canvas.top, x - r, canvas.top],
	                [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]
	            ] : [
	                [canvas.left, mathMin(coords.top, y - r), canvas.left, y - r],
	                [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]
	            ];
	        for (var i = 0; i < 2; i++) {
	            lines[i].attr({
	                points: points[i]
	            })
	        }
	    },
	    _resetLinesCanvas: function() {
	        var canvas = this._canvas;
	        this._linesCanvas = {
	            left: canvas.left,
	            right: canvas.right,
	            top: canvas.top,
	            bottom: canvas.bottom
	        }
	    },
	    _getClipRectForPane: function(x, y) {
	        var i, coords, panes = this._panes;
	        for (i = 0; i < panes.length; i++) {
	            coords = panes[i].coords;
	            if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {
	                return panes[i].clipRect
	            }
	        }
	        return {
	            id: null
	        }
	    },
	    show: function(data) {
	        var that = this,
	            point = data.point,
	            pointData = point.getCrosshairData(data.x, data.y),
	            r = point.getPointRadius(),
	            horizontal = that._horizontal,
	            vertical = that._vertical,
	            rad = !r ? 0 : r + 3,
	            canvas = that._canvas,
	            x = mathFloor(pointData.x),
	            y = mathFloor(pointData.y);
	        if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {
	            that._crosshairGroup.attr({
	                visibility: "visible"
	            });
	            that._resetLinesCanvas();
	            that._circle.attr({
	                cx: x,
	                cy: y,
	                r: rad,
	                clipId: that._getClipRectForPane(x, y).id
	            });
	            if (horizontal.lines) {
	                that._updateText(pointData.yValue, pointData.axis, horizontal.labels, point, getLabelCheckerPosition(x, y, true, canvas));
	                that._updateLines(horizontal.lines, x, y, rad, true);
	                that._horizontalGroup.attr({
	                    translateY: y - canvas.top
	                })
	            }
	            if (vertical.lines) {
	                that._updateText(pointData.xValue, pointData.axis, vertical.labels, point, getLabelCheckerPosition(x, y, false, canvas));
	                that._updateLines(vertical.lines, x, y, rad, false);
	                that._verticalGroup.attr({
	                    translateX: x - canvas.left
	                })
	            }
	        } else {
	            that.hide()
	        }
	    }
	};
	exports.Crosshair = Crosshair;


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * DevExtreme (viz/pie_chart.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var $ = __webpack_require__(5),
	    errors = __webpack_require__(3),
	    seriesConsts = __webpack_require__(305),
	    vizUtils = __webpack_require__(291),
	    commonUtils = __webpack_require__(8),
	    rangeModule = __webpack_require__(349),
	    registerComponent = __webpack_require__(44),
	    baseChartModule = __webpack_require__(292),
	    BaseChart = baseChartModule.BaseChart,
	    overlapping = baseChartModule.overlapping,
	    seriesSpacing = seriesConsts.pieSeriesSpacing,
	    translator1DModule = __webpack_require__(365),
	    OPTIONS_FOR_REFRESH_SERIES = ["startAngle", "innerRadius", "segmentsDirection", "type"],
	    _extend = $.extend,
	    _each = $.each,
	    _noop = $.noop,
	    _getVerticallyShiftedAngularCoords = __webpack_require__(291).getVerticallyShiftedAngularCoords,
	    states = seriesConsts.states,
	    SELECTED_STATE = states.selectedMark,
	    HOVER_STATE = states.hoverMark,
	    HOVER = states.hover,
	    NORMAL = states.normal,
	    SELECTION = states.selection,
	    APPLY_HOVER = states.applyHover,
	    RESET_ITEM = states.resetItem;

	function AbstractSeries(index, points) {
	    var that = this;
	    that.index = index;
	    that.fullState = 0;
	    that._points = points;
	    that._selectedPointsCount = 0;
	    return that
	}
	AbstractSeries.prototype = {
	    isHovered: function() {
	        return !!(1 & this.fullState)
	    },
	    setHoverState: function(state, _, legendCallback) {
	        var that = this;
	        if (state && !that.isHovered()) {
	            that._changeStyle(legendCallback, APPLY_HOVER, HOVER);
	            that.fullState |= HOVER_STATE
	        } else {
	            if (!state && that.isHovered()) {
	                that._changeStyle(legendCallback, RESET_ITEM, NORMAL);
	                that.fullState &= ~HOVER_STATE
	            }
	        }
	    },
	    _changeStyle: function(legendCallback, legendAction, pointAction) {
	        var that = this;
	        !that._selectedPointsCount && legendCallback(legendAction);
	        _each(that._points || [], function(_, p) {
	            !p.isSelected() && p.applyStyle(pointAction)
	        })
	    },
	    setPointHoverState: function(data) {
	        var point = data.point;
	        point.fullState |= HOVER_STATE;
	        if (!point.isSelected()) {
	            point.applyStyle(HOVER);
	            if (!this._selectedPointsCount) {
	                data.legendCallback(APPLY_HOVER)
	            }
	        }
	    },
	    releasePointHoverState: function(data) {
	        var point = data.point;
	        point.fullState &= ~HOVER_STATE;
	        if (!point.isSelected()) {
	            point.applyStyle(NORMAL);
	            if (!this._selectedPointsCount) {
	                data.legendCallback(RESET_ITEM)
	            }
	        }
	    },
	    setPointSelectedState: function(data) {
	        var that = this,
	            point = data.point;
	        point.fullState |= SELECTED_STATE;
	        point.applyStyle(SELECTION);
	        !that._selectedPointsCount && data.legendCallback(states.applySelected);
	        that._selectedPointsCount++
	    },
	    releasePointSelectedState: function(data) {
	        var action, that = this,
	            point = data.point;
	        point.fullState &= ~SELECTED_STATE;
	        if (point.isHovered() || that.isHovered()) {
	            point.applyStyle(HOVER);
	            action = APPLY_HOVER
	        } else {
	            point.applyStyle(NORMAL);
	            action = RESET_ITEM
	        }
	        that._selectedPointsCount--;
	        !that._selectedPointsCount && data.legendCallback(action)
	    }
	};
	var dxPieChart = BaseChart.inherit({
	    _setDeprecatedOptions: function() {
	        this.callBase.apply(this, arguments);
	        _extend(this._deprecatedOptions, {
	            "series.innerRadius": {
	                since: "15.2",
	                message: "Use the 'innerRadius' option instead"
	            },
	            "series.startAngle": {
	                since: "15.2",
	                message: "Use the 'startAngle' option instead"
	            },
	            "series.segmentsDirection": {
	                since: "15.2",
	                message: "Use the 'segmentsDirection' option instead"
	            },
	            "series.type": {
	                since: "15.2",
	                message: "Use the 'type' option instead"
	            }
	        })
	    },
	    _chartType: "pie",
	    _layoutManagerOptions: function() {
	        var diameter = this._themeManager.getOptions("diameter");
	        if (commonUtils.isNumber(diameter)) {
	            if (diameter > 1) {
	                diameter = 1
	            } else {
	                if (diameter < 0) {
	                    diameter = 0
	                }
	            }
	        } else {
	            diameter = void 0
	        }
	        return _extend(true, {}, this.callBase(), {
	            piePercentage: diameter
	        })
	    },
	    _optionChangesMap: {
	        diameter: "REINIT"
	    },
	    _groupSeries: function() {
	        var series = this.series;
	        this._groupsData = {
	            groups: [{
	                series: series,
	                valueOptions: {
	                    valueType: "numeric"
	                }
	            }],
	            argumentOptions: series[0] && series[0].getOptions()
	        }
	    },
	    _populateBusinessRange: function() {
	        var singleSeriesRange, businessRanges = [],
	            series = this.series;
	        this.businessRanges = null;
	        _each(series, function(_, singleSeries) {
	            var range = new rangeModule.Range;
	            singleSeriesRange = singleSeries.getRangeData();
	            range.addRange(singleSeriesRange.val);
	            if (!range.isDefined()) {
	                range.setStubData()
	            }
	            businessRanges.push(range)
	        });
	        this.businessRanges = businessRanges
	    },
	    _specialProcessSeries: function() {
	        _each(this.series, function(_, singleSeries) {
	            singleSeries.arrangePoints()
	        })
	    },
	    _createTranslator: function(range) {
	        return (new translator1DModule.Translator1D).setDomain(range.min, range.max).setCodomain(360, 0)
	    },
	    _checkPaneName: function() {
	        return true
	    },
	    _processSingleSeries: function(singleSeries) {
	        singleSeries.arrangePoints()
	    },
	    _collectPointsByArg: function() {
	        var itemIndex, that = this,
	            points = {},
	            args = {},
	            index = 0;
	        _each(that.series, function(_, singleSeries) {
	            var count, arrayArguments = {};
	            _each(singleSeries.getPoints(), function(_, point) {
	                var argument = point.argument;
	                arrayArguments[argument] = ++arrayArguments[argument] || 0;
	                count = arrayArguments[argument];
	                itemIndex = args[argument + count];
	                if (void 0 === itemIndex) {
	                    point.index = args[argument + count] = index;
	                    points[index] = [point];
	                    index++
	                } else {
	                    point.index = itemIndex;
	                    points[itemIndex].push(point)
	                }
	            })
	        });
	        that._collectionPointsArg = points
	    },
	    _getLegendTargets: function() {
	        var that = this,
	            points = [];
	        _each(that._collectionPointsArg, function(_, id) {
	            _each(id, function(i, point) {
	                if (0 === i) {
	                    points.push(that._getLegendOptions(point))
	                } else {
	                    if (!points[points.length - 1].visible) {
	                        points[points.length - 1].visible = point.isVisible()
	                    }
	                }
	            })
	        });
	        return points
	    },
	    _getAxisDrawingMethods: _noop,
	    _getLayoutTargets: function() {
	        return [{
	            canvas: this._canvas
	        }]
	    },
	    _getAxesForTransform: function() {
	        return {
	            verticalAxes: [],
	            horizontalAxes: []
	        }
	    },
	    _getLayoutSeries: function(series, drawOptions) {
	        var layout, that = this,
	            canvas = that._canvas,
	            drawnLabels = false;
	        layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, true);
	        _each(series, function(i, singleSeries) {
	            singleSeries.correctPosition(layout);
	            drawnLabels = singleSeries.drawLabelsWOPoints(that._createTranslator(that.businessRanges[i])) || drawnLabels
	        });
	        if (drawnLabels) {
	            layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, drawOptions.hideLayoutLabels)
	        }
	        return layout
	    },
	    _updateSeriesDimensions: function(drawOptions) {
	        var innerRad, delta, layout, that = this,
	            visibleSeries = that._getVisibleSeries(),
	            lengthVisibleSeries = visibleSeries.length;
	        if (lengthVisibleSeries) {
	            layout = that._getLayoutSeries(visibleSeries, drawOptions);
	            delta = (layout.radiusOuter - layout.radiusInner - seriesSpacing * (lengthVisibleSeries - 1)) / lengthVisibleSeries;
	            innerRad = layout.radiusInner;
	            that._setCenter({
	                x: layout.centerX,
	                y: layout.centerY
	            });
	            _each(visibleSeries, function(_, singleSeries) {
	                singleSeries.correctRadius({
	                    radiusInner: innerRad,
	                    radiusOuter: innerRad + delta
	                });
	                innerRad += delta + seriesSpacing
	            })
	        }
	    },
	    _prepareTranslators: function(_, i) {
	        return this._createTranslator(this.businessRanges[i])
	    },
	    _getLegendCallBack: function() {
	        var legend = this._legend;
	        return function(point) {
	            return legend.getActionCallback(point)
	        }
	    },
	    _adjustSeries: function() {
	        _each(this.series, function(_, singleSeries) {
	            singleSeries.adjustLabels()
	        })
	    },
	    _prepareStackPoints: _noop,
	    _resetStackPoints: _noop,
	    _applyExtraSettings: _noop,
	    _resolveLabelOverlappingShift: function() {
	        var that = this,
	            series = that.series,
	            center = that._center;
	        _each(series, function(_, singleSeries) {
	            if ("inside" === singleSeries.getOptions().label.position) {
	                return
	            }
	            var points = singleSeries.getVisiblePoints(),
	                lPoints = [],
	                rPoints = [];
	            $.each(points, function(_, point) {
	                var angle = vizUtils.normalizeAngle(point.middleAngle);
	                (angle <= 90 || angle >= 270 ? rPoints : lPoints).push(point)
	            });
	            overlapping.resolveLabelOverlappingInOneDirection(lPoints, that._canvas, false, shiftFunction);
	            overlapping.resolveLabelOverlappingInOneDirection(rPoints, that._canvas, false, shiftFunction)
	        });

	        function shiftFunction(box, length) {
	            return _getVerticallyShiftedAngularCoords(box, -length, center)
	        }
	    },
	    _setCenter: function(center) {
	        this._center = center
	    },
	    _getStoredSeries: function() {
	        var abstractSeries = this._abstractSeries;
	        if (!abstractSeries) {
	            abstractSeries = this._abstractSeries = []
	        } else {
	            abstractSeries.splice(0, abstractSeries.length)
	        }
	        _each(this._collectionPointsArg, function(i, points) {
	            abstractSeries.push(new AbstractSeries(i, points))
	        });
	        return abstractSeries
	    },
	    _disposeSeries: function() {
	        this.callBase.apply(this, arguments);
	        this._abstractSeries = null
	    },
	    getSeries: function() {
	        errors.log("W0002", "dxPieChart", "getSeries", "15.2", "Use the 'getAllSeries' method instead");
	        return this.series[0]
	    },
	    _legendDataField: "point",
	    _legendItemTextField: "argument",
	    _updateLegendPosition: _noop,
	    _renderTrackers: _noop,
	    _trackerType: "PieTracker",
	    _createScrollBar: _noop,
	    _updateAxesLayout: _noop,
	    _applyClipRects: _noop,
	    _appendAdditionalSeriesGroups: _noop,
	    _prepareToRender: _noop,
	    _isLegendInside: _noop,
	    _renderAxes: _noop,
	    _isRotated: _noop,
	    _seriesPopulatedHandlerCore: _noop,
	    _reinitAxes: _noop,
	    _correctAxes: _noop,
	    _getExtraOptions: function() {
	        var that = this;
	        return {
	            startAngle: that.option("startAngle"),
	            innerRadius: that.option("innerRadius"),
	            segmentsDirection: that.option("segmentsDirection"),
	            type: that.option("type")
	        }
	    }
	});
	_each(OPTIONS_FOR_REFRESH_SERIES, function(_, name) {
	    dxPieChart.prototype._optionChangesMap[name] = "REFRESH_SERIES_DATA_INIT"
	});
	registerComponent("dxPieChart", dxPieChart);
	module.exports = dxPieChart;
	module.exports.default = module.exports;


/***/ },
/* 365 */
/***/ function(module, exports) {

	/**
	 * DevExtreme (viz/translators/translator1d.js)
	 * Version: 16.2.3
	 * Build date: Tue Dec 13 2016
	 *
	 * Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
	 * EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
	 */
	"use strict";
	var _Number = Number;

	function Translator1D() {
	    this.setDomain(arguments[0], arguments[1]).setCodomain(arguments[2], arguments[3])
	}
	Translator1D.prototype = {
	    constructor: Translator1D,
	    setDomain: function(domain1, domain2) {
	        var that = this;
	        that._domain1 = _Number(domain1);
	        that._domain2 = _Number(domain2);
	        that._domainDelta = that._domain2 - that._domain1;
	        return that
	    },
	    setCodomain: function(codomain1, codomain2) {
	        var that = this;
	        that._codomain1 = _Number(codomain1);
	        that._codomain2 = _Number(codomain2);
	        that._codomainDelta = that._codomain2 - that._codomain1;
	        return that
	    },
	    getDomain: function() {
	        return [this._domain1, this._domain2]
	    },
	    getCodomain: function() {
	        return [this._codomain1, this._codomain2]
	    },
	    getDomainStart: function() {
	        return this._domain1
	    },
	    getDomainEnd: function() {
	        return this._domain2
	    },
	    getCodomainStart: function() {
	        return this._codomain1
	    },
	    getCodomainEnd: function() {
	        return this._codomain2
	    },
	    getDomainRange: function() {
	        return this._domainDelta
	    },
	    getCodomainRange: function() {
	        return this._codomainDelta
	    },
	    translate: function(value) {
	        var ratio = (_Number(value) - this._domain1) / this._domainDelta;
	        return 0 <= ratio && ratio <= 1 ? this._codomain1 + ratio * this._codomainDelta : NaN
	    },
	    adjust: function(value) {
	        var ratio = (_Number(value) - this._domain1) / this._domainDelta,
	            result = NaN;
	        if (ratio < 0) {
	            result = this._domain1
	        } else {
	            if (ratio > 1) {
	                result = this._domain2
	            } else {
	                if (0 <= ratio && ratio <= 1) {
	                    result = _Number(value)
	                }
	            }
	        }
	        return result
	    }
	};
	exports.Translator1D = Translator1D;


/***/ }
/******/ ]);